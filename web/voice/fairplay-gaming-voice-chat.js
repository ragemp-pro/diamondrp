/*
 * fairplay-gaming-voice-chat v2.0.0
 * fairplay gaming voice chat powered by mediasoup 
 * Copyright: 2017-2019 kemperrr <kemperrr@fpgm.ru>
 * License: All Rights Reserved
 */

(function e(t,n,r){function s(o,u){if(!n[o]){if(!t[o]){var a=typeof require=="function"&&require;if(!u&&a)return a(o,!0);if(i)return i(o,!0);var f=new Error("Cannot find module '"+o+"'");throw f.code="MODULE_NOT_FOUND",f}var l=n[o]={exports:{}};t[o][0].call(l.exports,function(e){var n=t[o][1][e];return s(n?n:e)},l,l.exports,e,t,n,r)}return n[o].exports}var i=typeof require=="function"&&require;for(var o=0;o<r.length;o++)s(r[o]);return s})({1:[function(require,module,exports){
	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
			value: true
	});
	
	var _from = require('babel-runtime/core-js/array/from');
	
	var _from2 = _interopRequireDefault(_from);
	
	var _values = require('babel-runtime/core-js/object/values');
	
	var _values2 = _interopRequireDefault(_values);
	
	var _getIterator2 = require('babel-runtime/core-js/get-iterator');
	
	var _getIterator3 = _interopRequireDefault(_getIterator2);
	
	var _map = require('babel-runtime/core-js/map');
	
	var _map2 = _interopRequireDefault(_map);
	
	var _classCallCheck2 = require('babel-runtime/helpers/classCallCheck');
	
	var _classCallCheck3 = _interopRequireDefault(_classCallCheck2);
	
	var _createClass2 = require('babel-runtime/helpers/createClass');
	
	var _createClass3 = _interopRequireDefault(_createClass2);
	
	var _utils = require('./utils');
	
	var _hark = require('hark');
	
	var _hark2 = _interopRequireDefault(_hark);
	
	var _mediastreamGain = require('mediastream-gain');
	
	var _mediastreamGain2 = _interopRequireDefault(_mediastreamGain);
	
	var _events = require('./helpers/events');
	
	var _events2 = _interopRequireDefault(_events);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	var DataStore = function () {
			function DataStore() {
					(0, _classCallCheck3.default)(this, DataStore);
	
	
					this.mainContext = new AudioContext();
					this.mainVolume = this.mainContext.createGain();
	
					this.mainVolume.connect(this.mainContext.destination);
					this.mainVolume.gain.setValueAtTime(1, this.mainContext.currentTime);
	
					this._peers = new _map2.default();
					this._consumers = {};
					this._producers = {};
	
					/** @type {Object} */
					this._producerHark = null;
	
					this.isPositioning = true;
	
					this._producerVolume = null;
	
					this.lastVolumeUpdate = Date.now();
					this.consumersVolumeQueue = {};
			}
	
			(0, _createClass3.default)(DataStore, [{
					key: 'changePositioning',
					value: function changePositioning(isPositioning) {
							this.isPositioning = isPositioning;
					}
	
					/* MAIN - START */
	
			}, {
					key: 'changeMainVolume',
					value: function changeMainVolume(volume) {
							if (typeof this.mainVolume !== 'undefined' && typeof this.mainVolume.gain !== 'undefined' && !isNaN(volume)) {
									this.mainVolume.gain.setValueAtTime(volume, this.mainContext.currentTime);
							}
					}
	
					/* MAIN - END */
	
					/* PRODUCERS - START */
	
			}, {
					key: 'addProducer',
					value: function addProducer(producer) {
							var _this = this;
	
							if (this._producerHark) {
									this._producerHark.stop();
							}
	
							var stream = new MediaStream();
	
							if (producer.track) {
									stream.addTrack(producer.track);
							}
	
							this._producerVolume = new _mediastreamGain2.default(stream);
	
							this._producerHark = (0, _hark2.default)(stream, { play: false });
	
							this._producerHark.on('volume_change', function (dBs, threshold) {
									var volume = Math.round(Math.pow(10, dBs / 85) * 10);
	
									if (volume === 1) {
											volume = 0;
									}
	
									var currentTime = Date.now();
	
									if (currentTime >= _this.lastVolumeUpdate + 1000) {
											//MpEvents.triggerClientChangeProducerVolume(volume);
	
											//MpEvents.triggerClientChangeConsumersVolume(this.consumersVolumeQueue);
											_this.consumersVolumeQueue = {};
	
											_this.lastVolumeUpdate = currentTime;
									}
							});
	
							this._producers[producer.id] = producer;
					}
			}, {
					key: 'removeProducer',
					value: function removeProducer(producerId) {
	
							if (this._producerHark) {
									this._producerHark.stop();
							}
	
							delete this._producerVolume;
							delete this._producers[producerId];
					}
			}, {
					key: 'setProducerPaused',
					value: function setProducerPaused(producerId, originator) {
							var producer = this._producers[producerId];
	
							if (originator === 'local') {
									producer.locallyPaused = true;
							} else {
									producer.remotelyPaused = true;
							}
					}
			}, {
					key: 'setProducerResumed',
					value: function setProducerResumed(producerId, originator) {
							var producer = this._producers[producerId];
	
							if (originator === 'local') {
									producer.locallyPaused = false;
							} else {
									producer.remotelyPaused = false;
							}
					}
			}, {
					key: 'setProducerTrack',
					value: function setProducerTrack(producerId, track) {
							var producer = this._producers[producerId];
							producer.track = track;
					}
			}, {
					key: 'changeProducerVolume',
					value: function changeProducerVolume(volume) {
							var _iteratorNormalCompletion = true;
							var _didIteratorError = false;
							var _iteratorError = undefined;
	
							try {
									for (var _iterator = (0, _getIterator3.default)((0, _values2.default)(this._producers)), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
											var producer = _step.value;
	
											if (typeof this._producerVolume !== 'undefined' && !isNaN(volume)) {
													this._producerVolume.setGain(volume);
											}
									}
							} catch (err) {
									_didIteratorError = true;
									_iteratorError = err;
							} finally {
									try {
											if (!_iteratorNormalCompletion && _iterator.return) {
													_iterator.return();
											}
									} finally {
											if (_didIteratorError) {
													throw _iteratorError;
											}
									}
							}
					}
	
					/* PRODUCERS - END */
	
					/* PEERS - START */
	
			}, {
					key: 'addPeer',
					value: function addPeer(peer) {
							this._peers.set(peer.name, peer);
					}
			}, {
					key: 'removePeer',
					value: function removePeer(peerName) {
							this._peers.delete(peerName);
					}
	
					/* PEERS - END */
	
					/* CONSUMERS - START */
	
			}, {
					key: 'addConsumer',
					value: function addConsumer(consumer) {
							consumer.volume = 0;
							consumer.balance = 0;
	
							this._consumers[consumer.id] = consumer;
					}
			}, {
					key: 'removeConsumer',
					value: function removeConsumer(consumerId) {
	
							var consumer = this._consumers[consumerId];
	
							if (!consumer) {
									console.log(consumerId + ' is not found');
									return false;
							}
	
							if (typeof consumer.audioElement !== 'undefined') {
									consumer.audioElement.remove();
							}
	
							if (consumer.hark) {
									consumer.hark.stop();
							}
	
							if (typeof consumer.streamSource !== 'undefined') {
									consumer.gainNode.disconnect(this.mainVolume);
									consumer.streamSource.disconnect(consumer.gainNode);
									consumer.gainNode.disconnect(consumer.panner);
									consumer.panner.disconnect(this.mainVolume);
							}
	
							delete this._consumers[consumerId];
					}
			}, {
					key: 'setConsumerPaused',
					value: function setConsumerPaused(consumerId, originator) {
							var consumer = this._consumers[consumerId];
	
							if (!consumer) {
									console.log(consumerId + ' is not found');
									return false;
							}
	
							if (originator === 'local') {
									consumer.locallyPaused = true;
							} else {
									consumer.remotelyPaused = true;
							}
					}
			}, {
					key: 'setConsumerResumed',
					value: function setConsumerResumed(consumerId, originator) {
							var consumer = this._consumers[consumerId];
	
							if (!consumer) {
									console.log(consumerId + ' is not found');
									return false;
							}
	
							if (originator === 'local') {
									consumer.locallyPaused = false;
							} else {
									consumer.remotelyPaused = false;
							}
					}
			}, {
					key: 'setConsumerEffectiveProfile',
					value: function setConsumerEffectiveProfile(consumerId, profile) {
							var consumer = this._consumers[consumerId];
	
							if (!consumer) {
									console.log(consumerId + ' is not found');
									return false;
							}
	
							consumer.profile = profile;
					}
			}, {
					key: 'setConsumerTrack',
					value: function setConsumerTrack(consumerId, track) {
							var _this2 = this;
	
							var consumer = this._consumers[consumerId];
	
							if (!consumer) {
									console.log(consumerId + ' is not found');
									return false;
							}
	
							var audio = new Audio();
							audio.autoplay = !this.isPositioning;
							audio.volume = 0;
	
							var stream = new MediaStream();
	
							if (track) {
									stream.addTrack(track);
							}
	
							audio.srcObject = stream;
	
							if (consumer.hark) {
									consumer.hark.stop();
							}
	
							var consumerHark = (0, _hark2.default)(stream, { play: false });
	
							consumerHark.on('volume_change', function (dBs, threshold) {
									var volume = Math.round(Math.pow(10, dBs / 85) * 10);
	
									if (volume === 1) {
											volume = 0;
									}
	
									_this2.consumersVolumeQueue[consumer.peerName] = volume;
							});
	
							if (this.isPositioning) {
									var source = this.mainContext.createMediaStreamSource(stream);
	
									// GainNode (proximity)
									consumer.gainNode = this.mainContext.createGain();
									source.connect(consumer.gainNode);
									consumer.gainNode.connect(this.mainVolume);
									consumer.gainNode.gain.setValueAtTime(0, this.mainContext.currentTime);
	
									// PannerNode (stereo)
									var panner = this.mainContext.createPanner();
									consumer.panner = panner;
									consumer.gainNode.connect(consumer.panner);
									consumer.panner.connect(this.mainVolume);
									consumer.panner.setOrientation(0, 0, 1);
	
									consumer.streamSource = source;
							} else {
									consumer.audioElement = audio;
							}
	
							consumer.hark = consumerHark;
							consumer.track = track;
					}
			}, {
					key: 'changeConsumerVolume',
					value: function changeConsumerVolume(peerName, volume, balance) {
							var _iteratorNormalCompletion2 = true;
							var _didIteratorError2 = false;
							var _iteratorError2 = undefined;
	
							try {
									for (var _iterator2 = (0, _getIterator3.default)((0, _values2.default)(this._consumers)), _step2; !(_iteratorNormalCompletion2 = (_step2 = _iterator2.next()).done); _iteratorNormalCompletion2 = true) {
											var consumer = _step2.value;
	
											if (consumer.peerName === peerName) {
	
													if (consumer.audioElement) {
															consumer.audioElement.volume = volume;
													}
	
													if (typeof consumer.gainNode !== 'undefined' && typeof consumer.gainNode.gain !== 'undefined' && !isNaN(volume)) {
															consumer.gainNode.gain.setValueAtTime(volume, this.mainContext.currentTime);
															consumer.volume = volume;
													}
	
													if (typeof consumer.panner !== 'undefined' && !isNaN(balance)) {
															consumer.panner.setPosition(balance, 0, 1 - Math.abs(balance));
															consumer.balance = balance;
													}
											}
									}
							} catch (err) {
									_didIteratorError2 = true;
									_iteratorError2 = err;
							} finally {
									try {
											if (!_iteratorNormalCompletion2 && _iterator2.return) {
													_iterator2.return();
											}
									} finally {
											if (_didIteratorError2) {
													throw _iteratorError2;
											}
									}
							}
					}
	
					/* CONSUMERS - END */
	
			}, {
					key: 'producers',
					get: function get() {
							return (0, _from2.default)(this._producers);
					}
			}]);
			return DataStore;
	}();
	
	exports.default = new DataStore();
	
	},{"./helpers/events":4,"./utils":8,"babel-runtime/core-js/array/from":35,"babel-runtime/core-js/get-iterator":36,"babel-runtime/core-js/map":39,"babel-runtime/core-js/object/values":46,"babel-runtime/helpers/classCallCheck":51,"babel-runtime/helpers/createClass":52,"hark":195,"mediastream-gain":196}],2:[function(require,module,exports){
	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
		value: true
	});
	
	var _classCallCheck2 = require('babel-runtime/helpers/classCallCheck');
	
	var _classCallCheck3 = _interopRequireDefault(_classCallCheck2);
	
	var _createClass2 = require('babel-runtime/helpers/createClass');
	
	var _createClass3 = _interopRequireDefault(_createClass2);
	
	var _debug = require('debug');
	
	var _debug2 = _interopRequireDefault(_debug);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	var APP_NAME = 'mediasoup-demo';
	
	var Logger = function () {
		function Logger(prefix) {
			(0, _classCallCheck3.default)(this, Logger);
	
			if (prefix) {
				this._debug = (0, _debug2.default)(APP_NAME + ':' + prefix);
				this._warn = (0, _debug2.default)(APP_NAME + ':WARN:' + prefix);
				this._error = (0, _debug2.default)(APP_NAME + ':ERROR:' + prefix);
			} else {
				this._debug = (0, _debug2.default)(APP_NAME);
				this._warn = (0, _debug2.default)(APP_NAME + ':WARN');
				this._error = (0, _debug2.default)(APP_NAME + ':ERROR');
			}
	
			/* eslint-disable no-console */
			this._debug.log = console.info.bind(console);
			this._warn.log = console.warn.bind(console);
			this._error.log = console.error.bind(console);
			/* eslint-enable no-console */
		}
	
		(0, _createClass3.default)(Logger, [{
			key: 'debug',
			get: function get() {
				return this._debug;
			}
		}, {
			key: 'warn',
			get: function get() {
				return this._warn;
			}
		}, {
			key: 'error',
			get: function get() {
				return this._error;
			}
		}]);
		return Logger;
	}();
	
	exports.default = Logger;
	
	},{"babel-runtime/helpers/classCallCheck":51,"babel-runtime/helpers/createClass":52,"debug":192}],3:[function(require,module,exports){
	'use strict';
	
	if (typeof window.mp === 'undefined') {
			window.mp = {
					invoke: function invoke(name) {
							var _console;
	
							for (var _len = arguments.length, args = Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
									args[_key - 1] = arguments[_key];
							}
	
							(_console = console).log.apply(_console, ['invoke', name].concat(args));
					},
					trigger: function trigger(name) {
							var _console2;
	
							for (var _len2 = arguments.length, args = Array(_len2 > 1 ? _len2 - 1 : 0), _key2 = 1; _key2 < _len2; _key2++) {
									args[_key2 - 1] = arguments[_key2];
							}
	
							(_console2 = console).log.apply(_console2, ['trigger', name].concat(args));
					},
					enableDebuggingAlerts: function enableDebuggingAlerts() {}
			};
	}
	
	},{}],4:[function(require,module,exports){
	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
			value: true
	});
	
	var _stringify = require('babel-runtime/core-js/json/stringify');
	
	var _stringify2 = _interopRequireDefault(_stringify);
	
	var _extends2 = require('babel-runtime/helpers/extends');
	
	var _extends3 = _interopRequireDefault(_extends2);
	
	var _set = require('babel-runtime/core-js/set');
	
	var _set2 = _interopRequireDefault(_set);
	
	var _toConsumableArray2 = require('babel-runtime/helpers/toConsumableArray');
	
	var _toConsumableArray3 = _interopRequireDefault(_toConsumableArray2);
	
	var _map = require('babel-runtime/core-js/map');
	
	var _map2 = _interopRequireDefault(_map);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	/**
	 * @type {Map<String, Set<Function>>}
	*/
	var __events = new _map2.default();
	
	if (!window.isRageMp) {
			window.addEventListener('message', function (event) {
					var data = event.data;
					if (__events.has(data.type)) {
							var args = data.args || [];
							callEvent.apply(undefined, [data.type].concat((0, _toConsumableArray3.default)(args)));
					}
			});
	}
	
	var listenEvent = function listenEvent(eventName, eventFunction) {
			if (__events.has(eventName)) {
					var event = __events.get(eventName);
	
					if (!event.has(eventFunction)) {
							event.add(eventFunction);
					}
			} else {
					__events.set(eventName, new _set2.default([eventFunction]));
			}
	};
	
	var callEvent = function callEvent(eventName) {
			for (var _len = arguments.length, args = Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
					args[_key - 1] = arguments[_key];
			}
	
			if (__events.has(eventName)) {
					var event = __events.get(eventName);
	
					event.forEach(function (eventFunction) {
							eventFunction.apply(undefined, args);
					});
			}
	};
	
	var removeEvent = function removeEvent(eventName, eventFunction) {
			if (__events.has(eventName)) {
					var event = __events.get(eventName);
	
					if (event.has(eventFunction)) {
							event.delete(eventFunction);
					} else {
							event.clear();
					}
			}
	};
	
	var FiveMTrigger = function FiveMTrigger(eventName, args) {
			args = (0, _extends3.default)({}, args);
	
			fetch('http://' + eventName, {
					method: 'POST',
					body: (0, _stringify2.default)(args)
			});
	};
	
	var triggerClientChangeStateConnection = function triggerClientChangeStateConnection(state) {
			if (isRageMp) {
					mp.trigger('voice.changeStateConnection', state);
			} else {
					FiveMTrigger('voice/changeStateConnection', { state: state });
			}
	};
	
	var triggerClientRequestMediaPeerResponse = function triggerClientRequestMediaPeerResponse(peerName, status) {
			if (isRageMp) {
					mp.trigger('voice.requestMediaPeerResponse', peerName, status);
			} else {
					FiveMTrigger('voice/requestMediaPeerResponse', { peerName: peerName, status: status });
			}
	};
	
	var triggerClientRequestCloseMediaPeerResponse = function triggerClientRequestCloseMediaPeerResponse(peerName, status) {
			if (isRageMp) {
					mp.trigger('voice.requestCloseMediaPeerResponse', peerName, status);
			} else {
					FiveMTrigger('voice/requestCloseMediaPeerResponse', { peerName: peerName, status: status });
			}
	};
	
	var triggerClientChangeProducerVolume = function triggerClientChangeProducerVolume(volume) {
			if (isRageMp) {
					mp.trigger('voice.changeProducerVolume', volume);
			} else {
					FiveMTrigger('voice/changeProducerVolume', { volume: volume });
			}
	};
	
	var triggerClientChangeConsumerVolume = function triggerClientChangeConsumerVolume(peerName, volume) {
			if (isRageMp) {
					mp.trigger('voice.changeConsumerVolume', peerName, volume);
			} else {
					FiveMTrigger('voice/changeConsumerVolume', { peerName: peerName, volume: volume });
			}
	};
	
	var triggerClientChangeConsumersVolume = function triggerClientChangeConsumersVolume(consumers) {
			if (isRageMp) {
					mp.trigger('voice.changeConsumersVolume', (0, _stringify2.default)(consumers));
			} else {
					FiveMTrigger('voice/changeConsumersVolume', { consumers: consumers });
			}
	};
	
	var triggerClientMicrophoneEnabled = function triggerClientMicrophoneEnabled(peerName, isEnabled) {
			if (isRageMp) {
					mp.trigger('voice.toggleMicrophone', peerName, isEnabled);
			} else {
					FiveMTrigger('voice/toggleMicrophone', { peerName: peerName, isEnabled: isEnabled });
			}
	};
	
	exports.default = {
			on: listenEvent,
			call: callEvent,
			remove: removeEvent,
			triggerClientChangeStateConnection: triggerClientChangeStateConnection,
			triggerClientRequestMediaPeerResponse: triggerClientRequestMediaPeerResponse,
			triggerClientRequestCloseMediaPeerResponse: triggerClientRequestCloseMediaPeerResponse,
			triggerClientChangeProducerVolume: triggerClientChangeProducerVolume,
			triggerClientChangeConsumerVolume: triggerClientChangeConsumerVolume,
			triggerClientChangeConsumersVolume: triggerClientChangeConsumersVolume,
			triggerClientMicrophoneEnabled: triggerClientMicrophoneEnabled,
			__events: __events
	};
	
	},{"babel-runtime/core-js/json/stringify":38,"babel-runtime/core-js/map":39,"babel-runtime/core-js/set":48,"babel-runtime/helpers/extends":53,"babel-runtime/helpers/toConsumableArray":57}],5:[function(require,module,exports){
	'use strict';
	
	var _domready = require('domready');
	
	var _domready2 = _interopRequireDefault(_domready);
	
	var _urlParse = require('url-parse');
	
	var _urlParse2 = _interopRequireDefault(_urlParse);
	
	var _mediasoupClient = require('../mediasoup-client/');
	
	var _Logger = require('./Logger');
	
	var _Logger2 = _interopRequireDefault(_Logger);
	
	var _events = require('./helpers/events');
	
	var _events2 = _interopRequireDefault(_events);
	
	var _newClient = require('./newClient');
	
	var _newClient2 = _interopRequireDefault(_newClient);
	
	var _utils = require('./utils');
	
	var utils = _interopRequireWildcard(_utils);
	
	require('./dummies/mp');
	
	function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	mp.enableDebuggingAlerts(true);
	mp.events = _events2.default;
	
	var logger = new _Logger2.default();
	
	/** @type {NewClient} */
	var client = null;
	
	(0, _domready2.default)(function () {
		logger.debug('DOM ready');
	
		// init(undefined, 'asfds')
	});
	
	function init(playerId, playerToken) {
		var deviceId = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 'default';
		var producerVolume = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : 1;
		var isUsb = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : false;
		var isPositioning = arguments.length > 5 && arguments[5] !== undefined ? arguments[5] : true;
	
		logger.debug('run() [environment:%s]', "development");
	
		var urlParser = new _urlParse2.default(window.location.href, true);
		var produce = urlParser.query.produce !== 'false';
		var isSipEndpoint = urlParser.query.sipEndpoint === 'true';
		var useSimulcast = urlParser.query.simulcast !== 'false';
		var _userName_ = urlParser.query.name;
	
		var peerName = playerId || _userName_;
	
		console.log('myPeerName', peerName);
	
		var device = (0, _mediasoupClient.getDeviceInfo)();
	
		if (isSipEndpoint) {
			device.flag = 'sipendpoint';
			device.name = 'SIP Endpoint';
			device.version = undefined;
		}
	
		client = new _newClient2.default({
			peerName: peerName,
			token: playerToken,
			device: device,
			produce: produce,
			useSimulcast: useSimulcast,
			deviceId: deviceId,
			producerVolume: producerVolume,
			isUsb: isUsb,
			isPositioning: isPositioning
		});
	
		window._client = client;
	}
	
	mp.events.on('init', function (playerId, token, deviceId, producerVolume, isUsb, isPositioning) {
		init(playerId, token, deviceId, producerVolume, isUsb, isPositioning);
	});
	
	mp.events.on('streamIn', function (playerId) {
		if (client && client._stateConnection !== 'closed') {
			client.requestMediaPeer(playerId);
		}
	});
	
	mp.events.on('streamOut', function (playerId) {
		if (client && client._stateConnection !== 'closed') {
			client.requestCloseMediaPeer(playerId);
		}
	});
	
	mp.events.on('changeVolumeConsumer', function (playerId, volume, balance) {
		if (client && client._stateConnection !== 'closed') {
			client.changeConsumerVolume(playerId, volume, balance);
		}
	});
	
	mp.events.on('changeVolumeConsumers', function (peers) {
		if (client && client._stateConnection !== 'closed') {
			client.changeConsumersVolume(peers);
		}
	});
	
	mp.events.on('changeProducerVolume', function (volume) {
		if (client && client._stateConnection !== 'closed') {
			client.changeProducerVolume(volume);
		}
	});
	
	mp.events.on('changeMainVolume', function (volume) {
		if (client && client._stateConnection !== 'closed') {
			client.changeMainVolume(volume);
		}
	});
	
	mp.events.on('changeProducer', function (deviceId) {
		var producerVolume = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 1;
	
		if (client && client._stateConnection !== 'closed') {
			client.changeProducer(deviceId, producerVolume);
		}
	});
	
	mp.events.on('changeProducerIsUsb', function (isUsb) {
		if (client && client._stateConnection !== 'closed') {
			client.changeProducerIsUsb(isUsb);
		}
	});
	
	mp.events.on('changePositioning', function (isPositioning) {
		if (client && client._stateConnection !== 'closed') {
			client.changePositioning(isPositioning);
		}
	});
	
	mp.events.on('muteMic', function () {
		if (client && client._stateConnection !== 'closed') {
			client.muteMic();
		}
	});
	
	mp.events.on('unmuteMic', function () {
		if (client && client._stateConnection !== 'closed') {
			client.unmuteMic();
		}
	});
	
	mp.events.on('restartIce', function () {
		if (client && client._stateConnection !== 'closed') {
			client.restartIce();
		}
	});
	
	mp.events.on('quit', function () {
		if (client && client._stateConnection !== 'closed') {
			client.close();
		}
	});
	
	},{"../mediasoup-client/":32,"./Logger":2,"./dummies/mp":3,"./helpers/events":4,"./newClient":6,"./utils":8,"domready":194,"url-parse":216}],6:[function(require,module,exports){
	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
		value: true
	});
	
	var _getIterator2 = require('babel-runtime/core-js/get-iterator');
	
	var _getIterator3 = _interopRequireDefault(_getIterator2);
	
	var _promise = require('babel-runtime/core-js/promise');
	
	var _promise2 = _interopRequireDefault(_promise);
	
	var _classCallCheck2 = require('babel-runtime/helpers/classCallCheck');
	
	var _classCallCheck3 = _interopRequireDefault(_classCallCheck2);
	
	var _createClass2 = require('babel-runtime/helpers/createClass');
	
	var _createClass3 = _interopRequireDefault(_createClass2);
	
	var _protooClient = require('protoo-client');
	
	var _protooClient2 = _interopRequireDefault(_protooClient);
	
	var _mediasoupClient = require('../mediasoup-client/');
	
	var mediasoupClient = _interopRequireWildcard(_mediasoupClient);
	
	var _Logger = require('./Logger');
	
	var _Logger2 = _interopRequireDefault(_Logger);
	
	var _urlFactory = require('./urlFactory');
	
	var _DataStore = require('./DataStore');
	
	var _DataStore2 = _interopRequireDefault(_DataStore);
	
	var _events = require('./helpers/events');
	
	var _events2 = _interopRequireDefault(_events);
	
	function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	var logger = new _Logger2.default('NewClient');
	
	var ROOM_OPTIONS = {
		requestTimeout: 10000,
		transportOptions: {
			tcp: false
		},
		turnServers: [{ urls: "stun:voice.fpgm.ru:3478", username: "kemperrr", credential: "625101" }, { urls: "turn:voice.fpgm.ru:3478", username: "kemperrr", credential: "625101" }, { urls: "stun:voip.libertyroleplay.ru:3478", username: "disquse", credential: "625101" }, { urls: "turn:voip.libertyroleplay.ru:3478", username: "disquse", credential: "625101" }, { urls: "turn:turn.kandidatrp.ru:3478", username: "kandidat", credential: "1992" }, { urls: "stun:stun.kandidatrp.ru:3478", username: "kandidat", credential: "1992" }, { urls: "stun:top-gta.com:3478", username: "arp", credential: "arparp11" }, { urls: "turn:top-gta.com:3478", username: "arp", credential: "arparp11" }]
	};
	
	var NewClient = function () {
		function NewClient(_ref) {
			var peerName = _ref.peerName,
					token = _ref.token,
					device = _ref.device,
					useSimulcast = _ref.useSimulcast,
					produce = _ref.produce,
					deviceId = _ref.deviceId,
					producerVolume = _ref.producerVolume,
					isUsb = _ref.isUsb,
					isPositioning = _ref.isPositioning;
			(0, _classCallCheck3.default)(this, NewClient);
	
			logger.debug('constructor() [peerName:"%s", device:%s]', peerName, device.flag);
	
			this._dataStore = _DataStore2.default;
	
			var protooUrl = (0, _urlFactory.getProtooUrl)(peerName, token);
			var protooTransport = new _protooClient2.default.WebSocketTransport(protooUrl);
	
			this._token = token;
	
			this._closed = false;
	
			this._produce = produce;
	
			this._useSimulcast = useSimulcast;
	
			this._peerName = peerName;
	
			this.deviceId = deviceId;
	
			this.producerVolume = producerVolume;
	
			this._protoo = new _protooClient2.default.Peer(protooTransport);
	
			this._room = new mediasoupClient.Room(ROOM_OPTIONS);
	
			this._sendTransport = null;
	
			this._recvTransport = null;
	
			this._micProducer = null;
	
			this.isUsb = isUsb;
	
			this.isPositioning = isPositioning;
			_DataStore2.default.changePositioning(isPositioning);
	
			this._stateConnection = 'closed';
	
			this._join({ device: device, token: token });
		}
	
		(0, _createClass3.default)(NewClient, [{
			key: 'setStateConnection',
			value: function setStateConnection(state) {
				this._stateConnection = state;
				_events2.default.triggerClientChangeStateConnection(state);
			}
		}, {
			key: 'close',
			value: function close() {
				var _this = this;
	
				if (this._closed) return;
	
				this._closed = true;
	
				logger.debug('close()');
	
				// Leave the mediasoup Room.
				this._room.leave();
	
				// Close protoo Peer (wait a bit so mediasoup-client can send
				// the 'leaveRoom' notification).
				setTimeout(function () {
					return _this._protoo.close();
				}, 250);
	
				this.setStateConnection('closed');
			}
		}, {
			key: 'requestMediaPeer',
			value: function requestMediaPeer(peerName) {
	
				if (!this._room._peers.has(peerName)) {
					this._room.requestMediaPeer(peerName).then(function (response) {
						_events2.default.triggerClientRequestMediaPeerResponse(peerName, response.status);
					}).catch(function (err) {
						console.log('requestMediaPeer - error', peerName, err);
						_events2.default.triggerClientRequestMediaPeerResponse(peerName, false);
					});
				}
			}
		}, {
			key: 'requestCloseMediaPeer',
			value: function requestCloseMediaPeer(peerName) {
				if (this._room._peers.has(peerName)) this._room.requestCloseMediaPeer(peerName).then(function (response) {
					_events2.default.triggerClientRequestCloseMediaPeerResponse(peerName, response.status);
				}).catch(function (err) {
					console.log('requestCloseMediaPeer - error', peerName, err);
					_events2.default.triggerClientRequestCloseMediaPeerResponse(peerName, false);
				});
			}
		}, {
			key: 'muteMic',
			value: function muteMic() {
				if (!this._micProducer) return false;
	
				logger.debug('muteMic()');
	
				this._micProducer.pause();
			}
		}, {
			key: 'unmuteMic',
			value: function unmuteMic() {
				if (!this._micProducer) return false;
	
				logger.debug('unmuteMic()');
	
				this._micProducer.resume();
			}
		}, {
			key: 'changePositioning',
			value: function changePositioning(isPositioning) {
				this.isPositioning = isPositioning;
				_DataStore2.default.changePositioning(isPositioning);
			}
		}, {
			key: 'changeConsumerVolume',
			value: function changeConsumerVolume(consumerId, volume, balance) {
				_DataStore2.default.changeConsumerVolume(consumerId, volume, balance);
			}
		}, {
			key: 'changeConsumersVolume',
			value: function changeConsumersVolume(peers) {
				peers = typeof peers === 'string' ? JSON.parse(peers) : peers;
	
				peers.forEach(function (peer) {
					_DataStore2.default.changeConsumerVolume(peer.name, peer.volume, peer.balance);
				});
			}
		}, {
			key: 'changeProducerVolume',
			value: function changeProducerVolume(volume) {
				_DataStore2.default.changeProducerVolume(volume);
			}
		}, {
			key: 'changeMainVolume',
			value: function changeMainVolume(volume) {
				_DataStore2.default.changeMainVolume(volume);
			}
		}, {
			key: 'changeProducer',
			value: function changeProducer(deviceId, producerVolume) {
	
				logger.debug('changeProducer() [deviceId:"%s", producerVolume:%d]', deviceId, producerVolume);
	
				this._micProducer.close();
				this.deviceId = deviceId;
				this.producerVolume = producerVolume;
				this._setMicProducer(deviceId, producerVolume, this.isUsb).catch(function () {});
			}
		}, {
			key: 'changeProducerIsUsb',
			value: function changeProducerIsUsb(isUsb) {
				logger.debug('changeProducerIsUsb() [isUsb:"%s"]', isUsb);
	
				this._micProducer.close();
				this.isUsb = isUsb;
				this._setMicProducer(this.deviceId, this.producerVolume, isUsb).catch(function () {});
			}
		}, {
			key: 'restartIce',
			value: function restartIce() {
				var _this2 = this;
	
				logger.debug('restartIce()');
	
				return _promise2.default.resolve().then(function () {
					_this2._room.restartIce();
				}).catch(function (error) {
					logger.error('restartIce() failed: %o', error);
				});
			}
		}, {
			key: '_join',
			value: function _join(_ref2) {
				var _this3 = this;
	
				var device = _ref2.device,
						token = _ref2.token;
	
	
				this.setStateConnection('connecting');
	
				this._protoo.on('open', function () {
					logger.debug('protoo Peer "open" event');
	
					_this3._joinRoom({ device: device, token: token });
				});
	
				this._protoo.on('disconnected', function () {
					logger.warn('protoo Peer "disconnected" event');
	
					// Leave Room.
					try {
						_this3._room.remoteClose({ cause: 'protoo disconnected' });
					} catch (error) {}
	
					_this3.setStateConnection('connecting');
				});
	
				this._protoo.on('close', function () {
					if (_this3._closed) return;
	
					logger.warn('protoo Peer "close" event');
	
					_this3.close();
				});
	
				this._protoo.on('request', function (request, accept, reject) {
					logger.debug('_handleProtooRequest() [method:%s, data:%o]', request.method, request.data);
	
					switch (request.method) {
						case 'mediasoup-notification':
							{
								accept();
	
								var notification = request.data;
	
								_this3._room.receiveNotification(notification);
	
								break;
							}
	
						default:
							{
								logger.error('unknown protoo method "%s"', request.method);
	
								reject(404, 'unknown method');
							}
					}
				});
			}
		}, {
			key: '_joinRoom',
			value: function _joinRoom(_ref3) {
				var _this4 = this;
	
				var device = _ref3.device,
						token = _ref3.token;
	
				logger.debug('_joinRoom()');
	
				this._room.removeAllListeners();
	
				this._room.on('close', function (originator, appData) {
					if (originator === 'remote') {
						logger.warn('mediasoup Peer/Room remotely closed [appData:%o]', appData);
	
						_this4.setStateConnection('closed');
	
						return;
					}
				});
	
				this._room.on('request', function (request, callback, errback) {
					logger.debug('sending mediasoup request [method:%s]:%o', request.method, request);
	
					_this4._protoo.send('mediasoup-request', request).then(callback).catch(errback);
				});
	
				this._room.on('notify', function (notification) {
					logger.debug('sending mediasoup notification [method:%s]:%o', notification.method, notification);
	
					_this4._protoo.send('mediasoup-notification', notification).catch(function (error) {
						logger.warn('could not send mediasoup notification:%o', error);
					});
				});
	
				this._room.on('newpeer', function (peer) {
					logger.debug('room "newpeer" event [name:"%s", peer:%o]', peer.name, peer);
					_this4._handlePeer(peer);
				});
	
				this._room.join(this._peerName, { device: device, token: token }).then(function () {
					// Create Transport for sending.
					_this4._sendTransport = _this4._room.createTransport('send', { media: 'SEND_MIC_WEBCAM' });
	
					_this4._sendTransport.on('close', function (originator) {
						logger.debug('Transport "close" event [originator:%s]', originator);
					});
	
					_this4._sendTransport.on('connectionstatechange', function (state) {
						if (state === 'connected') {
							_this4.setStateConnection('connected');
							console.log('state connected');
						} else if (state === 'failed' || state === 'disconnected') {
							logger.warn("sendTransport connectionstatechange FAILED or DISCONNECTED!");
							_this4.restartIce();
						}
					});
	
					// Create Transport for receiving.
					_this4._recvTransport = _this4._room.createTransport('recv', { media: 'RECV' });
	
					_this4._recvTransport.on('close', function (originator) {
						logger.debug('receiving Transport "close" event [originator:%s]', originator);
					});
	
					_this4._recvTransport.on('connectionstatechange', function (state) {
						if (state === 'failed' || state === 'disconnected') {
							logger.warn("_recvTransport connectionstatechange FAILED or DISCONNECTED!");
							_this4.restartIce();
						}
					});
				}).then(function () {
					// Don't produce if explicitely requested to not to do it.
					if (!_this4._produce) return;
	
					// NOTE: Don't depend on this Promise to continue (so we don't do return).
					_promise2.default.resolve()
					// Add our mic.
					.then(function () {
						if (!_this4._room.canSend('audio')) return;
	
						_this4._setMicProducer(_this4.deviceId, _this4.producerVolume, _this4.isUsb).catch(function () {});
					});
				}).then(function () {
					// this.setStateConnection('connected');
				}).catch(function (error) {
					logger.error('_joinRoom() failed:%o', error);
	
					_this4.close();
				});
			}
		}, {
			key: '_setMicProducer',
			value: function _setMicProducer(deviceId, producerVolume, isUsb) {
				var _this5 = this;
	
				if (!this._room.canSend('audio')) {
					return _promise2.default.reject(new Error('cannot send audio'));
				}
	
				if (this._micProducer) {
					return _promise2.default.reject(new Error('mic Producer already exists'));
				}
	
				var producer = void 0;
	
				return _promise2.default.resolve().then(function () {
					logger.debug('_setMicProducer() | calling getUserMedia()');
	
					var constraints = {
						audio: {
							echoCancellation: window.isRageMp ? true : isUsb ? false : null,
							noiseSuppression: false,
							autoGainControl: false,
							deviceId: deviceId,
							volume: producerVolume
						}
					};
	
					return navigator.mediaDevices.getUserMedia(constraints);
				}).then(function (stream) {
					var track = stream.getAudioTracks()[0];
					track.enabled = false;
	
					producer = _this5._room.createProducer(track, null, { source: 'mic' });
	
					// No need to keep original track.
					track.stop();
	
					// Send it.
					return producer.send(_this5._sendTransport);
				}).then(function () {
					producer.pause();
	
					_this5._micProducer = producer;
	
					_DataStore2.default.addProducer({
						id: producer.id,
						source: 'mic',
						locallyPaused: producer.locallyPaused,
						remotelyPaused: producer.remotelyPaused,
						track: producer.track,
						codec: producer.rtpParameters.codecs[0].name
					});
	
					producer.on('close', function (originator) {
						logger.debug('mic Producer "close" event [originator:%s]', originator);
	
						_this5._micProducer = null;
						_DataStore2.default.removeProducer(producer.id);
					});
	
					producer.on('pause', function (originator) {
						logger.debug('mic Producer "pause" event [originator:%s]', originator);
	
						_DataStore2.default.setProducerPaused(producer.id, originator);
					});
	
					producer.on('resume', function (originator) {
						logger.debug('mic Producer "resume" event [originator:%s]', originator);
	
						_DataStore2.default.setProducerResumed(producer.id, originator);
					});
	
					producer.on('handled', function () {
						logger.debug('mic Producer "handled" event');
					});
	
					producer.on('unhandled', function () {
						logger.debug('mic Producer "unhandled" event');
					});
				}).then(function () {
					logger.debug('_setMicProducer() succeeded');
				}).catch(function (error) {
					logger.error('_setMicProducer() failed:%o', error);
	
					if (producer) producer.close();
	
					/* throw error; */
				});
			}
		}, {
			key: '_handlePeer',
			value: function _handlePeer(peer) {
				var _this6 = this;
	
				var _ref4 = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {},
						_ref4$notify = _ref4.notify,
						notify = _ref4$notify === undefined ? true : _ref4$notify;
	
				_DataStore2.default.addPeer({
					name: peer.name,
					consumers: []
				});
	
				console.log('newPeer', peer.name);
	
				var _iteratorNormalCompletion = true;
				var _didIteratorError = false;
				var _iteratorError = undefined;
	
				try {
					for (var _iterator = (0, _getIterator3.default)(peer.consumers), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
						var consumer = _step.value;
	
						this._handleConsumer(consumer);
					}
				} catch (err) {
					_didIteratorError = true;
					_iteratorError = err;
				} finally {
					try {
						if (!_iteratorNormalCompletion && _iterator.return) {
							_iterator.return();
						}
					} finally {
						if (_didIteratorError) {
							throw _iteratorError;
						}
					}
				}
	
				peer.on('close', function (originator) {
					logger.debug('peer "close" event [name:"%s", originator:%s]', peer.name, originator);
	
					_DataStore2.default.removePeer(peer.name);
				});
	
				peer.on('newconsumer', function (consumer) {
					logger.debug('peer "newconsumer" event [name:"%s", id:%s, consumer:%o]', peer.name, consumer.id, consumer);
	
					_this6._handleConsumer(consumer);
				});
			}
		}, {
			key: '_handleConsumer',
			value: function _handleConsumer(consumer) {
				var codec = consumer.rtpParameters.codecs[0];
	
				_DataStore2.default.addConsumer({
					id: consumer.id,
					peerName: consumer.peer.name,
					source: consumer.appData.source,
					supported: consumer.supported,
					locallyPaused: consumer.locallyPaused,
					remotelyPaused: consumer.remotelyPaused,
					track: null,
					codec: codec ? codec.name : null
				});
	
				consumer.on('close', function (originator) {
					logger.debug('consumer "close" event [id:%s, originator:%s, consumer:%o]', consumer.id, originator, consumer);
	
					_DataStore2.default.removeConsumer(consumer.id);
				});
	
				consumer.on('pause', function (originator) {
					logger.debug('consumer "pause" event [id:%s, originator:%s, consumer:%o]', consumer.id, originator, consumer);
	
					_DataStore2.default.setConsumerPaused(consumer.id, originator);
	
					if (typeof consumer !== 'undefined' && typeof consumer.peer !== 'undefined') {
						_events2.default.triggerClientMicrophoneEnabled(consumer.peer.name, false);
					}
				});
	
				consumer.on('resume', function (originator) {
					logger.debug('consumer "resume" event [id:%s, originator:%s, consumer:%o]', consumer.id, originator, consumer);
	
					_DataStore2.default.setConsumerResumed(consumer.id, originator);
	
					if (typeof consumer !== 'undefined' && typeof consumer.peer !== 'undefined') {
						_events2.default.triggerClientMicrophoneEnabled(consumer.peer.name, true);
					}
				});
	
				consumer.on('effectiveprofilechange', function (profile) {
					logger.debug('consumer "effectiveprofilechange" event [id:%s, consumer:%o, profile:%s]', consumer.id, consumer, profile);
	
					_DataStore2.default.setConsumerEffectiveProfile(consumer.id, profile);
				});
	
				// Receive the consumer (if we can).
				if (consumer.supported) {
	
					consumer.receive(this._recvTransport).then(function (track) {
						_DataStore2.default.setConsumerTrack(consumer.id, track);
					}).catch(function (error) {
						logger.error('unexpected error while receiving a new Consumer:%o', error);
					});
				}
			}
		}, {
			key: 'stateConnection',
			get: function get() {
				return this._stateConnection;
			}
		}]);
		return NewClient;
	}();
	
	exports.default = NewClient;
	
	},{"../mediasoup-client/":32,"./DataStore":1,"./Logger":2,"./helpers/events":4,"./urlFactory":7,"babel-runtime/core-js/get-iterator":36,"babel-runtime/core-js/promise":47,"babel-runtime/helpers/classCallCheck":51,"babel-runtime/helpers/createClass":52,"protoo-client":201}],7:[function(require,module,exports){
	"use strict";
	
	Object.defineProperty(exports, "__esModule", {
		value: true
	});
	exports.getProtooUrl = getProtooUrl;
	function getProtooUrl(peerName, token) {
		var hostname = window.location.hostname;
		var url = "wss://diamond-voice.ru:3443/?peerName=" + peerName + "&token=" + token;
	
		return url;
	}
	
	},{}],8:[function(require,module,exports){
	"use strict";
	
	Object.defineProperty(exports, "__esModule", {
		value: true
	});
	var UUID = exports.UUID = function UUID(a) {
		return a ? (a ^ Math.random() * 16 >> a / 4).toString(16) : ([1e7] + -1e3 + -4e3 + -8e3 + -1e11).replace(/[018]/g, UUID);
	};
	
	var lerp = exports.lerp = function lerp(value_one, value_two, deltaTime) {
		return value_one + (value_two - value_one) * deltaTime;
	};
	
	var clamp = exports.clamp = function clamp(min, max, current) {
		return Math.min(Math.max(current, min), max);
	};
	
	},{}],9:[function(require,module,exports){
	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
		value: true
	});
	
	var _promise = require('babel-runtime/core-js/promise');
	
	var _promise2 = _interopRequireDefault(_promise);
	
	var _extends2 = require('babel-runtime/helpers/extends');
	
	var _extends3 = _interopRequireDefault(_extends2);
	
	var _getPrototypeOf = require('babel-runtime/core-js/object/get-prototype-of');
	
	var _getPrototypeOf2 = _interopRequireDefault(_getPrototypeOf);
	
	var _classCallCheck2 = require('babel-runtime/helpers/classCallCheck');
	
	var _classCallCheck3 = _interopRequireDefault(_classCallCheck2);
	
	var _createClass2 = require('babel-runtime/helpers/createClass');
	
	var _createClass3 = _interopRequireDefault(_createClass2);
	
	var _possibleConstructorReturn2 = require('babel-runtime/helpers/possibleConstructorReturn');
	
	var _possibleConstructorReturn3 = _interopRequireDefault(_possibleConstructorReturn2);
	
	var _inherits2 = require('babel-runtime/helpers/inherits');
	
	var _inherits3 = _interopRequireDefault(_inherits2);
	
	var _events = require('events');
	
	var _Logger = require('./Logger');
	
	var _Logger2 = _interopRequireDefault(_Logger);
	
	var _errors = require('./errors');
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	var logger = new _Logger2.default('CommandQueue');
	
	var CommandQueue = function (_EventEmitter) {
		(0, _inherits3.default)(CommandQueue, _EventEmitter);
	
		function CommandQueue() {
			(0, _classCallCheck3.default)(this, CommandQueue);
	
			var _this = (0, _possibleConstructorReturn3.default)(this, (CommandQueue.__proto__ || (0, _getPrototypeOf2.default)(CommandQueue)).call(this));
	
			_this.setMaxListeners(Infinity);
	
			// Closed flag.
			// @type {Boolean}
			_this._closed = false;
	
			// Busy running a command.
			// @type {Boolean}
			_this._busy = false;
	
			// Queue for pending commands. Each command is an Object with method,
			// resolve, reject, and other members (depending the case).
			// @type {Array<Object>}
			_this._queue = [];
			return _this;
		}
	
		(0, _createClass3.default)(CommandQueue, [{
			key: 'close',
			value: function close() {
				this._closed = true;
			}
		}, {
			key: 'push',
			value: function push(method, data) {
				var _this2 = this;
	
				var command = (0, _extends3.default)({ method: method }, data);
	
				logger.debug('push() [method:%s]', method);
	
				return new _promise2.default(function (resolve, reject) {
					var queue = _this2._queue;
	
					command.resolve = resolve;
					command.reject = reject;
	
					// Append command to the queue.
					queue.push(command);
					_this2._handlePendingCommands();
				});
			}
		}, {
			key: '_handlePendingCommands',
			value: function _handlePendingCommands() {
				var _this3 = this;
	
				if (this._busy) return;
	
				var queue = this._queue;
	
				// Take the first command.
				var command = queue[0];
	
				if (!command) return;
	
				this._busy = true;
	
				// Execute it.
				this._handleCommand(command).then(function () {
					_this3._busy = false;
	
					// Remove the first command (the completed one) from the queue.
					queue.shift();
	
					// And continue.
					_this3._handlePendingCommands();
				});
			}
		}, {
			key: '_handleCommand',
			value: function _handleCommand(command) {
				var _this4 = this;
	
				logger.debug('_handleCommand() [method:%s]', command.method);
	
				if (this._closed) {
					command.reject(new _errors.InvalidStateError('closed'));
	
					return _promise2.default.resolve();
				}
	
				var promiseHolder = { promise: null };
	
				this.emit('exec', command, promiseHolder);
	
				return _promise2.default.resolve().then(function () {
					return promiseHolder.promise;
				}).then(function (result) {
					logger.debug('_handleCommand() | command succeeded [method:%s]', command.method);
	
					if (_this4._closed) {
						command.reject(new _errors.InvalidStateError('closed'));
	
						return;
					}
	
					// Resolve the command with the given result (if any).
					command.resolve(result);
				}).catch(function (error) {
					logger.error('_handleCommand() | command failed [method:%s]: %o', command.method, error);
	
					// Reject the command with the error.
					command.reject(error);
				});
			}
		}]);
		return CommandQueue;
	}(_events.EventEmitter);
	
	exports.default = CommandQueue;
	
	},{"./Logger":13,"./errors":18,"babel-runtime/core-js/object/get-prototype-of":43,"babel-runtime/core-js/promise":47,"babel-runtime/helpers/classCallCheck":51,"babel-runtime/helpers/createClass":52,"babel-runtime/helpers/extends":53,"babel-runtime/helpers/inherits":54,"babel-runtime/helpers/possibleConstructorReturn":55,"events":60}],10:[function(require,module,exports){
	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
		value: true
	});
	
	var _typeof2 = require('babel-runtime/helpers/typeof');
	
	var _typeof3 = _interopRequireDefault(_typeof2);
	
	var _promise = require('babel-runtime/core-js/promise');
	
	var _promise2 = _interopRequireDefault(_promise);
	
	var _getPrototypeOf = require('babel-runtime/core-js/object/get-prototype-of');
	
	var _getPrototypeOf2 = _interopRequireDefault(_getPrototypeOf);
	
	var _classCallCheck2 = require('babel-runtime/helpers/classCallCheck');
	
	var _classCallCheck3 = _interopRequireDefault(_classCallCheck2);
	
	var _createClass2 = require('babel-runtime/helpers/createClass');
	
	var _createClass3 = _interopRequireDefault(_createClass2);
	
	var _possibleConstructorReturn2 = require('babel-runtime/helpers/possibleConstructorReturn');
	
	var _possibleConstructorReturn3 = _interopRequireDefault(_possibleConstructorReturn2);
	
	var _inherits2 = require('babel-runtime/helpers/inherits');
	
	var _inherits3 = _interopRequireDefault(_inherits2);
	
	var _set = require('babel-runtime/core-js/set');
	
	var _set2 = _interopRequireDefault(_set);
	
	var _Logger = require('./Logger');
	
	var _Logger2 = _interopRequireDefault(_Logger);
	
	var _EnhancedEventEmitter2 = require('./EnhancedEventEmitter');
	
	var _EnhancedEventEmitter3 = _interopRequireDefault(_EnhancedEventEmitter2);
	
	var _errors = require('./errors');
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	var PROFILES = new _set2.default(['default', 'low', 'medium', 'high']);
	var DEFAULT_STATS_INTERVAL = 1000;
	
	var logger = new _Logger2.default('Consumer');
	
	var Consumer = function (_EnhancedEventEmitter) {
		(0, _inherits3.default)(Consumer, _EnhancedEventEmitter);
	
		/**
		* @private
		*
		* @emits {originator: String, [appData]: Any} pause
		* @emits {originator: String, [appData]: Any} resume
		* @emits {profile: String} effectiveprofilechange
		* @emits {stats: Object} stats
		* @emits handled
		* @emits unhandled
		* @emits {originator: String} close
		*
		* @emits @close
		*/
		function Consumer(id, kind, rtpParameters, peer, appData) {
			(0, _classCallCheck3.default)(this, Consumer);
	
			// Id.
			// @type {Number}
			var _this = (0, _possibleConstructorReturn3.default)(this, (Consumer.__proto__ || (0, _getPrototypeOf2.default)(Consumer)).call(this, logger));
	
			_this._id = id;
	
			// Closed flag.
			// @type {Boolean}
			_this._closed = false;
	
			// Media kind.
			// @type {String}
			_this._kind = kind;
	
			// RTP parameters.
			// @type {RTCRtpParameters}
			_this._rtpParameters = rtpParameters;
	
			// Associated Peer.
			// @type {Peer}
			_this._peer = peer;
	
			// App custom data.
			// @type {Any}
			_this._appData = appData;
	
			// Whether we can receive this Consumer (based on our RTP capabilities).
			// @type {Boolean}
			_this._supported = false;
	
			// Associated Transport.
			// @type {Transport}
			_this._transport = null;
	
			// Remote track.
			// @type {MediaStreamTrack}
			_this._track = null;
	
			// Locally paused flag.
			// @type {Boolean}
			_this._locallyPaused = false;
	
			// Remotely paused flag.
			// @type {Boolean}
			_this._remotelyPaused = false;
	
			// Periodic stats flag.
			// @type {Boolean}
			_this._statsEnabled = false;
	
			// Periodic stats gathering interval (milliseconds).
			// @type {Number}
			_this._statsInterval = DEFAULT_STATS_INTERVAL;
	
			// Preferred profile.
			// @type {String}
			_this._preferredProfile = 'default';
	
			// Effective profile.
			// @type {String}
			_this._effectiveProfile = null;
			return _this;
		}
	
		/**
		* Consumer id.
		*
		* @return {Number}
		*/
	
	
		(0, _createClass3.default)(Consumer, [{
			key: 'close',
	
	
			/**
		 * Closes the Consumer.
		 * This is called when the local Room is closed.
		 *
		 * @private
		 */
			value: function close() {
				logger.debug('close()');
	
				if (this._closed) return;
	
				this._closed = true;
	
				if (this._statsEnabled) {
					this._statsEnabled = false;
	
					if (this.transport) this.transport.disableConsumerStats(this);
				}
	
				this.emit('@close');
				this.safeEmit('close', 'local');
	
				this._destroy();
			}
	
			/**
		 * My remote Consumer was closed.
		 * Invoked via remote notification.
		 *
		 * @private
		 */
	
		}, {
			key: 'remoteClose',
			value: function remoteClose() {
				logger.debug('remoteClose()');
	
				if (this._closed) return;
	
				this._closed = true;
	
				if (this._transport) this._transport.removeConsumer(this);
	
				this._destroy();
	
				this.emit('@close');
				this.safeEmit('close', 'remote');
			}
		}, {
			key: '_destroy',
			value: function _destroy() {
				this._transport = null;
	
				try {
					this._track.stop();
				} catch (error) {}
	
				this._track = null;
			}
	
			/**
		 * Receives RTP.
		 *
		 * @param {transport} Transport instance.
		 *
		 * @return {Promise} Resolves with a remote MediaStreamTrack.
		 */
	
		}, {
			key: 'receive',
			value: function receive(transport) {
				var _this2 = this;
	
				logger.debug('receive() [transport:%o]', transport);
	
				if (this._closed) return _promise2.default.reject(new _errors.InvalidStateError('Consumer closed'));else if (!this._supported) return _promise2.default.reject(new Error('unsupported codecs'));else if (this._transport) return _promise2.default.reject(new Error('already handled by a Transport'));else if ((typeof transport === 'undefined' ? 'undefined' : (0, _typeof3.default)(transport)) !== 'object') return _promise2.default.reject(new TypeError('invalid Transport'));
	
				this._transport = transport;
	
				return transport.addConsumer(this).then(function (track) {
					_this2._track = track;
	
					// If we were paused, disable the track.
					if (_this2.paused) track.enabled = false;
	
					transport.once('@close', function () {
						if (_this2._closed || _this2._transport !== transport) return;
	
						_this2._transport = null;
	
						try {
							_this2._track.stop();
						} catch (error) {}
	
						_this2._track = null;
	
						_this2.safeEmit('unhandled');
					});
	
					_this2.safeEmit('handled');
	
					if (_this2._statsEnabled) transport.enableConsumerStats(_this2, _this2._statsInterval);
	
					return track;
				}).catch(function (error) {
					_this2._transport = null;
	
					throw error;
				});
			}
	
			/**
		 * Pauses receiving media.
		 *
		 * @param {Any} [appData] - App custom data.
		 *
		 * @return {Boolean} true if paused.
		 */
	
		}, {
			key: 'pause',
			value: function pause(appData) {
				logger.debug('pause()');
	
				if (this._closed) {
					logger.error('pause() | Consumer closed');
	
					return false;
				} else if (this._locallyPaused) {
					return true;
				}
	
				this._locallyPaused = true;
	
				if (this._track) this._track.enabled = false;
	
				if (this._transport) this._transport.pauseConsumer(this, appData);
	
				this.safeEmit('pause', 'local', appData);
	
				// Return true if really paused.
				return this.paused;
			}
	
			/**
		 * My remote Consumer was paused.
		 * Invoked via remote notification.
		 *
		 * @private
		 *
		 * @param {Any} [appData] - App custom data.
		 */
	
		}, {
			key: 'remotePause',
			value: function remotePause(appData) {
				logger.debug('remotePause()');
	
				if (this._closed || this._remotelyPaused) return;
	
				this._remotelyPaused = true;
	
				if (this._track) this._track.enabled = false;
	
				this.safeEmit('pause', 'remote', appData);
			}
	
			/**
		 * Resumes receiving media.
		 *
		 * @param {Any} [appData] - App custom data.
		 *
		 * @return {Boolean} true if not paused.
		 */
	
		}, {
			key: 'resume',
			value: function resume(appData) {
				logger.debug('resume()');
	
				if (this._closed) {
					logger.error('resume() | Consumer closed');
	
					return false;
				} else if (!this._locallyPaused) {
					return true;
				}
	
				this._locallyPaused = false;
	
				if (this._track && !this._remotelyPaused) this._track.enabled = true;
	
				if (this._transport) this._transport.resumeConsumer(this, appData);
	
				this.safeEmit('resume', 'local', appData);
	
				// Return true if not paused.
				return !this.paused;
			}
	
			/**
		 * My remote Consumer was resumed.
		 * Invoked via remote notification.
		 *
		 * @private
		 *
		 * @param {Any} [appData] - App custom data.
		 */
	
		}, {
			key: 'remoteResume',
			value: function remoteResume(appData) {
				logger.debug('remoteResume()');
	
				if (this._closed || !this._remotelyPaused) return;
	
				this._remotelyPaused = false;
	
				if (this._track && !this._locallyPaused) this._track.enabled = true;
	
				this.safeEmit('resume', 'remote', appData);
			}
	
			/**
		 * Set preferred receiving profile.
		 *
		 * @param {String} profile
		 */
	
		}, {
			key: 'setPreferredProfile',
			value: function setPreferredProfile(profile) {
				logger.debug('setPreferredProfile() [profile:%s]', profile);
	
				if (this._closed) {
					logger.error('setPreferredProfile() | Consumer closed');
	
					return;
				} else if (profile === this._preferredProfile) {
					return;
				} else if (!PROFILES.has(profile)) {
					logger.error('setPreferredProfile() | invalid profile "%s"', profile);
	
					return;
				}
	
				this._preferredProfile = profile;
	
				if (this._transport) this._transport.setConsumerPreferredProfile(this, this._preferredProfile);
			}
	
			/**
		 * Preferred receiving profile was set on my remote Consumer.
		 *
		 * @param {String} profile
		 */
	
		}, {
			key: 'remoteSetPreferredProfile',
			value: function remoteSetPreferredProfile(profile) {
				logger.debug('remoteSetPreferredProfile() [profile:%s]', profile);
	
				if (this._closed || profile === this._preferredProfile) return;
	
				this._preferredProfile = profile;
			}
	
			/**
		 * Effective receiving profile changed on my remote Consumer.
		 *
		 * @param {String} profile
		 */
	
		}, {
			key: 'remoteEffectiveProfileChanged',
			value: function remoteEffectiveProfileChanged(profile) {
				logger.debug('remoteEffectiveProfileChanged() [profile:%s]', profile);
	
				if (this._closed || profile === this._effectiveProfile) return;
	
				this._effectiveProfile = profile;
	
				this.safeEmit('effectiveprofilechange', this._effectiveProfile);
			}
	
			/**
		 * Enables periodic stats retrieval.
		 */
	
		}, {
			key: 'enableStats',
			value: function enableStats() {
				var interval = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : DEFAULT_STATS_INTERVAL;
	
				logger.debug('enableStats() [interval:%s]', interval);
	
				if (this._closed) {
					logger.error('enableStats() | Consumer closed');
	
					return;
				}
	
				if (this._statsEnabled) return;
	
				if (typeof interval !== 'number' || interval < 1000) this._statsInterval = DEFAULT_STATS_INTERVAL;else this._statsInterval = interval;
	
				this._statsEnabled = true;
	
				if (this._transport) this._transport.enableConsumerStats(this, this._statsInterval);
			}
	
			/**
		 * Disables periodic stats retrieval.
		 */
	
		}, {
			key: 'disableStats',
			value: function disableStats() {
				logger.debug('disableStats()');
	
				if (this._closed) {
					logger.error('disableStats() | Consumer closed');
	
					return;
				}
	
				if (!this._statsEnabled) return;
	
				this._statsEnabled = false;
	
				if (this._transport) this._transport.disableConsumerStats(this);
			}
	
			/**
		 * Mark this Consumer as suitable for reception or not.
		 *
		 * @private
		 *
		 * @param {Boolean} flag
		 */
	
		}, {
			key: 'setSupported',
			value: function setSupported(flag) {
				this._supported = flag;
			}
	
			/**
		 * Receive remote stats.
		 *
		 * @private
		 *
		 * @param {Object} stats
		 */
	
		}, {
			key: 'remoteStats',
			value: function remoteStats(stats) {
				this.safeEmit('stats', stats);
			}
		}, {
			key: 'id',
			get: function get() {
				return this._id;
			}
	
			/**
		 * Whether the Consumer is closed.
		 *
		 * @return {Boolean}
		 */
	
		}, {
			key: 'closed',
			get: function get() {
				return this._closed;
			}
	
			/**
		 * Media kind.
		 *
		 * @return {String}
		 */
	
		}, {
			key: 'kind',
			get: function get() {
				return this._kind;
			}
	
			/**
		 * RTP parameters.
		 *
		 * @return {RTCRtpParameters}
		 */
	
		}, {
			key: 'rtpParameters',
			get: function get() {
				return this._rtpParameters;
			}
	
			/**
		 * Associated Peer.
		 *
		 * @return {Peer}
		 */
	
		}, {
			key: 'peer',
			get: function get() {
				return this._peer;
			}
	
			/**
		 * App custom data.
		 *
		 * @return {Any}
		 */
	
		}, {
			key: 'appData',
			get: function get() {
				return this._appData;
			}
	
			/**
		 * Whether we can receive this Consumer (based on our RTP capabilities).
		 *
		 * @return {Boolean}
		 */
	
		}, {
			key: 'supported',
			get: function get() {
				return this._supported;
			}
	
			/**
		 * Associated Transport.
		 *
		 * @return {Transport}
		 */
	
		}, {
			key: 'transport',
			get: function get() {
				return this._transport;
			}
	
			/**
		 * The associated track (if any yet).
		 *
		 * @return {MediaStreamTrack|Null}
		 */
	
		}, {
			key: 'track',
			get: function get() {
				return this._track;
			}
	
			/**
		 * Whether the Consumer is locally paused.
		 *
		 * @return {Boolean}
		 */
	
		}, {
			key: 'locallyPaused',
			get: function get() {
				return this._locallyPaused;
			}
	
			/**
		 * Whether the Consumer is remotely paused.
		 *
		 * @return {Boolean}
		 */
	
		}, {
			key: 'remotelyPaused',
			get: function get() {
				return this._remotelyPaused;
			}
	
			/**
		 * Whether the Consumer is paused.
		 *
		 * @return {Boolean}
		 */
	
		}, {
			key: 'paused',
			get: function get() {
				return this._locallyPaused || this._remotelyPaused;
			}
	
			/**
		 * The preferred profile.
		 *
		 * @type {String}
		 */
	
		}, {
			key: 'preferredProfile',
			get: function get() {
				return this._preferredProfile;
			}
	
			/**
		 * The effective profile.
		 *
		 * @type {String}
		 */
	
		}, {
			key: 'effectiveProfile',
			get: function get() {
				return this._effectiveProfile;
			}
		}]);
		return Consumer;
	}(_EnhancedEventEmitter3.default);
	
	exports.default = Consumer;
	
	},{"./EnhancedEventEmitter":12,"./Logger":13,"./errors":18,"babel-runtime/core-js/object/get-prototype-of":43,"babel-runtime/core-js/promise":47,"babel-runtime/core-js/set":48,"babel-runtime/helpers/classCallCheck":51,"babel-runtime/helpers/createClass":52,"babel-runtime/helpers/inherits":54,"babel-runtime/helpers/possibleConstructorReturn":55,"babel-runtime/helpers/typeof":58}],11:[function(require,module,exports){
	(function (global){
	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
		value: true
	});
	
	var _classCallCheck2 = require('babel-runtime/helpers/classCallCheck');
	
	var _classCallCheck3 = _interopRequireDefault(_classCallCheck2);
	
	var _createClass2 = require('babel-runtime/helpers/createClass');
	
	var _createClass3 = _interopRequireDefault(_createClass2);
	
	var _bowser = require('bowser');
	
	var _bowser2 = _interopRequireDefault(_bowser);
	
	var _Logger = require('./Logger');
	
	var _Logger2 = _interopRequireDefault(_Logger);
	
	var _Chrome = require('./handlers/Chrome55');
	
	var _Chrome2 = _interopRequireDefault(_Chrome);
	
	var _Chrome3 = require('./handlers/Chrome67');
	
	var _Chrome4 = _interopRequireDefault(_Chrome3);
	
	var _Safari = require('./handlers/Safari11');
	
	var _Safari2 = _interopRequireDefault(_Safari);
	
	var _Firefox = require('./handlers/Firefox50');
	
	var _Firefox2 = _interopRequireDefault(_Firefox);
	
	var _Firefox3 = require('./handlers/Firefox59');
	
	var _Firefox4 = _interopRequireDefault(_Firefox3);
	
	var _Edge = require('./handlers/Edge11');
	
	var _Edge2 = _interopRequireDefault(_Edge);
	
	var _ReactNative = require('./handlers/ReactNative');
	
	var _ReactNative2 = _interopRequireDefault(_ReactNative);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	var logger = new _Logger2.default('Device');
	
	/**
	 * Class with static members representing the underlying device or browser.
	 */
	
	var Device = function () {
		function Device() {
			(0, _classCallCheck3.default)(this, Device);
		}
	
		(0, _createClass3.default)(Device, null, [{
			key: 'getFlag',
	
			/**
		 * Get the device flag.
		 *
		 * @return {String}
		 */
			value: function getFlag() {
				if (!Device._detected) Device._detect();
	
				return Device._flag;
			}
	
			/**
		 * Get the device name.
		 *
		 * @return {String}
		 */
	
		}, {
			key: 'getName',
			value: function getName() {
				if (!Device._detected) Device._detect();
	
				return Device._name;
			}
	
			/**
		 * Get the device version.
		 *
		 * @return {String}
		 */
	
		}, {
			key: 'getVersion',
			value: function getVersion() {
				if (!Device._detected) Device._detect();
	
				return Device._version;
			}
	
			/**
		 * Get the bowser module Object.
		 *
		 * @return {Object}
		 */
	
		}, {
			key: 'getBowser',
			value: function getBowser() {
				if (!Device._detected) Device._detect();
	
				return Device._bowser;
			}
	
			/**
		 * Whether this device is supported.
		 *
		 * @return {Boolean}
		 */
	
		}, {
			key: 'isSupported',
			value: function isSupported() {
				if (!Device._detected) Device._detect();
	
				return Boolean(Device._handlerClass);
			}
	
			/**
		 * Returns a suitable WebRTC handler class.
		 *
		 * @type {Class}
		 */
	
		}, {
			key: '_detect',
	
	
			/**
		 * Detects the current device/browser.
		 *
		 * @private
		 */
			value: function _detect() {
				Device._detected = true;
	
				// If this is React-Native manually fill data.
				if (global.navigator && global.navigator.product === 'ReactNative') {
					Device._flag = 'react-native';
					Device._name = 'ReactNative';
					Device._version = undefined; // NOTE: No idea how to know it.
					Device._bowser = {};
					Device._handlerClass = _ReactNative2.default;
				}
				// If this is a browser use bowser module detection.
				else if (global.navigator && typeof global.navigator.userAgent === 'string') {
						var ua = global.navigator.userAgent;
						var browser = _bowser2.default.detect(ua);
	
						Device._flag = undefined;
						Device._name = browser.name || undefined;
						Device._version = browser.version || undefined;
						Device._bowser = browser;
						Device._handlerClass = null;
	
						// Chrome, Chromium (desktop and mobile).
						if (_bowser2.default.check({ chrome: '67', chromium: '67' }, true, ua)) {
							Device._flag = 'chrome';
							Device._handlerClass = _Chrome4.default;
						} else if (_bowser2.default.check({ chrome: '55', chromium: '55' }, true, ua)) {
							Device._flag = 'chrome';
							Device._handlerClass = _Chrome2.default;
						}
						// Firefox (desktop and mobile).
						else if (_bowser2.default.check({ firefox: '59' }, true, ua)) {
								Device._flag = 'firefox';
								Device._handlerClass = _Firefox4.default;
							} else if (_bowser2.default.check({ firefox: '50' }, true, ua)) {
								Device._flag = 'firefox';
								Device._handlerClass = _Firefox2.default;
							}
							// Safari (desktop and mobile).
							else if (_bowser2.default.check({ safari: '11' }, true, ua)) {
									Device._flag = 'safari';
									Device._handlerClass = _Safari2.default;
								}
								// Edge (desktop).
								else if (_bowser2.default.check({ msedge: '11' }, true, ua)) {
										Device._flag = 'msedge';
										Device._handlerClass = _Edge2.default;
									}
						// Opera (desktop and mobile).
						if (_bowser2.default.check({ opera: '44' }, true, ua)) {
							Device._flag = 'opera';
							Device._handlerClass = _Chrome2.default;
						}
	
						if (Device.isSupported()) {
							logger.debug('browser supported [flag:%s, name:"%s", version:%s, handler:%s]', Device._flag, Device._name, Device._version, Device._handlerClass.tag);
						} else {
							logger.warn('browser not supported [name:%s, version:%s]', Device._name, Device._version);
						}
					}
					// Otherwise fail.
					else {
							logger.warn('device not supported');
						}
			}
		}, {
			key: 'Handler',
			get: function get() {
				if (!Device._detected) Device._detect();
	
				return Device._handlerClass;
			}
		}]);
		return Device;
	}();
	
	// Initialized flag.
	// @type {Boolean}
	
	
	exports.default = Device;
	Device._detected = false;
	
	// Device flag.
	// @type {String}
	Device._flag = undefined;
	
	// Device name.
	// @type {String}
	Device._name = undefined;
	
	// Device version.
	// @type {String}
	Device._version = undefined;
	
	// bowser module Object.
	// @type {Object}
	Device._bowser = undefined;
	
	// WebRTC hander for this device.
	// @type {Class}
	Device._handlerClass = null;
	
	}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})
	
	},{"./Logger":13,"./handlers/Chrome55":19,"./handlers/Chrome67":20,"./handlers/Edge11":21,"./handlers/Firefox50":22,"./handlers/Firefox59":23,"./handlers/ReactNative":24,"./handlers/Safari11":25,"babel-runtime/helpers/classCallCheck":51,"babel-runtime/helpers/createClass":52,"bowser":59}],12:[function(require,module,exports){
	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
		value: true
	});
	
	var _promise = require('babel-runtime/core-js/promise');
	
	var _promise2 = _interopRequireDefault(_promise);
	
	var _getPrototypeOf = require('babel-runtime/core-js/object/get-prototype-of');
	
	var _getPrototypeOf2 = _interopRequireDefault(_getPrototypeOf);
	
	var _classCallCheck2 = require('babel-runtime/helpers/classCallCheck');
	
	var _classCallCheck3 = _interopRequireDefault(_classCallCheck2);
	
	var _createClass2 = require('babel-runtime/helpers/createClass');
	
	var _createClass3 = _interopRequireDefault(_createClass2);
	
	var _possibleConstructorReturn2 = require('babel-runtime/helpers/possibleConstructorReturn');
	
	var _possibleConstructorReturn3 = _interopRequireDefault(_possibleConstructorReturn2);
	
	var _inherits2 = require('babel-runtime/helpers/inherits');
	
	var _inherits3 = _interopRequireDefault(_inherits2);
	
	var _events = require('events');
	
	var _Logger = require('./Logger');
	
	var _Logger2 = _interopRequireDefault(_Logger);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	var EnhancedEventEmitter = function (_EventEmitter) {
		(0, _inherits3.default)(EnhancedEventEmitter, _EventEmitter);
	
		function EnhancedEventEmitter(logger) {
			(0, _classCallCheck3.default)(this, EnhancedEventEmitter);
	
			var _this = (0, _possibleConstructorReturn3.default)(this, (EnhancedEventEmitter.__proto__ || (0, _getPrototypeOf2.default)(EnhancedEventEmitter)).call(this));
	
			_this.setMaxListeners(Infinity);
	
			_this._logger = logger || new _Logger2.default('EnhancedEventEmitter');
			return _this;
		}
	
		(0, _createClass3.default)(EnhancedEventEmitter, [{
			key: 'safeEmit',
			value: function safeEmit(event) {
				try {
					for (var _len = arguments.length, args = Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
						args[_key - 1] = arguments[_key];
					}
	
					this.emit.apply(this, [event].concat(args));
				} catch (error) {
					this._logger.error('safeEmit() | event listener threw an error [event:%s]:%o', event, error);
				}
			}
		}, {
			key: 'safeEmitAsPromise',
			value: function safeEmitAsPromise(event) {
				var _this2 = this;
	
				for (var _len2 = arguments.length, args = Array(_len2 > 1 ? _len2 - 1 : 0), _key2 = 1; _key2 < _len2; _key2++) {
					args[_key2 - 1] = arguments[_key2];
				}
	
				return new _promise2.default(function (resolve, reject) {
					var callback = function callback(result) {
						resolve(result);
					};
	
					var errback = function errback(error) {
						_this2._logger.error('safeEmitAsPromise() | errback called [event:%s]:%o', event, error);
	
						reject(error);
					};
	
					_this2.safeEmit.apply(_this2, [event].concat(args, [callback, errback]));
				});
			}
		}]);
		return EnhancedEventEmitter;
	}(_events.EventEmitter);
	
	exports.default = EnhancedEventEmitter;
	
	},{"./Logger":13,"babel-runtime/core-js/object/get-prototype-of":43,"babel-runtime/core-js/promise":47,"babel-runtime/helpers/classCallCheck":51,"babel-runtime/helpers/createClass":52,"babel-runtime/helpers/inherits":54,"babel-runtime/helpers/possibleConstructorReturn":55,"events":60}],13:[function(require,module,exports){
	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
		value: true
	});
	
	var _classCallCheck2 = require('babel-runtime/helpers/classCallCheck');
	
	var _classCallCheck3 = _interopRequireDefault(_classCallCheck2);
	
	var _createClass2 = require('babel-runtime/helpers/createClass');
	
	var _createClass3 = _interopRequireDefault(_createClass2);
	
	var _debug = require('debug');
	
	var _debug2 = _interopRequireDefault(_debug);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	var APP_NAME = 'mediasoup-client';
	
	var Logger = function () {
		function Logger(prefix) {
			(0, _classCallCheck3.default)(this, Logger);
	
			if (prefix) {
				this._debug = (0, _debug2.default)(APP_NAME + ':' + prefix);
				this._warn = (0, _debug2.default)(APP_NAME + ':WARN:' + prefix);
				this._error = (0, _debug2.default)(APP_NAME + ':ERROR:' + prefix);
			} else {
				this._debug = (0, _debug2.default)(APP_NAME);
				this._warn = (0, _debug2.default)(APP_NAME + ':WARN');
				this._error = (0, _debug2.default)(APP_NAME + ':ERROR');
			}
	
			/* eslint-disable no-console */
			this._debug.log = console.info.bind(console);
			this._warn.log = console.warn.bind(console);
			this._error.log = console.error.bind(console);
			/* eslint-enable no-console */
		}
	
		(0, _createClass3.default)(Logger, [{
			key: 'debug',
			get: function get() {
				return this._debug;
			}
		}, {
			key: 'warn',
			get: function get() {
				return this._warn;
			}
		}, {
			key: 'error',
			get: function get() {
				return this._error;
			}
		}]);
		return Logger;
	}();
	
	exports.default = Logger;
	
	},{"babel-runtime/helpers/classCallCheck":51,"babel-runtime/helpers/createClass":52,"debug":192}],14:[function(require,module,exports){
	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
		value: true
	});
	
	var _from = require('babel-runtime/core-js/array/from');
	
	var _from2 = _interopRequireDefault(_from);
	
	var _getIterator2 = require('babel-runtime/core-js/get-iterator');
	
	var _getIterator3 = _interopRequireDefault(_getIterator2);
	
	var _map = require('babel-runtime/core-js/map');
	
	var _map2 = _interopRequireDefault(_map);
	
	var _getPrototypeOf = require('babel-runtime/core-js/object/get-prototype-of');
	
	var _getPrototypeOf2 = _interopRequireDefault(_getPrototypeOf);
	
	var _classCallCheck2 = require('babel-runtime/helpers/classCallCheck');
	
	var _classCallCheck3 = _interopRequireDefault(_classCallCheck2);
	
	var _createClass2 = require('babel-runtime/helpers/createClass');
	
	var _createClass3 = _interopRequireDefault(_createClass2);
	
	var _possibleConstructorReturn2 = require('babel-runtime/helpers/possibleConstructorReturn');
	
	var _possibleConstructorReturn3 = _interopRequireDefault(_possibleConstructorReturn2);
	
	var _inherits2 = require('babel-runtime/helpers/inherits');
	
	var _inherits3 = _interopRequireDefault(_inherits2);
	
	var _Logger = require('./Logger');
	
	var _Logger2 = _interopRequireDefault(_Logger);
	
	var _EnhancedEventEmitter2 = require('./EnhancedEventEmitter');
	
	var _EnhancedEventEmitter3 = _interopRequireDefault(_EnhancedEventEmitter2);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	var logger = new _Logger2.default('Peer');
	
	var Peer = function (_EnhancedEventEmitter) {
		(0, _inherits3.default)(Peer, _EnhancedEventEmitter);
	
		/**
		* @private
		*
		* @emits {consumer: Consumer} newconsumer
		* @emits {originator: String, [appData]: Any} close
		*
		* @emits @close
		*/
		function Peer(name, appData) {
			(0, _classCallCheck3.default)(this, Peer);
	
			// Name.
			// @type {String}
			var _this = (0, _possibleConstructorReturn3.default)(this, (Peer.__proto__ || (0, _getPrototypeOf2.default)(Peer)).call(this, logger));
	
			_this._name = name;
	
			// Closed flag.
			// @type {Boolean}
			_this._closed = false;
	
			// App custom data.
			// @type {Any}
			_this._appData = appData;
	
			// Map of Consumers indexed by id.
			// @type {map<Number, Consumer>}
			_this._consumers = new _map2.default();
			return _this;
		}
	
		/**
		* Peer name.
		*
		* @return {String}
		*/
	
	
		(0, _createClass3.default)(Peer, [{
			key: 'close',
	
	
			/**
		 * Closes the Peer.
		 * This is called when the local Room is closed.
		 *
		 * @private
		 */
			value: function close() {
				logger.debug('close()');
	
				if (this._closed) return;
	
				this._closed = true;
	
				this.emit('@close');
				this.safeEmit('close', 'local');
	
				// Close all the Consumers.
				var _iteratorNormalCompletion = true;
				var _didIteratorError = false;
				var _iteratorError = undefined;
	
				try {
					for (var _iterator = (0, _getIterator3.default)(this._consumers.values()), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
						var consumer = _step.value;
	
						consumer.close();
					}
				} catch (err) {
					_didIteratorError = true;
					_iteratorError = err;
				} finally {
					try {
						if (!_iteratorNormalCompletion && _iterator.return) {
							_iterator.return();
						}
					} finally {
						if (_didIteratorError) {
							throw _iteratorError;
						}
					}
				}
			}
	
			/**
		 * The remote Peer or Room was closed.
		 * Invoked via remote notification.
		 *
		 * @private
		 *
		 * @param {Any} [appData] - App custom data.
		 */
	
		}, {
			key: 'remoteClose',
			value: function remoteClose(appData) {
				logger.debug('remoteClose()');
	
				if (this._closed) return;
	
				this._closed = true;
	
				this.emit('@close');
				this.safeEmit('close', 'remote', appData);
	
				// Close all the Consumers.
				var _iteratorNormalCompletion2 = true;
				var _didIteratorError2 = false;
				var _iteratorError2 = undefined;
	
				try {
					for (var _iterator2 = (0, _getIterator3.default)(this._consumers.values()), _step2; !(_iteratorNormalCompletion2 = (_step2 = _iterator2.next()).done); _iteratorNormalCompletion2 = true) {
						var consumer = _step2.value;
	
						consumer.remoteClose();
					}
				} catch (err) {
					_didIteratorError2 = true;
					_iteratorError2 = err;
				} finally {
					try {
						if (!_iteratorNormalCompletion2 && _iterator2.return) {
							_iterator2.return();
						}
					} finally {
						if (_didIteratorError2) {
							throw _iteratorError2;
						}
					}
				}
			}
	
			/**
		 * Get the Consumer with the given id.
		 *
		 * @param {Number} id
		 *
		 * @return {Consumer}
		 */
	
		}, {
			key: 'getConsumerById',
			value: function getConsumerById(id) {
				return this._consumers.get(id);
			}
	
			/**
		 * Add an associated Consumer.
		 *
		 * @private
		 *
		 * @param {Consumer} consumer
		 */
	
		}, {
			key: 'addConsumer',
			value: function addConsumer(consumer) {
				var _this2 = this;
	
				if (this._consumers.has(consumer.id)) throw new Error('Consumer already exists [id:' + consumer.id + ']');
	
				// Store it.
				this._consumers.set(consumer.id, consumer);
	
				// Handle it.
				consumer.on('@close', function () {
					_this2._consumers.delete(consumer.id);
				});
	
				// Emit event.
				this.safeEmit('newconsumer', consumer);
			}
		}, {
			key: 'name',
			get: function get() {
				return this._name;
			}
	
			/**
		 * Whether the Peer is closed.
		 *
		 * @return {Boolean}
		 */
	
		}, {
			key: 'closed',
			get: function get() {
				return this._closed;
			}
	
			/**
		 * App custom data.
		 *
		 * @return {Any}
		 */
	
		}, {
			key: 'appData',
			get: function get() {
				return this._appData;
			}
	
			/**
		 * The list of Consumers.
		 *
		 * @return {Array<Consumer>}
		 */
	
		}, {
			key: 'consumers',
			get: function get() {
				return (0, _from2.default)(this._consumers.values());
			}
		}]);
		return Peer;
	}(_EnhancedEventEmitter3.default);
	
	exports.default = Peer;
	
	},{"./EnhancedEventEmitter":12,"./Logger":13,"babel-runtime/core-js/array/from":35,"babel-runtime/core-js/get-iterator":36,"babel-runtime/core-js/map":39,"babel-runtime/core-js/object/get-prototype-of":43,"babel-runtime/helpers/classCallCheck":51,"babel-runtime/helpers/createClass":52,"babel-runtime/helpers/inherits":54,"babel-runtime/helpers/possibleConstructorReturn":55}],15:[function(require,module,exports){
	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
		value: true
	});
	
	var _promise = require('babel-runtime/core-js/promise');
	
	var _promise2 = _interopRequireDefault(_promise);
	
	var _extends2 = require('babel-runtime/helpers/extends');
	
	var _extends3 = _interopRequireDefault(_extends2);
	
	var _typeof2 = require('babel-runtime/helpers/typeof');
	
	var _typeof3 = _interopRequireDefault(_typeof2);
	
	var _getPrototypeOf = require('babel-runtime/core-js/object/get-prototype-of');
	
	var _getPrototypeOf2 = _interopRequireDefault(_getPrototypeOf);
	
	var _classCallCheck2 = require('babel-runtime/helpers/classCallCheck');
	
	var _classCallCheck3 = _interopRequireDefault(_classCallCheck2);
	
	var _createClass2 = require('babel-runtime/helpers/createClass');
	
	var _createClass3 = _interopRequireDefault(_createClass2);
	
	var _possibleConstructorReturn2 = require('babel-runtime/helpers/possibleConstructorReturn');
	
	var _possibleConstructorReturn3 = _interopRequireDefault(_possibleConstructorReturn2);
	
	var _inherits2 = require('babel-runtime/helpers/inherits');
	
	var _inherits3 = _interopRequireDefault(_inherits2);
	
	var _Logger = require('./Logger');
	
	var _Logger2 = _interopRequireDefault(_Logger);
	
	var _EnhancedEventEmitter2 = require('./EnhancedEventEmitter');
	
	var _EnhancedEventEmitter3 = _interopRequireDefault(_EnhancedEventEmitter2);
	
	var _errors = require('./errors');
	
	var _utils = require('./utils');
	
	var utils = _interopRequireWildcard(_utils);
	
	function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	var DEFAULT_STATS_INTERVAL = 1000;
	var SIMULCAST_DEFAULT = {
		low: 100000,
		medium: 300000,
		high: 1500000
	};
	
	var logger = new _Logger2.default('Producer');
	
	var Producer = function (_EnhancedEventEmitter) {
		(0, _inherits3.default)(Producer, _EnhancedEventEmitter);
	
		/**
		* @private
		*
		* @emits {originator: String, [appData]: Any} pause
		* @emits {originator: String, [appData]: Any} resume
		* @emits {stats: Object} stats
		* @emits handled
		* @emits unhandled
		* @emits trackended
		* @emits {originator: String, [appData]: Any} close
		*
		* @emits {originator: String, [appData]: Any} @close
		*/
		function Producer(track, options, appData) {
			(0, _classCallCheck3.default)(this, Producer);
	
			// Id.
			// @type {Number}
			var _this = (0, _possibleConstructorReturn3.default)(this, (Producer.__proto__ || (0, _getPrototypeOf2.default)(Producer)).call(this, logger));
	
			_this._id = utils.randomNumber();
	
			// Closed flag.
			// @type {Boolean}
			_this._closed = false;
	
			// Original track.
			// @type {MediaStreamTrack}
			_this._originalTrack = track;
	
			// Track cloned from the original one (if supported).
			// @type {MediaStreamTrack}
			try {
				_this._track = track.clone();
			} catch (error) {
				_this._track = track;
			}
	
			// App custom data.
			// @type {Any}
			_this._appData = appData;
	
			// Simulcast.
			// @type {Object|false}
			_this._simulcast = false;
	
			if ((0, _typeof3.default)(options.simulcast) === 'object') _this._simulcast = (0, _extends3.default)({}, SIMULCAST_DEFAULT, options.simulcast);else if (options.simulcast === true) _this._simulcast = (0, _extends3.default)({}, SIMULCAST_DEFAULT);
	
			// Associated Transport.
			// @type {Transport}
			_this._transport = null;
	
			// RTP parameters.
			// @type {RTCRtpParameters}
			_this._rtpParameters = null;
	
			// Locally paused flag.
			// @type {Boolean}
			_this._locallyPaused = !_this._track.enabled;
	
			// Remotely paused flag.
			// @type {Boolean}
			_this._remotelyPaused = false;
	
			// Periodic stats flag.
			// @type {Boolean}
			_this._statsEnabled = false;
	
			// Periodic stats gathering interval (milliseconds).
			// @type {Number}
			_this._statsInterval = DEFAULT_STATS_INTERVAL;
	
			// Handle the effective track.
			_this._handleTrack();
			return _this;
		}
	
		/**
		* Producer id.
		*
		* @return {Number}
		*/
	
	
		(0, _createClass3.default)(Producer, [{
			key: 'close',
	
	
			/**
		 * Closes the Producer.
		 *
		 * @param {Any} [appData] - App custom data.
		 */
			value: function close(appData) {
				logger.debug('close()');
	
				if (this._closed) return;
	
				this._closed = true;
	
				if (this._statsEnabled) {
					this._statsEnabled = false;
	
					if (this.transport) {
						this.transport.disableProducerStats(this);
					}
				}
	
				if (this._transport) this._transport.removeProducer(this, 'local', appData);
	
				this._destroy();
	
				this.emit('@close', 'local', appData);
				this.safeEmit('close', 'local', appData);
			}
	
			/**
		 * My remote Producer was closed.
		 * Invoked via remote notification.
		 *
		 * @private
		 *
		 * @param {Any} [appData] - App custom data.
		 */
	
		}, {
			key: 'remoteClose',
			value: function remoteClose(appData) {
				logger.debug('remoteClose()');
	
				if (this._closed) return;
	
				this._closed = true;
	
				if (this._transport) this._transport.removeProducer(this, 'remote', appData);
	
				this._destroy();
	
				this.emit('@close', 'remote', appData);
				this.safeEmit('close', 'remote', appData);
			}
		}, {
			key: '_destroy',
			value: function _destroy() {
				this._transport = false;
				this._rtpParameters = null;
	
				try {
					this._track.stop();
				} catch (error) {}
			}
	
			/**
		 * Sends RTP.
		 *
		 * @param {Transport} transport instance.
		 *
		 * @return {Promise}
		 */
	
		}, {
			key: 'send',
			value: function send(transport) {
				var _this2 = this;
	
				logger.debug('send() [transport:%o]', transport);
	
				if (this._closed) return _promise2.default.reject(new _errors.InvalidStateError('Producer closed'));else if (this._transport) return _promise2.default.reject(new Error('already handled by a Transport'));else if ((typeof transport === 'undefined' ? 'undefined' : (0, _typeof3.default)(transport)) !== 'object') return _promise2.default.reject(new TypeError('invalid Transport'));
	
				this._transport = transport;
	
				return transport.addProducer(this).then(function () {
					transport.once('@close', function () {
						if (_this2._closed || _this2._transport !== transport) return;
	
						_this2._transport.removeProducer(_this2, 'local');
	
						_this2._transport = null;
						_this2._rtpParameters = null;
	
						_this2.safeEmit('unhandled');
					});
	
					_this2.safeEmit('handled');
	
					if (_this2._statsEnabled) transport.enableProducerStats(_this2, _this2._statsInterval);
				}).catch(function (error) {
					_this2._transport = null;
	
					throw error;
				});
			}
	
			/**
		 * Pauses sending media.
		 *
		 * @param {Any} [appData] - App custom data.
		 *
		 * @return {Boolean} true if paused.
		 */
	
		}, {
			key: 'pause',
			value: function pause(appData) {
				logger.debug('pause()');
	
				if (this._closed) {
					logger.error('pause() | Producer closed');
	
					return false;
				} else if (this._locallyPaused) {
					return true;
				}
	
				this._locallyPaused = true;
				this._track.enabled = false;
	
				if (this._transport) this._transport.pauseProducer(this, appData);
	
				this.safeEmit('pause', 'local', appData);
	
				// Return true if really paused.
				return this.paused;
			}
	
			/**
		 * My remote Producer was paused.
		 * Invoked via remote notification.
		 *
		 * @private
		 *
		 * @param {Any} [appData] - App custom data.
		 */
	
		}, {
			key: 'remotePause',
			value: function remotePause(appData) {
				logger.debug('remotePause()');
	
				if (this._closed || this._remotelyPaused) return;
	
				this._remotelyPaused = true;
				this._track.enabled = false;
	
				this.safeEmit('pause', 'remote', appData);
			}
	
			/**
		 * Resumes sending media.
		 *
		 * @param {Any} [appData] - App custom data.
		 *
		 * @return {Boolean} true if not paused.
		 */
	
		}, {
			key: 'resume',
			value: function resume(appData) {
				logger.debug('resume()');
	
				if (this._closed) {
					logger.error('resume() | Producer closed');
	
					return false;
				} else if (!this._locallyPaused) {
					return true;
				}
	
				this._locallyPaused = false;
	
				if (!this._remotelyPaused) this._track.enabled = true;
	
				if (this._transport) this._transport.resumeProducer(this, appData);
	
				this.safeEmit('resume', 'local', appData);
	
				// Return true if not paused.
				return !this.paused;
			}
	
			/**
		 * My remote Producer was resumed.
		 * Invoked via remote notification.
		 *
		 * @private
		 *
		 * @param {Any} [appData] - App custom data.
		 */
	
		}, {
			key: 'remoteResume',
			value: function remoteResume(appData) {
				logger.debug('remoteResume()');
	
				if (this._closed || !this._remotelyPaused) return;
	
				this._remotelyPaused = false;
	
				if (!this._locallyPaused) this._track.enabled = true;
	
				this.safeEmit('resume', 'remote', appData);
			}
	
			/**
		 * Replaces the current track with a new one.
		 *
		 * @param {MediaStreamTrack} track - New track.
		 *
		 * @return {Promise} Resolves with the new track itself.
		 */
	
		}, {
			key: 'replaceTrack',
			value: function replaceTrack(track) {
				var _this3 = this;
	
				logger.debug('replaceTrack() [track:%o]', track);
	
				if (this._closed) return _promise2.default.reject(new _errors.InvalidStateError('Producer closed'));else if (!(track instanceof MediaStreamTrack)) return _promise2.default.reject(new TypeError('track is not a MediaStreamTrack'));else if (track.readyState === 'ended') return _promise2.default.reject(new Error('track.readyState is "ended"'));
	
				var clonedTrack = void 0;
	
				try {
					clonedTrack = track.clone();
				} catch (error) {
					clonedTrack = track;
				}
	
				return _promise2.default.resolve().then(function () {
					// If this Producer is handled by a Transport, we need to tell it about
					// the new track.
					if (_this3._transport) return _this3._transport.replaceProducerTrack(_this3, clonedTrack);
				}).then(function () {
					// Stop the previous track.
					try {
						_this3._track.onended = null;_this3._track.stop();
					} catch (error) {}
	
					// If this Producer was locally paused/resumed and the state of the new
					// track does not match, fix it.
					if (!_this3.paused) clonedTrack.enabled = true;else clonedTrack.enabled = false;
	
					// Set the new tracks.
					_this3._originalTrack = track;
					_this3._track = clonedTrack;
	
					// Handle the effective track.
					_this3._handleTrack();
	
					// Return the new track.
					return _this3._track;
				});
			}
	
			/**
		 * Set/update RTP parameters.
		 *
		 * @private
		 *
		 * @param {RTCRtpParameters} rtpParameters
		 */
	
		}, {
			key: 'setRtpParameters',
			value: function setRtpParameters(rtpParameters) {
				this._rtpParameters = rtpParameters;
			}
	
			/**
		 * Enables periodic stats retrieval.
		 */
	
		}, {
			key: 'enableStats',
			value: function enableStats() {
				var interval = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : DEFAULT_STATS_INTERVAL;
	
				logger.debug('enableStats() [interval:%s]', interval);
	
				if (this._closed) {
					logger.error('enableStats() | Producer closed');
	
					return;
				}
	
				if (this._statsEnabled) return;
	
				if (typeof interval !== 'number' || interval < 1000) this._statsInterval = DEFAULT_STATS_INTERVAL;else this._statsInterval = interval;
	
				this._statsEnabled = true;
	
				if (this._transport) this._transport.enableProducerStats(this, this._statsInterval);
			}
	
			/**
		 * Disables periodic stats retrieval.
		 */
	
		}, {
			key: 'disableStats',
			value: function disableStats() {
				logger.debug('disableStats()');
	
				if (this._closed) {
					logger.error('disableStats() | Producer closed');
	
					return;
				}
	
				if (!this._statsEnabled) return;
	
				this._statsEnabled = false;
	
				if (this._transport) this._transport.disableProducerStats(this);
			}
	
			/**
		 * Receive remote stats.
		 *
		 * @private
		 *
		 * @param {Object} stats
		 */
	
		}, {
			key: 'remoteStats',
			value: function remoteStats(stats) {
				this.safeEmit('stats', stats);
			}
	
			/**
		 * @private
		 */
	
		}, {
			key: '_handleTrack',
			value: function _handleTrack() {
				var _this4 = this;
	
				// If the cloned track is closed (for example if the desktop sharing is closed
				// via chrome UI) notify the app and let it decide wheter to close the Producer
				// or not.
				this._track.onended = function () {
					if (_this4._closed) return;
	
					logger.warn('track "ended" event');
	
					_this4.safeEmit('trackended');
				};
			}
		}, {
			key: 'id',
			get: function get() {
				return this._id;
			}
	
			/**
		 * Whether the Producer is closed.
		 *
		 * @return {Boolean}
		 */
	
		}, {
			key: 'closed',
			get: function get() {
				return this._closed;
			}
	
			/**
		 * Media kind.
		 *
		 * @return {String}
		 */
	
		}, {
			key: 'kind',
			get: function get() {
				return this._track.kind;
			}
	
			/**
		 * The associated track.
		 *
		 * @return {MediaStreamTrack}
		 */
	
		}, {
			key: 'track',
			get: function get() {
				return this._track;
			}
	
			/**
		 * The associated original track.
		 *
		 * @return {MediaStreamTrack}
		 */
	
		}, {
			key: 'originalTrack',
			get: function get() {
				return this._originalTrack;
			}
	
			/**
		 * Simulcast settings.
		 *
		 * @return {Object|false}
		 */
	
		}, {
			key: 'simulcast',
			get: function get() {
				return this._simulcast;
			}
	
			/**
		 * App custom data.
		 *
		 * @return {Any}
		 */
	
		}, {
			key: 'appData',
			get: function get() {
				return this._appData;
			}
	
			/**
		 * Associated Transport.
		 *
		 * @return {Transport}
		 */
	
		}, {
			key: 'transport',
			get: function get() {
				return this._transport;
			}
	
			/**
		 * RTP parameters.
		 *
		 * @return {RTCRtpParameters}
		 */
	
		}, {
			key: 'rtpParameters',
			get: function get() {
				return this._rtpParameters;
			}
	
			/**
		 * Whether the Producer is locally paused.
		 *
		 * @return {Boolean}
		 */
	
		}, {
			key: 'locallyPaused',
			get: function get() {
				return this._locallyPaused;
			}
	
			/**
		 * Whether the Producer is remotely paused.
		 *
		 * @return {Boolean}
		 */
	
		}, {
			key: 'remotelyPaused',
			get: function get() {
				return this._remotelyPaused;
			}
	
			/**
		 * Whether the Producer is paused.
		 *
		 * @return {Boolean}
		 */
	
		}, {
			key: 'paused',
			get: function get() {
				return this._locallyPaused || this._remotelyPaused;
			}
		}]);
		return Producer;
	}(_EnhancedEventEmitter3.default);
	
	exports.default = Producer;
	
	},{"./EnhancedEventEmitter":12,"./Logger":13,"./errors":18,"./utils":34,"babel-runtime/core-js/object/get-prototype-of":43,"babel-runtime/core-js/promise":47,"babel-runtime/helpers/classCallCheck":51,"babel-runtime/helpers/createClass":52,"babel-runtime/helpers/extends":53,"babel-runtime/helpers/inherits":54,"babel-runtime/helpers/possibleConstructorReturn":55,"babel-runtime/helpers/typeof":58}],16:[function(require,module,exports){
	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
		value: true
	});
	
	var _from = require('babel-runtime/core-js/array/from');
	
	var _from2 = _interopRequireDefault(_from);
	
	var _extends2 = require('babel-runtime/helpers/extends');
	
	var _extends3 = _interopRequireDefault(_extends2);
	
	var _typeof2 = require('babel-runtime/helpers/typeof');
	
	var _typeof3 = _interopRequireDefault(_typeof2);
	
	var _getIterator2 = require('babel-runtime/core-js/get-iterator');
	
	var _getIterator3 = _interopRequireDefault(_getIterator2);
	
	var _promise = require('babel-runtime/core-js/promise');
	
	var _promise2 = _interopRequireDefault(_promise);
	
	var _set = require('babel-runtime/core-js/set');
	
	var _set2 = _interopRequireDefault(_set);
	
	var _map = require('babel-runtime/core-js/map');
	
	var _map2 = _interopRequireDefault(_map);
	
	var _getPrototypeOf = require('babel-runtime/core-js/object/get-prototype-of');
	
	var _getPrototypeOf2 = _interopRequireDefault(_getPrototypeOf);
	
	var _classCallCheck2 = require('babel-runtime/helpers/classCallCheck');
	
	var _classCallCheck3 = _interopRequireDefault(_classCallCheck2);
	
	var _createClass2 = require('babel-runtime/helpers/createClass');
	
	var _createClass3 = _interopRequireDefault(_createClass2);
	
	var _possibleConstructorReturn2 = require('babel-runtime/helpers/possibleConstructorReturn');
	
	var _possibleConstructorReturn3 = _interopRequireDefault(_possibleConstructorReturn2);
	
	var _inherits2 = require('babel-runtime/helpers/inherits');
	
	var _inherits3 = _interopRequireDefault(_inherits2);
	
	var _Logger = require('./Logger');
	
	var _Logger2 = _interopRequireDefault(_Logger);
	
	var _EnhancedEventEmitter2 = require('./EnhancedEventEmitter');
	
	var _EnhancedEventEmitter3 = _interopRequireDefault(_EnhancedEventEmitter2);
	
	var _errors = require('./errors');
	
	var _ortc = require('./ortc');
	
	var ortc = _interopRequireWildcard(_ortc);
	
	var _Device = require('./Device');
	
	var _Device2 = _interopRequireDefault(_Device);
	
	var _Transport = require('./Transport');
	
	var _Transport2 = _interopRequireDefault(_Transport);
	
	var _Producer = require('./Producer');
	
	var _Producer2 = _interopRequireDefault(_Producer);
	
	var _Peer = require('./Peer');
	
	var _Peer2 = _interopRequireDefault(_Peer);
	
	var _Consumer = require('./Consumer');
	
	var _Consumer2 = _interopRequireDefault(_Consumer);
	
	function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	var logger = new _Logger2.default('Room');
	
	var RoomState = {
		new: 'new',
		joining: 'joining',
		joined: 'joined',
		closed: 'closed'
	};
	
	/**
	 * An instance of Room represents a remote multi conference and a local
	 * peer that joins it.
	 */
	
	var Room = function (_EnhancedEventEmitter) {
		(0, _inherits3.default)(Room, _EnhancedEventEmitter);
	
		/**
		* Room class.
		*
		* @param {Object} [options]
		* @param {Object} [roomSettings] Remote room settings, including its RTP
		* capabilities, mandatory codecs, etc. If given, no 'queryRoom' request is sent
		* to the server to discover them.
		* @param {Number} [options.requestTimeout=10000] - Timeout for sent requests
		* (in milliseconds). Defaults to 10000 (10 seconds).
		* @param {Object} [options.transportOptions] - Options for Transport created in mediasoup.
		* @param {Array<RTCIceServer>} [options.turnServers] - Array of TURN servers.
		*
		* @throws {Error} if device is not supported.
		*
		* @emits {request: Object, callback: Function, errback: Function} request
		* @emits {notification: Object} notify
		* @emits {peer: Peer} newpeer
		* @emits {originator: String, [appData]: Any} close
		*/
		function Room(options) {
			(0, _classCallCheck3.default)(this, Room);
	
			var _this = (0, _possibleConstructorReturn3.default)(this, (Room.__proto__ || (0, _getPrototypeOf2.default)(Room)).call(this, logger));
	
			logger.debug('constructor() [options:%o]', options);
	
			if (!_Device2.default.isSupported()) throw new Error('current browser/device not supported');
	
			options = options || {};
	
			// Computed settings.
			// @type {Object}
			_this._settings = {
				roomSettings: options.roomSettings,
				requestTimeout: options.requestTimeout || 10000,
				transportOptions: options.transportOptions || {},
				turnServers: options.turnServers || []
			};
	
			// Room state.
			// @type {Boolean}
			_this._state = RoomState.new;
	
			// My mediasoup Peer name.
			// @type {String}
			_this._peerName = null;
	
			// Map of Transports indexed by id.
			// @type {map<Number, Transport>}
			_this._transports = new _map2.default();
	
			// Map of Producers indexed by id.
			// @type {map<Number, Producer>}
			_this._producers = new _map2.default();
	
			// Map of Peers indexed by name.
			// @type {map<String, Peer>}
			_this._peers = new _map2.default();
	
			// Extended RTP capabilities.
			// @type {Object}
			_this._extendedRtpCapabilities = null;
	
			// Whether we can send audio/video based on computed extended RTP
			// capabilities.
			// @type {Object}
			_this._canSendByKind = {
				audio: false,
				video: false
			};
	
			_this.peersConnectingQueue = new _set2.default();
			return _this;
		}
	
		/**
		* Whether the Room is joined.
		*
		* @return {Boolean}
		*/
	
	
		(0, _createClass3.default)(Room, [{
			key: 'getTransportById',
	
	
			/**
		 * Get the Transport with the given id.
		 *
		 * @param {Number} id
		 *
		 * @return {Transport}
		 */
			value: function getTransportById(id) {
				return this._transports.get(id);
			}
	
			/**
		 * Get the Producer with the given id.
		 *
		 * @param {Number} id
		 *
		 * @return {Producer}
		 */
	
		}, {
			key: 'getProducerById',
			value: function getProducerById(id) {
				return this._producers.get(id);
			}
	
			/**
		 * Get the Peer with the given name.
		 *
		 * @param {String} name
		 *
		 * @return {Peer}
		 */
	
		}, {
			key: 'getPeerByName',
			value: function getPeerByName(name) {
				return this._peers.get(name);
			}
	
			/**
		 * Start the procedures to join a remote room.
		 * @param {String} peerName - My mediasoup Peer name.
		 * @param {Any} [appData] - App custom data.
		 * @return {Promise}
		 */
	
		}, {
			key: 'join',
			value: function join(peerName, appData) {
				var _this2 = this;
	
				logger.debug('join() [peerName:"%s"]', peerName);
	
				if (typeof peerName !== 'string') return _promise2.default.reject(new TypeError('invalid peerName'));
	
				if (this._state !== RoomState.new && this._state !== RoomState.closed) {
					return _promise2.default.reject(new _errors.InvalidStateError('invalid state "' + this._state + '"'));
				}
	
				this._peerName = peerName;
				this._state = RoomState.joining;
	
				var roomSettings = void 0;
	
				return _promise2.default.resolve().then(function () {
					// If Room settings are provided don't query them.
					if (_this2._settings.roomSettings) {
						roomSettings = _this2._settings.roomSettings;
	
						return;
					} else {
						return _this2._sendRequest('queryRoom', { target: 'room' }).then(function (response) {
							roomSettings = response;
	
							logger.debug('join() | got Room settings:%o', roomSettings);
						});
					}
				}).then(function () {
					return _Device2.default.Handler.getNativeRtpCapabilities();
				}).then(function (nativeRtpCapabilities) {
					logger.debug('join() | native RTP capabilities:%o', nativeRtpCapabilities);
	
					// Get extended RTP capabilities.
					_this2._extendedRtpCapabilities = ortc.getExtendedRtpCapabilities(nativeRtpCapabilities, roomSettings.rtpCapabilities);
	
					logger.debug('join() | extended RTP capabilities:%o', _this2._extendedRtpCapabilities);
	
					// Check unsupported codecs.
					var unsupportedRoomCodecs = ortc.getUnsupportedCodecs(roomSettings.rtpCapabilities, roomSettings.mandatoryCodecPayloadTypes, _this2._extendedRtpCapabilities);
	
					if (unsupportedRoomCodecs.length > 0) {
						logger.error('%s mandatory room codecs not supported:%o', unsupportedRoomCodecs.length, unsupportedRoomCodecs);
	
						throw new _errors.UnsupportedError('mandatory room codecs not supported', unsupportedRoomCodecs);
					}
	
					// Check whether we can send audio/video.
					_this2._canSendByKind.audio = ortc.canSend('audio', _this2._extendedRtpCapabilities);
					_this2._canSendByKind.video = ortc.canSend('video', _this2._extendedRtpCapabilities);
	
					// Generate our effective RTP capabilities for receiving media.
					var effectiveLocalRtpCapabilities = ortc.getRtpCapabilities(_this2._extendedRtpCapabilities);
	
					logger.debug('join() | effective local RTP capabilities for receiving:%o', effectiveLocalRtpCapabilities);
	
					var data = {
						target: 'room',
						peerName: _this2._peerName,
						rtpCapabilities: effectiveLocalRtpCapabilities,
						appData: appData
					};
	
					return _this2._sendRequest('join', data).then(function (response) {
						return response.peers;
					});
				}).then(function (peers) {
					// Handle Peers already existing in the room.
					/* for (const peerData of peers || [])
			{
				try
				{
					this._handlePeerData(peerData);
				}
				catch (error)
				{
					logger.error('join() | error handling Peer:%o', error);
				}
			} */
	
					_this2._state = RoomState.joined;
	
					logger.debug('join() | joined the Room');
	
					// Return the list of already existing Peers.
					return _this2.peers;
				}).catch(function (error) {
					_this2._state = RoomState.new;
	
					throw error;
				});
			}
		}, {
			key: 'requestMediaPeer',
			value: function requestMediaPeer(peerName) {
				var _this3 = this;
	
				if (this._peers.has(peerName)) {
					return _promise2.default.resolve().then(function () {
						return { status: false };
					});
				}
	
				if (this.peersConnectingQueue.has(peerName)) {
					return _promise2.default.resolve().then(function () {
						return { status: false };
					});
				}
	
				this.peersConnectingQueue.add(peerName);
	
				logger.debug('requestMediaPeer() [peerName:"%s"]', peerName);
	
				return _promise2.default.resolve().then(function () {
					return _this3._sendRequest('requestMediaPeer', { peerName: peerName, myPeerName: _this3._peerName });
				}).then(function (response) {
	
					if (response.status) {
						_this3._handlePeerData(response.peer);
					}
	
					_this3.peersConnectingQueue.delete(peerName);
	
					logger.debug('requestMediaPeer():status [peerName:"%s", status:"%s"]', peerName, response.status);
	
					return response;
				}).catch(function (err) {
					_this3.peersConnectingQueue.delete(peerName);
					return err;
				});
			}
		}, {
			key: 'requestCloseMediaPeer',
			value: function requestCloseMediaPeer(peerName) {
				var _this4 = this;
	
				logger.debug('requestCloseMediaPeer() [peerName:"%s"]', peerName);
	
				return _promise2.default.resolve().then(function () {
					return _this4._sendRequest('requestCloseMediaPeer', { peerName: peerName, myPeerName: _this4._peerName });
				}).then(function (response) {
					logger.debug('requestCloseMediaPeer():status [peerName:"%s", status:"%s"]', peerName, response.status);
					return response;
				});
			}
	
			/**
		 * Leave the Room.
		 *
		 * @param {Any} [appData] - App custom data.
		 */
	
		}, {
			key: 'leave',
			value: function leave(appData) {
				logger.debug('leave()');
	
				if (this.closed) return;
	
				// Send a notification.
				this._sendNotification('leave', { appData: appData });
	
				// Set closed state after sending the notification (otherwise the
				// notification won't be sent).
				this._state = RoomState.closed;
	
				this.safeEmit('close', 'local', appData);
	
				// Close all the Transports.
				var _iteratorNormalCompletion = true;
				var _didIteratorError = false;
				var _iteratorError = undefined;
	
				try {
					for (var _iterator = (0, _getIterator3.default)(this._transports.values()), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
						var transport = _step.value;
	
						transport.close();
					}
	
					// Close all the Producers.
				} catch (err) {
					_didIteratorError = true;
					_iteratorError = err;
				} finally {
					try {
						if (!_iteratorNormalCompletion && _iterator.return) {
							_iterator.return();
						}
					} finally {
						if (_didIteratorError) {
							throw _iteratorError;
						}
					}
				}
	
				var _iteratorNormalCompletion2 = true;
				var _didIteratorError2 = false;
				var _iteratorError2 = undefined;
	
				try {
					for (var _iterator2 = (0, _getIterator3.default)(this._producers.values()), _step2; !(_iteratorNormalCompletion2 = (_step2 = _iterator2.next()).done); _iteratorNormalCompletion2 = true) {
						var producer = _step2.value;
	
						producer.close();
					}
	
					// Close all the Peers.
				} catch (err) {
					_didIteratorError2 = true;
					_iteratorError2 = err;
				} finally {
					try {
						if (!_iteratorNormalCompletion2 && _iterator2.return) {
							_iterator2.return();
						}
					} finally {
						if (_didIteratorError2) {
							throw _iteratorError2;
						}
					}
				}
	
				var _iteratorNormalCompletion3 = true;
				var _didIteratorError3 = false;
				var _iteratorError3 = undefined;
	
				try {
					for (var _iterator3 = (0, _getIterator3.default)(this._peers.values()), _step3; !(_iteratorNormalCompletion3 = (_step3 = _iterator3.next()).done); _iteratorNormalCompletion3 = true) {
						var peer = _step3.value;
	
						peer.close();
					}
				} catch (err) {
					_didIteratorError3 = true;
					_iteratorError3 = err;
				} finally {
					try {
						if (!_iteratorNormalCompletion3 && _iterator3.return) {
							_iterator3.return();
						}
					} finally {
						if (_didIteratorError3) {
							throw _iteratorError3;
						}
					}
				}
			}
	
			/**
		 * The remote Room was closed or our remote Peer has been closed.
		 * Invoked via remote notification or via API.
		 *
		 * @param {Any} [appData] - App custom data.
		 */
	
		}, {
			key: 'remoteClose',
			value: function remoteClose(appData) {
				logger.debug('remoteClose()');
	
				if (this.closed) return;
	
				this._state = RoomState.closed;
	
				this.safeEmit('close', 'remote', appData);
	
				// Close all the Transports.
				var _iteratorNormalCompletion4 = true;
				var _didIteratorError4 = false;
				var _iteratorError4 = undefined;
	
				try {
					for (var _iterator4 = (0, _getIterator3.default)(this._transports.values()), _step4; !(_iteratorNormalCompletion4 = (_step4 = _iterator4.next()).done); _iteratorNormalCompletion4 = true) {
						var transport = _step4.value;
	
						transport.remoteClose();
					}
	
					// Close all the Producers.
				} catch (err) {
					_didIteratorError4 = true;
					_iteratorError4 = err;
				} finally {
					try {
						if (!_iteratorNormalCompletion4 && _iterator4.return) {
							_iterator4.return();
						}
					} finally {
						if (_didIteratorError4) {
							throw _iteratorError4;
						}
					}
				}
	
				var _iteratorNormalCompletion5 = true;
				var _didIteratorError5 = false;
				var _iteratorError5 = undefined;
	
				try {
					for (var _iterator5 = (0, _getIterator3.default)(this._producers.values()), _step5; !(_iteratorNormalCompletion5 = (_step5 = _iterator5.next()).done); _iteratorNormalCompletion5 = true) {
						var producer = _step5.value;
	
						producer.remoteClose();
					}
	
					// Close all the Peers.
				} catch (err) {
					_didIteratorError5 = true;
					_iteratorError5 = err;
				} finally {
					try {
						if (!_iteratorNormalCompletion5 && _iterator5.return) {
							_iterator5.return();
						}
					} finally {
						if (_didIteratorError5) {
							throw _iteratorError5;
						}
					}
				}
	
				var _iteratorNormalCompletion6 = true;
				var _didIteratorError6 = false;
				var _iteratorError6 = undefined;
	
				try {
					for (var _iterator6 = (0, _getIterator3.default)(this._peers.values()), _step6; !(_iteratorNormalCompletion6 = (_step6 = _iterator6.next()).done); _iteratorNormalCompletion6 = true) {
						var peer = _step6.value;
	
						peer.remoteClose();
					}
				} catch (err) {
					_didIteratorError6 = true;
					_iteratorError6 = err;
				} finally {
					try {
						if (!_iteratorNormalCompletion6 && _iterator6.return) {
							_iterator6.return();
						}
					} finally {
						if (_didIteratorError6) {
							throw _iteratorError6;
						}
					}
				}
			}
	
			/**
		 * Whether we can send audio/video.
		 *
		 * @param {String} kind - 'audio' or 'video'.
		 *
		 * @return {Boolean}
		 */
	
		}, {
			key: 'canSend',
			value: function canSend(kind) {
				if (!this.joined) throw new _errors.InvalidStateError('invalid state "' + this._state + '"');else if (kind !== 'audio' && kind !== 'video') throw new TypeError('invalid kind "' + kind + '"');
	
				return this._canSendByKind[kind];
			}
	
			/**
		 * Creates a Transport.
		 *
		 * @param {String} direction - Must be 'send' or 'recv'.
		 * @param {Any} [appData] - App custom data.
		 *
		 * @return {Transport}
		 *
		 * @throws {InvalidStateError} if not joined.
		 * @throws {TypeError} if wrong arguments.
		 */
	
		}, {
			key: 'createTransport',
			value: function createTransport(direction, appData) {
				var _this5 = this;
	
				logger.debug('createTransport() [direction:%s]', direction);
	
				if (!this.joined) throw new _errors.InvalidStateError('invalid state "' + this._state + '"');else if (direction !== 'send' && direction !== 'recv') throw new TypeError('invalid direction "' + direction + '"');
	
				// Create a new Transport.
				var transport = new _Transport2.default(direction, this._extendedRtpCapabilities, this._settings, appData);
	
				// Store it.
				this._transports.set(transport.id, transport);
	
				transport.on('@request', function (method, data, callback, errback) {
					_this5._sendRequest(method, data).then(callback).catch(errback);
				});
	
				transport.on('@notify', function (method, data) {
					_this5._sendNotification(method, data);
				});
	
				transport.on('@close', function () {
					_this5._transports.delete(transport.id);
				});
	
				return transport;
			}
	
			/**
		 * Creates a Producer.
		 *
		 * @param {MediaStreamTrack} track
		 * @param {Object} [options]
		 * @param {Object} [options.simulcast]
		 * @param {Any} [appData] - App custom data.
		 *
		 * @return {Producer}
		 *
		 * @throws {InvalidStateError} if not joined.
		 * @throws {TypeError} if wrong arguments.
		 * @throws {Error} if cannot send the given kind.
		 */
	
		}, {
			key: 'createProducer',
			value: function createProducer(track, options, appData) {
				var _this6 = this;
	
				logger.debug('createProducer() [track:%o, options:%o]', track, options);
	
				if (!this.joined) throw new _errors.InvalidStateError('invalid state "' + this._state + '"');else if (!(track instanceof MediaStreamTrack)) throw new TypeError('track is not a MediaStreamTrack');else if (!this._canSendByKind[track.kind]) throw new Error('cannot send ' + track.kind);else if (track.readyState === 'ended') throw new Error('track.readyState is "ended"');
	
				options = options || {};
	
				// Create a new Producer.
				var producer = new _Producer2.default(track, options, appData);
	
				// Store it.
				this._producers.set(producer.id, producer);
	
				producer.on('@close', function () {
					_this6._producers.delete(producer.id);
				});
	
				return producer;
			}
	
			/**
		 * Produce a ICE restart in all the Transports.
		 */
	
		}, {
			key: 'restartIce',
			value: function restartIce() {
				if (!this.joined) throw new _errors.InvalidStateError('invalid state "' + this._state + '"');
	
				var _iteratorNormalCompletion7 = true;
				var _didIteratorError7 = false;
				var _iteratorError7 = undefined;
	
				try {
					for (var _iterator7 = (0, _getIterator3.default)(this._transports.values()), _step7; !(_iteratorNormalCompletion7 = (_step7 = _iterator7.next()).done); _iteratorNormalCompletion7 = true) {
						var transport = _step7.value;
	
						transport.restartIce();
					}
				} catch (err) {
					_didIteratorError7 = true;
					_iteratorError7 = err;
				} finally {
					try {
						if (!_iteratorNormalCompletion7 && _iterator7.return) {
							_iterator7.return();
						}
					} finally {
						if (_didIteratorError7) {
							throw _iteratorError7;
						}
					}
				}
			}
	
			/**
		 * Provide the local Room with a notification generated by mediasoup server.
		 *
		 * @param {Object} notification
		 */
	
		}, {
			key: 'receiveNotification',
			value: function receiveNotification(notification) {
				var _this7 = this;
	
				if (this.closed) return _promise2.default.reject(new _errors.InvalidStateError('Room closed'));else if ((typeof notification === 'undefined' ? 'undefined' : (0, _typeof3.default)(notification)) !== 'object') return _promise2.default.reject(new TypeError('wrong notification Object'));else if (notification.notification !== true) return _promise2.default.reject(new TypeError('not a notification'));else if (typeof notification.method !== 'string') return _promise2.default.reject(new TypeError('wrong/missing notification method'));
	
				var method = notification.method;
	
	
				logger.debug('receiveNotification() [method:%s, notification:%o]', method, notification);
	
				return _promise2.default.resolve().then(function () {
					switch (method) {
						case 'closed':
							{
								var appData = notification.appData;
	
	
								_this7.remoteClose(appData);
	
								break;
							}
	
						case 'transportClosed':
							{
								var id = notification.id,
										_appData = notification.appData;
	
								var transport = _this7._transports.get(id);
	
								if (!transport) throw new Error('Transport not found [id:"' + id + '"]');
	
								transport.remoteClose(_appData);
	
								break;
							}
	
						case 'transportStats':
							{
								var _id = notification.id,
										stats = notification.stats;
	
								var _transport = _this7._transports.get(_id);
	
								if (!_transport) throw new Error('transport not found [id:' + _id + ']');
	
								_transport.remoteStats(stats);
	
								break;
							}
	
						case 'newPeer':
							{
								var name = notification.name;
	
	
								if (_this7._peers.has(name)) throw new Error('Peer already exists [name:"' + name + '"]');
	
								var peerData = notification;
	
								_this7._handlePeerData(peerData);
	
								break;
							}
	
						case 'peerClosed':
							{
	
								if (!_this7.closed) {
									var peerName = notification.name;
									var _appData2 = notification.appData;
	
									var peer = _this7._peers.get(peerName);
	
									if (!peer) return; // throw new Error(`no Peer found [name:"${peerName}"]`);
	
									peer.remoteClose(_appData2);
								}
	
								break;
							}
	
						case 'producerPaused':
							{
								var _id2 = notification.id,
										_appData3 = notification.appData;
	
								var producer = _this7._producers.get(_id2);
	
								if (!producer) throw new Error('Producer not found [id:' + _id2 + ']');
	
								producer.remotePause(_appData3);
	
								break;
							}
	
						case 'producerResumed':
							{
								var _id3 = notification.id,
										_appData4 = notification.appData;
	
								var _producer = _this7._producers.get(_id3);
	
								if (!_producer) throw new Error('Producer not found [id:' + _id3 + ']');
	
								_producer.remoteResume(_appData4);
	
								break;
							}
	
						case 'producerClosed':
							{
								var _id4 = notification.id,
										_appData5 = notification.appData;
	
								var _producer2 = _this7._producers.get(_id4);
	
								if (!_producer2) throw new Error('Producer not found [id:' + _id4 + ']');
	
								_producer2.remoteClose(_appData5);
	
								break;
							}
	
						case 'producerStats':
							{
								var _id5 = notification.id,
										_stats = notification.stats;
	
								var _producer3 = _this7._producers.get(_id5);
	
								if (!_producer3) throw new Error('Producer not found [id:' + _id5 + ']');
	
								_producer3.remoteStats(_stats);
	
								break;
							}
	
						case 'newConsumer':
							{
								var _peerName = notification.peerName;
	
								var _peer = _this7._peers.get(_peerName);
	
								if (!_peer) throw new Error('no Peer found [name:"' + _peerName + '"]');
	
								var consumerData = notification;
	
								_this7._handleConsumerData(consumerData, _peer);
	
								break;
							}
	
						case 'consumerClosed':
							{
								var _id6 = notification.id,
										_peerName2 = notification.peerName,
										_appData6 = notification.appData;
	
								var _peer2 = _this7._peers.get(_peerName2);
	
								if (!_peer2) throw new Error('no Peer found [name:"' + _peerName2 + '"]');
	
								var consumer = _peer2.getConsumerById(_id6);
	
								if (!consumer) throw new Error('Consumer not found [id:' + _id6 + ']');
	
								consumer.remoteClose(_appData6);
	
								break;
							}
	
						case 'consumerPaused':
							{
								var _id7 = notification.id,
										_peerName3 = notification.peerName,
										_appData7 = notification.appData;
	
								var _peer3 = _this7._peers.get(_peerName3);
	
								if (!_peer3) throw new Error('no Peer found [name:"' + _peerName3 + '"]');
	
								var _consumer = _peer3.getConsumerById(_id7);
	
								if (!_consumer) throw new Error('Consumer not found [id:' + _id7 + ']');
	
								_consumer.remotePause(_appData7);
	
								break;
							}
	
						case 'consumerResumed':
							{
								var _id8 = notification.id,
										_peerName4 = notification.peerName,
										_appData8 = notification.appData;
	
								var _peer4 = _this7._peers.get(_peerName4);
	
								if (!_peer4) throw new Error('no Peer found [name:"' + _peerName4 + '"]');
	
								var _consumer2 = _peer4.getConsumerById(_id8);
	
								if (!_consumer2) throw new Error('Consumer not found [id:' + _id8 + ']');
	
								_consumer2.remoteResume(_appData8);
	
								break;
							}
	
						case 'consumerPreferredProfileSet':
							{
								var _id9 = notification.id,
										_peerName5 = notification.peerName,
										profile = notification.profile;
	
								var _peer5 = _this7._peers.get(_peerName5);
	
								if (!_peer5) throw new Error('no Peer found [name:"' + _peerName5 + '"]');
	
								var _consumer3 = _peer5.getConsumerById(_id9);
	
								if (!_consumer3) throw new Error('Consumer not found [id:' + _id9 + ']');
	
								_consumer3.remoteSetPreferredProfile(profile);
	
								break;
							}
	
						case 'consumerEffectiveProfileChanged':
							{
								var _id10 = notification.id,
										_peerName6 = notification.peerName,
										_profile = notification.profile;
	
								var _peer6 = _this7._peers.get(_peerName6);
	
								if (!_peer6) throw new Error('no Peer found [name:"' + _peerName6 + '"]');
	
								var _consumer4 = _peer6.getConsumerById(_id10);
	
								if (!_consumer4) throw new Error('Consumer not found [id:' + _id10 + ']');
	
								_consumer4.remoteEffectiveProfileChanged(_profile);
	
								break;
							}
	
						case 'consumerStats':
							{
								var _id11 = notification.id,
										_peerName7 = notification.peerName,
										_stats2 = notification.stats;
	
								var _peer7 = _this7._peers.get(_peerName7);
	
								if (!_peer7) throw new Error('no Peer found [name:"' + _peerName7 + '"]');
	
								var _consumer5 = _peer7.getConsumerById(_id11);
	
								if (!_consumer5) throw new Error('Consumer not found [id:' + _id11 + ']');
	
								_consumer5.remoteStats(_stats2);
	
								break;
							}
	
						default:
							throw new Error('unknown notification method "' + method + '"');
					}
				}).catch(function (error) {
					logger.error('receiveNotification() failed [notification:%o]: %s', notification, error);
				});
			}
		}, {
			key: '_sendRequest',
			value: function _sendRequest(method, data) {
				var _this8 = this;
	
				var request = (0, _extends3.default)({ method: method, target: 'peer' }, data);
	
				// Should never happen.
				// Ignore if closed.
				if (this.closed) {
					logger.error('_sendRequest() | Room closed [method:%s, request:%o]', method, request);
	
					return _promise2.default.reject(new _errors.InvalidStateError('Room closed'));
				}
	
				logger.debug('_sendRequest() [method:%s, request:%o]', method, request);
	
				return new _promise2.default(function (resolve, reject) {
					var done = false;
	
					var timer = setTimeout(function () {
						logger.error('request failed [method:%s]: timeout', method);
	
						done = true;
						reject(new _errors.TimeoutError('timeout'));
					}, _this8._settings.requestTimeout);
	
					var callback = function callback(response) {
						if (done) return;
	
						done = true;
						clearTimeout(timer);
	
						if (_this8.closed) {
							logger.error('request failed [method:%s]: Room closed', method);
	
							reject(new Error('Room closed'));
	
							return;
						}
	
						logger.debug('request succeeded [method:%s, response:%o]', method, response);
	
						resolve(response);
					};
	
					var errback = function errback(error) {
						if (done) return;
	
						done = true;
						clearTimeout(timer);
	
						if (_this8.closed) {
							logger.error('request failed [method:%s]: Room closed', method);
	
							reject(new Error('Room closed'));
	
							return;
						}
	
						// Make sure message is an Error.
						if (!(error instanceof Error)) error = new Error(String(error));
	
						logger.error('request failed [method:%s]:%o', method, error);
	
						reject(error);
					};
	
					_this8.safeEmit('request', request, callback, errback);
				});
			}
		}, {
			key: '_sendNotification',
			value: function _sendNotification(method, data) {
				// Ignore if closed.
				if (this.closed) return;
	
				var notification = (0, _extends3.default)({ method: method, target: 'peer', notification: true }, data);
	
				logger.debug('_sendNotification() [method:%s, notification:%o]', method, notification);
	
				this.safeEmit('notify', notification);
			}
		}, {
			key: '_handlePeerData',
			value: function _handlePeerData(peerData) {
				var _this9 = this;
	
				var name = peerData.name,
						consumers = peerData.consumers,
						appData = peerData.appData;
	
				var peer = new _Peer2.default(name, appData);
	
				// Store it.
				this._peers.set(peer.name, peer);
	
				peer.on('@close', function () {
					_this9._peers.delete(peer.name);
				});
	
				// Add consumers.
	
				if ((typeof consumers === 'undefined' ? 'undefined' : (0, _typeof3.default)(consumers)) === 'object') {
					var _iteratorNormalCompletion8 = true;
					var _didIteratorError8 = false;
					var _iteratorError8 = undefined;
	
					try {
						for (var _iterator8 = (0, _getIterator3.default)(consumers), _step8; !(_iteratorNormalCompletion8 = (_step8 = _iterator8.next()).done); _iteratorNormalCompletion8 = true) {
							var consumerData = _step8.value;
	
							try {
								this._handleConsumerData(consumerData, peer);
							} catch (error) {
								logger.error('error handling existing Consumer in Peer:%o', error);
							}
						}
					} catch (err) {
						_didIteratorError8 = true;
						_iteratorError8 = err;
					} finally {
						try {
							if (!_iteratorNormalCompletion8 && _iterator8.return) {
								_iterator8.return();
							}
						} finally {
							if (_didIteratorError8) {
								throw _iteratorError8;
							}
						}
					}
				}
	
				// If already joined emit event.
				if (this.joined) this.safeEmit('newpeer', peer);
			}
		}, {
			key: '_handleConsumerData',
			value: function _handleConsumerData(producerData, peer) {
				var id = producerData.id,
						kind = producerData.kind,
						rtpParameters = producerData.rtpParameters,
						paused = producerData.paused,
						appData = producerData.appData;
	
				var consumer = new _Consumer2.default(id, kind, rtpParameters, peer, appData);
				var supported = ortc.canReceive(consumer.rtpParameters, this._extendedRtpCapabilities);
	
				if (supported) consumer.setSupported(true);
	
				if (paused) consumer.remotePause();
	
				peer.addConsumer(consumer);
			}
		}, {
			key: 'joined',
			get: function get() {
				return this._state === RoomState.joined;
			}
	
			/**
		 * Whether the Room is closed.
		 *
		 * @return {Boolean}
		 */
	
		}, {
			key: 'closed',
			get: function get() {
				return this._state === RoomState.closed;
			}
	
			/**
		 * My mediasoup Peer name.
		 *
		 * @return {String}
		 */
	
		}, {
			key: 'peerName',
			get: function get() {
				return this._peerName;
			}
	
			/**
		 * The list of Transports.
		 *
		 * @return {Array<Transport>}
		 */
	
		}, {
			key: 'transports',
			get: function get() {
				return (0, _from2.default)(this._transports.values());
			}
	
			/**
		 * The list of Producers.
		 *
		 * @return {Array<Producer>}
		 */
	
		}, {
			key: 'producers',
			get: function get() {
				return (0, _from2.default)(this._producers.values());
			}
	
			/**
		 * The list of Peers.
		 *
		 * @return {Array<Peer>}
		 */
	
		}, {
			key: 'peers',
			get: function get() {
				return (0, _from2.default)(this._peers.values());
			}
		}]);
		return Room;
	}(_EnhancedEventEmitter3.default);
	
	exports.default = Room;
	
	},{"./Consumer":10,"./Device":11,"./EnhancedEventEmitter":12,"./Logger":13,"./Peer":14,"./Producer":15,"./Transport":17,"./errors":18,"./ortc":33,"babel-runtime/core-js/array/from":35,"babel-runtime/core-js/get-iterator":36,"babel-runtime/core-js/map":39,"babel-runtime/core-js/object/get-prototype-of":43,"babel-runtime/core-js/promise":47,"babel-runtime/core-js/set":48,"babel-runtime/helpers/classCallCheck":51,"babel-runtime/helpers/createClass":52,"babel-runtime/helpers/extends":53,"babel-runtime/helpers/inherits":54,"babel-runtime/helpers/possibleConstructorReturn":55,"babel-runtime/helpers/typeof":58}],17:[function(require,module,exports){
	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
		value: true
	});
	
	var _promise = require('babel-runtime/core-js/promise');
	
	var _promise2 = _interopRequireDefault(_promise);
	
	var _getPrototypeOf = require('babel-runtime/core-js/object/get-prototype-of');
	
	var _getPrototypeOf2 = _interopRequireDefault(_getPrototypeOf);
	
	var _classCallCheck2 = require('babel-runtime/helpers/classCallCheck');
	
	var _classCallCheck3 = _interopRequireDefault(_classCallCheck2);
	
	var _createClass2 = require('babel-runtime/helpers/createClass');
	
	var _createClass3 = _interopRequireDefault(_createClass2);
	
	var _possibleConstructorReturn2 = require('babel-runtime/helpers/possibleConstructorReturn');
	
	var _possibleConstructorReturn3 = _interopRequireDefault(_possibleConstructorReturn2);
	
	var _inherits2 = require('babel-runtime/helpers/inherits');
	
	var _inherits3 = _interopRequireDefault(_inherits2);
	
	var _Logger = require('./Logger');
	
	var _Logger2 = _interopRequireDefault(_Logger);
	
	var _EnhancedEventEmitter2 = require('./EnhancedEventEmitter');
	
	var _EnhancedEventEmitter3 = _interopRequireDefault(_EnhancedEventEmitter2);
	
	var _errors = require('./errors');
	
	var _utils = require('./utils');
	
	var utils = _interopRequireWildcard(_utils);
	
	var _Device = require('./Device');
	
	var _Device2 = _interopRequireDefault(_Device);
	
	var _CommandQueue = require('./CommandQueue');
	
	var _CommandQueue2 = _interopRequireDefault(_CommandQueue);
	
	function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	var DEFAULT_STATS_INTERVAL = 1000;
	
	var logger = new _Logger2.default('Transport');
	
	var Transport = function (_EnhancedEventEmitter) {
		(0, _inherits3.default)(Transport, _EnhancedEventEmitter);
	
		/**
		* @private
		*
		* @emits {state: String} connectionstatechange
		* @emits {stats: Object} stats
		* @emits {originator: String, [appData]: Any} close
		*
		* @emits {method: String, [data]: Object, callback: Function, errback: Function} @request
		* @emits {method: String, [data]: Object} @notify
		* @emits @close
		*/
		function Transport(direction, extendedRtpCapabilities, settings, appData) {
			(0, _classCallCheck3.default)(this, Transport);
	
			var _this = (0, _possibleConstructorReturn3.default)(this, (Transport.__proto__ || (0, _getPrototypeOf2.default)(Transport)).call(this, logger));
	
			logger.debug('constructor() [direction:%s, extendedRtpCapabilities:%o]', direction, extendedRtpCapabilities);
	
			// Id.
			// @type {Number}
			_this._id = utils.randomNumber();
	
			// Closed flag.
			// @type {Boolean}
			_this._closed = false;
	
			// Direction.
			// @type {String}
			_this._direction = direction;
	
			// Room settings.
			// @type {Object}
			_this._settings = settings;
	
			// App custom data.
			// @type {Any}
			_this._appData = appData;
	
			// Periodic stats flag.
			// @type {Boolean}
			_this._statsEnabled = false;
	
			// Commands handler.
			// @type {CommandQueue}
			_this._commandQueue = new _CommandQueue2.default();
	
			// Device specific handler.
			_this._handler = new _Device2.default.Handler(direction, extendedRtpCapabilities, settings);
	
			// Transport state. Values can be:
			// 'new'/'connecting'/'connected'/'failed'/'disconnected'/'closed'
			// @type {String}
			_this._connectionState = 'new';
	
			_this._commandQueue.on('exec', _this._execCommand.bind(_this));
	
			_this._handleHandler();
			return _this;
		}
	
		/**
		* Transport id.
		*
		* @return {Number}
		*/
	
	
		(0, _createClass3.default)(Transport, [{
			key: 'close',
	
	
			/**
		 * Close the Transport.
		 *
		 * @param {Any} [appData] - App custom data.
		 */
			value: function close(appData) {
				logger.debug('close()');
	
				if (this._closed) return;
	
				this._closed = true;
	
				if (this._statsEnabled) {
					this._statsEnabled = false;
					this.disableStats();
				}
	
				this.safeEmit('@notify', 'closeTransport', { id: this._id, appData: appData });
	
				this.emit('@close');
				this.safeEmit('close', 'local', appData);
	
				this._destroy();
			}
	
			/**
		 * My remote Transport was closed.
		 * Invoked via remote notification.
		 *
		 * @private
		 *
		 * @param {Any} [appData] - App custom data.
		 */
	
		}, {
			key: 'remoteClose',
			value: function remoteClose(appData) {
				logger.debug('remoteClose()');
	
				if (this._closed) return;
	
				this._closed = true;
	
				this.emit('@close');
				this.safeEmit('close', 'remote', appData);
	
				this._destroy();
			}
		}, {
			key: '_destroy',
			value: function _destroy() {
				// Close the CommandQueue.
				this._commandQueue.close();
	
				// Close the handler.
				this._handler.close();
			}
		}, {
			key: 'restartIce',
			value: function restartIce() {
				var _this2 = this;
	
				logger.debug('restartIce()');
	
				if (this._closed) return;else if (this._connectionState === 'new') return;
	
				_promise2.default.resolve().then(function () {
					var data = {
						id: _this2._id
					};
	
					return _this2.safeEmitAsPromise('@request', 'restartTransport', data);
				}).then(function (response) {
					var remoteIceParameters = response.iceParameters;
	
					// Enqueue command.
					return _this2._commandQueue.push('restartIce', { remoteIceParameters: remoteIceParameters });
				}).catch(function (error) {
					logger.error('restartIce() | failed: %o', error);
				});
			}
		}, {
			key: 'enableStats',
			value: function enableStats() {
				var interval = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : DEFAULT_STATS_INTERVAL;
	
				logger.debug('enableStats() [interval:%s]', interval);
	
				if (typeof interval !== 'number' || interval < 1000) interval = DEFAULT_STATS_INTERVAL;
	
				this._statsEnabled = true;
	
				var data = {
					id: this._id,
					interval: interval
				};
	
				this.safeEmit('@notify', 'enableTransportStats', data);
			}
		}, {
			key: 'disableStats',
			value: function disableStats() {
				logger.debug('disableStats()');
	
				this._statsEnabled = false;
	
				var data = {
					id: this._id
				};
	
				this.safeEmit('@notify', 'disableTransportStats', data);
			}
		}, {
			key: '_handleHandler',
			value: function _handleHandler() {
				var _this3 = this;
	
				var handler = this._handler;
	
				handler.on('@connectionstatechange', function (state) {
					if (_this3._connectionState === state) return;
	
					logger.debug('Transport connection state changed to %s', state);
	
					_this3._connectionState = state;
	
					if (!_this3._closed) _this3.safeEmit('connectionstatechange', state);
				});
	
				handler.on('@needcreatetransport', function (transportLocalParameters, callback, errback) {
					var data = {
						id: _this3._id,
						direction: _this3._direction,
						options: _this3._settings.transportOptions,
						appData: _this3._appData
					};
	
					if (transportLocalParameters) data.dtlsParameters = transportLocalParameters.dtlsParameters;
	
					_this3.safeEmit('@request', 'createTransport', data, callback, errback);
				});
	
				handler.on('@needupdatetransport', function (transportLocalParameters) {
					var data = {
						id: _this3._id,
						dtlsParameters: transportLocalParameters.dtlsParameters
					};
	
					_this3.safeEmit('@notify', 'updateTransport', data);
				});
	
				handler.on('@needupdateproducer', function (producer, rtpParameters) {
					var data = {
						id: producer.id,
						rtpParameters: rtpParameters
					};
	
					// Update Producer RTP parameters.
					producer.setRtpParameters(rtpParameters);
	
					// Notify the server.
					_this3.safeEmit('@notify', 'updateProducer', data);
				});
			}
	
			/**
		 * Send the given Producer over this Transport.
		 *
		 * @private
		 *
		 * @param {Producer} producer
		 *
		 * @return {Promise}
		 */
	
		}, {
			key: 'addProducer',
			value: function addProducer(producer) {
				logger.debug('addProducer() [producer:%o]', producer);
	
				if (this._closed) return _promise2.default.reject(new _errors.InvalidStateError('Transport closed'));
				if (this._direction !== 'send') return _promise2.default.reject(new Error('not a sending Transport'));
	
				// Enqueue command.
				return this._commandQueue.push('addProducer', { producer: producer });
			}
	
			/**
		 * @private
		 */
	
		}, {
			key: 'removeProducer',
			value: function removeProducer(producer, originator, appData) {
				logger.debug('removeProducer() [producer:%o]', producer);
	
				// Enqueue command.
				if (!this._closed) {
					this._commandQueue.push('removeProducer', { producer: producer }).catch(function () {});
				}
	
				if (originator === 'local') this.safeEmit('@notify', 'closeProducer', { id: producer.id, appData: appData });
			}
	
			/**
		 * @private
		 */
	
		}, {
			key: 'pauseProducer',
			value: function pauseProducer(producer, appData) {
				logger.debug('pauseProducer() [producer:%o]', producer);
	
				var data = {
					id: producer.id,
					appData: appData
				};
	
				this.safeEmit('@notify', 'pauseProducer', data);
			}
	
			/**
		 * @private
		 */
	
		}, {
			key: 'resumeProducer',
			value: function resumeProducer(producer, appData) {
				logger.debug('resumeProducer() [producer:%o]', producer);
	
				var data = {
					id: producer.id,
					appData: appData
				};
	
				this.safeEmit('@notify', 'resumeProducer', data);
			}
	
			/**
		 * @private
		 *
		 * @return {Promise}
		 */
	
		}, {
			key: 'replaceProducerTrack',
			value: function replaceProducerTrack(producer, track) {
				logger.debug('replaceProducerTrack() [producer:%o]', producer);
	
				return this._commandQueue.push('replaceProducerTrack', { producer: producer, track: track });
			}
	
			/**
		 * @private
		 */
	
		}, {
			key: 'enableProducerStats',
			value: function enableProducerStats(producer, interval) {
				logger.debug('enableProducerStats() [producer:%o]', producer);
	
				var data = {
					id: producer.id,
					interval: interval
				};
	
				this.safeEmit('@notify', 'enableProducerStats', data);
			}
	
			/**
		 * @private
		 */
	
		}, {
			key: 'disableProducerStats',
			value: function disableProducerStats(producer) {
				logger.debug('disableProducerStats() [producer:%o]', producer);
	
				var data = {
					id: producer.id
				};
	
				this.safeEmit('@notify', 'disableProducerStats', data);
			}
	
			/**
		 * Receive the given Consumer over this Transport.
		 *
		 * @private
		 *
		 * @param {Consumer} consumer
		 *
		 * @return {Promise} Resolves to a remote MediaStreamTrack.
		 */
	
		}, {
			key: 'addConsumer',
			value: function addConsumer(consumer) {
				logger.debug('addConsumer() [consumer:%o]', consumer);
	
				if (this._closed) return _promise2.default.reject(new _errors.InvalidStateError('Transport closed'));
				if (this._direction !== 'recv') return _promise2.default.reject(new Error('not a receiving Transport'));
	
				// Enqueue command.
				return this._commandQueue.push('addConsumer', { consumer: consumer });
			}
	
			/**
		 * @private
		 */
	
		}, {
			key: 'removeConsumer',
			value: function removeConsumer(consumer) {
				logger.debug('removeConsumer() [consumer:%o]', consumer);
	
				// Enqueue command.
				this._commandQueue.push('removeConsumer', { consumer: consumer }).catch(function () {});
			}
	
			/**
		 * @private
		 */
	
		}, {
			key: 'pauseConsumer',
			value: function pauseConsumer(consumer, appData) {
				logger.debug('pauseConsumer() [consumer:%o]', consumer);
	
				var data = {
					id: consumer.id,
					appData: appData
				};
	
				this.safeEmit('@notify', 'pauseConsumer', data);
			}
	
			/**
		 * @private
		 */
	
		}, {
			key: 'resumeConsumer',
			value: function resumeConsumer(consumer, appData) {
				logger.debug('resumeConsumer() [consumer:%o]', consumer);
	
				var data = {
					id: consumer.id,
					appData: appData
				};
	
				this.safeEmit('@notify', 'resumeConsumer', data);
			}
	
			/**
		 * @private
		 */
	
		}, {
			key: 'setConsumerPreferredProfile',
			value: function setConsumerPreferredProfile(consumer, profile) {
				logger.debug('setConsumerPreferredProfile() [consumer:%o]', consumer);
	
				var data = {
					id: consumer.id,
					profile: profile
				};
	
				this.safeEmit('@notify', 'setConsumerPreferredProfile', data);
			}
	
			/**
		 * @private
		 */
	
		}, {
			key: 'enableConsumerStats',
			value: function enableConsumerStats(consumer, interval) {
				logger.debug('enableConsumerStats() [consumer:%o]', consumer);
	
				var data = {
					id: consumer.id,
					interval: interval
				};
	
				this.safeEmit('@notify', 'enableConsumerStats', data);
			}
	
			/**
		 * @private
		 */
	
		}, {
			key: 'disableConsumerStats',
			value: function disableConsumerStats(consumer) {
				logger.debug('disableConsumerStats() [consumer:%o]', consumer);
	
				var data = {
					id: consumer.id
				};
	
				this.safeEmit('@notify', 'disableConsumerStats', data);
			}
	
			/**
		 * Receive remote stats.
		 *
		 * @private
		 *
		 * @param {Object} stats
		 */
	
		}, {
			key: 'remoteStats',
			value: function remoteStats(stats) {
				this.safeEmit('stats', stats);
			}
		}, {
			key: '_execCommand',
			value: function _execCommand(command, promiseHolder) {
				var promise = void 0;
	
				try {
					switch (command.method) {
						case 'addProducer':
							{
								var producer = command.producer;
	
	
								promise = this._execAddProducer(producer);
								break;
							}
	
						case 'removeProducer':
							{
								var _producer = command.producer;
	
	
								promise = this._execRemoveProducer(_producer);
								break;
							}
	
						case 'replaceProducerTrack':
							{
								var _producer2 = command.producer,
										track = command.track;
	
	
								promise = this._execReplaceProducerTrack(_producer2, track);
								break;
							}
	
						case 'addConsumer':
							{
								var consumer = command.consumer;
	
	
								promise = this._execAddConsumer(consumer);
								break;
							}
	
						case 'removeConsumer':
							{
								var _consumer = command.consumer;
	
	
								promise = this._execRemoveConsumer(_consumer);
								break;
							}
	
						case 'restartIce':
							{
								var remoteIceParameters = command.remoteIceParameters;
	
	
								promise = this._execRestartIce(remoteIceParameters);
								break;
							}
	
						default:
							{
								promise = _promise2.default.reject(new Error('unknown command method "' + command.method + '"'));
							}
					}
				} catch (error) {
					promise = _promise2.default.reject(error);
				}
	
				// Fill the given Promise holder.
				promiseHolder.promise = promise;
			}
		}, {
			key: '_execAddProducer',
			value: function _execAddProducer(producer) {
				var _this4 = this;
	
				logger.debug('_execAddProducer()');
	
				var producerRtpParameters = void 0;
	
				// Call the handler.
				return _promise2.default.resolve().then(function () {
					return _this4._handler.addProducer(producer);
				}).then(function (rtpParameters) {
					producerRtpParameters = rtpParameters;
	
					var data = {
						id: producer.id,
						kind: producer.kind,
						transportId: _this4._id,
						rtpParameters: rtpParameters,
						paused: producer.locallyPaused,
						appData: producer.appData
					};
	
					return _this4.safeEmitAsPromise('@request', 'createProducer', data);
				}).then(function () {
					producer.setRtpParameters(producerRtpParameters);
				});
			}
		}, {
			key: '_execRemoveProducer',
			value: function _execRemoveProducer(producer) {
				logger.debug('_execRemoveProducer()');
	
				// Call the handler.
				return this._handler.removeProducer(producer);
			}
		}, {
			key: '_execReplaceProducerTrack',
			value: function _execReplaceProducerTrack(producer, track) {
				logger.debug('_execReplaceProducerTrack()');
	
				// Call the handler.
				return this._handler.replaceProducerTrack(producer, track);
			}
		}, {
			key: '_execAddConsumer',
			value: function _execAddConsumer(consumer) {
				var _this5 = this;
	
				logger.debug('_execAddConsumer()');
	
				var consumerTrack = void 0;
	
				// Call the handler.
				return _promise2.default.resolve().then(function () {
					return _this5._handler.addConsumer(consumer);
				}).then(function (track) {
					consumerTrack = track;
	
					var data = {
						id: consumer.id,
						transportId: _this5.id,
						paused: consumer.locallyPaused,
						preferredProfile: consumer.preferredProfile
					};
	
					return _this5.safeEmitAsPromise('@request', 'enableConsumer', data);
				}).then(function (response) {
					var paused = response.paused,
							preferredProfile = response.preferredProfile,
							effectiveProfile = response.effectiveProfile;
	
	
					if (paused) consumer.remotePause();
	
					if (preferredProfile) consumer.remoteSetPreferredProfile(preferredProfile);
	
					if (effectiveProfile) consumer.remoteEffectiveProfileChanged(effectiveProfile);
	
					return consumerTrack;
				});
			}
		}, {
			key: '_execRemoveConsumer',
			value: function _execRemoveConsumer(consumer) {
				logger.debug('_execRemoveConsumer()');
	
				// Call the handler.
				return this._handler.removeConsumer(consumer);
			}
		}, {
			key: '_execRestartIce',
			value: function _execRestartIce(remoteIceParameters) {
				logger.debug('_execRestartIce()');
	
				// Call the handler.
				return this._handler.restartIce(remoteIceParameters);
			}
		}, {
			key: 'id',
			get: function get() {
				return this._id;
			}
	
			/**
		 * Whether the Transport is closed.
		 *
		 * @return {Boolean}
		 */
	
		}, {
			key: 'closed',
			get: function get() {
				return this._closed;
			}
	
			/**
		 * Transport direction.
		 *
		 * @return {String}
		 */
	
		}, {
			key: 'direction',
			get: function get() {
				return this._direction;
			}
	
			/**
		 * App custom data.
		 *
		 * @return {Any}
		 */
	
		}, {
			key: 'appData',
			get: function get() {
				return this._appData;
			}
	
			/**
		 * Connection state.
		 *
		 * @return {String}
		 */
	
		}, {
			key: 'connectionState',
			get: function get() {
				return this._connectionState;
			}
		}]);
		return Transport;
	}(_EnhancedEventEmitter3.default);
	
	exports.default = Transport;
	
	},{"./CommandQueue":9,"./Device":11,"./EnhancedEventEmitter":12,"./Logger":13,"./errors":18,"./utils":34,"babel-runtime/core-js/object/get-prototype-of":43,"babel-runtime/core-js/promise":47,"babel-runtime/helpers/classCallCheck":51,"babel-runtime/helpers/createClass":52,"babel-runtime/helpers/inherits":54,"babel-runtime/helpers/possibleConstructorReturn":55}],18:[function(require,module,exports){
	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
		value: true
	});
	exports.UnsupportedError = exports.TimeoutError = exports.InvalidStateError = undefined;
	
	var _getPrototypeOf = require('babel-runtime/core-js/object/get-prototype-of');
	
	var _getPrototypeOf2 = _interopRequireDefault(_getPrototypeOf);
	
	var _classCallCheck2 = require('babel-runtime/helpers/classCallCheck');
	
	var _classCallCheck3 = _interopRequireDefault(_classCallCheck2);
	
	var _possibleConstructorReturn2 = require('babel-runtime/helpers/possibleConstructorReturn');
	
	var _possibleConstructorReturn3 = _interopRequireDefault(_possibleConstructorReturn2);
	
	var _inherits2 = require('babel-runtime/helpers/inherits');
	
	var _inherits3 = _interopRequireDefault(_inherits2);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	/**
	 * Error produced when calling a method in an invalid state.
	 */
	var InvalidStateError = exports.InvalidStateError = function (_Error) {
		(0, _inherits3.default)(InvalidStateError, _Error);
	
		function InvalidStateError(message) {
			(0, _classCallCheck3.default)(this, InvalidStateError);
	
			var _this = (0, _possibleConstructorReturn3.default)(this, (InvalidStateError.__proto__ || (0, _getPrototypeOf2.default)(InvalidStateError)).call(this, message));
	
			_this.name = 'InvalidStateError';
	
			if (Error.hasOwnProperty('captureStackTrace')) // Just in V8.
				Error.captureStackTrace(_this, InvalidStateError);else _this.stack = new Error(message).stack;
			return _this;
		}
	
		return InvalidStateError;
	}(Error);
	
	/**
	 * Error produced when a Promise is rejected due to a timeout.
	 */
	
	
	var TimeoutError = exports.TimeoutError = function (_Error2) {
		(0, _inherits3.default)(TimeoutError, _Error2);
	
		function TimeoutError(message) {
			(0, _classCallCheck3.default)(this, TimeoutError);
	
			var _this2 = (0, _possibleConstructorReturn3.default)(this, (TimeoutError.__proto__ || (0, _getPrototypeOf2.default)(TimeoutError)).call(this, message));
	
			_this2.name = 'TimeoutError';
	
			if (Error.hasOwnProperty('captureStackTrace')) // Just in V8.
				Error.captureStackTrace(_this2, InvalidStateError);else _this2.stack = new Error(message).stack;
			return _this2;
		}
	
		return TimeoutError;
	}(Error);
	
	/**
	 * Error indicating not support for something.
	 */
	
	
	var UnsupportedError = exports.UnsupportedError = function (_Error3) {
		(0, _inherits3.default)(UnsupportedError, _Error3);
	
		function UnsupportedError(message, data) {
			(0, _classCallCheck3.default)(this, UnsupportedError);
	
			var _this3 = (0, _possibleConstructorReturn3.default)(this, (UnsupportedError.__proto__ || (0, _getPrototypeOf2.default)(UnsupportedError)).call(this, message));
	
			_this3.name = 'UnsupportedError';
	
			if (Error.hasOwnProperty('captureStackTrace')) // Just in V8.
				Error.captureStackTrace(_this3, InvalidStateError);else _this3.stack = new Error(message).stack;
	
			_this3.data = data;
			return _this3;
		}
	
		return UnsupportedError;
	}(Error);
	
	},{"babel-runtime/core-js/object/get-prototype-of":43,"babel-runtime/helpers/classCallCheck":51,"babel-runtime/helpers/inherits":54,"babel-runtime/helpers/possibleConstructorReturn":55}],19:[function(require,module,exports){
	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
		value: true
	});
	
	var _from = require('babel-runtime/core-js/array/from');
	
	var _from2 = _interopRequireDefault(_from);
	
	var _map = require('babel-runtime/core-js/map');
	
	var _map2 = _interopRequireDefault(_map);
	
	var _set = require('babel-runtime/core-js/set');
	
	var _set2 = _interopRequireDefault(_set);
	
	var _promise = require('babel-runtime/core-js/promise');
	
	var _promise2 = _interopRequireDefault(_promise);
	
	var _getPrototypeOf = require('babel-runtime/core-js/object/get-prototype-of');
	
	var _getPrototypeOf2 = _interopRequireDefault(_getPrototypeOf);
	
	var _classCallCheck2 = require('babel-runtime/helpers/classCallCheck');
	
	var _classCallCheck3 = _interopRequireDefault(_classCallCheck2);
	
	var _createClass2 = require('babel-runtime/helpers/createClass');
	
	var _createClass3 = _interopRequireDefault(_createClass2);
	
	var _possibleConstructorReturn2 = require('babel-runtime/helpers/possibleConstructorReturn');
	
	var _possibleConstructorReturn3 = _interopRequireDefault(_possibleConstructorReturn2);
	
	var _inherits2 = require('babel-runtime/helpers/inherits');
	
	var _inherits3 = _interopRequireDefault(_inherits2);
	
	var _sdpTransform = require('sdp-transform');
	
	var _sdpTransform2 = _interopRequireDefault(_sdpTransform);
	
	var _Logger = require('../Logger');
	
	var _Logger2 = _interopRequireDefault(_Logger);
	
	var _EnhancedEventEmitter2 = require('../EnhancedEventEmitter');
	
	var _EnhancedEventEmitter3 = _interopRequireDefault(_EnhancedEventEmitter2);
	
	var _utils = require('../utils');
	
	var utils = _interopRequireWildcard(_utils);
	
	var _ortc = require('../ortc');
	
	var ortc = _interopRequireWildcard(_ortc);
	
	var _commonUtils = require('./sdp/commonUtils');
	
	var sdpCommonUtils = _interopRequireWildcard(_commonUtils);
	
	var _planBUtils = require('./sdp/planBUtils');
	
	var sdpPlanBUtils = _interopRequireWildcard(_planBUtils);
	
	var _RemotePlanBSdp = require('./sdp/RemotePlanBSdp');
	
	var _RemotePlanBSdp2 = _interopRequireDefault(_RemotePlanBSdp);
	
	function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	var logger = new _Logger2.default('Chrome55');
	
	var Handler = function (_EnhancedEventEmitter) {
		(0, _inherits3.default)(Handler, _EnhancedEventEmitter);
	
		function Handler(direction, rtpParametersByKind, settings) {
			(0, _classCallCheck3.default)(this, Handler);
	
			// RTCPeerConnection instance.
			// @type {RTCPeerConnection}
			var _this = (0, _possibleConstructorReturn3.default)(this, (Handler.__proto__ || (0, _getPrototypeOf2.default)(Handler)).call(this, logger));
	
			_this._pc = new RTCPeerConnection({
				iceServers: settings.turnServers || [],
				iceTransportPolicy: 'all',
				bundlePolicy: 'max-bundle',
				rtcpMuxPolicy: 'require'
			});
	
			// Generic sending RTP parameters for audio and video.
			// @type {Object}
			_this._rtpParametersByKind = rtpParametersByKind;
	
			// Remote SDP handler.
			// @type {RemotePlanBSdp}
			_this._remoteSdp = new _RemotePlanBSdp2.default(direction, rtpParametersByKind);
	
			// Handle RTCPeerConnection connection status.
			_this._pc.addEventListener('iceconnectionstatechange', function () {
				switch (_this._pc.iceConnectionState) {
					case 'checking':
						_this.emit('@connectionstatechange', 'connecting');
						break;
					case 'connected':
					case 'completed':
						_this.emit('@connectionstatechange', 'connected');
						break;
					case 'failed':
						_this.emit('@connectionstatechange', 'failed');
						break;
					case 'disconnected':
						_this.emit('@connectionstatechange', 'disconnected');
						break;
					case 'closed':
						_this.emit('@connectionstatechange', 'closed');
						break;
				}
			});
			return _this;
		}
	
		(0, _createClass3.default)(Handler, [{
			key: 'close',
			value: function close() {
				logger.debug('close()');
	
				// Close RTCPeerConnection.
				try {
					this._pc.close();
				} catch (error) {}
			}
		}]);
		return Handler;
	}(_EnhancedEventEmitter3.default);
	
	var SendHandler = function (_Handler) {
		(0, _inherits3.default)(SendHandler, _Handler);
	
		function SendHandler(rtpParametersByKind, settings) {
			(0, _classCallCheck3.default)(this, SendHandler);
	
			// Got transport local and remote parameters.
			// @type {Boolean}
			var _this2 = (0, _possibleConstructorReturn3.default)(this, (SendHandler.__proto__ || (0, _getPrototypeOf2.default)(SendHandler)).call(this, 'send', rtpParametersByKind, settings));
	
			_this2._transportReady = false;
	
			// Local stream.
			// @type {MediaStream}
			_this2._stream = new MediaStream();
			return _this2;
		}
	
		(0, _createClass3.default)(SendHandler, [{
			key: 'addProducer',
			value: function addProducer(producer) {
				var _this3 = this;
	
				var track = producer.track;
	
	
				logger.debug('addProducer() [id:%s, kind:%s, trackId:%s]', producer.id, producer.kind, track.id);
	
				if (this._stream.getTrackById(track.id)) return _promise2.default.reject(new Error('track already added'));
	
				var localSdpObj = void 0;
	
				return _promise2.default.resolve().then(function () {
					// Add the track to the local stream.
					_this3._stream.addTrack(track);
	
					// Add the stream to the PeerConnection.
					_this3._pc.addStream(_this3._stream);
	
					return _this3._pc.createOffer();
				}).then(function (offer) {
					// If simulcast is set, mangle the offer.
					if (producer.simulcast) {
						logger.debug('addProducer() | enabling simulcast');
	
						var sdpObject = _sdpTransform2.default.parse(offer.sdp);
	
						sdpPlanBUtils.addSimulcastForTrack(sdpObject, track);
	
						var offerSdp = _sdpTransform2.default.write(sdpObject);
	
						offer = { type: 'offer', sdp: offerSdp };
					}
	
					logger.debug('addProducer() | calling pc.setLocalDescription() [offer:%o]', offer);
	
					return _this3._pc.setLocalDescription(offer);
				}).then(function () {
					if (!_this3._transportReady) return _this3._setupTransport();
				}).then(function () {
					localSdpObj = _sdpTransform2.default.parse(_this3._pc.localDescription.sdp);
	
					var remoteSdp = _this3._remoteSdp.createAnswerSdp(localSdpObj);
					var answer = { type: 'answer', sdp: remoteSdp };
	
					logger.debug('addProducer() | calling pc.setRemoteDescription() [answer:%o]', answer);
	
					return _this3._pc.setRemoteDescription(answer);
				}).then(function () {
					var rtpParameters = utils.clone(_this3._rtpParametersByKind[producer.kind]);
	
					// Fill the RTP parameters for this track.
					sdpPlanBUtils.fillRtpParametersForTrack(rtpParameters, localSdpObj, track);
	
					return rtpParameters;
				}).catch(function (error) {
					// Panic here. Try to undo things.
	
					_this3._stream.removeTrack(track);
					_this3._pc.addStream(_this3._stream);
	
					throw error;
				});
			}
		}, {
			key: 'removeProducer',
			value: function removeProducer(producer) {
				var _this4 = this;
	
				var track = producer.track;
	
	
				logger.debug('removeProducer() [id:%s, kind:%s, trackId:%s]', producer.id, producer.kind, track.id);
	
				return _promise2.default.resolve().then(function () {
					// Remove the track from the local stream.
					_this4._stream.removeTrack(track);
	
					// Add the stream to the PeerConnection.
					_this4._pc.addStream(_this4._stream);
	
					return _this4._pc.createOffer();
				}).then(function (offer) {
					logger.debug('removeProducer() | calling pc.setLocalDescription() [offer:%o]', offer);
	
					return _this4._pc.setLocalDescription(offer);
				}).catch(function (error) {
					// NOTE: If there are no sending tracks, setLocalDescription() will fail with
					// "Failed to create channels". If so, ignore it.
					if (_this4._stream.getTracks().length === 0) {
						logger.warn('removeProducer() | ignoring expected error due no sending tracks: %s', error.toString());
	
						return;
					}
	
					throw error;
				}).then(function () {
					if (_this4._pc.signalingState === 'stable') return;
	
					var localSdpObj = _sdpTransform2.default.parse(_this4._pc.localDescription.sdp);
					var remoteSdp = _this4._remoteSdp.createAnswerSdp(localSdpObj);
					var answer = { type: 'answer', sdp: remoteSdp };
	
					logger.debug('removeProducer() | calling pc.setRemoteDescription() [answer:%o]', answer);
	
					return _this4._pc.setRemoteDescription(answer);
				});
			}
		}, {
			key: 'replaceProducerTrack',
			value: function replaceProducerTrack(producer, track) {
				var _this5 = this;
	
				logger.debug('replaceProducerTrack() [id:%s, kind:%s, trackId:%s]', producer.id, producer.kind, track.id);
	
				var oldTrack = producer.track;
				var localSdpObj = void 0;
	
				return _promise2.default.resolve().then(function () {
					// Remove the old track from the local stream.
					_this5._stream.removeTrack(oldTrack);
	
					// Add the new track to the local stream.
					_this5._stream.addTrack(track);
	
					// Add the stream to the PeerConnection.
					_this5._pc.addStream(_this5._stream);
	
					return _this5._pc.createOffer();
				}).then(function (offer) {
					// If simulcast is set, mangle the offer.
					if (producer.simulcast) {
						logger.debug('addProducer() | enabling simulcast');
	
						var sdpObject = _sdpTransform2.default.parse(offer.sdp);
	
						sdpPlanBUtils.addSimulcastForTrack(sdpObject, track);
	
						var offerSdp = _sdpTransform2.default.write(sdpObject);
	
						offer = { type: 'offer', sdp: offerSdp };
					}
	
					logger.debug('replaceProducerTrack() | calling pc.setLocalDescription() [offer:%o]', offer);
	
					return _this5._pc.setLocalDescription(offer);
				}).then(function () {
					localSdpObj = _sdpTransform2.default.parse(_this5._pc.localDescription.sdp);
	
					var remoteSdp = _this5._remoteSdp.createAnswerSdp(localSdpObj);
					var answer = { type: 'answer', sdp: remoteSdp };
	
					logger.debug('replaceProducerTrack() | calling pc.setRemoteDescription() [answer:%o]', answer);
	
					return _this5._pc.setRemoteDescription(answer);
				}).then(function () {
					var rtpParameters = utils.clone(_this5._rtpParametersByKind[producer.kind]);
	
					// Fill the RTP parameters for the new track.
					sdpPlanBUtils.fillRtpParametersForTrack(rtpParameters, localSdpObj, track);
	
					// We need to provide new RTP parameters.
					_this5.safeEmit('@needupdateproducer', producer, rtpParameters);
				}).catch(function (error) {
					// Panic here. Try to undo things.
	
					_this5._stream.removeTrack(track);
					_this5._stream.addTrack(oldTrack);
					_this5._pc.addStream(_this5._stream);
	
					throw error;
				});
			}
		}, {
			key: 'restartIce',
			value: function restartIce(remoteIceParameters) {
				var _this6 = this;
	
				logger.debug('restartIce()');
	
				// Provide the remote SDP handler with new remote ICE parameters.
				this._remoteSdp.updateTransportRemoteIceParameters(remoteIceParameters);
	
				return _promise2.default.resolve().then(function () {
					return _this6._pc.createOffer({ iceRestart: true });
				}).then(function (offer) {
					logger.debug('restartIce() | calling pc.setLocalDescription() [offer:%o]', offer);
	
					return _this6._pc.setLocalDescription(offer);
				}).then(function () {
					var localSdpObj = _sdpTransform2.default.parse(_this6._pc.localDescription.sdp);
					var remoteSdp = _this6._remoteSdp.createAnswerSdp(localSdpObj);
					var answer = { type: 'answer', sdp: remoteSdp };
	
					logger.debug('restartIce() | calling pc.setRemoteDescription() [answer:%o]', answer);
	
					return _this6._pc.setRemoteDescription(answer);
				});
			}
		}, {
			key: '_setupTransport',
			value: function _setupTransport() {
				var _this7 = this;
	
				logger.debug('_setupTransport()');
	
				return _promise2.default.resolve().then(function () {
					// Get our local DTLS parameters.
					var transportLocalParameters = {};
					var sdp = _this7._pc.localDescription.sdp;
					var sdpObj = _sdpTransform2.default.parse(sdp);
					var dtlsParameters = sdpCommonUtils.extractDtlsParameters(sdpObj);
	
					// Let's decide that we'll be DTLS server (because we can).
					dtlsParameters.role = 'server';
	
					transportLocalParameters.dtlsParameters = dtlsParameters;
	
					// Provide the remote SDP handler with transport local parameters.
					_this7._remoteSdp.setTransportLocalParameters(transportLocalParameters);
	
					// We need transport remote parameters.
					return _this7.safeEmitAsPromise('@needcreatetransport', transportLocalParameters);
				}).then(function (transportRemoteParameters) {
					// Provide the remote SDP handler with transport remote parameters.
					_this7._remoteSdp.setTransportRemoteParameters(transportRemoteParameters);
	
					_this7._transportReady = true;
				});
			}
		}]);
		return SendHandler;
	}(Handler);
	
	var RecvHandler = function (_Handler2) {
		(0, _inherits3.default)(RecvHandler, _Handler2);
	
		function RecvHandler(rtpParametersByKind, settings) {
			(0, _classCallCheck3.default)(this, RecvHandler);
	
			// Got transport remote parameters.
			// @type {Boolean}
			var _this8 = (0, _possibleConstructorReturn3.default)(this, (RecvHandler.__proto__ || (0, _getPrototypeOf2.default)(RecvHandler)).call(this, 'recv', rtpParametersByKind, settings));
	
			_this8._transportCreated = false;
	
			// Got transport local parameters.
			// @type {Boolean}
			_this8._transportUpdated = false;
	
			// Seen media kinds.
			// @type {Set<String>}
			_this8._kinds = new _set2.default();
	
			// Map of Consumers information indexed by consumer.id.
			// - kind {String}
			// - trackId {String}
			// - ssrc {Number}
			// - rtxSsrc {Number}
			// - cname {String}
			// @type {Map<Number, Object>}
			_this8._consumerInfos = new _map2.default();
			return _this8;
		}
	
		(0, _createClass3.default)(RecvHandler, [{
			key: 'addConsumer',
			value: function addConsumer(consumer) {
				var _this9 = this;
	
				logger.debug('addConsumer() [id:%s, kind:%s]', consumer.id, consumer.kind);
	
				if (this._consumerInfos.has(consumer.id)) return _promise2.default.reject(new Error('Consumer already added'));
	
				var encoding = consumer.rtpParameters.encodings[0];
				var cname = consumer.rtpParameters.rtcp.cname;
				var consumerInfo = {
					kind: consumer.kind,
					streamId: 'recv-stream-' + consumer.id,
					trackId: 'consumer-' + consumer.kind + '-' + consumer.id,
					ssrc: encoding.ssrc,
					cname: cname
				};
	
				if (encoding.rtx && encoding.rtx.ssrc) consumerInfo.rtxSsrc = encoding.rtx.ssrc;
	
				this._consumerInfos.set(consumer.id, consumerInfo);
				this._kinds.add(consumer.kind);
	
				return _promise2.default.resolve().then(function () {
					if (!_this9._transportCreated) return _this9._setupTransport();
				}).then(function () {
					var remoteSdp = _this9._remoteSdp.createOfferSdp((0, _from2.default)(_this9._kinds), (0, _from2.default)(_this9._consumerInfos.values()));
					var offer = { type: 'offer', sdp: remoteSdp };
	
					logger.debug('addConsumer() | calling pc.setRemoteDescription() [offer:%o]', offer);
	
					return _this9._pc.setRemoteDescription(offer);
				}).then(function () {
					return _this9._pc.createAnswer();
				}).then(function (answer) {
					logger.debug('addConsumer() | calling pc.setLocalDescription() [answer:%o]', answer);
	
					return _this9._pc.setLocalDescription(answer);
				}).then(function () {
					if (!_this9._transportUpdated) return _this9._updateTransport();
				}).then(function () {
					var stream = _this9._pc.getRemoteStreams().find(function (s) {
						return s.id === consumerInfo.streamId;
					});
					var track = stream.getTrackById(consumerInfo.trackId);
	
					if (!track) throw new Error('remote track not found');
	
					return track;
				});
			}
		}, {
			key: 'removeConsumer',
			value: function removeConsumer(consumer) {
				var _this10 = this;
	
				logger.debug('removeConsumer() [id:%s, kind:%s]', consumer.id, consumer.kind);
	
				if (!this._consumerInfos.has(consumer.id)) return _promise2.default.reject(new Error('Consumer not found'));
	
				this._consumerInfos.delete(consumer.id);
	
				return _promise2.default.resolve().then(function () {
					var remoteSdp = _this10._remoteSdp.createOfferSdp((0, _from2.default)(_this10._kinds), (0, _from2.default)(_this10._consumerInfos.values()));
					var offer = { type: 'offer', sdp: remoteSdp };
	
					logger.debug('removeConsumer() | calling pc.setRemoteDescription() [offer:%o]', offer);
	
					return _this10._pc.setRemoteDescription(offer);
				}).then(function () {
					return _this10._pc.createAnswer();
				}).then(function (answer) {
					logger.debug('removeConsumer() | calling pc.setLocalDescription() [answer:%o]', answer);
	
					return _this10._pc.setLocalDescription(answer);
				});
			}
		}, {
			key: 'restartIce',
			value: function restartIce(remoteIceParameters) {
				var _this11 = this;
	
				logger.debug('restartIce()');
	
				// Provide the remote SDP handler with new remote ICE parameters.
				this._remoteSdp.updateTransportRemoteIceParameters(remoteIceParameters);
	
				return _promise2.default.resolve().then(function () {
					var remoteSdp = _this11._remoteSdp.createOfferSdp((0, _from2.default)(_this11._kinds), (0, _from2.default)(_this11._consumerInfos.values()));
					var offer = { type: 'offer', sdp: remoteSdp };
	
					logger.debug('restartIce() | calling pc.setRemoteDescription() [offer:%o]', offer);
	
					return _this11._pc.setRemoteDescription(offer);
				}).then(function () {
					return _this11._pc.createAnswer();
				}).then(function (answer) {
					logger.debug('restartIce() | calling pc.setLocalDescription() [answer:%o]', answer);
	
					return _this11._pc.setLocalDescription(answer);
				});
			}
		}, {
			key: '_setupTransport',
			value: function _setupTransport() {
				var _this12 = this;
	
				logger.debug('_setupTransport()');
	
				return _promise2.default.resolve().then(function () {
					// We need transport remote parameters.
					return _this12.safeEmitAsPromise('@needcreatetransport', null);
				}).then(function (transportRemoteParameters) {
					// Provide the remote SDP handler with transport remote parameters.
					_this12._remoteSdp.setTransportRemoteParameters(transportRemoteParameters);
	
					_this12._transportCreated = true;
				});
			}
		}, {
			key: '_updateTransport',
			value: function _updateTransport() {
				logger.debug('_updateTransport()');
	
				// Get our local DTLS parameters.
				// const transportLocalParameters = {};
				var sdp = this._pc.localDescription.sdp;
				var sdpObj = _sdpTransform2.default.parse(sdp);
				var dtlsParameters = sdpCommonUtils.extractDtlsParameters(sdpObj);
				var transportLocalParameters = { dtlsParameters: dtlsParameters };
	
				// We need to provide transport local parameters.
				this.safeEmit('@needupdatetransport', transportLocalParameters);
	
				this._transportUpdated = true;
			}
		}]);
		return RecvHandler;
	}(Handler);
	
	var Chrome55 = function () {
		(0, _createClass3.default)(Chrome55, null, [{
			key: 'getNativeRtpCapabilities',
			value: function getNativeRtpCapabilities() {
				logger.debug('getNativeRtpCapabilities()');
	
				var pc = new RTCPeerConnection({
					iceServers: [],
					iceTransportPolicy: 'all',
					bundlePolicy: 'max-bundle',
					rtcpMuxPolicy: 'require'
				});
	
				return pc.createOffer({
					offerToReceiveAudio: true,
					offerToReceiveVideo: true
				}).then(function (offer) {
					try {
						pc.close();
					} catch (error) {}
	
					var sdpObj = _sdpTransform2.default.parse(offer.sdp);
					var nativeRtpCapabilities = sdpCommonUtils.extractRtpCapabilities(sdpObj);
	
					return nativeRtpCapabilities;
				}).catch(function (error) {
					try {
						pc.close();
					} catch (error2) {}
	
					throw error;
				});
			}
		}, {
			key: 'tag',
			get: function get() {
				return 'Chrome55';
			}
		}]);
	
		function Chrome55(direction, extendedRtpCapabilities, settings) {
			(0, _classCallCheck3.default)(this, Chrome55);
	
			logger.debug('constructor() [direction:%s, extendedRtpCapabilities:%o]', direction, extendedRtpCapabilities);
	
			var rtpParametersByKind = void 0;
	
			switch (direction) {
				case 'send':
					{
						rtpParametersByKind = {
							audio: ortc.getSendingRtpParameters('audio', extendedRtpCapabilities),
							video: ortc.getSendingRtpParameters('video', extendedRtpCapabilities)
						};
	
						return new SendHandler(rtpParametersByKind, settings);
					}
				case 'recv':
					{
						rtpParametersByKind = {
							audio: ortc.getReceivingFullRtpParameters('audio', extendedRtpCapabilities),
							video: ortc.getReceivingFullRtpParameters('video', extendedRtpCapabilities)
						};
	
						return new RecvHandler(rtpParametersByKind, settings);
					}
			}
		}
	
		return Chrome55;
	}();
	
	exports.default = Chrome55;
	
	},{"../EnhancedEventEmitter":12,"../Logger":13,"../ortc":33,"../utils":34,"./sdp/RemotePlanBSdp":27,"./sdp/commonUtils":29,"./sdp/planBUtils":30,"babel-runtime/core-js/array/from":35,"babel-runtime/core-js/map":39,"babel-runtime/core-js/object/get-prototype-of":43,"babel-runtime/core-js/promise":47,"babel-runtime/core-js/set":48,"babel-runtime/helpers/classCallCheck":51,"babel-runtime/helpers/createClass":52,"babel-runtime/helpers/inherits":54,"babel-runtime/helpers/possibleConstructorReturn":55,"sdp-transform":213}],20:[function(require,module,exports){
	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
		value: true
	});
	
	var _from = require('babel-runtime/core-js/array/from');
	
	var _from2 = _interopRequireDefault(_from);
	
	var _map = require('babel-runtime/core-js/map');
	
	var _map2 = _interopRequireDefault(_map);
	
	var _set = require('babel-runtime/core-js/set');
	
	var _set2 = _interopRequireDefault(_set);
	
	var _promise = require('babel-runtime/core-js/promise');
	
	var _promise2 = _interopRequireDefault(_promise);
	
	var _getPrototypeOf = require('babel-runtime/core-js/object/get-prototype-of');
	
	var _getPrototypeOf2 = _interopRequireDefault(_getPrototypeOf);
	
	var _classCallCheck2 = require('babel-runtime/helpers/classCallCheck');
	
	var _classCallCheck3 = _interopRequireDefault(_classCallCheck2);
	
	var _createClass2 = require('babel-runtime/helpers/createClass');
	
	var _createClass3 = _interopRequireDefault(_createClass2);
	
	var _possibleConstructorReturn2 = require('babel-runtime/helpers/possibleConstructorReturn');
	
	var _possibleConstructorReturn3 = _interopRequireDefault(_possibleConstructorReturn2);
	
	var _inherits2 = require('babel-runtime/helpers/inherits');
	
	var _inherits3 = _interopRequireDefault(_inherits2);
	
	var _sdpTransform = require('sdp-transform');
	
	var _sdpTransform2 = _interopRequireDefault(_sdpTransform);
	
	var _Logger = require('../Logger');
	
	var _Logger2 = _interopRequireDefault(_Logger);
	
	var _EnhancedEventEmitter2 = require('../EnhancedEventEmitter');
	
	var _EnhancedEventEmitter3 = _interopRequireDefault(_EnhancedEventEmitter2);
	
	var _utils = require('../utils');
	
	var utils = _interopRequireWildcard(_utils);
	
	var _ortc = require('../ortc');
	
	var ortc = _interopRequireWildcard(_ortc);
	
	var _commonUtils = require('./sdp/commonUtils');
	
	var sdpCommonUtils = _interopRequireWildcard(_commonUtils);
	
	var _planBUtils = require('./sdp/planBUtils');
	
	var sdpPlanBUtils = _interopRequireWildcard(_planBUtils);
	
	var _RemotePlanBSdp = require('./sdp/RemotePlanBSdp');
	
	var _RemotePlanBSdp2 = _interopRequireDefault(_RemotePlanBSdp);
	
	function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	var logger = new _Logger2.default('Chrome67');
	
	var Handler = function (_EnhancedEventEmitter) {
		(0, _inherits3.default)(Handler, _EnhancedEventEmitter);
	
		function Handler(direction, rtpParametersByKind, settings) {
			(0, _classCallCheck3.default)(this, Handler);
	
			// RTCPeerConnection instance.
			// @type {RTCPeerConnection}
			var _this = (0, _possibleConstructorReturn3.default)(this, (Handler.__proto__ || (0, _getPrototypeOf2.default)(Handler)).call(this, logger));
	
			_this._pc = new RTCPeerConnection({
				iceServers: settings.turnServers || [],
				iceTransportPolicy: 'all',
				bundlePolicy: 'max-bundle',
				rtcpMuxPolicy: 'require'
			});
	
			// Generic sending RTP parameters for audio and video.
			// @type {Object}
			_this._rtpParametersByKind = rtpParametersByKind;
	
			// Remote SDP handler.
			// @type {RemotePlanBSdp}
			_this._remoteSdp = new _RemotePlanBSdp2.default(direction, rtpParametersByKind);
	
			// Handle RTCPeerConnection connection status.
			_this._pc.addEventListener('iceconnectionstatechange', function () {
				switch (_this._pc.iceConnectionState) {
					case 'checking':
						_this.emit('@connectionstatechange', 'connecting');
						break;
					case 'connected':
					case 'completed':
						_this.emit('@connectionstatechange', 'connected');
						break;
					case 'failed':
						_this.emit('@connectionstatechange', 'failed');
						break;
					case 'disconnected':
						_this.emit('@connectionstatechange', 'disconnected');
						break;
					case 'closed':
						_this.emit('@connectionstatechange', 'closed');
						break;
				}
			});
			return _this;
		}
	
		(0, _createClass3.default)(Handler, [{
			key: 'close',
			value: function close() {
				logger.debug('close()');
	
				// Close RTCPeerConnection.
				try {
					this._pc.close();
				} catch (error) {}
			}
		}]);
		return Handler;
	}(_EnhancedEventEmitter3.default);
	
	var SendHandler = function (_Handler) {
		(0, _inherits3.default)(SendHandler, _Handler);
	
		function SendHandler(rtpParametersByKind, settings) {
			(0, _classCallCheck3.default)(this, SendHandler);
	
			// Got transport local and remote parameters.
			// @type {Boolean}
			var _this2 = (0, _possibleConstructorReturn3.default)(this, (SendHandler.__proto__ || (0, _getPrototypeOf2.default)(SendHandler)).call(this, 'send', rtpParametersByKind, settings));
	
			_this2._transportReady = false;
	
			// Local stream.
			// @type {MediaStream}
			_this2._stream = new MediaStream();
			return _this2;
		}
	
		(0, _createClass3.default)(SendHandler, [{
			key: 'addProducer',
			value: function addProducer(producer) {
				var _this3 = this;
	
				var track = producer.track;
	
	
				logger.debug('addProducer() [id:%s, kind:%s, trackId:%s]', producer.id, producer.kind, track.id);
	
				if (this._stream.getTrackById(track.id)) return _promise2.default.reject(new Error('track already added'));
	
				var localSdpObj = void 0;
	
				return _promise2.default.resolve().then(function () {
					// Add the track to the local stream.
					_this3._stream.addTrack(track);
	
					// Add the stream to the PeerConnection.
					_this3._pc.addStream(_this3._stream);
	
					return _this3._pc.createOffer();
				}).then(function (offer) {
					// If simulcast is set, mangle the offer.
					if (producer.simulcast) {
						logger.debug('addProducer() | enabling simulcast');
	
						var sdpObject = _sdpTransform2.default.parse(offer.sdp);
	
						sdpPlanBUtils.addSimulcastForTrack(sdpObject, track);
	
						var offerSdp = _sdpTransform2.default.write(sdpObject);
	
						offer = { type: 'offer', sdp: offerSdp };
					}
	
					logger.debug('addProducer() | calling pc.setLocalDescription() [offer:%o]', offer);
	
					return _this3._pc.setLocalDescription(offer);
				}).then(function () {
					if (!_this3._transportReady) return _this3._setupTransport();
				}).then(function () {
					localSdpObj = _sdpTransform2.default.parse(_this3._pc.localDescription.sdp);
	
					var remoteSdp = _this3._remoteSdp.createAnswerSdp(localSdpObj);
					var answer = { type: 'answer', sdp: remoteSdp };
	
					logger.debug('addProducer() | calling pc.setRemoteDescription() [answer:%o]', answer);
	
					return _this3._pc.setRemoteDescription(answer);
				}).then(function () {
					var rtpParameters = utils.clone(_this3._rtpParametersByKind[producer.kind]);
	
					// Fill the RTP parameters for this track.
					sdpPlanBUtils.fillRtpParametersForTrack(rtpParameters, localSdpObj, track);
	
					return rtpParameters;
				}).catch(function (error) {
					// Panic here. Try to undo things.
	
					_this3._stream.removeTrack(track);
					_this3._pc.addStream(_this3._stream);
	
					throw error;
				});
			}
		}, {
			key: 'removeProducer',
			value: function removeProducer(producer) {
				var _this4 = this;
	
				var track = producer.track;
	
	
				logger.debug('removeProducer() [id:%s, kind:%s, trackId:%s]', producer.id, producer.kind, track.id);
	
				return _promise2.default.resolve().then(function () {
					// Remove the track from the local stream.
					_this4._stream.removeTrack(track);
	
					// Add the stream to the PeerConnection.
					_this4._pc.addStream(_this4._stream);
	
					return _this4._pc.createOffer();
				}).then(function (offer) {
					logger.debug('removeProducer() | calling pc.setLocalDescription() [offer:%o]', offer);
	
					return _this4._pc.setLocalDescription(offer);
				}).catch(function (error) {
					// NOTE: If there are no sending tracks, setLocalDescription() will fail with
					// "Failed to create channels". If so, ignore it.
					if (_this4._stream.getTracks().length === 0) {
						logger.warn('removeProducer() | ignoring expected error due no sending tracks: %s', error.toString());
	
						return;
					}
	
					throw error;
				}).then(function () {
					if (_this4._pc.signalingState === 'stable') return;
	
					var localSdpObj = _sdpTransform2.default.parse(_this4._pc.localDescription.sdp);
					var remoteSdp = _this4._remoteSdp.createAnswerSdp(localSdpObj);
					var answer = { type: 'answer', sdp: remoteSdp };
	
					logger.debug('removeProducer() | calling pc.setRemoteDescription() [answer:%o]', answer);
	
					return _this4._pc.setRemoteDescription(answer);
				});
			}
		}, {
			key: 'replaceProducerTrack',
			value: function replaceProducerTrack(producer, track) {
				var _this5 = this;
	
				logger.debug('replaceProducerTrack() [id:%s, kind:%s, trackId:%s]', producer.id, producer.kind, track.id);
	
				var oldTrack = producer.track;
	
				return _promise2.default.resolve().then(function () {
					// Get the associated RTCRtpSender.
					var rtpSender = _this5._pc.getSenders().find(function (s) {
						return s.track === oldTrack;
					});
	
					if (!rtpSender) throw new Error('local track not found');
	
					return rtpSender.replaceTrack(track);
				}).then(function () {
					// Remove the old track from the local stream.
					_this5._stream.removeTrack(oldTrack);
	
					// Add the new track to the local stream.
					_this5._stream.addTrack(track);
				});
			}
		}, {
			key: 'restartIce',
			value: function restartIce(remoteIceParameters) {
				var _this6 = this;
	
				logger.debug('restartIce()');
	
				// Provide the remote SDP handler with new remote ICE parameters.
				this._remoteSdp.updateTransportRemoteIceParameters(remoteIceParameters);
	
				return _promise2.default.resolve().then(function () {
					return _this6._pc.createOffer({ iceRestart: true });
				}).then(function (offer) {
					logger.debug('restartIce() | calling pc.setLocalDescription() [offer:%o]', offer);
	
					return _this6._pc.setLocalDescription(offer);
				}).then(function () {
					var localSdpObj = _sdpTransform2.default.parse(_this6._pc.localDescription.sdp);
					var remoteSdp = _this6._remoteSdp.createAnswerSdp(localSdpObj);
					var answer = { type: 'answer', sdp: remoteSdp };
	
					logger.debug('restartIce() | calling pc.setRemoteDescription() [answer:%o]', answer);
	
					return _this6._pc.setRemoteDescription(answer);
				});
			}
		}, {
			key: '_setupTransport',
			value: function _setupTransport() {
				var _this7 = this;
	
				logger.debug('_setupTransport()');
	
				return _promise2.default.resolve().then(function () {
					// Get our local DTLS parameters.
					var transportLocalParameters = {};
					var sdp = _this7._pc.localDescription.sdp;
					var sdpObj = _sdpTransform2.default.parse(sdp);
					var dtlsParameters = sdpCommonUtils.extractDtlsParameters(sdpObj);
	
					// Let's decide that we'll be DTLS server (because we can).
					dtlsParameters.role = 'server';
	
					transportLocalParameters.dtlsParameters = dtlsParameters;
	
					// Provide the remote SDP handler with transport local parameters.
					_this7._remoteSdp.setTransportLocalParameters(transportLocalParameters);
	
					// We need transport remote parameters.
					return _this7.safeEmitAsPromise('@needcreatetransport', transportLocalParameters);
				}).then(function (transportRemoteParameters) {
					// Provide the remote SDP handler with transport remote parameters.
					_this7._remoteSdp.setTransportRemoteParameters(transportRemoteParameters);
	
					_this7._transportReady = true;
				});
			}
		}]);
		return SendHandler;
	}(Handler);
	
	var RecvHandler = function (_Handler2) {
		(0, _inherits3.default)(RecvHandler, _Handler2);
	
		function RecvHandler(rtpParametersByKind, settings) {
			(0, _classCallCheck3.default)(this, RecvHandler);
	
			// Got transport remote parameters.
			// @type {Boolean}
			var _this8 = (0, _possibleConstructorReturn3.default)(this, (RecvHandler.__proto__ || (0, _getPrototypeOf2.default)(RecvHandler)).call(this, 'recv', rtpParametersByKind, settings));
	
			_this8._transportCreated = false;
	
			// Got transport local parameters.
			// @type {Boolean}
			_this8._transportUpdated = false;
	
			// Seen media kinds.
			// @type {Set<String>}
			_this8._kinds = new _set2.default();
	
			// Map of Consumers information indexed by consumer.id.
			// - kind {String}
			// - trackId {String}
			// - ssrc {Number}
			// - rtxSsrc {Number}
			// - cname {String}
			// @type {Map<Number, Object>}
			_this8._consumerInfos = new _map2.default();
			return _this8;
		}
	
		(0, _createClass3.default)(RecvHandler, [{
			key: 'addConsumer',
			value: function addConsumer(consumer) {
				var _this9 = this;
	
				logger.debug('addConsumer() [id:%s, kind:%s]', consumer.id, consumer.kind);
	
				if (this._consumerInfos.has(consumer.id)) return _promise2.default.reject(new Error('Consumer already added'));
	
				var encoding = consumer.rtpParameters.encodings[0];
				var cname = consumer.rtpParameters.rtcp.cname;
				var consumerInfo = {
					kind: consumer.kind,
					streamId: 'recv-stream-' + consumer.id,
					trackId: 'consumer-' + consumer.kind + '-' + consumer.id,
					ssrc: encoding.ssrc,
					cname: cname
				};
	
				if (encoding.rtx && encoding.rtx.ssrc) consumerInfo.rtxSsrc = encoding.rtx.ssrc;
	
				this._consumerInfos.set(consumer.id, consumerInfo);
				this._kinds.add(consumer.kind);
	
				return _promise2.default.resolve().then(function () {
					if (!_this9._transportCreated) return _this9._setupTransport();
				}).then(function () {
					var remoteSdp = _this9._remoteSdp.createOfferSdp((0, _from2.default)(_this9._kinds), (0, _from2.default)(_this9._consumerInfos.values()));
					var offer = { type: 'offer', sdp: remoteSdp };
	
					logger.debug('addConsumer() | calling pc.setRemoteDescription() [offer:%o]', offer);
	
					return _this9._pc.setRemoteDescription(offer);
				}).then(function () {
					return _this9._pc.createAnswer();
				}).then(function (answer) {
					logger.debug('addConsumer() | calling pc.setLocalDescription() [answer:%o]', answer);
	
					return _this9._pc.setLocalDescription(answer);
				}).then(function () {
					if (!_this9._transportUpdated) return _this9._updateTransport();
				}).then(function () {
					var stream = _this9._pc.getRemoteStreams().find(function (s) {
						return s.id === consumerInfo.streamId;
					});
					var track = stream.getTrackById(consumerInfo.trackId);
	
					if (!track) throw new Error('remote track not found');
	
					return track;
				});
			}
		}, {
			key: 'removeConsumer',
			value: function removeConsumer(consumer) {
				var _this10 = this;
	
				logger.debug('removeConsumer() [id:%s, kind:%s]', consumer.id, consumer.kind);
	
				if (!this._consumerInfos.has(consumer.id)) return _promise2.default.reject(new Error('Consumer not found'));
	
				this._consumerInfos.delete(consumer.id);
	
				return _promise2.default.resolve().then(function () {
					var remoteSdp = _this10._remoteSdp.createOfferSdp((0, _from2.default)(_this10._kinds), (0, _from2.default)(_this10._consumerInfos.values()));
					var offer = { type: 'offer', sdp: remoteSdp };
	
					logger.debug('removeConsumer() | calling pc.setRemoteDescription() [offer:%o]', offer);
	
					return _this10._pc.setRemoteDescription(offer);
				}).then(function () {
					return _this10._pc.createAnswer();
				}).then(function (answer) {
					logger.debug('removeConsumer() | calling pc.setLocalDescription() [answer:%o]', answer);
	
					return _this10._pc.setLocalDescription(answer);
				});
			}
		}, {
			key: 'restartIce',
			value: function restartIce(remoteIceParameters) {
				var _this11 = this;
	
				logger.debug('restartIce()');
	
				// Provide the remote SDP handler with new remote ICE parameters.
				this._remoteSdp.updateTransportRemoteIceParameters(remoteIceParameters);
	
				return _promise2.default.resolve().then(function () {
					var remoteSdp = _this11._remoteSdp.createOfferSdp((0, _from2.default)(_this11._kinds), (0, _from2.default)(_this11._consumerInfos.values()));
					var offer = { type: 'offer', sdp: remoteSdp };
	
					logger.debug('restartIce() | calling pc.setRemoteDescription() [offer:%o]', offer);
	
					return _this11._pc.setRemoteDescription(offer);
				}).then(function () {
					return _this11._pc.createAnswer();
				}).then(function (answer) {
					logger.debug('restartIce() | calling pc.setLocalDescription() [answer:%o]', answer);
	
					return _this11._pc.setLocalDescription(answer);
				});
			}
		}, {
			key: '_setupTransport',
			value: function _setupTransport() {
				var _this12 = this;
	
				logger.debug('_setupTransport()');
	
				return _promise2.default.resolve().then(function () {
					// We need transport remote parameters.
					return _this12.safeEmitAsPromise('@needcreatetransport', null);
				}).then(function (transportRemoteParameters) {
					// Provide the remote SDP handler with transport remote parameters.
					_this12._remoteSdp.setTransportRemoteParameters(transportRemoteParameters);
	
					_this12._transportCreated = true;
				});
			}
		}, {
			key: '_updateTransport',
			value: function _updateTransport() {
				logger.debug('_updateTransport()');
	
				// Get our local DTLS parameters.
				// const transportLocalParameters = {};
				var sdp = this._pc.localDescription.sdp;
				var sdpObj = _sdpTransform2.default.parse(sdp);
				var dtlsParameters = sdpCommonUtils.extractDtlsParameters(sdpObj);
				var transportLocalParameters = { dtlsParameters: dtlsParameters };
	
				// We need to provide transport local parameters.
				this.safeEmit('@needupdatetransport', transportLocalParameters);
	
				this._transportUpdated = true;
			}
		}]);
		return RecvHandler;
	}(Handler);
	
	var Chrome67 = function () {
		(0, _createClass3.default)(Chrome67, null, [{
			key: 'getNativeRtpCapabilities',
			value: function getNativeRtpCapabilities() {
				logger.debug('getNativeRtpCapabilities()');
	
				var pc = new RTCPeerConnection({
					iceServers: [],
					iceTransportPolicy: 'all',
					bundlePolicy: 'max-bundle',
					rtcpMuxPolicy: 'require'
				});
	
				return pc.createOffer({
					offerToReceiveAudio: true,
					offerToReceiveVideo: true
				}).then(function (offer) {
					try {
						pc.close();
					} catch (error) {}
	
					var sdpObj = _sdpTransform2.default.parse(offer.sdp);
					var nativeRtpCapabilities = sdpCommonUtils.extractRtpCapabilities(sdpObj);
	
					return nativeRtpCapabilities;
				}).catch(function (error) {
					try {
						pc.close();
					} catch (error2) {}
	
					throw error;
				});
			}
		}, {
			key: 'tag',
			get: function get() {
				return 'Chrome67';
			}
		}]);
	
		function Chrome67(direction, extendedRtpCapabilities, settings) {
			(0, _classCallCheck3.default)(this, Chrome67);
	
			logger.debug('constructor() [direction:%s, extendedRtpCapabilities:%o]', direction, extendedRtpCapabilities);
	
			var rtpParametersByKind = void 0;
	
			switch (direction) {
				case 'send':
					{
						rtpParametersByKind = {
							audio: ortc.getSendingRtpParameters('audio', extendedRtpCapabilities),
							video: ortc.getSendingRtpParameters('video', extendedRtpCapabilities)
						};
	
						return new SendHandler(rtpParametersByKind, settings);
					}
				case 'recv':
					{
						rtpParametersByKind = {
							audio: ortc.getReceivingFullRtpParameters('audio', extendedRtpCapabilities),
							video: ortc.getReceivingFullRtpParameters('video', extendedRtpCapabilities)
						};
	
						return new RecvHandler(rtpParametersByKind, settings);
					}
			}
		}
	
		return Chrome67;
	}();
	
	exports.default = Chrome67;
	
	},{"../EnhancedEventEmitter":12,"../Logger":13,"../ortc":33,"../utils":34,"./sdp/RemotePlanBSdp":27,"./sdp/commonUtils":29,"./sdp/planBUtils":30,"babel-runtime/core-js/array/from":35,"babel-runtime/core-js/map":39,"babel-runtime/core-js/object/get-prototype-of":43,"babel-runtime/core-js/promise":47,"babel-runtime/core-js/set":48,"babel-runtime/helpers/classCallCheck":51,"babel-runtime/helpers/createClass":52,"babel-runtime/helpers/inherits":54,"babel-runtime/helpers/possibleConstructorReturn":55,"sdp-transform":213}],21:[function(require,module,exports){
	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
		value: true
	});
	
	var _promise = require('babel-runtime/core-js/promise');
	
	var _promise2 = _interopRequireDefault(_promise);
	
	var _getIterator2 = require('babel-runtime/core-js/get-iterator');
	
	var _getIterator3 = _interopRequireDefault(_getIterator2);
	
	var _map = require('babel-runtime/core-js/map');
	
	var _map2 = _interopRequireDefault(_map);
	
	var _getPrototypeOf = require('babel-runtime/core-js/object/get-prototype-of');
	
	var _getPrototypeOf2 = _interopRequireDefault(_getPrototypeOf);
	
	var _classCallCheck2 = require('babel-runtime/helpers/classCallCheck');
	
	var _classCallCheck3 = _interopRequireDefault(_classCallCheck2);
	
	var _possibleConstructorReturn2 = require('babel-runtime/helpers/possibleConstructorReturn');
	
	var _possibleConstructorReturn3 = _interopRequireDefault(_possibleConstructorReturn2);
	
	var _createClass2 = require('babel-runtime/helpers/createClass');
	
	var _createClass3 = _interopRequireDefault(_createClass2);
	
	var _inherits2 = require('babel-runtime/helpers/inherits');
	
	var _inherits3 = _interopRequireDefault(_inherits2);
	
	var _Logger = require('../Logger');
	
	var _Logger2 = _interopRequireDefault(_Logger);
	
	var _EnhancedEventEmitter2 = require('../EnhancedEventEmitter');
	
	var _EnhancedEventEmitter3 = _interopRequireDefault(_EnhancedEventEmitter2);
	
	var _utils = require('../utils');
	
	var utils = _interopRequireWildcard(_utils);
	
	var _ortc = require('../ortc');
	
	var ortc = _interopRequireWildcard(_ortc);
	
	var _edgeUtils = require('./ortc/edgeUtils');
	
	var edgeUtils = _interopRequireWildcard(_edgeUtils);
	
	function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	var CNAME = 'CNAME-EDGE-' + utils.randomNumber(); /* global RTCIceGatherer, RTCIceTransport, RTCDtlsTransport, RTCRtpReceiver, RTCRtpSender */
	
	var logger = new _Logger2.default('Edge11');
	
	var Edge11 = function (_EnhancedEventEmitter) {
		(0, _inherits3.default)(Edge11, _EnhancedEventEmitter);
		(0, _createClass3.default)(Edge11, null, [{
			key: 'getNativeRtpCapabilities',
			value: function getNativeRtpCapabilities() {
				logger.debug('getNativeRtpCapabilities()');
	
				return edgeUtils.getCapabilities();
			}
		}, {
			key: 'tag',
			get: function get() {
				return 'Edge11';
			}
		}]);
	
		function Edge11(direction, extendedRtpCapabilities, settings) {
			(0, _classCallCheck3.default)(this, Edge11);
	
			var _this = (0, _possibleConstructorReturn3.default)(this, (Edge11.__proto__ || (0, _getPrototypeOf2.default)(Edge11)).call(this, logger));
	
			logger.debug('constructor() [direction:%s, extendedRtpCapabilities:%o]', direction, extendedRtpCapabilities);
	
			// Generic sending RTP parameters for audio and video.
			// @type {Object}
			_this._rtpParametersByKind = {
				audio: ortc.getSendingRtpParameters('audio', extendedRtpCapabilities),
				video: ortc.getSendingRtpParameters('video', extendedRtpCapabilities)
			};
	
			// Got transport local and remote parameters.
			// @type {Boolean}
			_this._transportReady = false;
	
			// ICE gatherer.
			_this._iceGatherer = null;
	
			// ICE transport.
			_this._iceTransport = null;
	
			// DTLS transport.
			// @type {RTCDtlsTransport}
			_this._dtlsTransport = null;
	
			// Map of RTCRtpSenders indexed by Producer.id.
			// @type {Map<Number, RTCRtpSender}
			_this._rtpSenders = new _map2.default();
	
			// Map of RTCRtpReceivers indexed by Consumer.id.
			// @type {Map<Number, RTCRtpReceiver}
			_this._rtpReceivers = new _map2.default();
	
			// Remote Transport parameters.
			// @type {Object}
			_this._transportRemoteParameters = null;
	
			_this._setIceGatherer(settings);
			_this._setIceTransport();
			_this._setDtlsTransport();
			return _this;
		}
	
		(0, _createClass3.default)(Edge11, [{
			key: 'close',
			value: function close() {
				logger.debug('close()');
	
				// Close the ICE gatherer.
				// NOTE: Not yet implemented by Edge.
				try {
					this._iceGatherer.close();
				} catch (error) {}
	
				// Close the ICE transport.
				try {
					this._iceTransport.stop();
				} catch (error) {}
	
				// Close the DTLS transport.
				try {
					this._dtlsTransport.stop();
				} catch (error) {}
	
				// Close RTCRtpSenders.
				var _iteratorNormalCompletion = true;
				var _didIteratorError = false;
				var _iteratorError = undefined;
	
				try {
					for (var _iterator = (0, _getIterator3.default)(this._rtpSenders.values()), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
						var rtpSender = _step.value;
	
						try {
							rtpSender.stop();
						} catch (error) {}
					}
	
					// Close RTCRtpReceivers.
				} catch (err) {
					_didIteratorError = true;
					_iteratorError = err;
				} finally {
					try {
						if (!_iteratorNormalCompletion && _iterator.return) {
							_iterator.return();
						}
					} finally {
						if (_didIteratorError) {
							throw _iteratorError;
						}
					}
				}
	
				var _iteratorNormalCompletion2 = true;
				var _didIteratorError2 = false;
				var _iteratorError2 = undefined;
	
				try {
					for (var _iterator2 = (0, _getIterator3.default)(this._rtpReceivers.values()), _step2; !(_iteratorNormalCompletion2 = (_step2 = _iterator2.next()).done); _iteratorNormalCompletion2 = true) {
						var rtpReceiver = _step2.value;
	
						try {
							rtpReceiver.stop();
						} catch (error) {}
					}
				} catch (err) {
					_didIteratorError2 = true;
					_iteratorError2 = err;
				} finally {
					try {
						if (!_iteratorNormalCompletion2 && _iterator2.return) {
							_iterator2.return();
						}
					} finally {
						if (_didIteratorError2) {
							throw _iteratorError2;
						}
					}
				}
			}
		}, {
			key: 'addProducer',
			value: function addProducer(producer) {
				var _this2 = this;
	
				var track = producer.track;
	
	
				logger.debug('addProducer() [id:%s, kind:%s, trackId:%s]', producer.id, producer.kind, track.id);
	
				if (this._rtpSenders.has(producer.id)) return _promise2.default.reject(new Error('Producer already added'));
	
				return _promise2.default.resolve().then(function () {
					if (!_this2._transportReady) return _this2._setupTransport();
				}).then(function () {
					logger.debug('addProducer() | calling new RTCRtpSender()');
	
					var rtpSender = new RTCRtpSender(track, _this2._dtlsTransport);
					var rtpParameters = utils.clone(_this2._rtpParametersByKind[producer.kind]);
	
					// Fill RTCRtpParameters.encodings.
					var encoding = {
						ssrc: utils.randomNumber()
					};
	
					if (rtpParameters.codecs.some(function (codec) {
						return codec.name === 'rtx';
					})) {
						encoding.rtx = {
							ssrc: utils.randomNumber()
						};
					}
	
					rtpParameters.encodings.push(encoding);
	
					// Fill RTCRtpParameters.rtcp.
					rtpParameters.rtcp = {
						cname: CNAME,
						reducedSize: true,
						mux: true
					};
	
					// NOTE: Convert our standard RTCRtpParameters into those that Edge
					// expects.
					var edgeRtpParameters = edgeUtils.mangleRtpParameters(rtpParameters);
	
					logger.debug('addProducer() | calling rtpSender.send() [params:%o]', edgeRtpParameters);
	
					rtpSender.send(edgeRtpParameters);
	
					// Store it.
					_this2._rtpSenders.set(producer.id, rtpSender);
	
					return rtpParameters;
				});
			}
		}, {
			key: 'removeProducer',
			value: function removeProducer(producer) {
				var _this3 = this;
	
				var track = producer.track;
	
	
				logger.debug('removeProducer() [id:%s, kind:%s, trackId:%s]', producer.id, producer.kind, track.id);
	
				return _promise2.default.resolve().then(function () {
					var rtpSender = _this3._rtpSenders.get(producer.id);
	
					if (!rtpSender) throw new Error('RTCRtpSender not found');
	
					_this3._rtpSenders.delete(producer.id);
	
					try {
						logger.debug('removeProducer() | calling rtpSender.stop()');
	
						rtpSender.stop();
					} catch (error) {
						logger.warn('rtpSender.stop() failed:%o', error);
					}
				});
			}
		}, {
			key: 'replaceProducerTrack',
			value: function replaceProducerTrack(producer, track) {
				var _this4 = this;
	
				logger.debug('replaceProducerTrack() [id:%s, kind:%s, trackId:%s]', producer.id, producer.kind, track.id);
	
				return _promise2.default.resolve().then(function () {
					var rtpSender = _this4._rtpSenders.get(producer.id);
	
					if (!rtpSender) throw new Error('RTCRtpSender not found');
	
					rtpSender.setTrack(track);
				});
			}
		}, {
			key: 'addConsumer',
			value: function addConsumer(consumer) {
				var _this5 = this;
	
				logger.debug('addConsumer() [id:%s, kind:%s]', consumer.id, consumer.kind);
	
				if (this._rtpReceivers.has(consumer.id)) return _promise2.default.reject(new Error('Consumer already added'));
	
				return _promise2.default.resolve().then(function () {
					if (!_this5._transportReady) return _this5._setupTransport();
				}).then(function () {
					logger.debug('addProducer() | calling new RTCRtpReceiver()');
	
					var rtpReceiver = new RTCRtpReceiver(_this5._dtlsTransport, consumer.kind);
	
					rtpReceiver.addEventListener('error', function (event) {
						logger.error('iceGatherer "error" event [event:%o]', event);
					});
	
					// NOTE: Convert our standard RTCRtpParameters into those that Edge
					// expects.
					var edgeRtpParameters = edgeUtils.mangleRtpParameters(consumer.rtpParameters);
	
					logger.debug('addProducer() | calling rtpReceiver.receive() [params:%o]', edgeRtpParameters);
	
					rtpReceiver.receive(edgeRtpParameters);
	
					// Store it.
					_this5._rtpReceivers.set(consumer.id, rtpReceiver);
	
					return rtpReceiver.track;
				});
			}
		}, {
			key: 'removeConsumer',
			value: function removeConsumer(consumer) {
				var _this6 = this;
	
				logger.debug('removeConsumer() [id:%s, kind:%s]', consumer.id, consumer.kind);
	
				return _promise2.default.resolve().then(function () {
					var rtpReceiver = _this6._rtpReceivers.get(consumer.id);
	
					if (!rtpReceiver) throw new Error('RTCRtpReceiver not found');
	
					_this6._rtpReceivers.delete(consumer.id);
	
					try {
						logger.debug('removeConsumer() | calling rtpReceiver.stop()');
	
						rtpReceiver.stop();
					} catch (error) {
						logger.warn('rtpReceiver.stop() failed:%o', error);
					}
				});
			}
		}, {
			key: 'restartIce',
			value: function restartIce(remoteIceParameters) {
				var _this7 = this;
	
				logger.debug('restartIce()');
	
				_promise2.default.resolve().then(function () {
					_this7._transportRemoteParameters.iceParameters = remoteIceParameters;
	
					var remoteIceCandidates = _this7._transportRemoteParameters.iceCandidates;
	
					logger.debug('restartIce() | calling iceTransport.start()');
	
					_this7._iceTransport.start(_this7._iceGatherer, remoteIceParameters, 'controlling');
	
					var _iteratorNormalCompletion3 = true;
					var _didIteratorError3 = false;
					var _iteratorError3 = undefined;
	
					try {
						for (var _iterator3 = (0, _getIterator3.default)(remoteIceCandidates), _step3; !(_iteratorNormalCompletion3 = (_step3 = _iterator3.next()).done); _iteratorNormalCompletion3 = true) {
							var candidate = _step3.value;
	
							_this7._iceTransport.addRemoteCandidate(candidate);
						}
					} catch (err) {
						_didIteratorError3 = true;
						_iteratorError3 = err;
					} finally {
						try {
							if (!_iteratorNormalCompletion3 && _iterator3.return) {
								_iterator3.return();
							}
						} finally {
							if (_didIteratorError3) {
								throw _iteratorError3;
							}
						}
					}
	
					_this7._iceTransport.addRemoteCandidate({});
				});
			}
		}, {
			key: '_setIceGatherer',
			value: function _setIceGatherer(settings) {
				var iceGatherer = new RTCIceGatherer({
					iceServers: settings.turnServers || [],
					gatherPolicy: 'all'
				});
	
				iceGatherer.addEventListener('error', function (event) {
					logger.error('iceGatherer "error" event [event:%o]', event);
				});
	
				// NOTE: Not yet implemented by Edge, which starts gathering automatically.
				try {
					iceGatherer.gather();
				} catch (error) {
					logger.debug('iceGatherer.gather() failed: %s', error.toString());
				}
	
				this._iceGatherer = iceGatherer;
			}
		}, {
			key: '_setIceTransport',
			value: function _setIceTransport() {
				var _this8 = this;
	
				var iceTransport = new RTCIceTransport(this._iceGatherer);
	
				// NOTE: Not yet implemented by Edge.
				iceTransport.addEventListener('statechange', function () {
					switch (iceTransport.state) {
						case 'checking':
							_this8.emit('@connectionstatechange', 'connecting');
							break;
						case 'connected':
						case 'completed':
							_this8.emit('@connectionstatechange', 'connected');
							break;
						case 'failed':
							_this8.emit('@connectionstatechange', 'failed');
							break;
						case 'disconnected':
							_this8.emit('@connectionstatechange', 'disconnected');
							break;
						case 'closed':
							_this8.emit('@connectionstatechange', 'closed');
							break;
					}
				});
	
				// NOTE: Not standard, but implemented by Edge.
				iceTransport.addEventListener('icestatechange', function () {
					switch (iceTransport.state) {
						case 'checking':
							_this8.emit('@connectionstatechange', 'connecting');
							break;
						case 'connected':
						case 'completed':
							_this8.emit('@connectionstatechange', 'connected');
							break;
						case 'failed':
							_this8.emit('@connectionstatechange', 'failed');
							break;
						case 'disconnected':
							_this8.emit('@connectionstatechange', 'disconnected');
							break;
						case 'closed':
							_this8.emit('@connectionstatechange', 'closed');
							break;
					}
				});
	
				iceTransport.addEventListener('candidatepairchange', function (event) {
					logger.debug('iceTransport "candidatepairchange" event [pair:%o]', event.pair);
				});
	
				this._iceTransport = iceTransport;
			}
		}, {
			key: '_setDtlsTransport',
			value: function _setDtlsTransport() {
				var dtlsTransport = new RTCDtlsTransport(this._iceTransport);
	
				// NOTE: Not yet implemented by Edge.
				dtlsTransport.addEventListener('statechange', function () {
					logger.debug('dtlsTransport "statechange" event [state:%s]', dtlsTransport.state);
				});
	
				// NOTE: Not standard, but implemented by Edge.
				dtlsTransport.addEventListener('dtlsstatechange', function () {
					logger.debug('dtlsTransport "dtlsstatechange" event [state:%s]', dtlsTransport.state);
				});
	
				dtlsTransport.addEventListener('error', function (event) {
					logger.error('dtlsTransport "error" event [event:%o]', event);
				});
	
				this._dtlsTransport = dtlsTransport;
			}
		}, {
			key: '_setupTransport',
			value: function _setupTransport() {
				var _this9 = this;
	
				logger.debug('_setupTransport()');
	
				return _promise2.default.resolve().then(function () {
					// Get our local DTLS parameters.
					var transportLocalParameters = {};
					var dtlsParameters = _this9._dtlsTransport.getLocalParameters();
	
					// Let's decide that we'll be DTLS server (because we can).
					dtlsParameters.role = 'server';
	
					transportLocalParameters.dtlsParameters = dtlsParameters;
	
					// We need transport remote parameters.
					return _this9.safeEmitAsPromise('@needcreatetransport', transportLocalParameters);
				}).then(function (transportRemoteParameters) {
					_this9._transportRemoteParameters = transportRemoteParameters;
	
					var remoteIceParameters = transportRemoteParameters.iceParameters;
					var remoteIceCandidates = transportRemoteParameters.iceCandidates;
					var remoteDtlsParameters = transportRemoteParameters.dtlsParameters;
	
					// Start the RTCIceTransport.
					_this9._iceTransport.start(_this9._iceGatherer, remoteIceParameters, 'controlling');
	
					// Add remote ICE candidates.
					var _iteratorNormalCompletion4 = true;
					var _didIteratorError4 = false;
					var _iteratorError4 = undefined;
	
					try {
						for (var _iterator4 = (0, _getIterator3.default)(remoteIceCandidates), _step4; !(_iteratorNormalCompletion4 = (_step4 = _iterator4.next()).done); _iteratorNormalCompletion4 = true) {
							var candidate = _step4.value;
	
							_this9._iceTransport.addRemoteCandidate(candidate);
						}
	
						// Also signal a 'complete' candidate as per spec.
						// NOTE: It should be {complete: true} but Edge prefers {}.
						// NOTE: If we don't signal end of candidates, the Edge RTCIceTransport
						// won't enter the 'completed' state.
					} catch (err) {
						_didIteratorError4 = true;
						_iteratorError4 = err;
					} finally {
						try {
							if (!_iteratorNormalCompletion4 && _iterator4.return) {
								_iterator4.return();
							}
						} finally {
							if (_didIteratorError4) {
								throw _iteratorError4;
							}
						}
					}
	
					_this9._iceTransport.addRemoteCandidate({});
	
					// NOTE: Edge does not like SHA less than 256.
					remoteDtlsParameters.fingerprints = remoteDtlsParameters.fingerprints.filter(function (fingerprint) {
						return fingerprint.algorithm === 'sha-256' || fingerprint.algorithm === 'sha-384' || fingerprint.algorithm === 'sha-512';
					});
	
					// Start the RTCDtlsTransport.
					_this9._dtlsTransport.start(remoteDtlsParameters);
	
					_this9._transportReady = true;
				});
			}
		}]);
		return Edge11;
	}(_EnhancedEventEmitter3.default);
	
	exports.default = Edge11;
	
	},{"../EnhancedEventEmitter":12,"../Logger":13,"../ortc":33,"../utils":34,"./ortc/edgeUtils":26,"babel-runtime/core-js/get-iterator":36,"babel-runtime/core-js/map":39,"babel-runtime/core-js/object/get-prototype-of":43,"babel-runtime/core-js/promise":47,"babel-runtime/helpers/classCallCheck":51,"babel-runtime/helpers/createClass":52,"babel-runtime/helpers/inherits":54,"babel-runtime/helpers/possibleConstructorReturn":55}],22:[function(require,module,exports){
	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
		value: true
	});
	
	var _from = require('babel-runtime/core-js/array/from');
	
	var _from2 = _interopRequireDefault(_from);
	
	var _map = require('babel-runtime/core-js/map');
	
	var _map2 = _interopRequireDefault(_map);
	
	var _promise = require('babel-runtime/core-js/promise');
	
	var _promise2 = _interopRequireDefault(_promise);
	
	var _getPrototypeOf = require('babel-runtime/core-js/object/get-prototype-of');
	
	var _getPrototypeOf2 = _interopRequireDefault(_getPrototypeOf);
	
	var _classCallCheck2 = require('babel-runtime/helpers/classCallCheck');
	
	var _classCallCheck3 = _interopRequireDefault(_classCallCheck2);
	
	var _createClass2 = require('babel-runtime/helpers/createClass');
	
	var _createClass3 = _interopRequireDefault(_createClass2);
	
	var _possibleConstructorReturn2 = require('babel-runtime/helpers/possibleConstructorReturn');
	
	var _possibleConstructorReturn3 = _interopRequireDefault(_possibleConstructorReturn2);
	
	var _inherits2 = require('babel-runtime/helpers/inherits');
	
	var _inherits3 = _interopRequireDefault(_inherits2);
	
	var _sdpTransform = require('sdp-transform');
	
	var _sdpTransform2 = _interopRequireDefault(_sdpTransform);
	
	var _Logger = require('../Logger');
	
	var _Logger2 = _interopRequireDefault(_Logger);
	
	var _EnhancedEventEmitter2 = require('../EnhancedEventEmitter');
	
	var _EnhancedEventEmitter3 = _interopRequireDefault(_EnhancedEventEmitter2);
	
	var _utils = require('../utils');
	
	var utils = _interopRequireWildcard(_utils);
	
	var _ortc = require('../ortc');
	
	var ortc = _interopRequireWildcard(_ortc);
	
	var _commonUtils = require('./sdp/commonUtils');
	
	var sdpCommonUtils = _interopRequireWildcard(_commonUtils);
	
	var _unifiedPlanUtils = require('./sdp/unifiedPlanUtils');
	
	var sdpUnifiedPlanUtils = _interopRequireWildcard(_unifiedPlanUtils);
	
	var _RemoteUnifiedPlanSdp = require('./sdp/RemoteUnifiedPlanSdp');
	
	var _RemoteUnifiedPlanSdp2 = _interopRequireDefault(_RemoteUnifiedPlanSdp);
	
	function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	var logger = new _Logger2.default('Firefox50');
	
	var Handler = function (_EnhancedEventEmitter) {
		(0, _inherits3.default)(Handler, _EnhancedEventEmitter);
	
		function Handler(direction, rtpParametersByKind, settings) {
			(0, _classCallCheck3.default)(this, Handler);
	
			// RTCPeerConnection instance.
			// @type {RTCPeerConnection}
			var _this = (0, _possibleConstructorReturn3.default)(this, (Handler.__proto__ || (0, _getPrototypeOf2.default)(Handler)).call(this, logger));
	
			_this._pc = new RTCPeerConnection({
				iceServers: settings.turnServers || [],
				iceTransportPolicy: 'all',
				bundlePolicy: 'max-bundle',
				rtcpMuxPolicy: 'require'
			});
	
			// Generic sending RTP parameters for audio and video.
			// @type {Object}
			_this._rtpParametersByKind = rtpParametersByKind;
	
			// Remote SDP handler.
			// @type {RemoteUnifiedPlanSdp}
			_this._remoteSdp = new _RemoteUnifiedPlanSdp2.default(direction, rtpParametersByKind);
	
			// Handle RTCPeerConnection connection status.
			_this._pc.addEventListener('iceconnectionstatechange', function () {
				switch (_this._pc.iceConnectionState) {
					case 'checking':
						_this.emit('@connectionstatechange', 'connecting');
						break;
					case 'connected':
					case 'completed':
						_this.emit('@connectionstatechange', 'connected');
						break;
					case 'failed':
						_this.emit('@connectionstatechange', 'failed');
						break;
					case 'disconnected':
						_this.emit('@connectionstatechange', 'disconnected');
						break;
					case 'closed':
						_this.emit('@connectionstatechange', 'closed');
						break;
				}
			});
			return _this;
		}
	
		(0, _createClass3.default)(Handler, [{
			key: 'close',
			value: function close() {
				logger.debug('close()');
	
				// Close RTCPeerConnection.
				try {
					this._pc.close();
				} catch (error) {}
			}
		}]);
		return Handler;
	}(_EnhancedEventEmitter3.default);
	
	var SendHandler = function (_Handler) {
		(0, _inherits3.default)(SendHandler, _Handler);
	
		function SendHandler(rtpParametersByKind, settings) {
			(0, _classCallCheck3.default)(this, SendHandler);
	
			// Got transport local and remote parameters.
			// @type {Boolean}
			var _this2 = (0, _possibleConstructorReturn3.default)(this, (SendHandler.__proto__ || (0, _getPrototypeOf2.default)(SendHandler)).call(this, 'send', rtpParametersByKind, settings));
	
			_this2._transportReady = false;
	
			// Local stream.
			// @type {MediaStream}
			_this2._stream = new MediaStream();
	
			// RID value counter for simulcast (so they never match).
			// @type {Number}
			_this2._nextRid = 1;
			return _this2;
		}
	
		(0, _createClass3.default)(SendHandler, [{
			key: 'addProducer',
			value: function addProducer(producer) {
				var _this3 = this;
	
				var track = producer.track;
	
	
				logger.debug('addProducer() [id:%s, kind:%s, trackId:%s]', producer.id, producer.kind, track.id);
	
				if (this._stream.getTrackById(track.id)) return _promise2.default.reject(new Error('track already added'));
	
				var rtpSender = void 0;
				var localSdpObj = void 0;
	
				return _promise2.default.resolve().then(function () {
					_this3._stream.addTrack(track);
	
					// Add the stream to the PeerConnection.
					rtpSender = _this3._pc.addTrack(track, _this3._stream);
				}).then(function () {
					// If simulcast is not enabled, do nothing.
					if (!producer.simulcast) return;
	
					logger.debug('addProducer() | enabling simulcast');
	
					var encodings = [];
	
					if (producer.simulcast.high) {
						encodings.push({
							rid: 'high' + _this3._nextRid,
							active: true,
							priority: 'high',
							maxBitrate: producer.simulcast.high
						});
					}
	
					if (producer.simulcast.medium) {
						encodings.push({
							rid: 'medium' + _this3._nextRid,
							active: true,
							priority: 'medium',
							maxBitrate: producer.simulcast.medium
						});
					}
	
					if (producer.simulcast.low) {
						encodings.push({
							rid: 'low' + _this3._nextRid,
							active: true,
							priority: 'low',
							maxBitrate: producer.simulcast.low
						});
					}
	
					// Update RID counter for future ones.
					_this3._nextRid++;
	
					return rtpSender.setParameters({ encodings: encodings });
				}).then(function () {
					return _this3._pc.createOffer();
				}).then(function (offer) {
					logger.debug('addProducer() | calling pc.setLocalDescription() [offer:%o]', offer);
	
					return _this3._pc.setLocalDescription(offer);
				}).then(function () {
					if (!_this3._transportReady) return _this3._setupTransport();
				}).then(function () {
					localSdpObj = _sdpTransform2.default.parse(_this3._pc.localDescription.sdp);
	
					var remoteSdp = _this3._remoteSdp.createAnswerSdp(localSdpObj);
					var answer = { type: 'answer', sdp: remoteSdp };
	
					logger.debug('addProducer() | calling pc.setRemoteDescription() [answer:%o]', answer);
	
					return _this3._pc.setRemoteDescription(answer);
				}).then(function () {
					var rtpParameters = utils.clone(_this3._rtpParametersByKind[producer.kind]);
	
					// Fill the RTP parameters for this track.
					sdpUnifiedPlanUtils.fillRtpParametersForTrack(rtpParameters, localSdpObj, track);
	
					return rtpParameters;
				}).catch(function (error) {
					// Panic here. Try to undo things.
	
					try {
						_this3._pc.removeTrack(rtpSender);
					} catch (error2) {}
	
					_this3._stream.removeTrack(track);
	
					throw error;
				});
			}
		}, {
			key: 'removeProducer',
			value: function removeProducer(producer) {
				var _this4 = this;
	
				var track = producer.track;
	
	
				logger.debug('removeProducer() [id:%s, kind:%s, trackId:%s]', producer.id, producer.kind, track.id);
	
				return _promise2.default.resolve().then(function () {
					// Get the associated RTCRtpSender.
					var rtpSender = _this4._pc.getSenders().find(function (s) {
						return s.track === track;
					});
	
					if (!rtpSender) throw new Error('RTCRtpSender found');
	
					// Remove the associated RtpSender.
					_this4._pc.removeTrack(rtpSender);
	
					// Remove the track from the local stream.
					_this4._stream.removeTrack(track);
	
					return _promise2.default.resolve().then(function () {
						return _this4._pc.createOffer();
					}).then(function (offer) {
						logger.debug('removeProducer() | calling pc.setLocalDescription() [offer:%o]', offer);
	
						return _this4._pc.setLocalDescription(offer);
					});
				}).then(function () {
					var localSdpObj = _sdpTransform2.default.parse(_this4._pc.localDescription.sdp);
					var remoteSdp = _this4._remoteSdp.createAnswerSdp(localSdpObj);
					var answer = { type: 'answer', sdp: remoteSdp };
	
					logger.debug('removeProducer() | calling pc.setRemoteDescription() [answer:%o]', answer);
	
					return _this4._pc.setRemoteDescription(answer);
				});
			}
		}, {
			key: 'replaceProducerTrack',
			value: function replaceProducerTrack(producer, track) {
				var _this5 = this;
	
				logger.debug('replaceProducerTrack() [id:%s, kind:%s, trackId:%s]', producer.id, producer.kind, track.id);
	
				var oldTrack = producer.track;
	
				return _promise2.default.resolve().then(function () {
					// Get the associated RTCRtpSender.
					var rtpSender = _this5._pc.getSenders().find(function (s) {
						return s.track === oldTrack;
					});
	
					if (!rtpSender) throw new Error('local track not found');
	
					return rtpSender.replaceTrack(track);
				}).then(function () {
					// Remove the old track from the local stream.
					_this5._stream.removeTrack(oldTrack);
	
					// Add the new track to the local stream.
					_this5._stream.addTrack(track);
				});
			}
		}, {
			key: 'restartIce',
			value: function restartIce(remoteIceParameters) {
				var _this6 = this;
	
				logger.debug('restartIce()');
	
				// Provide the remote SDP handler with new remote ICE parameters.
				this._remoteSdp.updateTransportRemoteIceParameters(remoteIceParameters);
	
				return _promise2.default.resolve().then(function () {
					return _this6._pc.createOffer({ iceRestart: true });
				}).then(function (offer) {
					logger.debug('restartIce() | calling pc.setLocalDescription() [offer:%o]', offer);
	
					return _this6._pc.setLocalDescription(offer);
				}).then(function () {
					var localSdpObj = _sdpTransform2.default.parse(_this6._pc.localDescription.sdp);
					var remoteSdp = _this6._remoteSdp.createAnswerSdp(localSdpObj);
					var answer = { type: 'answer', sdp: remoteSdp };
	
					logger.debug('restartIce() | calling pc.setRemoteDescription() [answer:%o]', answer);
	
					return _this6._pc.setRemoteDescription(answer);
				});
			}
		}, {
			key: '_setupTransport',
			value: function _setupTransport() {
				var _this7 = this;
	
				logger.debug('_setupTransport()');
	
				return _promise2.default.resolve().then(function () {
					// Get our local DTLS parameters.
					var transportLocalParameters = {};
					var sdp = _this7._pc.localDescription.sdp;
					var sdpObj = _sdpTransform2.default.parse(sdp);
					var dtlsParameters = sdpCommonUtils.extractDtlsParameters(sdpObj);
	
					// Let's decide that we'll be DTLS server (because we can).
					dtlsParameters.role = 'server';
	
					transportLocalParameters.dtlsParameters = dtlsParameters;
	
					// Provide the remote SDP handler with transport local parameters.
					_this7._remoteSdp.setTransportLocalParameters(transportLocalParameters);
	
					// We need transport remote parameters.
					return _this7.safeEmitAsPromise('@needcreatetransport', transportLocalParameters);
				}).then(function (transportRemoteParameters) {
					// Provide the remote SDP handler with transport remote parameters.
					_this7._remoteSdp.setTransportRemoteParameters(transportRemoteParameters);
	
					_this7._transportReady = true;
				});
			}
		}]);
		return SendHandler;
	}(Handler);
	
	var RecvHandler = function (_Handler2) {
		(0, _inherits3.default)(RecvHandler, _Handler2);
	
		function RecvHandler(rtpParametersByKind, settings) {
			(0, _classCallCheck3.default)(this, RecvHandler);
	
			// Got transport remote parameters.
			// @type {Boolean}
			var _this8 = (0, _possibleConstructorReturn3.default)(this, (RecvHandler.__proto__ || (0, _getPrototypeOf2.default)(RecvHandler)).call(this, 'recv', rtpParametersByKind, settings));
	
			_this8._transportCreated = false;
	
			// Got transport local parameters.
			// @type {Boolean}
			_this8._transportUpdated = false;
	
			// Map of Consumers information indexed by consumer.id.
			// - mid {String}
			// - kind {String}
			// - closed {Boolean}
			// - trackId {String}
			// - ssrc {Number}
			// - rtxSsrc {Number}
			// - cname {String}
			// @type {Map<Number, Object>}
			_this8._consumerInfos = new _map2.default();
	
			// Add an entry into consumers info to hold a fake DataChannel, so
			// the first m= section of the remote SDP is always "active" and Firefox
			// does not close the transport when there is no remote audio/video Consumers.
			//
			// ISSUE: https://github.com/versatica/mediasoup-client/issues/2
			var fakeDataChannelConsumerInfo = {
				mid: 'fake-dc',
				kind: 'application',
				closed: false,
				cname: null
			};
	
			_this8._consumerInfos.set(555, fakeDataChannelConsumerInfo);
			return _this8;
		}
	
		(0, _createClass3.default)(RecvHandler, [{
			key: 'addConsumer',
			value: function addConsumer(consumer) {
				var _this9 = this;
	
				logger.debug('addConsumer() [id:%s, kind:%s]', consumer.id, consumer.kind);
	
				if (this._consumerInfos.has(consumer.id)) return _promise2.default.reject(new Error('Consumer already added'));
	
				var encoding = consumer.rtpParameters.encodings[0];
				var cname = consumer.rtpParameters.rtcp.cname;
				var consumerInfo = {
					mid: '' + consumer.kind[0] + consumer.id,
					kind: consumer.kind,
					closed: consumer.closed,
					streamId: 'recv-stream-' + consumer.id,
					trackId: 'consumer-' + consumer.kind + '-' + consumer.id,
					ssrc: encoding.ssrc,
					cname: cname
				};
	
				if (encoding.rtx && encoding.rtx.ssrc) consumerInfo.rtxSsrc = encoding.rtx.ssrc;
	
				this._consumerInfos.set(consumer.id, consumerInfo);
	
				return _promise2.default.resolve().then(function () {
					if (!_this9._transportCreated) return _this9._setupTransport();
				}).then(function () {
					var remoteSdp = _this9._remoteSdp.createOfferSdp((0, _from2.default)(_this9._consumerInfos.values()));
					var offer = { type: 'offer', sdp: remoteSdp };
	
					logger.debug('addConsumer() | calling pc.setRemoteDescription() [offer:%o]', offer);
	
					return _this9._pc.setRemoteDescription(offer);
				}).then(function () {
					return _this9._pc.createAnswer();
				}).then(function (answer) {
					logger.debug('addConsumer() | calling pc.setLocalDescription() [answer:%o]', answer);
	
					return _this9._pc.setLocalDescription(answer);
				}).then(function () {
					if (!_this9._transportUpdated) return _this9._updateTransport();
				}).then(function () {
					var newRtpReceiver = _this9._pc.getReceivers().find(function (rtpReceiver) {
						var track = rtpReceiver.track;
	
	
						if (!track) return false;
	
						return track.id === consumerInfo.trackId;
					});
	
					if (!newRtpReceiver) throw new Error('remote track not found');
	
					return newRtpReceiver.track;
				});
			}
		}, {
			key: 'removeConsumer',
			value: function removeConsumer(consumer) {
				var _this10 = this;
	
				logger.debug('removeConsumer() [id:%s, kind:%s]', consumer.id, consumer.kind);
	
				var consumerInfo = this._consumerInfos.get(consumer.id);
	
				if (!consumerInfo) return _promise2.default.reject(new Error('Consumer not found'));
	
				consumerInfo.closed = true;
	
				return _promise2.default.resolve().then(function () {
					var remoteSdp = _this10._remoteSdp.createOfferSdp((0, _from2.default)(_this10._consumerInfos.values()));
					var offer = { type: 'offer', sdp: remoteSdp };
	
					logger.debug('removeConsumer() | calling pc.setRemoteDescription() [offer:%o]', offer);
	
					return _this10._pc.setRemoteDescription(offer);
				}).then(function () {
					return _this10._pc.createAnswer();
				}).then(function (answer) {
					logger.debug('removeConsumer() | calling pc.setLocalDescription() [answer:%o]', answer);
	
					return _this10._pc.setLocalDescription(answer);
				});
			}
		}, {
			key: 'restartIce',
			value: function restartIce(remoteIceParameters) {
				var _this11 = this;
	
				logger.debug('restartIce()');
	
				// Provide the remote SDP handler with new remote ICE parameters.
				this._remoteSdp.updateTransportRemoteIceParameters(remoteIceParameters);
	
				return _promise2.default.resolve().then(function () {
					var remoteSdp = _this11._remoteSdp.createOfferSdp((0, _from2.default)(_this11._consumerInfos.values()));
					var offer = { type: 'offer', sdp: remoteSdp };
	
					logger.debug('restartIce() | calling pc.setRemoteDescription() [offer:%o]', offer);
	
					return _this11._pc.setRemoteDescription(offer);
				}).then(function () {
					return _this11._pc.createAnswer();
				}).then(function (answer) {
					logger.debug('restartIce() | calling pc.setLocalDescription() [answer:%o]', answer);
	
					return _this11._pc.setLocalDescription(answer);
				});
			}
		}, {
			key: '_setupTransport',
			value: function _setupTransport() {
				var _this12 = this;
	
				logger.debug('_setupTransport()');
	
				return _promise2.default.resolve().then(function () {
					// We need transport remote parameters.
					return _this12.safeEmitAsPromise('@needcreatetransport', null);
				}).then(function (transportRemoteParameters) {
					// Provide the remote SDP handler with transport remote parameters.
					_this12._remoteSdp.setTransportRemoteParameters(transportRemoteParameters);
	
					_this12._transportCreated = true;
				});
			}
		}, {
			key: '_updateTransport',
			value: function _updateTransport() {
				logger.debug('_updateTransport()');
	
				// Get our local DTLS parameters.
				// const transportLocalParameters = {};
				var sdp = this._pc.localDescription.sdp;
				var sdpObj = _sdpTransform2.default.parse(sdp);
				var dtlsParameters = sdpCommonUtils.extractDtlsParameters(sdpObj);
				var transportLocalParameters = { dtlsParameters: dtlsParameters };
	
				// We need to provide transport local parameters.
				this.safeEmit('@needupdatetransport', transportLocalParameters);
	
				this._transportUpdated = true;
			}
		}]);
		return RecvHandler;
	}(Handler);
	
	var Firefox50 = function () {
		(0, _createClass3.default)(Firefox50, null, [{
			key: 'getNativeRtpCapabilities',
			value: function getNativeRtpCapabilities() {
				logger.debug('getNativeRtpCapabilities()');
	
				var pc = new RTCPeerConnection({
					iceServers: [],
					iceTransportPolicy: 'all',
					bundlePolicy: 'max-bundle',
					rtcpMuxPolicy: 'require'
				});
	
				// NOTE: We need to add a real video track to get the RID extension mapping.
				var canvas = document.createElement('canvas');
	
				// NOTE: Otherwise Firefox fails in next line.
				canvas.getContext('2d');
	
				var fakeStream = canvas.captureStream();
				var fakeVideoTrack = fakeStream.getVideoTracks()[0];
				var rtpSender = pc.addTrack(fakeVideoTrack, fakeStream);
	
				rtpSender.setParameters({
					encodings: [{ rid: 'RID1', maxBitrate: 40000 }, { rid: 'RID2', maxBitrate: 10000 }]
				});
	
				return pc.createOffer({
					offerToReceiveAudio: true,
					offerToReceiveVideo: true
				}).then(function (offer) {
					try {
						canvas.remove();
					} catch (error) {}
	
					try {
						pc.close();
					} catch (error) {}
	
					var sdpObj = _sdpTransform2.default.parse(offer.sdp);
					var nativeRtpCapabilities = sdpCommonUtils.extractRtpCapabilities(sdpObj);
	
					return nativeRtpCapabilities;
				}).catch(function (error) {
					try {
						canvas.remove();
					} catch (error2) {}
	
					try {
						pc.close();
					} catch (error2) {}
	
					throw error;
				});
			}
		}, {
			key: 'tag',
			get: function get() {
				return 'Firefox50';
			}
		}]);
	
		function Firefox50(direction, extendedRtpCapabilities, settings) {
			(0, _classCallCheck3.default)(this, Firefox50);
	
			logger.debug('constructor() [direction:%s, extendedRtpCapabilities:%o]', direction, extendedRtpCapabilities);
	
			var rtpParametersByKind = void 0;
	
			switch (direction) {
				case 'send':
					{
						rtpParametersByKind = {
							audio: ortc.getSendingRtpParameters('audio', extendedRtpCapabilities),
							video: ortc.getSendingRtpParameters('video', extendedRtpCapabilities)
						};
	
						return new SendHandler(rtpParametersByKind, settings);
					}
				case 'recv':
					{
						rtpParametersByKind = {
							audio: ortc.getReceivingFullRtpParameters('audio', extendedRtpCapabilities),
							video: ortc.getReceivingFullRtpParameters('video', extendedRtpCapabilities)
						};
	
						return new RecvHandler(rtpParametersByKind, settings);
					}
			}
		}
	
		return Firefox50;
	}();
	
	exports.default = Firefox50;
	
	},{"../EnhancedEventEmitter":12,"../Logger":13,"../ortc":33,"../utils":34,"./sdp/RemoteUnifiedPlanSdp":28,"./sdp/commonUtils":29,"./sdp/unifiedPlanUtils":31,"babel-runtime/core-js/array/from":35,"babel-runtime/core-js/map":39,"babel-runtime/core-js/object/get-prototype-of":43,"babel-runtime/core-js/promise":47,"babel-runtime/helpers/classCallCheck":51,"babel-runtime/helpers/createClass":52,"babel-runtime/helpers/inherits":54,"babel-runtime/helpers/possibleConstructorReturn":55,"sdp-transform":213}],23:[function(require,module,exports){
	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
		value: true
	});
	
	var _from = require('babel-runtime/core-js/array/from');
	
	var _from2 = _interopRequireDefault(_from);
	
	var _map = require('babel-runtime/core-js/map');
	
	var _map2 = _interopRequireDefault(_map);
	
	var _promise = require('babel-runtime/core-js/promise');
	
	var _promise2 = _interopRequireDefault(_promise);
	
	var _getPrototypeOf = require('babel-runtime/core-js/object/get-prototype-of');
	
	var _getPrototypeOf2 = _interopRequireDefault(_getPrototypeOf);
	
	var _classCallCheck2 = require('babel-runtime/helpers/classCallCheck');
	
	var _classCallCheck3 = _interopRequireDefault(_classCallCheck2);
	
	var _createClass2 = require('babel-runtime/helpers/createClass');
	
	var _createClass3 = _interopRequireDefault(_createClass2);
	
	var _possibleConstructorReturn2 = require('babel-runtime/helpers/possibleConstructorReturn');
	
	var _possibleConstructorReturn3 = _interopRequireDefault(_possibleConstructorReturn2);
	
	var _inherits2 = require('babel-runtime/helpers/inherits');
	
	var _inherits3 = _interopRequireDefault(_inherits2);
	
	var _sdpTransform = require('sdp-transform');
	
	var _sdpTransform2 = _interopRequireDefault(_sdpTransform);
	
	var _Logger = require('../Logger');
	
	var _Logger2 = _interopRequireDefault(_Logger);
	
	var _EnhancedEventEmitter2 = require('../EnhancedEventEmitter');
	
	var _EnhancedEventEmitter3 = _interopRequireDefault(_EnhancedEventEmitter2);
	
	var _utils = require('../utils');
	
	var utils = _interopRequireWildcard(_utils);
	
	var _ortc = require('../ortc');
	
	var ortc = _interopRequireWildcard(_ortc);
	
	var _commonUtils = require('./sdp/commonUtils');
	
	var sdpCommonUtils = _interopRequireWildcard(_commonUtils);
	
	var _unifiedPlanUtils = require('./sdp/unifiedPlanUtils');
	
	var sdpUnifiedPlanUtils = _interopRequireWildcard(_unifiedPlanUtils);
	
	var _RemoteUnifiedPlanSdp = require('./sdp/RemoteUnifiedPlanSdp');
	
	var _RemoteUnifiedPlanSdp2 = _interopRequireDefault(_RemoteUnifiedPlanSdp);
	
	function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	var logger = new _Logger2.default('Firefox59');
	
	var Handler = function (_EnhancedEventEmitter) {
		(0, _inherits3.default)(Handler, _EnhancedEventEmitter);
	
		function Handler(direction, rtpParametersByKind, settings) {
			(0, _classCallCheck3.default)(this, Handler);
	
			// RTCPeerConnection instance.
			// @type {RTCPeerConnection}
			var _this = (0, _possibleConstructorReturn3.default)(this, (Handler.__proto__ || (0, _getPrototypeOf2.default)(Handler)).call(this, logger));
	
			_this._pc = new RTCPeerConnection({
				iceServers: settings.turnServers || [],
				iceTransportPolicy: 'all',
				bundlePolicy: 'max-bundle',
				rtcpMuxPolicy: 'require'
			});
	
			// Generic sending RTP parameters for audio and video.
			// @type {Object}
			_this._rtpParametersByKind = rtpParametersByKind;
	
			// Remote SDP handler.
			// @type {RemoteUnifiedPlanSdp}
			_this._remoteSdp = new _RemoteUnifiedPlanSdp2.default(direction, rtpParametersByKind);
	
			// Handle RTCPeerConnection connection status.
			_this._pc.addEventListener('iceconnectionstatechange', function () {
				switch (_this._pc.iceConnectionState) {
					case 'checking':
						_this.emit('@connectionstatechange', 'connecting');
						break;
					case 'connected':
					case 'completed':
						_this.emit('@connectionstatechange', 'connected');
						break;
					case 'failed':
						_this.emit('@connectionstatechange', 'failed');
						break;
					case 'disconnected':
						_this.emit('@connectionstatechange', 'disconnected');
						break;
					case 'closed':
						_this.emit('@connectionstatechange', 'closed');
						break;
				}
			});
			return _this;
		}
	
		(0, _createClass3.default)(Handler, [{
			key: 'close',
			value: function close() {
				logger.debug('close()');
	
				// Close RTCPeerConnection.
				try {
					this._pc.close();
				} catch (error) {}
			}
		}]);
		return Handler;
	}(_EnhancedEventEmitter3.default);
	
	var SendHandler = function (_Handler) {
		(0, _inherits3.default)(SendHandler, _Handler);
	
		function SendHandler(rtpParametersByKind, settings) {
			(0, _classCallCheck3.default)(this, SendHandler);
	
			// Got transport local and remote parameters.
			// @type {Boolean}
			var _this2 = (0, _possibleConstructorReturn3.default)(this, (SendHandler.__proto__ || (0, _getPrototypeOf2.default)(SendHandler)).call(this, 'send', rtpParametersByKind, settings));
	
			_this2._transportReady = false;
	
			// Local stream.
			// @type {MediaStream}
			_this2._stream = new MediaStream();
	
			// RID value counter for simulcast (so they never match).
			// @type {Number}
			_this2._nextRid = 1;
			return _this2;
		}
	
		(0, _createClass3.default)(SendHandler, [{
			key: 'addProducer',
			value: function addProducer(producer) {
				var _this3 = this;
	
				var track = producer.track;
	
	
				logger.debug('addProducer() [id:%s, kind:%s, trackId:%s]', producer.id, producer.kind, track.id);
	
				if (this._stream.getTrackById(track.id)) return _promise2.default.reject(new Error('track already added'));
	
				var rtpSender = void 0;
				var localSdpObj = void 0;
	
				return _promise2.default.resolve().then(function () {
					_this3._stream.addTrack(track);
	
					// Add the stream to the PeerConnection.
					rtpSender = _this3._pc.addTrack(track, _this3._stream);
				}).then(function () {
					// If simulcast is not enabled, do nothing.
					if (!producer.simulcast) return;
	
					logger.debug('addProducer() | enabling simulcast');
	
					var encodings = [];
	
					if (producer.simulcast.high) {
						encodings.push({
							rid: 'high' + _this3._nextRid,
							active: true,
							priority: 'high',
							maxBitrate: producer.simulcast.high
						});
					}
	
					if (producer.simulcast.medium) {
						encodings.push({
							rid: 'medium' + _this3._nextRid,
							active: true,
							priority: 'medium',
							maxBitrate: producer.simulcast.medium
						});
					}
	
					if (producer.simulcast.low) {
						encodings.push({
							rid: 'low' + _this3._nextRid,
							active: true,
							priority: 'low',
							maxBitrate: producer.simulcast.low
						});
					}
	
					// Update RID counter for future ones.
					_this3._nextRid++;
	
					return rtpSender.setParameters({ encodings: encodings });
				}).then(function () {
					return _this3._pc.createOffer();
				}).then(function (offer) {
					logger.debug('addProducer() | calling pc.setLocalDescription() [offer:%o]', offer);
	
					return _this3._pc.setLocalDescription(offer);
				}).then(function () {
					if (!_this3._transportReady) return _this3._setupTransport();
				}).then(function () {
					localSdpObj = _sdpTransform2.default.parse(_this3._pc.localDescription.sdp);
	
					var remoteSdp = _this3._remoteSdp.createAnswerSdp(localSdpObj);
					var answer = { type: 'answer', sdp: remoteSdp };
	
					logger.debug('addProducer() | calling pc.setRemoteDescription() [answer:%o]', answer);
	
					return _this3._pc.setRemoteDescription(answer);
				}).then(function () {
					var rtpParameters = utils.clone(_this3._rtpParametersByKind[producer.kind]);
	
					// Fill the RTP parameters for this track.
					sdpUnifiedPlanUtils.fillRtpParametersForTrack(rtpParameters, localSdpObj, track);
	
					return rtpParameters;
				}).catch(function (error) {
					// Panic here. Try to undo things.
	
					try {
						_this3._pc.removeTrack(rtpSender);
					} catch (error2) {}
	
					_this3._stream.removeTrack(track);
	
					throw error;
				});
			}
		}, {
			key: 'removeProducer',
			value: function removeProducer(producer) {
				var _this4 = this;
	
				var track = producer.track;
	
	
				logger.debug('removeProducer() [id:%s, kind:%s, trackId:%s]', producer.id, producer.kind, track.id);
	
				return _promise2.default.resolve().then(function () {
					// Get the associated RTCRtpSender.
					var rtpSender = _this4._pc.getSenders().find(function (s) {
						return s.track === track;
					});
	
					if (!rtpSender) throw new Error('RTCRtpSender found');
	
					// Remove the associated RtpSender.
					_this4._pc.removeTrack(rtpSender);
	
					// Remove the track from the local stream.
					_this4._stream.removeTrack(track);
	
					return _promise2.default.resolve().then(function () {
						return _this4._pc.createOffer();
					}).then(function (offer) {
						logger.debug('removeProducer() | calling pc.setLocalDescription() [offer:%o]', offer);
	
						return _this4._pc.setLocalDescription(offer);
					});
				}).then(function () {
					var localSdpObj = _sdpTransform2.default.parse(_this4._pc.localDescription.sdp);
					var remoteSdp = _this4._remoteSdp.createAnswerSdp(localSdpObj);
					var answer = { type: 'answer', sdp: remoteSdp };
	
					logger.debug('removeProducer() | calling pc.setRemoteDescription() [answer:%o]', answer);
	
					return _this4._pc.setRemoteDescription(answer);
				});
			}
		}, {
			key: 'replaceProducerTrack',
			value: function replaceProducerTrack(producer, track) {
				var _this5 = this;
	
				logger.debug('replaceProducerTrack() [id:%s, kind:%s, trackId:%s]', producer.id, producer.kind, track.id);
	
				var oldTrack = producer.track;
	
				return _promise2.default.resolve().then(function () {
					// Get the associated RTCRtpSender.
					var rtpSender = _this5._pc.getSenders().find(function (s) {
						return s.track === oldTrack;
					});
	
					if (!rtpSender) throw new Error('local track not found');
	
					return rtpSender.replaceTrack(track);
				}).then(function () {
					// Remove the old track from the local stream.
					_this5._stream.removeTrack(oldTrack);
	
					// Add the new track to the local stream.
					_this5._stream.addTrack(track);
				});
			}
		}, {
			key: 'restartIce',
			value: function restartIce(remoteIceParameters) {
				var _this6 = this;
	
				logger.debug('restartIce()');
	
				// Provide the remote SDP handler with new remote ICE parameters.
				this._remoteSdp.updateTransportRemoteIceParameters(remoteIceParameters);
	
				return _promise2.default.resolve().then(function () {
					return _this6._pc.createOffer({ iceRestart: true });
				}).then(function (offer) {
					logger.debug('restartIce() | calling pc.setLocalDescription() [offer:%o]', offer);
	
					return _this6._pc.setLocalDescription(offer);
				}).then(function () {
					var localSdpObj = _sdpTransform2.default.parse(_this6._pc.localDescription.sdp);
					var remoteSdp = _this6._remoteSdp.createAnswerSdp(localSdpObj);
					var answer = { type: 'answer', sdp: remoteSdp };
	
					logger.debug('restartIce() | calling pc.setRemoteDescription() [answer:%o]', answer);
	
					return _this6._pc.setRemoteDescription(answer);
				});
			}
		}, {
			key: '_setupTransport',
			value: function _setupTransport() {
				var _this7 = this;
	
				logger.debug('_setupTransport()');
	
				return _promise2.default.resolve().then(function () {
					// Get our local DTLS parameters.
					var transportLocalParameters = {};
					var sdp = _this7._pc.localDescription.sdp;
					var sdpObj = _sdpTransform2.default.parse(sdp);
					var dtlsParameters = sdpCommonUtils.extractDtlsParameters(sdpObj);
	
					// Let's decide that we'll be DTLS server (because we can).
					dtlsParameters.role = 'server';
	
					transportLocalParameters.dtlsParameters = dtlsParameters;
	
					// Provide the remote SDP handler with transport local parameters.
					_this7._remoteSdp.setTransportLocalParameters(transportLocalParameters);
	
					// We need transport remote parameters.
					return _this7.safeEmitAsPromise('@needcreatetransport', transportLocalParameters);
				}).then(function (transportRemoteParameters) {
					// Provide the remote SDP handler with transport remote parameters.
					_this7._remoteSdp.setTransportRemoteParameters(transportRemoteParameters);
	
					_this7._transportReady = true;
				});
			}
		}]);
		return SendHandler;
	}(Handler);
	
	var RecvHandler = function (_Handler2) {
		(0, _inherits3.default)(RecvHandler, _Handler2);
	
		function RecvHandler(rtpParametersByKind, settings) {
			(0, _classCallCheck3.default)(this, RecvHandler);
	
			// Got transport remote parameters.
			// @type {Boolean}
			var _this8 = (0, _possibleConstructorReturn3.default)(this, (RecvHandler.__proto__ || (0, _getPrototypeOf2.default)(RecvHandler)).call(this, 'recv', rtpParametersByKind, settings));
	
			_this8._transportCreated = false;
	
			// Got transport local parameters.
			// @type {Boolean}
			_this8._transportUpdated = false;
	
			// Map of Consumers information indexed by consumer.id.
			// - mid {String}
			// - kind {String}
			// - closed {Boolean}
			// - trackId {String}
			// - ssrc {Number}
			// - rtxSsrc {Number}
			// - cname {String}
			// @type {Map<Number, Object>}
			_this8._consumerInfos = new _map2.default();
			return _this8;
		}
	
		(0, _createClass3.default)(RecvHandler, [{
			key: 'addConsumer',
			value: function addConsumer(consumer) {
				var _this9 = this;
	
				logger.debug('addConsumer() [id:%s, kind:%s]', consumer.id, consumer.kind);
	
				if (this._consumerInfos.has(consumer.id)) return _promise2.default.reject(new Error('Consumer already added'));
	
				var encoding = consumer.rtpParameters.encodings[0];
				var cname = consumer.rtpParameters.rtcp.cname;
				var consumerInfo = {
					mid: '' + consumer.kind[0] + consumer.id,
					kind: consumer.kind,
					closed: consumer.closed,
					streamId: 'recv-stream-' + consumer.id,
					trackId: 'consumer-' + consumer.kind + '-' + consumer.id,
					ssrc: encoding.ssrc,
					cname: cname
				};
	
				if (encoding.rtx && encoding.rtx.ssrc) consumerInfo.rtxSsrc = encoding.rtx.ssrc;
	
				this._consumerInfos.set(consumer.id, consumerInfo);
	
				return _promise2.default.resolve().then(function () {
					if (!_this9._transportCreated) return _this9._setupTransport();
				}).then(function () {
					var remoteSdp = _this9._remoteSdp.createOfferSdp((0, _from2.default)(_this9._consumerInfos.values()));
					var offer = { type: 'offer', sdp: remoteSdp };
	
					logger.debug('addConsumer() | calling pc.setRemoteDescription() [offer:%o]', offer);
	
					return _this9._pc.setRemoteDescription(offer);
				}).then(function () {
					return _this9._pc.createAnswer();
				}).then(function (answer) {
					logger.debug('addConsumer() | calling pc.setLocalDescription() [answer:%o]', answer);
	
					return _this9._pc.setLocalDescription(answer);
				}).then(function () {
					if (!_this9._transportUpdated) return _this9._updateTransport();
				}).then(function () {
					var newTransceiver = _this9._pc.getTransceivers().find(function (transceiver) {
						var receiver = transceiver.receiver;
	
	
						if (!receiver) return false;
	
						var track = receiver.track;
	
	
						if (!track) return false;
	
						return transceiver.mid === consumerInfo.mid;
					});
	
					if (!newTransceiver) throw new Error('remote track not found');
	
					return newTransceiver.receiver.track;
				});
			}
		}, {
			key: 'removeConsumer',
			value: function removeConsumer(consumer) {
				var _this10 = this;
	
				logger.debug('removeConsumer() [id:%s, kind:%s]', consumer.id, consumer.kind);
	
				var consumerInfo = this._consumerInfos.get(consumer.id);
	
				if (!consumerInfo) return _promise2.default.reject(new Error('Consumer not found'));
	
				consumerInfo.closed = true;
	
				return _promise2.default.resolve().then(function () {
					var remoteSdp = _this10._remoteSdp.createOfferSdp((0, _from2.default)(_this10._consumerInfos.values()));
					var offer = { type: 'offer', sdp: remoteSdp };
	
					logger.debug('removeConsumer() | calling pc.setRemoteDescription() [offer:%o]', offer);
	
					return _this10._pc.setRemoteDescription(offer);
				}).then(function () {
					return _this10._pc.createAnswer();
				}).then(function (answer) {
					logger.debug('removeConsumer() | calling pc.setLocalDescription() [answer:%o]', answer);
	
					return _this10._pc.setLocalDescription(answer);
				});
			}
		}, {
			key: 'restartIce',
			value: function restartIce(remoteIceParameters) {
				var _this11 = this;
	
				logger.debug('restartIce()');
	
				// Provide the remote SDP handler with new remote ICE parameters.
				this._remoteSdp.updateTransportRemoteIceParameters(remoteIceParameters);
	
				return _promise2.default.resolve().then(function () {
					var remoteSdp = _this11._remoteSdp.createOfferSdp((0, _from2.default)(_this11._consumerInfos.values()));
					var offer = { type: 'offer', sdp: remoteSdp };
	
					logger.debug('restartIce() | calling pc.setRemoteDescription() [offer:%o]', offer);
	
					return _this11._pc.setRemoteDescription(offer);
				}).then(function () {
					return _this11._pc.createAnswer();
				}).then(function (answer) {
					logger.debug('restartIce() | calling pc.setLocalDescription() [answer:%o]', answer);
	
					return _this11._pc.setLocalDescription(answer);
				});
			}
		}, {
			key: '_setupTransport',
			value: function _setupTransport() {
				var _this12 = this;
	
				logger.debug('_setupTransport()');
	
				return _promise2.default.resolve().then(function () {
					// We need transport remote parameters.
					return _this12.safeEmitAsPromise('@needcreatetransport', null);
				}).then(function (transportRemoteParameters) {
					// Provide the remote SDP handler with transport remote parameters.
					_this12._remoteSdp.setTransportRemoteParameters(transportRemoteParameters);
	
					_this12._transportCreated = true;
				});
			}
		}, {
			key: '_updateTransport',
			value: function _updateTransport() {
				logger.debug('_updateTransport()');
	
				// Get our local DTLS parameters.
				// const transportLocalParameters = {};
				var sdp = this._pc.localDescription.sdp;
				var sdpObj = _sdpTransform2.default.parse(sdp);
				var dtlsParameters = sdpCommonUtils.extractDtlsParameters(sdpObj);
				var transportLocalParameters = { dtlsParameters: dtlsParameters };
	
				// We need to provide transport local parameters.
				this.safeEmit('@needupdatetransport', transportLocalParameters);
	
				this._transportUpdated = true;
			}
		}]);
		return RecvHandler;
	}(Handler);
	
	var Firefox59 = function () {
		(0, _createClass3.default)(Firefox59, null, [{
			key: 'getNativeRtpCapabilities',
			value: function getNativeRtpCapabilities() {
				logger.debug('getNativeRtpCapabilities()');
	
				var pc = new RTCPeerConnection({
					iceServers: [],
					iceTransportPolicy: 'all',
					bundlePolicy: 'max-bundle',
					rtcpMuxPolicy: 'require'
				});
	
				// NOTE: We need to add a real video track to get the RID extension mapping.
				var canvas = document.createElement('canvas');
	
				// NOTE: Otherwise Firefox fails in next line.
				canvas.getContext('2d');
	
				var fakeStream = canvas.captureStream();
				var fakeVideoTrack = fakeStream.getVideoTracks()[0];
				var rtpSender = pc.addTrack(fakeVideoTrack, fakeStream);
	
				rtpSender.setParameters({
					encodings: [{ rid: 'RID1', maxBitrate: 40000 }, { rid: 'RID2', maxBitrate: 10000 }]
				});
	
				return pc.createOffer({
					offerToReceiveAudio: true,
					offerToReceiveVideo: true
				}).then(function (offer) {
					try {
						canvas.remove();
					} catch (error) {}
	
					try {
						pc.close();
					} catch (error) {}
	
					var sdpObj = _sdpTransform2.default.parse(offer.sdp);
					var nativeRtpCapabilities = sdpCommonUtils.extractRtpCapabilities(sdpObj);
	
					return nativeRtpCapabilities;
				}).catch(function (error) {
					try {
						canvas.remove();
					} catch (error2) {}
	
					try {
						pc.close();
					} catch (error2) {}
	
					throw error;
				});
			}
		}, {
			key: 'tag',
			get: function get() {
				return 'Firefox59';
			}
		}]);
	
		function Firefox59(direction, extendedRtpCapabilities, settings) {
			(0, _classCallCheck3.default)(this, Firefox59);
	
			logger.debug('constructor() [direction:%s, extendedRtpCapabilities:%o]', direction, extendedRtpCapabilities);
	
			var rtpParametersByKind = void 0;
	
			switch (direction) {
				case 'send':
					{
						rtpParametersByKind = {
							audio: ortc.getSendingRtpParameters('audio', extendedRtpCapabilities),
							video: ortc.getSendingRtpParameters('video', extendedRtpCapabilities)
						};
	
						return new SendHandler(rtpParametersByKind, settings);
					}
				case 'recv':
					{
						rtpParametersByKind = {
							audio: ortc.getReceivingFullRtpParameters('audio', extendedRtpCapabilities),
							video: ortc.getReceivingFullRtpParameters('video', extendedRtpCapabilities)
						};
	
						return new RecvHandler(rtpParametersByKind, settings);
					}
			}
		}
	
		return Firefox59;
	}();
	
	exports.default = Firefox59;
	
	},{"../EnhancedEventEmitter":12,"../Logger":13,"../ortc":33,"../utils":34,"./sdp/RemoteUnifiedPlanSdp":28,"./sdp/commonUtils":29,"./sdp/unifiedPlanUtils":31,"babel-runtime/core-js/array/from":35,"babel-runtime/core-js/map":39,"babel-runtime/core-js/object/get-prototype-of":43,"babel-runtime/core-js/promise":47,"babel-runtime/helpers/classCallCheck":51,"babel-runtime/helpers/createClass":52,"babel-runtime/helpers/inherits":54,"babel-runtime/helpers/possibleConstructorReturn":55,"sdp-transform":213}],24:[function(require,module,exports){
	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
		value: true
	});
	
	var _from = require('babel-runtime/core-js/array/from');
	
	var _from2 = _interopRequireDefault(_from);
	
	var _map = require('babel-runtime/core-js/map');
	
	var _map2 = _interopRequireDefault(_map);
	
	var _promise = require('babel-runtime/core-js/promise');
	
	var _promise2 = _interopRequireDefault(_promise);
	
	var _set = require('babel-runtime/core-js/set');
	
	var _set2 = _interopRequireDefault(_set);
	
	var _getPrototypeOf = require('babel-runtime/core-js/object/get-prototype-of');
	
	var _getPrototypeOf2 = _interopRequireDefault(_getPrototypeOf);
	
	var _classCallCheck2 = require('babel-runtime/helpers/classCallCheck');
	
	var _classCallCheck3 = _interopRequireDefault(_classCallCheck2);
	
	var _createClass2 = require('babel-runtime/helpers/createClass');
	
	var _createClass3 = _interopRequireDefault(_createClass2);
	
	var _possibleConstructorReturn2 = require('babel-runtime/helpers/possibleConstructorReturn');
	
	var _possibleConstructorReturn3 = _interopRequireDefault(_possibleConstructorReturn2);
	
	var _inherits2 = require('babel-runtime/helpers/inherits');
	
	var _inherits3 = _interopRequireDefault(_inherits2);
	
	var _sdpTransform = require('sdp-transform');
	
	var _sdpTransform2 = _interopRequireDefault(_sdpTransform);
	
	var _Logger = require('../Logger');
	
	var _Logger2 = _interopRequireDefault(_Logger);
	
	var _EnhancedEventEmitter2 = require('../EnhancedEventEmitter');
	
	var _EnhancedEventEmitter3 = _interopRequireDefault(_EnhancedEventEmitter2);
	
	var _utils = require('../utils');
	
	var utils = _interopRequireWildcard(_utils);
	
	var _ortc = require('../ortc');
	
	var ortc = _interopRequireWildcard(_ortc);
	
	var _commonUtils = require('./sdp/commonUtils');
	
	var sdpCommonUtils = _interopRequireWildcard(_commonUtils);
	
	var _planBUtils = require('./sdp/planBUtils');
	
	var sdpPlanBUtils = _interopRequireWildcard(_planBUtils);
	
	var _RemotePlanBSdp = require('./sdp/RemotePlanBSdp');
	
	var _RemotePlanBSdp2 = _interopRequireDefault(_RemotePlanBSdp);
	
	function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	var logger = new _Logger2.default('ReactNative');
	
	var Handler = function (_EnhancedEventEmitter) {
		(0, _inherits3.default)(Handler, _EnhancedEventEmitter);
	
		function Handler(direction, rtpParametersByKind, settings) {
			(0, _classCallCheck3.default)(this, Handler);
	
			// RTCPeerConnection instance.
			// @type {RTCPeerConnection}
			var _this = (0, _possibleConstructorReturn3.default)(this, (Handler.__proto__ || (0, _getPrototypeOf2.default)(Handler)).call(this, logger));
	
			_this._pc = new RTCPeerConnection({
				iceServers: settings.turnServers || [],
				iceTransportPolicy: 'all',
				bundlePolicy: 'max-bundle',
				rtcpMuxPolicy: 'require'
			});
	
			// Generic sending RTP parameters for audio and video.
			// @type {Object}
			_this._rtpParametersByKind = rtpParametersByKind;
	
			// Remote SDP handler.
			// @type {RemotePlanBSdp}
			_this._remoteSdp = new _RemotePlanBSdp2.default(direction, rtpParametersByKind);
	
			// Handle RTCPeerConnection connection status.
			_this._pc.addEventListener('iceconnectionstatechange', function () {
				switch (_this._pc.iceConnectionState) {
					case 'checking':
						_this.emit('@connectionstatechange', 'connecting');
						break;
					case 'connected':
					case 'completed':
						_this.emit('@connectionstatechange', 'connected');
						break;
					case 'failed':
						_this.emit('@connectionstatechange', 'failed');
						break;
					case 'disconnected':
						_this.emit('@connectionstatechange', 'disconnected');
						break;
					case 'closed':
						_this.emit('@connectionstatechange', 'closed');
						break;
				}
			});
			return _this;
		}
	
		(0, _createClass3.default)(Handler, [{
			key: 'close',
			value: function close() {
				logger.debug('close()');
	
				// Close RTCPeerConnection.
				try {
					this._pc.close();
				} catch (error) {}
			}
		}]);
		return Handler;
	}(_EnhancedEventEmitter3.default);
	
	var SendHandler = function (_Handler) {
		(0, _inherits3.default)(SendHandler, _Handler);
	
		function SendHandler(rtpParametersByKind, settings) {
			(0, _classCallCheck3.default)(this, SendHandler);
	
			// Got transport local and remote parameters.
			// @type {Boolean}
			var _this2 = (0, _possibleConstructorReturn3.default)(this, (SendHandler.__proto__ || (0, _getPrototypeOf2.default)(SendHandler)).call(this, 'send', rtpParametersByKind, settings));
	
			_this2._transportReady = false;
	
			// Handled tracks.
			// @type {Set<MediaStreamTrack>}
			_this2._tracks = new _set2.default();
			return _this2;
		}
	
		(0, _createClass3.default)(SendHandler, [{
			key: 'addProducer',
			value: function addProducer(producer) {
				var _this3 = this;
	
				var track = producer.track;
	
	
				logger.debug('addProducer() [id:%s, kind:%s, trackId:%s]', producer.id, producer.kind, track.id);
	
				if (this._tracks.has(track)) return _promise2.default.reject(new Error('track already added'));
	
				if (!track.streamReactTag) return _promise2.default.reject(new Error('no track.streamReactTag property'));
	
				var stream = void 0;
				var localSdpObj = void 0;
	
				return _promise2.default.resolve().then(function () {
					// Add the track to the Set.
					_this3._tracks.add(track);
	
					// Hack: Create a new stream with track.streamReactTag as id.
					stream = new MediaStream(track.streamReactTag);
	
					// Add the track to the stream.
					stream.addTrack(track);
	
					// Add the stream to the PeerConnection.
					_this3._pc.addStream(stream);
	
					return _this3._pc.createOffer();
				}).then(function (offer) {
					// If simulcast is set, mangle the offer.
					if (producer.simulcast) {
						logger.debug('addProducer() | enabling simulcast');
	
						var sdpObject = _sdpTransform2.default.parse(offer.sdp);
	
						sdpPlanBUtils.addSimulcastForTrack(sdpObject, track);
	
						var offerSdp = _sdpTransform2.default.write(sdpObject);
	
						offer = { type: 'offer', sdp: offerSdp };
					}
	
					logger.debug('addProducer() | calling pc.setLocalDescription() [offer:%o]', offer);
	
					var offerDesc = new RTCSessionDescription(offer);
	
					return _this3._pc.setLocalDescription(offerDesc);
				}).then(function () {
					if (!_this3._transportReady) return _this3._setupTransport();
				}).then(function () {
					localSdpObj = _sdpTransform2.default.parse(_this3._pc.localDescription.sdp);
	
					var remoteSdp = _this3._remoteSdp.createAnswerSdp(localSdpObj);
					var answer = { type: 'answer', sdp: remoteSdp };
	
					logger.debug('addProducer() | calling pc.setRemoteDescription() [answer:%o]', answer);
	
					var answerDesc = new RTCSessionDescription(answer);
	
					return _this3._pc.setRemoteDescription(answerDesc);
				}).then(function () {
					var rtpParameters = utils.clone(_this3._rtpParametersByKind[producer.kind]);
	
					// Fill the RTP parameters for this track.
					sdpPlanBUtils.fillRtpParametersForTrack(rtpParameters, localSdpObj, track);
	
					return rtpParameters;
				}).catch(function (error) {
					// Panic here. Try to undo things.
	
					_this3._tracks.delete(track);
					stream.removeTrack(track);
					_this3._pc.addStream(stream);
	
					throw error;
				});
			}
		}, {
			key: 'removeProducer',
			value: function removeProducer(producer) {
				var _this4 = this;
	
				var track = producer.track;
	
	
				logger.debug('removeProducer() [id:%s, kind:%s, trackId:%s]', producer.id, producer.kind, track.id);
	
				if (!track.streamReactTag) return _promise2.default.reject(new Error('no track.streamReactTag property'));
	
				return _promise2.default.resolve().then(function () {
					// Remove the track from the Set.
					_this4._tracks.delete(track);
	
					// Hack: Create a new stream with track.streamReactTag as id.
					var stream = new MediaStream(track.streamReactTag);
	
					// Add the track to the stream.
					stream.addTrack(track);
	
					// Add the stream to the PeerConnection.
					_this4._pc.addStream(stream);
	
					return _this4._pc.createOffer();
				}).then(function (offer) {
					logger.debug('removeProducer() | calling pc.setLocalDescription() [offer:%o]', offer);
	
					return _this4._pc.setLocalDescription(offer);
				}).catch(function (error) {
					// NOTE: If there are no sending tracks, setLocalDescription() will fail with
					// "Failed to create channels". If so, ignore it.
					if (_this4._tracks.size === 0) {
						logger.warn('removeProducer() | ignoring expected error due no sending tracks: %s', error.toString());
	
						return;
					}
	
					throw error;
				}).then(function () {
					if (_this4._pc.signalingState === 'stable') return;
	
					var localSdpObj = _sdpTransform2.default.parse(_this4._pc.localDescription.sdp);
					var remoteSdp = _this4._remoteSdp.createAnswerSdp(localSdpObj);
					var answer = { type: 'answer', sdp: remoteSdp };
	
					logger.debug('removeProducer() | calling pc.setRemoteDescription() [answer:%o]', answer);
	
					var answerDesc = new RTCSessionDescription(answer);
	
					return _this4._pc.setRemoteDescription(answerDesc);
				});
			}
		}, {
			key: 'replaceProducerTrack',
			value: function replaceProducerTrack(producer, track) {
				var _this5 = this;
	
				logger.debug('replaceProducerTrack() [id:%s, kind:%s, trackId:%s]', producer.id, producer.kind, track.id);
	
				if (!track.streamReactTag) return _promise2.default.reject(new Error('no track.streamReactTag property'));
	
				var oldTrack = producer.track;
				var stream = void 0;
				var localSdpObj = void 0;
	
				return _promise2.default.resolve().then(function () {
					// Add the new Track to the Set and remove the old one.
					_this5._tracks.add(track);
					_this5._tracks.delete(oldTrack);
	
					// Hack: Create a new stream with track.streamReactTag as id.
					stream = new MediaStream(track.streamReactTag);
	
					// Add the track to the stream and remove the old one.
					stream.addTrack(track);
					stream.removeTrack(oldTrack);
	
					// Add the stream to the PeerConnection.
					_this5._pc.addStream(stream);
	
					return _this5._pc.createOffer();
				}).then(function (offer) {
					// If simulcast is set, mangle the offer.
					if (producer.simulcast) {
						logger.debug('addProducer() | enabling simulcast');
	
						var sdpObject = _sdpTransform2.default.parse(offer.sdp);
	
						sdpPlanBUtils.addSimulcastForTrack(sdpObject, track);
	
						var offerSdp = _sdpTransform2.default.write(sdpObject);
	
						offer = { type: 'offer', sdp: offerSdp };
					}
	
					logger.debug('replaceProducerTrack() | calling pc.setLocalDescription() [offer:%o]', offer);
	
					var offerDesc = new RTCSessionDescription(offer);
	
					return _this5._pc.setLocalDescription(offerDesc);
				}).then(function () {
					localSdpObj = _sdpTransform2.default.parse(_this5._pc.localDescription.sdp);
	
					var remoteSdp = _this5._remoteSdp.createAnswerSdp(localSdpObj);
					var answer = { type: 'answer', sdp: remoteSdp };
	
					logger.debug('replaceProducerTrack() | calling pc.setRemoteDescription() [answer:%o]', answer);
	
					var answerDesc = new RTCSessionDescription(answer);
	
					return _this5._pc.setRemoteDescription(answerDesc);
				}).then(function () {
					var rtpParameters = utils.clone(_this5._rtpParametersByKind[producer.kind]);
	
					// Fill the RTP parameters for the new track.
					sdpPlanBUtils.fillRtpParametersForTrack(rtpParameters, localSdpObj, track);
	
					// We need to provide new RTP parameters.
					_this5.safeEmit('@needupdateproducer', producer, rtpParameters);
				}).catch(function (error) {
					// Panic here. Try to undo things.
	
					_this5._tracks.delete(track);
					stream.removeTrack(track);
					_this5._pc.addStream(stream);
	
					throw error;
				});
			}
		}, {
			key: 'restartIce',
			value: function restartIce(remoteIceParameters) {
				var _this6 = this;
	
				logger.debug('restartIce()');
	
				// Provide the remote SDP handler with new remote ICE parameters.
				this._remoteSdp.updateTransportRemoteIceParameters(remoteIceParameters);
	
				return _promise2.default.resolve().then(function () {
					return _this6._pc.createOffer({ iceRestart: true });
				}).then(function (offer) {
					logger.debug('restartIce() | calling pc.setLocalDescription() [offer:%o]', offer);
	
					return _this6._pc.setLocalDescription(offer);
				}).then(function () {
					var localSdpObj = _sdpTransform2.default.parse(_this6._pc.localDescription.sdp);
					var remoteSdp = _this6._remoteSdp.createAnswerSdp(localSdpObj);
					var answer = { type: 'answer', sdp: remoteSdp };
	
					logger.debug('restartIce() | calling pc.setRemoteDescription() [answer:%o]', answer);
	
					var answerDesc = new RTCSessionDescription(answer);
	
					return _this6._pc.setRemoteDescription(answerDesc);
				});
			}
		}, {
			key: '_setupTransport',
			value: function _setupTransport() {
				var _this7 = this;
	
				logger.debug('_setupTransport()');
	
				return _promise2.default.resolve().then(function () {
					// Get our local DTLS parameters.
					var transportLocalParameters = {};
					var sdp = _this7._pc.localDescription.sdp;
					var sdpObj = _sdpTransform2.default.parse(sdp);
					var dtlsParameters = sdpCommonUtils.extractDtlsParameters(sdpObj);
	
					// Let's decide that we'll be DTLS server (because we can).
					dtlsParameters.role = 'server';
	
					transportLocalParameters.dtlsParameters = dtlsParameters;
	
					// Provide the remote SDP handler with transport local parameters.
					_this7._remoteSdp.setTransportLocalParameters(transportLocalParameters);
	
					// We need transport remote parameters.
					return _this7.safeEmitAsPromise('@needcreatetransport', transportLocalParameters);
				}).then(function (transportRemoteParameters) {
					// Provide the remote SDP handler with transport remote parameters.
					_this7._remoteSdp.setTransportRemoteParameters(transportRemoteParameters);
	
					_this7._transportReady = true;
				});
			}
		}]);
		return SendHandler;
	}(Handler);
	
	var RecvHandler = function (_Handler2) {
		(0, _inherits3.default)(RecvHandler, _Handler2);
	
		function RecvHandler(rtpParametersByKind, settings) {
			(0, _classCallCheck3.default)(this, RecvHandler);
	
			// Got transport remote parameters.
			// @type {Boolean}
			var _this8 = (0, _possibleConstructorReturn3.default)(this, (RecvHandler.__proto__ || (0, _getPrototypeOf2.default)(RecvHandler)).call(this, 'recv', rtpParametersByKind, settings));
	
			_this8._transportCreated = false;
	
			// Got transport local parameters.
			// @type {Boolean}
			_this8._transportUpdated = false;
	
			// Seen media kinds.
			// @type {Set<String>}
			_this8._kinds = new _set2.default();
	
			// Map of Consumers information indexed by consumer.id.
			// - kind {String}
			// - trackId {String}
			// - ssrc {Number}
			// - rtxSsrc {Number}
			// - cname {String}
			// @type {Map<Number, Object>}
			_this8._consumerInfos = new _map2.default();
			return _this8;
		}
	
		(0, _createClass3.default)(RecvHandler, [{
			key: 'addConsumer',
			value: function addConsumer(consumer) {
				var _this9 = this;
	
				logger.debug('addConsumer() [id:%s, kind:%s]', consumer.id, consumer.kind);
	
				if (this._consumerInfos.has(consumer.id)) return _promise2.default.reject(new Error('Consumer already added'));
	
				var encoding = consumer.rtpParameters.encodings[0];
				var cname = consumer.rtpParameters.rtcp.cname;
				var consumerInfo = {
					kind: consumer.kind,
					streamId: 'recv-stream-' + consumer.id,
					trackId: 'consumer-' + consumer.kind + '-' + consumer.id,
					ssrc: encoding.ssrc,
					cname: cname
				};
	
				if (encoding.rtx && encoding.rtx.ssrc) consumerInfo.rtxSsrc = encoding.rtx.ssrc;
	
				this._consumerInfos.set(consumer.id, consumerInfo);
				this._kinds.add(consumer.kind);
	
				return _promise2.default.resolve().then(function () {
					if (!_this9._transportCreated) return _this9._setupTransport();
				}).then(function () {
					var remoteSdp = _this9._remoteSdp.createOfferSdp((0, _from2.default)(_this9._kinds), (0, _from2.default)(_this9._consumerInfos.values()));
					var offer = { type: 'offer', sdp: remoteSdp };
	
					logger.debug('addConsumer() | calling pc.setRemoteDescription() [offer:%o]', offer);
	
					var offerDesc = new RTCSessionDescription(offer);
	
					return _this9._pc.setRemoteDescription(offerDesc);
				}).then(function () {
					return _this9._pc.createAnswer();
				}).then(function (answer) {
					logger.debug('addConsumer() | calling pc.setLocalDescription() [answer:%o]', answer);
	
					return _this9._pc.setLocalDescription(answer);
				}).then(function () {
					if (!_this9._transportUpdated) return _this9._updateTransport();
				}).then(function () {
					var stream = _this9._pc.getRemoteStreams().find(function (s) {
						return s.id === consumerInfo.streamId;
					});
					var track = stream.getTrackById(consumerInfo.trackId);
	
					// Hack: Add a streamReactTag property with the reactTag of the MediaStream
					// generated by react-native-webrtc (this is needed because react-native-webrtc
					// assumes that we're gonna use the streams generated by it).
					track.streamReactTag = stream.reactTag;
	
					if (!track) throw new Error('remote track not found');
	
					return track;
				});
			}
		}, {
			key: 'removeConsumer',
			value: function removeConsumer(consumer) {
				var _this10 = this;
	
				logger.debug('removeConsumer() [id:%s, kind:%s]', consumer.id, consumer.kind);
	
				if (!this._consumerInfos.has(consumer.id)) return _promise2.default.reject(new Error('Consumer not found'));
	
				this._consumerInfos.delete(consumer.id);
	
				return _promise2.default.resolve().then(function () {
					var remoteSdp = _this10._remoteSdp.createOfferSdp((0, _from2.default)(_this10._kinds), (0, _from2.default)(_this10._consumerInfos.values()));
					var offer = { type: 'offer', sdp: remoteSdp };
	
					logger.debug('removeConsumer() | calling pc.setRemoteDescription() [offer:%o]', offer);
	
					var offerDesc = new RTCSessionDescription(offer);
	
					return _this10._pc.setRemoteDescription(offerDesc);
				}).then(function () {
					return _this10._pc.createAnswer();
				}).then(function (answer) {
					logger.debug('removeConsumer() | calling pc.setLocalDescription() [answer:%o]', answer);
	
					return _this10._pc.setLocalDescription(answer);
				});
			}
		}, {
			key: 'restartIce',
			value: function restartIce(remoteIceParameters) {
				var _this11 = this;
	
				logger.debug('restartIce()');
	
				// Provide the remote SDP handler with new remote ICE parameters.
				this._remoteSdp.updateTransportRemoteIceParameters(remoteIceParameters);
	
				return _promise2.default.resolve().then(function () {
					var remoteSdp = _this11._remoteSdp.createOfferSdp((0, _from2.default)(_this11._kinds), (0, _from2.default)(_this11._consumerInfos.values()));
					var offer = { type: 'offer', sdp: remoteSdp };
	
					logger.debug('restartIce() | calling pc.setRemoteDescription() [offer:%o]', offer);
	
					var offerDesc = new RTCSessionDescription(offer);
	
					return _this11._pc.setRemoteDescription(offerDesc);
				}).then(function () {
					return _this11._pc.createAnswer();
				}).then(function (answer) {
					logger.debug('restartIce() | calling pc.setLocalDescription() [answer:%o]', answer);
	
					return _this11._pc.setLocalDescription(answer);
				});
			}
		}, {
			key: '_setupTransport',
			value: function _setupTransport() {
				var _this12 = this;
	
				logger.debug('_setupTransport()');
	
				return _promise2.default.resolve().then(function () {
					// We need transport remote parameters.
					return _this12.safeEmitAsPromise('@needcreatetransport', null);
				}).then(function (transportRemoteParameters) {
					// Provide the remote SDP handler with transport remote parameters.
					_this12._remoteSdp.setTransportRemoteParameters(transportRemoteParameters);
	
					_this12._transportCreated = true;
				});
			}
		}, {
			key: '_updateTransport',
			value: function _updateTransport() {
				logger.debug('_updateTransport()');
	
				// Get our local DTLS parameters.
				// const transportLocalParameters = {};
				var sdp = this._pc.localDescription.sdp;
				var sdpObj = _sdpTransform2.default.parse(sdp);
				var dtlsParameters = sdpCommonUtils.extractDtlsParameters(sdpObj);
				var transportLocalParameters = { dtlsParameters: dtlsParameters };
	
				// We need to provide transport local parameters.
				this.safeEmit('@needupdatetransport', transportLocalParameters);
	
				this._transportUpdated = true;
			}
		}]);
		return RecvHandler;
	}(Handler);
	
	var ReactNative = function () {
		(0, _createClass3.default)(ReactNative, null, [{
			key: 'getNativeRtpCapabilities',
			value: function getNativeRtpCapabilities() {
				logger.debug('getNativeRtpCapabilities()');
	
				var pc = new RTCPeerConnection({
					iceServers: [],
					iceTransportPolicy: 'all',
					bundlePolicy: 'max-bundle',
					rtcpMuxPolicy: 'require'
				});
	
				return pc.createOffer({
					offerToReceiveAudio: true,
					offerToReceiveVideo: true
				}).then(function (offer) {
					try {
						pc.close();
					} catch (error) {}
	
					var sdpObj = _sdpTransform2.default.parse(offer.sdp);
					var nativeRtpCapabilities = sdpCommonUtils.extractRtpCapabilities(sdpObj);
	
					return nativeRtpCapabilities;
				}).catch(function (error) {
					try {
						pc.close();
					} catch (error2) {}
	
					throw error;
				});
			}
		}, {
			key: 'tag',
			get: function get() {
				return 'ReactNative';
			}
		}]);
	
		function ReactNative(direction, extendedRtpCapabilities, settings) {
			(0, _classCallCheck3.default)(this, ReactNative);
	
			logger.debug('constructor() [direction:%s, extendedRtpCapabilities:%o]', direction, extendedRtpCapabilities);
	
			var rtpParametersByKind = void 0;
	
			switch (direction) {
				case 'send':
					{
						rtpParametersByKind = {
							audio: ortc.getSendingRtpParameters('audio', extendedRtpCapabilities),
							video: ortc.getSendingRtpParameters('video', extendedRtpCapabilities)
						};
	
						return new SendHandler(rtpParametersByKind, settings);
					}
				case 'recv':
					{
						rtpParametersByKind = {
							audio: ortc.getReceivingFullRtpParameters('audio', extendedRtpCapabilities),
							video: ortc.getReceivingFullRtpParameters('video', extendedRtpCapabilities)
						};
	
						return new RecvHandler(rtpParametersByKind, settings);
					}
			}
		}
	
		return ReactNative;
	}();
	
	exports.default = ReactNative;
	
	},{"../EnhancedEventEmitter":12,"../Logger":13,"../ortc":33,"../utils":34,"./sdp/RemotePlanBSdp":27,"./sdp/commonUtils":29,"./sdp/planBUtils":30,"babel-runtime/core-js/array/from":35,"babel-runtime/core-js/map":39,"babel-runtime/core-js/object/get-prototype-of":43,"babel-runtime/core-js/promise":47,"babel-runtime/core-js/set":48,"babel-runtime/helpers/classCallCheck":51,"babel-runtime/helpers/createClass":52,"babel-runtime/helpers/inherits":54,"babel-runtime/helpers/possibleConstructorReturn":55,"sdp-transform":213}],25:[function(require,module,exports){
	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
		value: true
	});
	
	var _from = require('babel-runtime/core-js/array/from');
	
	var _from2 = _interopRequireDefault(_from);
	
	var _map = require('babel-runtime/core-js/map');
	
	var _map2 = _interopRequireDefault(_map);
	
	var _set = require('babel-runtime/core-js/set');
	
	var _set2 = _interopRequireDefault(_set);
	
	var _promise = require('babel-runtime/core-js/promise');
	
	var _promise2 = _interopRequireDefault(_promise);
	
	var _getPrototypeOf = require('babel-runtime/core-js/object/get-prototype-of');
	
	var _getPrototypeOf2 = _interopRequireDefault(_getPrototypeOf);
	
	var _classCallCheck2 = require('babel-runtime/helpers/classCallCheck');
	
	var _classCallCheck3 = _interopRequireDefault(_classCallCheck2);
	
	var _createClass2 = require('babel-runtime/helpers/createClass');
	
	var _createClass3 = _interopRequireDefault(_createClass2);
	
	var _possibleConstructorReturn2 = require('babel-runtime/helpers/possibleConstructorReturn');
	
	var _possibleConstructorReturn3 = _interopRequireDefault(_possibleConstructorReturn2);
	
	var _inherits2 = require('babel-runtime/helpers/inherits');
	
	var _inherits3 = _interopRequireDefault(_inherits2);
	
	var _sdpTransform = require('sdp-transform');
	
	var _sdpTransform2 = _interopRequireDefault(_sdpTransform);
	
	var _Logger = require('../Logger');
	
	var _Logger2 = _interopRequireDefault(_Logger);
	
	var _EnhancedEventEmitter2 = require('../EnhancedEventEmitter');
	
	var _EnhancedEventEmitter3 = _interopRequireDefault(_EnhancedEventEmitter2);
	
	var _utils = require('../utils');
	
	var utils = _interopRequireWildcard(_utils);
	
	var _ortc = require('../ortc');
	
	var ortc = _interopRequireWildcard(_ortc);
	
	var _commonUtils = require('./sdp/commonUtils');
	
	var sdpCommonUtils = _interopRequireWildcard(_commonUtils);
	
	var _planBUtils = require('./sdp/planBUtils');
	
	var sdpPlanBUtils = _interopRequireWildcard(_planBUtils);
	
	var _RemotePlanBSdp = require('./sdp/RemotePlanBSdp');
	
	var _RemotePlanBSdp2 = _interopRequireDefault(_RemotePlanBSdp);
	
	function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	var logger = new _Logger2.default('Safari11');
	
	var Handler = function (_EnhancedEventEmitter) {
		(0, _inherits3.default)(Handler, _EnhancedEventEmitter);
	
		function Handler(direction, rtpParametersByKind, settings) {
			(0, _classCallCheck3.default)(this, Handler);
	
			// RTCPeerConnection instance.
			// @type {RTCPeerConnection}
			var _this = (0, _possibleConstructorReturn3.default)(this, (Handler.__proto__ || (0, _getPrototypeOf2.default)(Handler)).call(this, logger));
	
			_this._pc = new RTCPeerConnection({
				iceServers: settings.turnServers || [],
				iceTransportPolicy: 'all',
				bundlePolicy: 'max-bundle',
				rtcpMuxPolicy: 'require'
			});
	
			// Generic sending RTP parameters for audio and video.
			// @type {Object}
			_this._rtpParametersByKind = rtpParametersByKind;
	
			// Remote SDP handler.
			// @type {RemotePlanBSdp}
			_this._remoteSdp = new _RemotePlanBSdp2.default(direction, rtpParametersByKind);
	
			// Handle RTCPeerConnection connection status.
			_this._pc.addEventListener('iceconnectionstatechange', function () {
				switch (_this._pc.iceConnectionState) {
					case 'checking':
						_this.emit('@connectionstatechange', 'connecting');
						break;
					case 'connected':
					case 'completed':
						_this.emit('@connectionstatechange', 'connected');
						break;
					case 'failed':
						_this.emit('@connectionstatechange', 'failed');
						break;
					case 'disconnected':
						_this.emit('@connectionstatechange', 'disconnected');
						break;
					case 'closed':
						_this.emit('@connectionstatechange', 'closed');
						break;
				}
			});
			return _this;
		}
	
		(0, _createClass3.default)(Handler, [{
			key: 'close',
			value: function close() {
				logger.debug('close()');
	
				// Close RTCPeerConnection.
				try {
					this._pc.close();
				} catch (error) {}
			}
		}]);
		return Handler;
	}(_EnhancedEventEmitter3.default);
	
	var SendHandler = function (_Handler) {
		(0, _inherits3.default)(SendHandler, _Handler);
	
		function SendHandler(rtpParametersByKind, settings) {
			(0, _classCallCheck3.default)(this, SendHandler);
	
			// Got transport local and remote parameters.
			// @type {Boolean}
			var _this2 = (0, _possibleConstructorReturn3.default)(this, (SendHandler.__proto__ || (0, _getPrototypeOf2.default)(SendHandler)).call(this, 'send', rtpParametersByKind, settings));
	
			_this2._transportReady = false;
	
			// Local stream.
			// @type {MediaStream}
			_this2._stream = new MediaStream();
			return _this2;
		}
	
		(0, _createClass3.default)(SendHandler, [{
			key: 'addProducer',
			value: function addProducer(producer) {
				var _this3 = this;
	
				var track = producer.track;
	
	
				logger.debug('addProducer() [id:%s, kind:%s, trackId:%s]', producer.id, producer.kind, track.id);
	
				if (this._stream.getTrackById(track.id)) return _promise2.default.reject(new Error('track already added'));
	
				var rtpSender = void 0;
				var localSdpObj = void 0;
	
				return _promise2.default.resolve().then(function () {
					_this3._stream.addTrack(track);
	
					// Add the stream to the PeerConnection.
					rtpSender = _this3._pc.addTrack(track, _this3._stream);
	
					return _this3._pc.createOffer();
				}).then(function (offer) {
					logger.debug('addProducer() | calling pc.setLocalDescription() [offer:%o]', offer);
	
					return _this3._pc.setLocalDescription(offer);
				}).then(function () {
					if (!_this3._transportReady) return _this3._setupTransport();
				}).then(function () {
					localSdpObj = _sdpTransform2.default.parse(_this3._pc.localDescription.sdp);
	
					var remoteSdp = _this3._remoteSdp.createAnswerSdp(localSdpObj);
					var answer = { type: 'answer', sdp: remoteSdp };
	
					logger.debug('addProducer() | calling pc.setRemoteDescription() [answer:%o]', answer);
	
					return _this3._pc.setRemoteDescription(answer);
				}).then(function () {
					var rtpParameters = utils.clone(_this3._rtpParametersByKind[producer.kind]);
	
					// Fill the RTP parameters for this track.
					sdpPlanBUtils.fillRtpParametersForTrack(rtpParameters, localSdpObj, track);
	
					return rtpParameters;
				}).catch(function (error) {
					// Panic here. Try to undo things.
	
					try {
						_this3._pc.removeTrack(rtpSender);
					} catch (error2) {}
	
					_this3._stream.removeTrack(track);
	
					throw error;
				});
			}
		}, {
			key: 'removeProducer',
			value: function removeProducer(producer) {
				var _this4 = this;
	
				var track = producer.track;
	
	
				logger.debug('removeProducer() [id:%s, kind:%s, trackId:%s]', producer.id, producer.kind, track.id);
	
				return _promise2.default.resolve().then(function () {
					// Get the associated RTCRtpSender.
					var rtpSender = _this4._pc.getSenders().find(function (s) {
						return s.track === track;
					});
	
					if (!rtpSender) throw new Error('RTCRtpSender found');
	
					// Remove the associated RtpSender.
					_this4._pc.removeTrack(rtpSender);
	
					// Remove the track from the local stream.
					_this4._stream.removeTrack(track);
	
					return _this4._pc.createOffer();
				}).then(function (offer) {
					logger.debug('removeProducer() | calling pc.setLocalDescription() [offer:%o]', offer);
	
					return _this4._pc.setLocalDescription(offer);
				}).catch(function (error) {
					// NOTE: If there are no sending tracks, setLocalDescription() will fail with
					// "Failed to create channels". If so, ignore it.
					if (_this4._stream.getTracks().length === 0) {
						logger.warn('removeLocalTrack() | ignoring expected error due no sending tracks: %s', error.toString());
	
						return;
					}
	
					throw error;
				}).then(function () {
					if (_this4._pc.signalingState === 'stable') return;
	
					var localSdpObj = _sdpTransform2.default.parse(_this4._pc.localDescription.sdp);
					var remoteSdp = _this4._remoteSdp.createAnswerSdp(localSdpObj);
					var answer = { type: 'answer', sdp: remoteSdp };
	
					logger.debug('removeProducer() | calling pc.setRemoteDescription() [answer:%o]', answer);
	
					return _this4._pc.setRemoteDescription(answer);
				});
			}
		}, {
			key: 'replaceProducerTrack',
			value: function replaceProducerTrack(producer, track) {
				var _this5 = this;
	
				logger.debug('replaceProducerTrack() [id:%s, kind:%s, trackId:%s]', producer.id, producer.kind, track.id);
	
				var oldTrack = producer.track;
	
				return _promise2.default.resolve().then(function () {
					// Get the associated RTCRtpSender.
					var rtpSender = _this5._pc.getSenders().find(function (s) {
						return s.track === oldTrack;
					});
	
					if (!rtpSender) throw new Error('local track not found');
	
					return rtpSender.replaceTrack(track);
				}).then(function () {
					// Remove the old track from the local stream.
					_this5._stream.removeTrack(oldTrack);
	
					// Add the new track to the local stream.
					_this5._stream.addTrack(track);
				});
			}
		}, {
			key: 'restartIce',
			value: function restartIce(remoteIceParameters) {
				var _this6 = this;
	
				logger.debug('restartIce()');
	
				// Provide the remote SDP handler with new remote ICE parameters.
				this._remoteSdp.updateTransportRemoteIceParameters(remoteIceParameters);
	
				return _promise2.default.resolve().then(function () {
					return _this6._pc.createOffer({ iceRestart: true });
				}).then(function (offer) {
					logger.debug('restartIce() | calling pc.setLocalDescription() [offer:%o]', offer);
	
					return _this6._pc.setLocalDescription(offer);
				}).then(function () {
					var localSdpObj = _sdpTransform2.default.parse(_this6._pc.localDescription.sdp);
					var remoteSdp = _this6._remoteSdp.createAnswerSdp(localSdpObj);
					var answer = { type: 'answer', sdp: remoteSdp };
	
					logger.debug('restartIce() | calling pc.setRemoteDescription() [answer:%o]', answer);
	
					return _this6._pc.setRemoteDescription(answer);
				});
			}
		}, {
			key: '_setupTransport',
			value: function _setupTransport() {
				var _this7 = this;
	
				logger.debug('_setupTransport()');
	
				return _promise2.default.resolve().then(function () {
					// Get our local DTLS parameters.
					var transportLocalParameters = {};
					var sdp = _this7._pc.localDescription.sdp;
					var sdpObj = _sdpTransform2.default.parse(sdp);
					var dtlsParameters = sdpCommonUtils.extractDtlsParameters(sdpObj);
	
					// Let's decide that we'll be DTLS server (because we can).
					dtlsParameters.role = 'server';
	
					transportLocalParameters.dtlsParameters = dtlsParameters;
	
					// Provide the remote SDP handler with transport local parameters.
					_this7._remoteSdp.setTransportLocalParameters(transportLocalParameters);
	
					// We need transport remote parameters.
					return _this7.safeEmitAsPromise('@needcreatetransport', transportLocalParameters);
				}).then(function (transportRemoteParameters) {
					// Provide the remote SDP handler with transport remote parameters.
					_this7._remoteSdp.setTransportRemoteParameters(transportRemoteParameters);
	
					_this7._transportReady = true;
				});
			}
		}]);
		return SendHandler;
	}(Handler);
	
	var RecvHandler = function (_Handler2) {
		(0, _inherits3.default)(RecvHandler, _Handler2);
	
		function RecvHandler(rtpParametersByKind, settings) {
			(0, _classCallCheck3.default)(this, RecvHandler);
	
			// Got transport remote parameters.
			// @type {Boolean}
			var _this8 = (0, _possibleConstructorReturn3.default)(this, (RecvHandler.__proto__ || (0, _getPrototypeOf2.default)(RecvHandler)).call(this, 'recv', rtpParametersByKind, settings));
	
			_this8._transportCreated = false;
	
			// Got transport local parameters.
			// @type {Boolean}
			_this8._transportUpdated = false;
	
			// Seen media kinds.
			// @type {Set<String>}
			_this8._kinds = new _set2.default();
	
			// Map of Consumers information indexed by consumer.id.
			// - kind {String}
			// - trackId {String}
			// - ssrc {Number}
			// - rtxSsrc {Number}
			// - cname {String}
			// @type {Map<Number, Object>}
			_this8._consumerInfos = new _map2.default();
			return _this8;
		}
	
		(0, _createClass3.default)(RecvHandler, [{
			key: 'addConsumer',
			value: function addConsumer(consumer) {
				var _this9 = this;
	
				logger.debug('addConsumer() [id:%s, kind:%s]', consumer.id, consumer.kind);
	
				if (this._consumerInfos.has(consumer.id)) return _promise2.default.reject(new Error('Consumer already added'));
	
				var encoding = consumer.rtpParameters.encodings[0];
				var cname = consumer.rtpParameters.rtcp.cname;
				var consumerInfo = {
					kind: consumer.kind,
					streamId: 'recv-stream-' + consumer.id,
					trackId: 'consumer-' + consumer.kind + '-' + consumer.id,
					ssrc: encoding.ssrc,
					cname: cname
				};
	
				if (encoding.rtx && encoding.rtx.ssrc) consumerInfo.rtxSsrc = encoding.rtx.ssrc;
	
				this._consumerInfos.set(consumer.id, consumerInfo);
				this._kinds.add(consumer.kind);
	
				return _promise2.default.resolve().then(function () {
					if (!_this9._transportCreated) return _this9._setupTransport();
				}).then(function () {
					var remoteSdp = _this9._remoteSdp.createOfferSdp((0, _from2.default)(_this9._kinds), (0, _from2.default)(_this9._consumerInfos.values()));
					var offer = { type: 'offer', sdp: remoteSdp };
	
					logger.debug('addConsumer() | calling pc.setRemoteDescription() [offer:%o]', offer);
	
					return _this9._pc.setRemoteDescription(offer);
				}).then(function () {
					return _this9._pc.createAnswer();
				}).then(function (answer) {
					logger.debug('addConsumer() | calling pc.setLocalDescription() [answer:%o]', answer);
	
					return _this9._pc.setLocalDescription(answer);
				}).then(function () {
					if (!_this9._transportUpdated) return _this9._updateTransport();
				}).then(function () {
					var newRtpReceiver = _this9._pc.getReceivers().find(function (rtpReceiver) {
						var track = rtpReceiver.track;
	
	
						if (!track) return false;
	
						return track.id === consumerInfo.trackId;
					});
	
					if (!newRtpReceiver) throw new Error('remote track not found');
	
					return newRtpReceiver.track;
				});
			}
		}, {
			key: 'removeConsumer',
			value: function removeConsumer(consumer) {
				var _this10 = this;
	
				logger.debug('removeConsumer() [id:%s, kind:%s]', consumer.id, consumer.kind);
	
				if (!this._consumerInfos.has(consumer.id)) return _promise2.default.reject(new Error('Consumer not found'));
	
				this._consumerInfos.delete(consumer.id);
	
				return _promise2.default.resolve().then(function () {
					var remoteSdp = _this10._remoteSdp.createOfferSdp((0, _from2.default)(_this10._kinds), (0, _from2.default)(_this10._consumerInfos.values()));
					var offer = { type: 'offer', sdp: remoteSdp };
	
					logger.debug('removeConsumer() | calling pc.setRemoteDescription() [offer:%o]', offer);
	
					return _this10._pc.setRemoteDescription(offer);
				}).then(function () {
					return _this10._pc.createAnswer();
				}).then(function (answer) {
					logger.debug('removeConsumer() | calling pc.setLocalDescription() [answer:%o]', answer);
	
					return _this10._pc.setLocalDescription(answer);
				});
			}
		}, {
			key: 'restartIce',
			value: function restartIce(remoteIceParameters) {
				var _this11 = this;
	
				logger.debug('restartIce()');
	
				// Provide the remote SDP handler with new remote ICE parameters.
				this._remoteSdp.updateTransportRemoteIceParameters(remoteIceParameters);
	
				return _promise2.default.resolve().then(function () {
					var remoteSdp = _this11._remoteSdp.createOfferSdp((0, _from2.default)(_this11._kinds), (0, _from2.default)(_this11._consumerInfos.values()));
					var offer = { type: 'offer', sdp: remoteSdp };
	
					logger.debug('restartIce() | calling pc.setRemoteDescription() [offer:%o]', offer);
	
					return _this11._pc.setRemoteDescription(offer);
				}).then(function () {
					return _this11._pc.createAnswer();
				}).then(function (answer) {
					logger.debug('restartIce() | calling pc.setLocalDescription() [answer:%o]', answer);
	
					return _this11._pc.setLocalDescription(answer);
				});
			}
		}, {
			key: '_setupTransport',
			value: function _setupTransport() {
				var _this12 = this;
	
				logger.debug('_setupTransport()');
	
				return _promise2.default.resolve().then(function () {
					// We need transport remote parameters.
					return _this12.safeEmitAsPromise('@needcreatetransport', null);
				}).then(function (transportRemoteParameters) {
					// Provide the remote SDP handler with transport remote parameters.
					_this12._remoteSdp.setTransportRemoteParameters(transportRemoteParameters);
	
					_this12._transportCreated = true;
				});
			}
		}, {
			key: '_updateTransport',
			value: function _updateTransport() {
				logger.debug('_updateTransport()');
	
				// Get our local DTLS parameters.
				// const transportLocalParameters = {};
				var sdp = this._pc.localDescription.sdp;
				var sdpObj = _sdpTransform2.default.parse(sdp);
				var dtlsParameters = sdpCommonUtils.extractDtlsParameters(sdpObj);
				var transportLocalParameters = { dtlsParameters: dtlsParameters };
	
				// We need to provide transport local parameters.
				this.safeEmit('@needupdatetransport', transportLocalParameters);
	
				this._transportUpdated = true;
			}
		}]);
		return RecvHandler;
	}(Handler);
	
	var Safari11 = function () {
		(0, _createClass3.default)(Safari11, null, [{
			key: 'getNativeRtpCapabilities',
			value: function getNativeRtpCapabilities() {
				logger.debug('getNativeRtpCapabilities()');
	
				var pc = new RTCPeerConnection({
					iceServers: [],
					iceTransportPolicy: 'all',
					bundlePolicy: 'max-bundle',
					rtcpMuxPolicy: 'require'
				});
	
				pc.addTransceiver('audio');
				pc.addTransceiver('video');
	
				return pc.createOffer().then(function (offer) {
					try {
						pc.close();
					} catch (error) {}
	
					var sdpObj = _sdpTransform2.default.parse(offer.sdp);
					var nativeRtpCapabilities = sdpCommonUtils.extractRtpCapabilities(sdpObj);
	
					return nativeRtpCapabilities;
				}).catch(function (error) {
					try {
						pc.close();
					} catch (error2) {}
	
					throw error;
				});
			}
		}, {
			key: 'tag',
			get: function get() {
				return 'Safari11';
			}
		}]);
	
		function Safari11(direction, extendedRtpCapabilities, settings) {
			(0, _classCallCheck3.default)(this, Safari11);
	
			logger.debug('constructor() [direction:%s, extendedRtpCapabilities:%o]', direction, extendedRtpCapabilities);
	
			var rtpParametersByKind = void 0;
	
			switch (direction) {
				case 'send':
					{
						rtpParametersByKind = {
							audio: ortc.getSendingRtpParameters('audio', extendedRtpCapabilities),
							video: ortc.getSendingRtpParameters('video', extendedRtpCapabilities)
						};
	
						return new SendHandler(rtpParametersByKind, settings);
					}
				case 'recv':
					{
						rtpParametersByKind = {
							audio: ortc.getReceivingFullRtpParameters('audio', extendedRtpCapabilities),
							video: ortc.getReceivingFullRtpParameters('video', extendedRtpCapabilities)
						};
	
						return new RecvHandler(rtpParametersByKind, settings);
					}
			}
		}
	
		return Safari11;
	}();
	
	exports.default = Safari11;
	
	},{"../EnhancedEventEmitter":12,"../Logger":13,"../ortc":33,"../utils":34,"./sdp/RemotePlanBSdp":27,"./sdp/commonUtils":29,"./sdp/planBUtils":30,"babel-runtime/core-js/array/from":35,"babel-runtime/core-js/map":39,"babel-runtime/core-js/object/get-prototype-of":43,"babel-runtime/core-js/promise":47,"babel-runtime/core-js/set":48,"babel-runtime/helpers/classCallCheck":51,"babel-runtime/helpers/createClass":52,"babel-runtime/helpers/inherits":54,"babel-runtime/helpers/possibleConstructorReturn":55,"sdp-transform":213}],26:[function(require,module,exports){
	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
		value: true
	});
	
	var _getIterator2 = require('babel-runtime/core-js/get-iterator');
	
	var _getIterator3 = _interopRequireDefault(_getIterator2);
	
	exports.getCapabilities = getCapabilities;
	exports.mangleRtpParameters = mangleRtpParameters;
	
	var _utils = require('../../utils');
	
	var utils = _interopRequireWildcard(_utils);
	
	function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	/**
	 * Normalize Edge's RTCRtpReceiver.getCapabilities() to produce a full
	 * compliant ORTC RTCRtpCapabilities.
	 *
	 * @return {RTCRtpCapabilities}
	 */
	function getCapabilities() {
		var nativeCaps = RTCRtpReceiver.getCapabilities();
		var caps = utils.clone(nativeCaps);
	
		var _iteratorNormalCompletion = true;
		var _didIteratorError = false;
		var _iteratorError = undefined;
	
		try {
			for (var _iterator = (0, _getIterator3.default)(caps.codecs), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
				var codec = _step.value;
	
				// Rename numChannels to channels.
				codec.channels = codec.numChannels;
				delete codec.numChannels;
	
				// Normalize channels.
				if (codec.kind !== 'audio') delete codec.channels;else if (!codec.channels) codec.channels = 1;
	
				// Add mimeType.
				codec.mimeType = codec.kind + '/' + codec.name;
	
				// NOTE: Edge sets some numeric parameters as String rather than Number. Fix them.
				if (codec.parameters) {
					var parameters = codec.parameters;
	
					if (parameters.apt) parameters.apt = Number(parameters.apt);
	
					if (parameters['packetization-mode']) parameters['packetization-mode'] = Number(parameters['packetization-mode']);
				}
	
				// Delete emty parameter String in rtcpFeedback.
				var _iteratorNormalCompletion2 = true;
				var _didIteratorError2 = false;
				var _iteratorError2 = undefined;
	
				try {
					for (var _iterator2 = (0, _getIterator3.default)(codec.rtcpFeedback || []), _step2; !(_iteratorNormalCompletion2 = (_step2 = _iterator2.next()).done); _iteratorNormalCompletion2 = true) {
						var feedback = _step2.value;
	
						if (!feedback.parameter) delete feedback.parameter;
					}
				} catch (err) {
					_didIteratorError2 = true;
					_iteratorError2 = err;
				} finally {
					try {
						if (!_iteratorNormalCompletion2 && _iterator2.return) {
							_iterator2.return();
						}
					} finally {
						if (_didIteratorError2) {
							throw _iteratorError2;
						}
					}
				}
			}
		} catch (err) {
			_didIteratorError = true;
			_iteratorError = err;
		} finally {
			try {
				if (!_iteratorNormalCompletion && _iterator.return) {
					_iterator.return();
				}
			} finally {
				if (_didIteratorError) {
					throw _iteratorError;
				}
			}
		}
	
		return caps;
	}
	
	/**
	 * Generate RTCRtpParameters as Edge like them.
	 *
	 * @param  {RTCRtpParameters} rtpParameters
	 * @return {RTCRtpParameters}
	 */
	/* global RTCRtpReceiver */
	
	function mangleRtpParameters(rtpParameters) {
		var params = utils.clone(rtpParameters);
	
		var _iteratorNormalCompletion3 = true;
		var _didIteratorError3 = false;
		var _iteratorError3 = undefined;
	
		try {
			for (var _iterator3 = (0, _getIterator3.default)(params.codecs), _step3; !(_iteratorNormalCompletion3 = (_step3 = _iterator3.next()).done); _iteratorNormalCompletion3 = true) {
				var codec = _step3.value;
	
				// Rename channels to numChannels.
				if (codec.channels) {
					codec.numChannels = codec.channels;
					delete codec.channels;
				}
	
				// Remove mimeType.
				delete codec.mimeType;
			}
		} catch (err) {
			_didIteratorError3 = true;
			_iteratorError3 = err;
		} finally {
			try {
				if (!_iteratorNormalCompletion3 && _iterator3.return) {
					_iterator3.return();
				}
			} finally {
				if (_didIteratorError3) {
					throw _iteratorError3;
				}
			}
		}
	
		return params;
	}
	
	},{"../../utils":34,"babel-runtime/core-js/get-iterator":36}],27:[function(require,module,exports){
	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
		value: true
	});
	
	var _keys = require('babel-runtime/core-js/object/keys');
	
	var _keys2 = _interopRequireDefault(_keys);
	
	var _getIterator2 = require('babel-runtime/core-js/get-iterator');
	
	var _getIterator3 = _interopRequireDefault(_getIterator2);
	
	var _getPrototypeOf = require('babel-runtime/core-js/object/get-prototype-of');
	
	var _getPrototypeOf2 = _interopRequireDefault(_getPrototypeOf);
	
	var _possibleConstructorReturn2 = require('babel-runtime/helpers/possibleConstructorReturn');
	
	var _possibleConstructorReturn3 = _interopRequireDefault(_possibleConstructorReturn2);
	
	var _inherits2 = require('babel-runtime/helpers/inherits');
	
	var _inherits3 = _interopRequireDefault(_inherits2);
	
	var _classCallCheck2 = require('babel-runtime/helpers/classCallCheck');
	
	var _classCallCheck3 = _interopRequireDefault(_classCallCheck2);
	
	var _createClass2 = require('babel-runtime/helpers/createClass');
	
	var _createClass3 = _interopRequireDefault(_createClass2);
	
	var _sdpTransform = require('sdp-transform');
	
	var _sdpTransform2 = _interopRequireDefault(_sdpTransform);
	
	var _Logger = require('../../Logger');
	
	var _Logger2 = _interopRequireDefault(_Logger);
	
	var _utils = require('../../utils');
	
	var utils = _interopRequireWildcard(_utils);
	
	function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	var logger = new _Logger2.default('RemotePlanBSdp');
	
	var RemoteSdp = function () {
		function RemoteSdp(rtpParametersByKind) {
			(0, _classCallCheck3.default)(this, RemoteSdp);
	
			// Generic sending RTP parameters for audio and video.
			// @type {Object}
			this._rtpParametersByKind = rtpParametersByKind;
	
			// Transport local parameters, including DTLS parameteres.
			// @type {Object}
			this._transportLocalParameters = null;
	
			// Transport remote parameters, including ICE parameters, ICE candidates
			// and DTLS parameteres.
			// @type {Object}
			this._transportRemoteParameters = null;
	
			// SDP global fields.
			// @type {Object}
			this._sdpGlobalFields = {
				id: utils.randomNumber(),
				version: 0
			};
		}
	
		(0, _createClass3.default)(RemoteSdp, [{
			key: 'setTransportLocalParameters',
			value: function setTransportLocalParameters(transportLocalParameters) {
				logger.debug('setTransportLocalParameters() [transportLocalParameters:%o]', transportLocalParameters);
	
				this._transportLocalParameters = transportLocalParameters;
			}
		}, {
			key: 'setTransportRemoteParameters',
			value: function setTransportRemoteParameters(transportRemoteParameters) {
				logger.debug('setTransportRemoteParameters() [transportRemoteParameters:%o]', transportRemoteParameters);
	
				this._transportRemoteParameters = transportRemoteParameters;
			}
		}, {
			key: 'updateTransportRemoteIceParameters',
			value: function updateTransportRemoteIceParameters(remoteIceParameters) {
				logger.debug('updateTransportRemoteIceParameters() [remoteIceParameters:%o]', remoteIceParameters);
	
				this._transportRemoteParameters.iceParameters = remoteIceParameters;
			}
		}]);
		return RemoteSdp;
	}();
	
	var SendRemoteSdp = function (_RemoteSdp) {
		(0, _inherits3.default)(SendRemoteSdp, _RemoteSdp);
	
		function SendRemoteSdp(rtpParametersByKind) {
			(0, _classCallCheck3.default)(this, SendRemoteSdp);
			return (0, _possibleConstructorReturn3.default)(this, (SendRemoteSdp.__proto__ || (0, _getPrototypeOf2.default)(SendRemoteSdp)).call(this, rtpParametersByKind));
		}
	
		(0, _createClass3.default)(SendRemoteSdp, [{
			key: 'createAnswerSdp',
			value: function createAnswerSdp(localSdpObj) {
				logger.debug('createAnswerSdp()');
	
				if (!this._transportLocalParameters) throw new Error('no transport local parameters');else if (!this._transportRemoteParameters) throw new Error('no transport remote parameters');
	
				var remoteIceParameters = this._transportRemoteParameters.iceParameters;
				var remoteIceCandidates = this._transportRemoteParameters.iceCandidates;
				var remoteDtlsParameters = this._transportRemoteParameters.dtlsParameters;
				var sdpObj = {};
				var mids = (localSdpObj.media || []).map(function (m) {
					return m.mid;
				});
	
				// Increase our SDP version.
				this._sdpGlobalFields.version++;
	
				sdpObj.version = 0;
				sdpObj.origin = {
					address: '0.0.0.0',
					ipVer: 4,
					netType: 'IN',
					sessionId: this._sdpGlobalFields.id,
					sessionVersion: this._sdpGlobalFields.version,
					username: 'mediasoup-client'
				};
				sdpObj.name = '-';
				sdpObj.timing = { start: 0, stop: 0 };
				sdpObj.icelite = remoteIceParameters.iceLite ? 'ice-lite' : null;
				sdpObj.msidSemantic = {
					semantic: 'WMS',
					token: '*'
				};
				sdpObj.groups = [{
					type: 'BUNDLE',
					mids: mids.join(' ')
				}];
				sdpObj.media = [];
	
				// NOTE: We take the latest fingerprint.
				var numFingerprints = remoteDtlsParameters.fingerprints.length;
	
				sdpObj.fingerprint = {
					type: remoteDtlsParameters.fingerprints[numFingerprints - 1].algorithm,
					hash: remoteDtlsParameters.fingerprints[numFingerprints - 1].value
				};
	
				var _iteratorNormalCompletion = true;
				var _didIteratorError = false;
				var _iteratorError = undefined;
	
				try {
					for (var _iterator = (0, _getIterator3.default)(localSdpObj.media || []), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
						var localMediaObj = _step.value;
	
						var kind = localMediaObj.type;
						var codecs = this._rtpParametersByKind[kind].codecs;
						var headerExtensions = this._rtpParametersByKind[kind].headerExtensions;
						var remoteMediaObj = {};
	
						remoteMediaObj.type = localMediaObj.type;
						remoteMediaObj.port = 7;
						remoteMediaObj.protocol = 'RTP/SAVPF';
						remoteMediaObj.connection = { ip: '127.0.0.1', version: 4 };
						remoteMediaObj.mid = localMediaObj.mid;
	
						remoteMediaObj.iceUfrag = remoteIceParameters.usernameFragment;
						remoteMediaObj.icePwd = remoteIceParameters.password;
						remoteMediaObj.candidates = [];
	
						var _iteratorNormalCompletion2 = true;
						var _didIteratorError2 = false;
						var _iteratorError2 = undefined;
	
						try {
							for (var _iterator2 = (0, _getIterator3.default)(remoteIceCandidates), _step2; !(_iteratorNormalCompletion2 = (_step2 = _iterator2.next()).done); _iteratorNormalCompletion2 = true) {
								var candidate = _step2.value;
	
								var candidateObj = {};
	
								// mediasoup does not support non rtcp-mux so candidates component is
								// always RTP (1).
								candidateObj.component = 1;
								candidateObj.foundation = candidate.foundation;
								candidateObj.ip = candidate.ip;
								candidateObj.port = candidate.port;
								candidateObj.priority = candidate.priority;
								candidateObj.transport = candidate.protocol;
								candidateObj.type = candidate.type;
								if (candidate.tcpType) candidateObj.tcptype = candidate.tcpType;
	
								remoteMediaObj.candidates.push(candidateObj);
							}
						} catch (err) {
							_didIteratorError2 = true;
							_iteratorError2 = err;
						} finally {
							try {
								if (!_iteratorNormalCompletion2 && _iterator2.return) {
									_iterator2.return();
								}
							} finally {
								if (_didIteratorError2) {
									throw _iteratorError2;
								}
							}
						}
	
						remoteMediaObj.endOfCandidates = 'end-of-candidates';
	
						// Announce support for ICE renomination.
						// https://tools.ietf.org/html/draft-thatcher-ice-renomination
						remoteMediaObj.iceOptions = 'renomination';
	
						switch (remoteDtlsParameters.role) {
							case 'client':
								remoteMediaObj.setup = 'active';
								break;
							case 'server':
								remoteMediaObj.setup = 'passive';
								break;
						}
	
						switch (localMediaObj.direction) {
							case 'sendrecv':
							case 'sendonly':
								remoteMediaObj.direction = 'recvonly';
								break;
							case 'recvonly':
							case 'inactive':
								remoteMediaObj.direction = 'inactive';
								break;
						}
	
						// If video, be ready for simulcast.
						if (kind === 'video') remoteMediaObj.xGoogleFlag = 'conference';
	
						remoteMediaObj.rtp = [];
						remoteMediaObj.rtcpFb = [];
						remoteMediaObj.fmtp = [];
	
						var _iteratorNormalCompletion3 = true;
						var _didIteratorError3 = false;
						var _iteratorError3 = undefined;
	
						try {
							for (var _iterator3 = (0, _getIterator3.default)(codecs), _step3; !(_iteratorNormalCompletion3 = (_step3 = _iterator3.next()).done); _iteratorNormalCompletion3 = true) {
								var codec = _step3.value;
	
								var rtp = {
									payload: codec.payloadType,
									codec: codec.name,
									rate: codec.clockRate
								};
	
								if (codec.channels > 1) rtp.encoding = codec.channels;
	
								remoteMediaObj.rtp.push(rtp);
	
								if (codec.parameters) {
									var paramFmtp = {
										payload: codec.payloadType,
										config: ''
									};
	
									var _iteratorNormalCompletion5 = true;
									var _didIteratorError5 = false;
									var _iteratorError5 = undefined;
	
									try {
										for (var _iterator5 = (0, _getIterator3.default)((0, _keys2.default)(codec.parameters)), _step5; !(_iteratorNormalCompletion5 = (_step5 = _iterator5.next()).done); _iteratorNormalCompletion5 = true) {
											var key = _step5.value;
	
											if (paramFmtp.config) paramFmtp.config += ';';
	
											paramFmtp.config += key + '=' + codec.parameters[key];
										}
									} catch (err) {
										_didIteratorError5 = true;
										_iteratorError5 = err;
									} finally {
										try {
											if (!_iteratorNormalCompletion5 && _iterator5.return) {
												_iterator5.return();
											}
										} finally {
											if (_didIteratorError5) {
												throw _iteratorError5;
											}
										}
									}
	
									if (paramFmtp.config) remoteMediaObj.fmtp.push(paramFmtp);
								}
	
								if (codec.rtcpFeedback) {
									var _iteratorNormalCompletion6 = true;
									var _didIteratorError6 = false;
									var _iteratorError6 = undefined;
	
									try {
										for (var _iterator6 = (0, _getIterator3.default)(codec.rtcpFeedback), _step6; !(_iteratorNormalCompletion6 = (_step6 = _iterator6.next()).done); _iteratorNormalCompletion6 = true) {
											var fb = _step6.value;
	
											remoteMediaObj.rtcpFb.push({
												payload: codec.payloadType,
												type: fb.type,
												subtype: fb.parameter || ''
											});
										}
									} catch (err) {
										_didIteratorError6 = true;
										_iteratorError6 = err;
									} finally {
										try {
											if (!_iteratorNormalCompletion6 && _iterator6.return) {
												_iterator6.return();
											}
										} finally {
											if (_didIteratorError6) {
												throw _iteratorError6;
											}
										}
									}
								}
							}
						} catch (err) {
							_didIteratorError3 = true;
							_iteratorError3 = err;
						} finally {
							try {
								if (!_iteratorNormalCompletion3 && _iterator3.return) {
									_iterator3.return();
								}
							} finally {
								if (_didIteratorError3) {
									throw _iteratorError3;
								}
							}
						}
	
						remoteMediaObj.payloads = codecs.map(function (codec) {
							return codec.payloadType;
						}).join(' ');
	
						remoteMediaObj.ext = [];
	
						var _iteratorNormalCompletion4 = true;
						var _didIteratorError4 = false;
						var _iteratorError4 = undefined;
	
						try {
							var _loop = function _loop() {
								var ext = _step4.value;
	
								// Don't add a header extension if not present in the offer.
								var matchedLocalExt = (localMediaObj.ext || []).find(function (localExt) {
									return localExt.uri === ext.uri;
								});
	
								if (!matchedLocalExt) return 'continue';
	
								remoteMediaObj.ext.push({
									uri: ext.uri,
									value: ext.id
								});
							};
	
							for (var _iterator4 = (0, _getIterator3.default)(headerExtensions), _step4; !(_iteratorNormalCompletion4 = (_step4 = _iterator4.next()).done); _iteratorNormalCompletion4 = true) {
								var _ret = _loop();
	
								if (_ret === 'continue') continue;
							}
						} catch (err) {
							_didIteratorError4 = true;
							_iteratorError4 = err;
						} finally {
							try {
								if (!_iteratorNormalCompletion4 && _iterator4.return) {
									_iterator4.return();
								}
							} finally {
								if (_didIteratorError4) {
									throw _iteratorError4;
								}
							}
						}
	
						remoteMediaObj.rtcpMux = 'rtcp-mux';
						remoteMediaObj.rtcpRsize = 'rtcp-rsize';
	
						// Push it.
						sdpObj.media.push(remoteMediaObj);
					}
				} catch (err) {
					_didIteratorError = true;
					_iteratorError = err;
				} finally {
					try {
						if (!_iteratorNormalCompletion && _iterator.return) {
							_iterator.return();
						}
					} finally {
						if (_didIteratorError) {
							throw _iteratorError;
						}
					}
				}
	
				var sdp = _sdpTransform2.default.write(sdpObj);
	
				return sdp;
			}
		}]);
		return SendRemoteSdp;
	}(RemoteSdp);
	
	var RecvRemoteSdp = function (_RemoteSdp2) {
		(0, _inherits3.default)(RecvRemoteSdp, _RemoteSdp2);
	
		function RecvRemoteSdp(rtpParametersByKind) {
			(0, _classCallCheck3.default)(this, RecvRemoteSdp);
			return (0, _possibleConstructorReturn3.default)(this, (RecvRemoteSdp.__proto__ || (0, _getPrototypeOf2.default)(RecvRemoteSdp)).call(this, rtpParametersByKind));
		}
	
		/**
		* @param {Array<String>} kinds - Media kinds.
		* @param {Array<Object>} consumerInfos - Consumer informations.
		* @return {String}
		*/
	
	
		(0, _createClass3.default)(RecvRemoteSdp, [{
			key: 'createOfferSdp',
			value: function createOfferSdp(kinds, consumerInfos) {
				var _this3 = this;
	
				logger.debug('createOfferSdp()');
	
				if (!this._transportRemoteParameters) throw new Error('no transport remote parameters');
	
				var remoteIceParameters = this._transportRemoteParameters.iceParameters;
				var remoteIceCandidates = this._transportRemoteParameters.iceCandidates;
				var remoteDtlsParameters = this._transportRemoteParameters.dtlsParameters;
				var sdpObj = {};
				var mids = kinds;
	
				// Increase our SDP version.
				this._sdpGlobalFields.version++;
	
				sdpObj.version = 0;
				sdpObj.origin = {
					address: '0.0.0.0',
					ipVer: 4,
					netType: 'IN',
					sessionId: this._sdpGlobalFields.id,
					sessionVersion: this._sdpGlobalFields.version,
					username: 'mediasoup-client'
				};
				sdpObj.name = '-';
				sdpObj.timing = { start: 0, stop: 0 };
				sdpObj.icelite = remoteIceParameters.iceLite ? 'ice-lite' : null;
				sdpObj.msidSemantic = {
					semantic: 'WMS',
					token: '*'
				};
				sdpObj.groups = [{
					type: 'BUNDLE',
					mids: mids.join(' ')
				}];
				sdpObj.media = [];
	
				// NOTE: We take the latest fingerprint.
				var numFingerprints = remoteDtlsParameters.fingerprints.length;
	
				sdpObj.fingerprint = {
					type: remoteDtlsParameters.fingerprints[numFingerprints - 1].algorithm,
					hash: remoteDtlsParameters.fingerprints[numFingerprints - 1].value
				};
	
				var _iteratorNormalCompletion7 = true;
				var _didIteratorError7 = false;
				var _iteratorError7 = undefined;
	
				try {
					var _loop2 = function _loop2() {
						var kind = _step7.value;
	
						var codecs = _this3._rtpParametersByKind[kind].codecs;
						var headerExtensions = _this3._rtpParametersByKind[kind].headerExtensions;
						var remoteMediaObj = {};
	
						remoteMediaObj.type = kind;
						remoteMediaObj.port = 7;
						remoteMediaObj.protocol = 'RTP/SAVPF';
						remoteMediaObj.connection = { ip: '127.0.0.1', version: 4 };
						remoteMediaObj.mid = kind;
	
						remoteMediaObj.iceUfrag = remoteIceParameters.usernameFragment;
						remoteMediaObj.icePwd = remoteIceParameters.password;
						remoteMediaObj.candidates = [];
	
						var _iteratorNormalCompletion8 = true;
						var _didIteratorError8 = false;
						var _iteratorError8 = undefined;
	
						try {
							for (var _iterator8 = (0, _getIterator3.default)(remoteIceCandidates), _step8; !(_iteratorNormalCompletion8 = (_step8 = _iterator8.next()).done); _iteratorNormalCompletion8 = true) {
								var candidate = _step8.value;
	
								var candidateObj = {};
	
								// mediasoup does not support non rtcp-mux so candidates component is
								// always RTP (1).
								candidateObj.component = 1;
								candidateObj.foundation = candidate.foundation;
								candidateObj.ip = candidate.ip;
								candidateObj.port = candidate.port;
								candidateObj.priority = candidate.priority;
								candidateObj.transport = candidate.protocol;
								candidateObj.type = candidate.type;
								if (candidate.tcpType) candidateObj.tcptype = candidate.tcpType;
	
								remoteMediaObj.candidates.push(candidateObj);
							}
						} catch (err) {
							_didIteratorError8 = true;
							_iteratorError8 = err;
						} finally {
							try {
								if (!_iteratorNormalCompletion8 && _iterator8.return) {
									_iterator8.return();
								}
							} finally {
								if (_didIteratorError8) {
									throw _iteratorError8;
								}
							}
						}
	
						remoteMediaObj.endOfCandidates = 'end-of-candidates';
	
						// Announce support for ICE renomination.
						// https://tools.ietf.org/html/draft-thatcher-ice-renomination
						remoteMediaObj.iceOptions = 'renomination';
	
						remoteMediaObj.setup = 'actpass';
	
						if (consumerInfos.some(function (info) {
							return info.kind === kind;
						})) remoteMediaObj.direction = 'sendonly';else remoteMediaObj.direction = 'inactive';
	
						remoteMediaObj.rtp = [];
						remoteMediaObj.rtcpFb = [];
						remoteMediaObj.fmtp = [];
	
						var _iteratorNormalCompletion9 = true;
						var _didIteratorError9 = false;
						var _iteratorError9 = undefined;
	
						try {
							for (var _iterator9 = (0, _getIterator3.default)(codecs), _step9; !(_iteratorNormalCompletion9 = (_step9 = _iterator9.next()).done); _iteratorNormalCompletion9 = true) {
								var codec = _step9.value;
	
								var rtp = {
									payload: codec.payloadType,
									codec: codec.name,
									rate: codec.clockRate
								};
	
								if (codec.channels > 1) rtp.encoding = codec.channels;
	
								remoteMediaObj.rtp.push(rtp);
	
								if (codec.parameters) {
									var paramFmtp = {
										payload: codec.payloadType,
										config: ''
									};
	
									var _iteratorNormalCompletion12 = true;
									var _didIteratorError12 = false;
									var _iteratorError12 = undefined;
	
									try {
										for (var _iterator12 = (0, _getIterator3.default)((0, _keys2.default)(codec.parameters)), _step12; !(_iteratorNormalCompletion12 = (_step12 = _iterator12.next()).done); _iteratorNormalCompletion12 = true) {
											var key = _step12.value;
	
											if (paramFmtp.config) paramFmtp.config += ';';
	
											paramFmtp.config += key + '=' + codec.parameters[key];
										}
									} catch (err) {
										_didIteratorError12 = true;
										_iteratorError12 = err;
									} finally {
										try {
											if (!_iteratorNormalCompletion12 && _iterator12.return) {
												_iterator12.return();
											}
										} finally {
											if (_didIteratorError12) {
												throw _iteratorError12;
											}
										}
									}
	
									if (paramFmtp.config) remoteMediaObj.fmtp.push(paramFmtp);
								}
	
								if (codec.rtcpFeedback) {
									var _iteratorNormalCompletion13 = true;
									var _didIteratorError13 = false;
									var _iteratorError13 = undefined;
	
									try {
										for (var _iterator13 = (0, _getIterator3.default)(codec.rtcpFeedback), _step13; !(_iteratorNormalCompletion13 = (_step13 = _iterator13.next()).done); _iteratorNormalCompletion13 = true) {
											var fb = _step13.value;
	
											remoteMediaObj.rtcpFb.push({
												payload: codec.payloadType,
												type: fb.type,
												subtype: fb.parameter || ''
											});
										}
									} catch (err) {
										_didIteratorError13 = true;
										_iteratorError13 = err;
									} finally {
										try {
											if (!_iteratorNormalCompletion13 && _iterator13.return) {
												_iterator13.return();
											}
										} finally {
											if (_didIteratorError13) {
												throw _iteratorError13;
											}
										}
									}
								}
							}
						} catch (err) {
							_didIteratorError9 = true;
							_iteratorError9 = err;
						} finally {
							try {
								if (!_iteratorNormalCompletion9 && _iterator9.return) {
									_iterator9.return();
								}
							} finally {
								if (_didIteratorError9) {
									throw _iteratorError9;
								}
							}
						}
	
						remoteMediaObj.payloads = codecs.map(function (codec) {
							return codec.payloadType;
						}).join(' ');
	
						remoteMediaObj.ext = [];
	
						var _iteratorNormalCompletion10 = true;
						var _didIteratorError10 = false;
						var _iteratorError10 = undefined;
	
						try {
							for (var _iterator10 = (0, _getIterator3.default)(headerExtensions), _step10; !(_iteratorNormalCompletion10 = (_step10 = _iterator10.next()).done); _iteratorNormalCompletion10 = true) {
								var _ext = _step10.value;
	
								remoteMediaObj.ext.push({
									uri: _ext.uri,
									value: _ext.id
								});
							}
						} catch (err) {
							_didIteratorError10 = true;
							_iteratorError10 = err;
						} finally {
							try {
								if (!_iteratorNormalCompletion10 && _iterator10.return) {
									_iterator10.return();
								}
							} finally {
								if (_didIteratorError10) {
									throw _iteratorError10;
								}
							}
						}
	
						remoteMediaObj.rtcpMux = 'rtcp-mux';
						remoteMediaObj.rtcpRsize = 'rtcp-rsize';
	
						remoteMediaObj.ssrcs = [];
						remoteMediaObj.ssrcGroups = [];
	
						var _iteratorNormalCompletion11 = true;
						var _didIteratorError11 = false;
						var _iteratorError11 = undefined;
	
						try {
							for (var _iterator11 = (0, _getIterator3.default)(consumerInfos), _step11; !(_iteratorNormalCompletion11 = (_step11 = _iterator11.next()).done); _iteratorNormalCompletion11 = true) {
								var info = _step11.value;
	
								if (info.kind !== kind) continue;
	
								remoteMediaObj.ssrcs.push({
									id: info.ssrc,
									attribute: 'msid',
									value: info.streamId + ' ' + info.trackId
								});
	
								remoteMediaObj.ssrcs.push({
									id: info.ssrc,
									attribute: 'mslabel',
									value: info.streamId
								});
	
								remoteMediaObj.ssrcs.push({
									id: info.ssrc,
									attribute: 'label',
									value: info.trackId
								});
	
								remoteMediaObj.ssrcs.push({
									id: info.ssrc,
									attribute: 'cname',
									value: info.cname
								});
	
								if (info.rtxSsrc) {
									remoteMediaObj.ssrcs.push({
										id: info.rtxSsrc,
										attribute: 'msid',
										value: info.streamId + ' ' + info.trackId
									});
	
									remoteMediaObj.ssrcs.push({
										id: info.rtxSsrc,
										attribute: 'mslabel',
										value: info.streamId
									});
	
									remoteMediaObj.ssrcs.push({
										id: info.rtxSsrc,
										attribute: 'label',
										value: info.trackId
									});
	
									remoteMediaObj.ssrcs.push({
										id: info.rtxSsrc,
										attribute: 'cname',
										value: info.cname
									});
	
									// Associate original and retransmission SSRC.
									remoteMediaObj.ssrcGroups.push({
										semantics: 'FID',
										ssrcs: info.ssrc + ' ' + info.rtxSsrc
									});
								}
							}
	
							// Push it.
						} catch (err) {
							_didIteratorError11 = true;
							_iteratorError11 = err;
						} finally {
							try {
								if (!_iteratorNormalCompletion11 && _iterator11.return) {
									_iterator11.return();
								}
							} finally {
								if (_didIteratorError11) {
									throw _iteratorError11;
								}
							}
						}
	
						sdpObj.media.push(remoteMediaObj);
					};
	
					for (var _iterator7 = (0, _getIterator3.default)(kinds), _step7; !(_iteratorNormalCompletion7 = (_step7 = _iterator7.next()).done); _iteratorNormalCompletion7 = true) {
						_loop2();
					}
				} catch (err) {
					_didIteratorError7 = true;
					_iteratorError7 = err;
				} finally {
					try {
						if (!_iteratorNormalCompletion7 && _iterator7.return) {
							_iterator7.return();
						}
					} finally {
						if (_didIteratorError7) {
							throw _iteratorError7;
						}
					}
				}
	
				var sdp = _sdpTransform2.default.write(sdpObj);
	
				return sdp;
			}
		}]);
		return RecvRemoteSdp;
	}(RemoteSdp);
	
	var RemotePlanBSdp = function RemotePlanBSdp(direction, rtpParametersByKind) {
		(0, _classCallCheck3.default)(this, RemotePlanBSdp);
	
		logger.debug('constructor() [direction:%s, rtpParametersByKind:%o]', direction, rtpParametersByKind);
	
		switch (direction) {
			case 'send':
				return new SendRemoteSdp(rtpParametersByKind);
			case 'recv':
				return new RecvRemoteSdp(rtpParametersByKind);
		}
	};
	
	exports.default = RemotePlanBSdp;
	
	},{"../../Logger":13,"../../utils":34,"babel-runtime/core-js/get-iterator":36,"babel-runtime/core-js/object/get-prototype-of":43,"babel-runtime/core-js/object/keys":44,"babel-runtime/helpers/classCallCheck":51,"babel-runtime/helpers/createClass":52,"babel-runtime/helpers/inherits":54,"babel-runtime/helpers/possibleConstructorReturn":55,"sdp-transform":213}],28:[function(require,module,exports){
	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
		value: true
	});
	
	var _keys = require('babel-runtime/core-js/object/keys');
	
	var _keys2 = _interopRequireDefault(_keys);
	
	var _getIterator2 = require('babel-runtime/core-js/get-iterator');
	
	var _getIterator3 = _interopRequireDefault(_getIterator2);
	
	var _getPrototypeOf = require('babel-runtime/core-js/object/get-prototype-of');
	
	var _getPrototypeOf2 = _interopRequireDefault(_getPrototypeOf);
	
	var _possibleConstructorReturn2 = require('babel-runtime/helpers/possibleConstructorReturn');
	
	var _possibleConstructorReturn3 = _interopRequireDefault(_possibleConstructorReturn2);
	
	var _inherits2 = require('babel-runtime/helpers/inherits');
	
	var _inherits3 = _interopRequireDefault(_inherits2);
	
	var _classCallCheck2 = require('babel-runtime/helpers/classCallCheck');
	
	var _classCallCheck3 = _interopRequireDefault(_classCallCheck2);
	
	var _createClass2 = require('babel-runtime/helpers/createClass');
	
	var _createClass3 = _interopRequireDefault(_createClass2);
	
	var _sdpTransform = require('sdp-transform');
	
	var _sdpTransform2 = _interopRequireDefault(_sdpTransform);
	
	var _Logger = require('../../Logger');
	
	var _Logger2 = _interopRequireDefault(_Logger);
	
	var _utils = require('../../utils');
	
	var utils = _interopRequireWildcard(_utils);
	
	function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	var logger = new _Logger2.default('RemoteUnifiedPlanSdp');
	
	var RemoteSdp = function () {
		function RemoteSdp(rtpParametersByKind) {
			(0, _classCallCheck3.default)(this, RemoteSdp);
	
			// Generic sending RTP parameters for audio and video.
			// @type {Object}
			this._rtpParametersByKind = rtpParametersByKind;
	
			// Transport local parameters, including DTLS parameteres.
			// @type {Object}
			this._transportLocalParameters = null;
	
			// Transport remote parameters, including ICE parameters, ICE candidates
			// and DTLS parameteres.
			// @type {Object}
			this._transportRemoteParameters = null;
	
			// SDP global fields.
			// @type {Object}
			this._sdpGlobalFields = {
				id: utils.randomNumber(),
				version: 0
			};
		}
	
		(0, _createClass3.default)(RemoteSdp, [{
			key: 'setTransportLocalParameters',
			value: function setTransportLocalParameters(transportLocalParameters) {
				logger.debug('setTransportLocalParameters() [transportLocalParameters:%o]', transportLocalParameters);
	
				this._transportLocalParameters = transportLocalParameters;
			}
		}, {
			key: 'setTransportRemoteParameters',
			value: function setTransportRemoteParameters(transportRemoteParameters) {
				logger.debug('setTransportRemoteParameters() [transportRemoteParameters:%o]', transportRemoteParameters);
	
				this._transportRemoteParameters = transportRemoteParameters;
			}
		}, {
			key: 'updateTransportRemoteIceParameters',
			value: function updateTransportRemoteIceParameters(remoteIceParameters) {
				logger.debug('updateTransportRemoteIceParameters() [remoteIceParameters:%o]', remoteIceParameters);
	
				this._transportRemoteParameters.iceParameters = remoteIceParameters;
			}
		}]);
		return RemoteSdp;
	}();
	
	var SendRemoteSdp = function (_RemoteSdp) {
		(0, _inherits3.default)(SendRemoteSdp, _RemoteSdp);
	
		function SendRemoteSdp(rtpParametersByKind) {
			(0, _classCallCheck3.default)(this, SendRemoteSdp);
			return (0, _possibleConstructorReturn3.default)(this, (SendRemoteSdp.__proto__ || (0, _getPrototypeOf2.default)(SendRemoteSdp)).call(this, rtpParametersByKind));
		}
	
		(0, _createClass3.default)(SendRemoteSdp, [{
			key: 'createAnswerSdp',
			value: function createAnswerSdp(localSdpObj) {
				logger.debug('createAnswerSdp()');
	
				if (!this._transportLocalParameters) throw new Error('no transport local parameters');else if (!this._transportRemoteParameters) throw new Error('no transport remote parameters');
	
				var remoteIceParameters = this._transportRemoteParameters.iceParameters;
				var remoteIceCandidates = this._transportRemoteParameters.iceCandidates;
				var remoteDtlsParameters = this._transportRemoteParameters.dtlsParameters;
				var sdpObj = {};
				var mids = (localSdpObj.media || []).filter(function (m) {
					return m.mid;
				}).map(function (m) {
					return m.mid;
				});
	
				// Increase our SDP version.
				this._sdpGlobalFields.version++;
	
				sdpObj.version = 0;
				sdpObj.origin = {
					address: '0.0.0.0',
					ipVer: 4,
					netType: 'IN',
					sessionId: this._sdpGlobalFields.id,
					sessionVersion: this._sdpGlobalFields.version,
					username: 'mediasoup-client'
				};
				sdpObj.name = '-';
				sdpObj.timing = { start: 0, stop: 0 };
				sdpObj.icelite = remoteIceParameters.iceLite ? 'ice-lite' : null;
				sdpObj.msidSemantic = {
					semantic: 'WMS',
					token: '*'
				};
	
				if (mids.length > 0) {
					sdpObj.groups = [{
						type: 'BUNDLE',
						mids: mids.join(' ')
					}];
				}
	
				sdpObj.media = [];
	
				// NOTE: We take the latest fingerprint.
				var numFingerprints = remoteDtlsParameters.fingerprints.length;
	
				sdpObj.fingerprint = {
					type: remoteDtlsParameters.fingerprints[numFingerprints - 1].algorithm,
					hash: remoteDtlsParameters.fingerprints[numFingerprints - 1].value
				};
	
				var _iteratorNormalCompletion = true;
				var _didIteratorError = false;
				var _iteratorError = undefined;
	
				try {
					for (var _iterator = (0, _getIterator3.default)(localSdpObj.media || []), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
						var localMediaObj = _step.value;
	
						var closed = localMediaObj.direction === 'inactive';
						var kind = localMediaObj.type;
						var codecs = this._rtpParametersByKind[kind].codecs;
						var headerExtensions = this._rtpParametersByKind[kind].headerExtensions;
						var remoteMediaObj = {};
	
						remoteMediaObj.type = localMediaObj.type;
						remoteMediaObj.port = 7;
						remoteMediaObj.protocol = 'RTP/SAVPF';
						remoteMediaObj.connection = { ip: '127.0.0.1', version: 4 };
						remoteMediaObj.mid = localMediaObj.mid;
	
						remoteMediaObj.iceUfrag = remoteIceParameters.usernameFragment;
						remoteMediaObj.icePwd = remoteIceParameters.password;
						remoteMediaObj.candidates = [];
	
						var _iteratorNormalCompletion2 = true;
						var _didIteratorError2 = false;
						var _iteratorError2 = undefined;
	
						try {
							for (var _iterator2 = (0, _getIterator3.default)(remoteIceCandidates), _step2; !(_iteratorNormalCompletion2 = (_step2 = _iterator2.next()).done); _iteratorNormalCompletion2 = true) {
								var candidate = _step2.value;
	
								var candidateObj = {};
	
								// mediasoup does not support non rtcp-mux so candidates component is
								// always RTP (1).
								candidateObj.component = 1;
								candidateObj.foundation = candidate.foundation;
								candidateObj.ip = candidate.ip;
								candidateObj.port = candidate.port;
								candidateObj.priority = candidate.priority;
								candidateObj.transport = candidate.protocol;
								candidateObj.type = candidate.type;
								if (candidate.tcpType) candidateObj.tcptype = candidate.tcpType;
	
								remoteMediaObj.candidates.push(candidateObj);
							}
						} catch (err) {
							_didIteratorError2 = true;
							_iteratorError2 = err;
						} finally {
							try {
								if (!_iteratorNormalCompletion2 && _iterator2.return) {
									_iterator2.return();
								}
							} finally {
								if (_didIteratorError2) {
									throw _iteratorError2;
								}
							}
						}
	
						remoteMediaObj.endOfCandidates = 'end-of-candidates';
	
						// Announce support for ICE renomination.
						// https://tools.ietf.org/html/draft-thatcher-ice-renomination
						remoteMediaObj.iceOptions = 'renomination';
	
						switch (remoteDtlsParameters.role) {
							case 'client':
								remoteMediaObj.setup = 'active';
								break;
							case 'server':
								remoteMediaObj.setup = 'passive';
								break;
						}
	
						switch (localMediaObj.direction) {
							case 'sendrecv':
							case 'sendonly':
								remoteMediaObj.direction = 'recvonly';
								break;
							case 'recvonly':
							case 'inactive':
								remoteMediaObj.direction = 'inactive';
								break;
						}
	
						remoteMediaObj.rtp = [];
						remoteMediaObj.rtcpFb = [];
						remoteMediaObj.fmtp = [];
	
						var _iteratorNormalCompletion3 = true;
						var _didIteratorError3 = false;
						var _iteratorError3 = undefined;
	
						try {
							for (var _iterator3 = (0, _getIterator3.default)(codecs), _step3; !(_iteratorNormalCompletion3 = (_step3 = _iterator3.next()).done); _iteratorNormalCompletion3 = true) {
								var codec = _step3.value;
	
								var rtp = {
									payload: codec.payloadType,
									codec: codec.name,
									rate: codec.clockRate
								};
	
								if (codec.channels > 1) rtp.encoding = codec.channels;
	
								remoteMediaObj.rtp.push(rtp);
	
								if (codec.parameters) {
									var paramFmtp = {
										payload: codec.payloadType,
										config: ''
									};
	
									var _iteratorNormalCompletion6 = true;
									var _didIteratorError6 = false;
									var _iteratorError6 = undefined;
	
									try {
										for (var _iterator6 = (0, _getIterator3.default)((0, _keys2.default)(codec.parameters)), _step6; !(_iteratorNormalCompletion6 = (_step6 = _iterator6.next()).done); _iteratorNormalCompletion6 = true) {
											var key = _step6.value;
	
											if (paramFmtp.config) paramFmtp.config += ';';
	
											paramFmtp.config += key + '=' + codec.parameters[key];
										}
									} catch (err) {
										_didIteratorError6 = true;
										_iteratorError6 = err;
									} finally {
										try {
											if (!_iteratorNormalCompletion6 && _iterator6.return) {
												_iterator6.return();
											}
										} finally {
											if (_didIteratorError6) {
												throw _iteratorError6;
											}
										}
									}
	
									if (paramFmtp.config) remoteMediaObj.fmtp.push(paramFmtp);
								}
	
								if (codec.rtcpFeedback) {
									var _iteratorNormalCompletion7 = true;
									var _didIteratorError7 = false;
									var _iteratorError7 = undefined;
	
									try {
										for (var _iterator7 = (0, _getIterator3.default)(codec.rtcpFeedback), _step7; !(_iteratorNormalCompletion7 = (_step7 = _iterator7.next()).done); _iteratorNormalCompletion7 = true) {
											var fb = _step7.value;
	
											remoteMediaObj.rtcpFb.push({
												payload: codec.payloadType,
												type: fb.type,
												subtype: fb.parameter || ''
											});
										}
									} catch (err) {
										_didIteratorError7 = true;
										_iteratorError7 = err;
									} finally {
										try {
											if (!_iteratorNormalCompletion7 && _iterator7.return) {
												_iterator7.return();
											}
										} finally {
											if (_didIteratorError7) {
												throw _iteratorError7;
											}
										}
									}
								}
							}
						} catch (err) {
							_didIteratorError3 = true;
							_iteratorError3 = err;
						} finally {
							try {
								if (!_iteratorNormalCompletion3 && _iterator3.return) {
									_iterator3.return();
								}
							} finally {
								if (_didIteratorError3) {
									throw _iteratorError3;
								}
							}
						}
	
						remoteMediaObj.payloads = codecs.map(function (codec) {
							return codec.payloadType;
						}).join(' ');
	
						// NOTE: Firefox does not like a=extmap lines if a=inactive.
						if (!closed) {
							remoteMediaObj.ext = [];
	
							var _iteratorNormalCompletion4 = true;
							var _didIteratorError4 = false;
							var _iteratorError4 = undefined;
	
							try {
								var _loop = function _loop() {
									var ext = _step4.value;
	
									// Don't add a header extension if not present in the offer.
									var matchedLocalExt = (localMediaObj.ext || []).find(function (localExt) {
										return localExt.uri === ext.uri;
									});
	
									if (!matchedLocalExt) return 'continue';
	
									remoteMediaObj.ext.push({
										uri: ext.uri,
										value: ext.id
									});
								};
	
								for (var _iterator4 = (0, _getIterator3.default)(headerExtensions), _step4; !(_iteratorNormalCompletion4 = (_step4 = _iterator4.next()).done); _iteratorNormalCompletion4 = true) {
									var _ret = _loop();
	
									if (_ret === 'continue') continue;
								}
							} catch (err) {
								_didIteratorError4 = true;
								_iteratorError4 = err;
							} finally {
								try {
									if (!_iteratorNormalCompletion4 && _iterator4.return) {
										_iterator4.return();
									}
								} finally {
									if (_didIteratorError4) {
										throw _iteratorError4;
									}
								}
							}
						}
	
						// Simulcast.
						if (localMediaObj.simulcast_03) {
							// eslint-disable-next-line camelcase
							remoteMediaObj.simulcast_03 = {
								value: localMediaObj.simulcast_03.value.replace(/send/g, 'recv')
							};
	
							remoteMediaObj.rids = [];
	
							var _iteratorNormalCompletion5 = true;
							var _didIteratorError5 = false;
							var _iteratorError5 = undefined;
	
							try {
								for (var _iterator5 = (0, _getIterator3.default)(localMediaObj.rids || []), _step5; !(_iteratorNormalCompletion5 = (_step5 = _iterator5.next()).done); _iteratorNormalCompletion5 = true) {
									var rid = _step5.value;
	
									if (rid.direction !== 'send') continue;
	
									remoteMediaObj.rids.push({
										id: rid.id,
										direction: 'recv'
									});
								}
							} catch (err) {
								_didIteratorError5 = true;
								_iteratorError5 = err;
							} finally {
								try {
									if (!_iteratorNormalCompletion5 && _iterator5.return) {
										_iterator5.return();
									}
								} finally {
									if (_didIteratorError5) {
										throw _iteratorError5;
									}
								}
							}
						}
	
						remoteMediaObj.rtcpMux = 'rtcp-mux';
						remoteMediaObj.rtcpRsize = 'rtcp-rsize';
	
						// Push it.
						sdpObj.media.push(remoteMediaObj);
					}
				} catch (err) {
					_didIteratorError = true;
					_iteratorError = err;
				} finally {
					try {
						if (!_iteratorNormalCompletion && _iterator.return) {
							_iterator.return();
						}
					} finally {
						if (_didIteratorError) {
							throw _iteratorError;
						}
					}
				}
	
				var sdp = _sdpTransform2.default.write(sdpObj);
	
				return sdp;
			}
		}]);
		return SendRemoteSdp;
	}(RemoteSdp);
	
	var RecvRemoteSdp = function (_RemoteSdp2) {
		(0, _inherits3.default)(RecvRemoteSdp, _RemoteSdp2);
	
		function RecvRemoteSdp(rtpParametersByKind) {
			(0, _classCallCheck3.default)(this, RecvRemoteSdp);
			return (0, _possibleConstructorReturn3.default)(this, (RecvRemoteSdp.__proto__ || (0, _getPrototypeOf2.default)(RecvRemoteSdp)).call(this, rtpParametersByKind));
		}
	
		/**
		* @param {Array<Object>} consumerInfos - Consumer informations.
		* @return {String}
		*/
	
	
		(0, _createClass3.default)(RecvRemoteSdp, [{
			key: 'createOfferSdp',
			value: function createOfferSdp(consumerInfos) {
				logger.debug('createOfferSdp()');
	
				if (!this._transportRemoteParameters) throw new Error('no transport remote parameters');
	
				var remoteIceParameters = this._transportRemoteParameters.iceParameters;
				var remoteIceCandidates = this._transportRemoteParameters.iceCandidates;
				var remoteDtlsParameters = this._transportRemoteParameters.dtlsParameters;
				var sdpObj = {};
				var mids = consumerInfos.map(function (info) {
					return info.mid;
				});
	
				// Increase our SDP version.
				this._sdpGlobalFields.version++;
	
				sdpObj.version = 0;
				sdpObj.origin = {
					address: '0.0.0.0',
					ipVer: 4,
					netType: 'IN',
					sessionId: this._sdpGlobalFields.id,
					sessionVersion: this._sdpGlobalFields.version,
					username: 'mediasoup-client'
				};
				sdpObj.name = '-';
				sdpObj.timing = { start: 0, stop: 0 };
				sdpObj.icelite = remoteIceParameters.iceLite ? 'ice-lite' : null;
				sdpObj.msidSemantic = {
					semantic: 'WMS',
					token: '*'
				};
	
				if (mids.length > 0) {
					sdpObj.groups = [{
						type: 'BUNDLE',
						mids: mids.join(' ')
					}];
				}
	
				sdpObj.media = [];
	
				// NOTE: We take the latest fingerprint.
				var numFingerprints = remoteDtlsParameters.fingerprints.length;
	
				sdpObj.fingerprint = {
					type: remoteDtlsParameters.fingerprints[numFingerprints - 1].algorithm,
					hash: remoteDtlsParameters.fingerprints[numFingerprints - 1].value
				};
	
				var _iteratorNormalCompletion8 = true;
				var _didIteratorError8 = false;
				var _iteratorError8 = undefined;
	
				try {
					for (var _iterator8 = (0, _getIterator3.default)(consumerInfos), _step8; !(_iteratorNormalCompletion8 = (_step8 = _iterator8.next()).done); _iteratorNormalCompletion8 = true) {
						var info = _step8.value;
	
						var closed = info.closed;
						var kind = info.kind;
						var codecs = void 0;
						var headerExtensions = void 0;
	
						if (info.kind !== 'application') {
							codecs = this._rtpParametersByKind[kind].codecs;
							headerExtensions = this._rtpParametersByKind[kind].headerExtensions;
						}
	
						var remoteMediaObj = {};
	
						if (info.kind !== 'application') {
							remoteMediaObj.type = kind;
							remoteMediaObj.port = 7;
							remoteMediaObj.protocol = 'RTP/SAVPF';
							remoteMediaObj.connection = { ip: '127.0.0.1', version: 4 };
							remoteMediaObj.mid = info.mid;
							remoteMediaObj.msid = info.streamId + ' ' + info.trackId;
						} else {
							remoteMediaObj.type = kind;
							remoteMediaObj.port = 9;
							remoteMediaObj.protocol = 'DTLS/SCTP';
							remoteMediaObj.connection = { ip: '127.0.0.1', version: 4 };
							remoteMediaObj.mid = info.mid;
						}
	
						remoteMediaObj.iceUfrag = remoteIceParameters.usernameFragment;
						remoteMediaObj.icePwd = remoteIceParameters.password;
						remoteMediaObj.candidates = [];
	
						var _iteratorNormalCompletion9 = true;
						var _didIteratorError9 = false;
						var _iteratorError9 = undefined;
	
						try {
							for (var _iterator9 = (0, _getIterator3.default)(remoteIceCandidates), _step9; !(_iteratorNormalCompletion9 = (_step9 = _iterator9.next()).done); _iteratorNormalCompletion9 = true) {
								var candidate = _step9.value;
	
								var candidateObj = {};
	
								// mediasoup does not support non rtcp-mux so candidates component is
								// always RTP (1).
								candidateObj.component = 1;
								candidateObj.foundation = candidate.foundation;
								candidateObj.ip = candidate.ip;
								candidateObj.port = candidate.port;
								candidateObj.priority = candidate.priority;
								candidateObj.transport = candidate.protocol;
								candidateObj.type = candidate.type;
								if (candidate.tcpType) candidateObj.tcptype = candidate.tcpType;
	
								remoteMediaObj.candidates.push(candidateObj);
							}
						} catch (err) {
							_didIteratorError9 = true;
							_iteratorError9 = err;
						} finally {
							try {
								if (!_iteratorNormalCompletion9 && _iterator9.return) {
									_iterator9.return();
								}
							} finally {
								if (_didIteratorError9) {
									throw _iteratorError9;
								}
							}
						}
	
						remoteMediaObj.endOfCandidates = 'end-of-candidates';
	
						// Announce support for ICE renomination.
						// https://tools.ietf.org/html/draft-thatcher-ice-renomination
						remoteMediaObj.iceOptions = 'renomination';
	
						remoteMediaObj.setup = 'actpass';
	
						if (info.kind !== 'application') {
							if (!closed) remoteMediaObj.direction = 'sendonly';else remoteMediaObj.direction = 'inactive';
	
							remoteMediaObj.rtp = [];
							remoteMediaObj.rtcpFb = [];
							remoteMediaObj.fmtp = [];
	
							var _iteratorNormalCompletion10 = true;
							var _didIteratorError10 = false;
							var _iteratorError10 = undefined;
	
							try {
								for (var _iterator10 = (0, _getIterator3.default)(codecs), _step10; !(_iteratorNormalCompletion10 = (_step10 = _iterator10.next()).done); _iteratorNormalCompletion10 = true) {
									var codec = _step10.value;
	
									var rtp = {
										payload: codec.payloadType,
										codec: codec.name,
										rate: codec.clockRate
									};
	
									if (codec.channels > 1) rtp.encoding = codec.channels;
	
									remoteMediaObj.rtp.push(rtp);
	
									if (codec.parameters) {
										var paramFmtp = {
											payload: codec.payloadType,
											config: ''
										};
	
										var _iteratorNormalCompletion12 = true;
										var _didIteratorError12 = false;
										var _iteratorError12 = undefined;
	
										try {
											for (var _iterator12 = (0, _getIterator3.default)((0, _keys2.default)(codec.parameters)), _step12; !(_iteratorNormalCompletion12 = (_step12 = _iterator12.next()).done); _iteratorNormalCompletion12 = true) {
												var key = _step12.value;
	
												if (paramFmtp.config) paramFmtp.config += ';';
	
												paramFmtp.config += key + '=' + codec.parameters[key];
											}
										} catch (err) {
											_didIteratorError12 = true;
											_iteratorError12 = err;
										} finally {
											try {
												if (!_iteratorNormalCompletion12 && _iterator12.return) {
													_iterator12.return();
												}
											} finally {
												if (_didIteratorError12) {
													throw _iteratorError12;
												}
											}
										}
	
										if (paramFmtp.config) remoteMediaObj.fmtp.push(paramFmtp);
									}
	
									if (codec.rtcpFeedback) {
										var _iteratorNormalCompletion13 = true;
										var _didIteratorError13 = false;
										var _iteratorError13 = undefined;
	
										try {
											for (var _iterator13 = (0, _getIterator3.default)(codec.rtcpFeedback), _step13; !(_iteratorNormalCompletion13 = (_step13 = _iterator13.next()).done); _iteratorNormalCompletion13 = true) {
												var fb = _step13.value;
	
												remoteMediaObj.rtcpFb.push({
													payload: codec.payloadType,
													type: fb.type,
													subtype: fb.parameter || ''
												});
											}
										} catch (err) {
											_didIteratorError13 = true;
											_iteratorError13 = err;
										} finally {
											try {
												if (!_iteratorNormalCompletion13 && _iterator13.return) {
													_iterator13.return();
												}
											} finally {
												if (_didIteratorError13) {
													throw _iteratorError13;
												}
											}
										}
									}
								}
							} catch (err) {
								_didIteratorError10 = true;
								_iteratorError10 = err;
							} finally {
								try {
									if (!_iteratorNormalCompletion10 && _iterator10.return) {
										_iterator10.return();
									}
								} finally {
									if (_didIteratorError10) {
										throw _iteratorError10;
									}
								}
							}
	
							remoteMediaObj.payloads = codecs.map(function (codec) {
								return codec.payloadType;
							}).join(' ');
	
							// NOTE: Firefox does not like a=extmap lines if a=inactive.
							if (!closed) {
								remoteMediaObj.ext = [];
	
								var _iteratorNormalCompletion11 = true;
								var _didIteratorError11 = false;
								var _iteratorError11 = undefined;
	
								try {
									for (var _iterator11 = (0, _getIterator3.default)(headerExtensions), _step11; !(_iteratorNormalCompletion11 = (_step11 = _iterator11.next()).done); _iteratorNormalCompletion11 = true) {
										var _ext = _step11.value;
	
										remoteMediaObj.ext.push({
											uri: _ext.uri,
											value: _ext.id
										});
									}
								} catch (err) {
									_didIteratorError11 = true;
									_iteratorError11 = err;
								} finally {
									try {
										if (!_iteratorNormalCompletion11 && _iterator11.return) {
											_iterator11.return();
										}
									} finally {
										if (_didIteratorError11) {
											throw _iteratorError11;
										}
									}
								}
							}
	
							remoteMediaObj.rtcpMux = 'rtcp-mux';
							remoteMediaObj.rtcpRsize = 'rtcp-rsize';
	
							if (!closed) {
								remoteMediaObj.ssrcs = [];
								remoteMediaObj.ssrcGroups = [];
	
								remoteMediaObj.ssrcs.push({
									id: info.ssrc,
									attribute: 'cname',
									value: info.cname
								});
	
								if (info.rtxSsrc) {
									remoteMediaObj.ssrcs.push({
										id: info.rtxSsrc,
										attribute: 'cname',
										value: info.cname
									});
	
									// Associate original and retransmission SSRC.
									remoteMediaObj.ssrcGroups.push({
										semantics: 'FID',
										ssrcs: info.ssrc + ' ' + info.rtxSsrc
									});
								}
							}
						} else {
							remoteMediaObj.payloads = 5000;
							remoteMediaObj.sctpmap = {
								app: 'webrtc-datachannel',
								maxMessageSize: 256,
								sctpmapNumber: 5000
							};
						}
	
						// Push it.
						sdpObj.media.push(remoteMediaObj);
					}
				} catch (err) {
					_didIteratorError8 = true;
					_iteratorError8 = err;
				} finally {
					try {
						if (!_iteratorNormalCompletion8 && _iterator8.return) {
							_iterator8.return();
						}
					} finally {
						if (_didIteratorError8) {
							throw _iteratorError8;
						}
					}
				}
	
				var sdp = _sdpTransform2.default.write(sdpObj);
	
				return sdp;
			}
		}]);
		return RecvRemoteSdp;
	}(RemoteSdp);
	
	var RemoteUnifiedPlanSdp = function RemoteUnifiedPlanSdp(direction, rtpParametersByKind) {
		(0, _classCallCheck3.default)(this, RemoteUnifiedPlanSdp);
	
		logger.debug('constructor() [direction:%s, rtpParametersByKind:%o]', direction, rtpParametersByKind);
	
		switch (direction) {
			case 'send':
				return new SendRemoteSdp(rtpParametersByKind);
			case 'recv':
				return new RecvRemoteSdp(rtpParametersByKind);
		}
	};
	
	exports.default = RemoteUnifiedPlanSdp;
	
	},{"../../Logger":13,"../../utils":34,"babel-runtime/core-js/get-iterator":36,"babel-runtime/core-js/object/get-prototype-of":43,"babel-runtime/core-js/object/keys":44,"babel-runtime/helpers/classCallCheck":51,"babel-runtime/helpers/createClass":52,"babel-runtime/helpers/inherits":54,"babel-runtime/helpers/possibleConstructorReturn":55,"sdp-transform":213}],29:[function(require,module,exports){
	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
		value: true
	});
	
	var _getIterator2 = require('babel-runtime/core-js/get-iterator');
	
	var _getIterator3 = _interopRequireDefault(_getIterator2);
	
	var _from = require('babel-runtime/core-js/array/from');
	
	var _from2 = _interopRequireDefault(_from);
	
	var _map = require('babel-runtime/core-js/map');
	
	var _map2 = _interopRequireDefault(_map);
	
	exports.extractRtpCapabilities = extractRtpCapabilities;
	exports.extractDtlsParameters = extractDtlsParameters;
	
	var _sdpTransform = require('sdp-transform');
	
	var _sdpTransform2 = _interopRequireDefault(_sdpTransform);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	/**
	 * Extract RTP capabilities from a SDP.
	 *
	 * @param {Object} sdpObj - SDP Object generated by sdp-transform.
	 * @return {RTCRtpCapabilities}
	 */
	function extractRtpCapabilities(sdpObj) {
		// Map of RtpCodecParameters indexed by payload type.
		var codecsMap = new _map2.default();
	
		// Array of RtpHeaderExtensions.
		var headerExtensions = [];
	
		// Whether a m=audio/video section has been already found.
		var gotAudio = false;
		var gotVideo = false;
	
		var _iteratorNormalCompletion = true;
		var _didIteratorError = false;
		var _iteratorError = undefined;
	
		try {
			for (var _iterator = (0, _getIterator3.default)(sdpObj.media), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
				var m = _step.value;
	
				var kind = m.type;
	
				switch (kind) {
					case 'audio':
						{
							if (gotAudio) continue;
	
							gotAudio = true;
							break;
						}
					case 'video':
						{
							if (gotVideo) continue;
	
							gotVideo = true;
							break;
						}
					default:
						{
							continue;
						}
				}
	
				// Get codecs.
				var _iteratorNormalCompletion2 = true;
				var _didIteratorError2 = false;
				var _iteratorError2 = undefined;
	
				try {
					for (var _iterator2 = (0, _getIterator3.default)(m.rtp), _step2; !(_iteratorNormalCompletion2 = (_step2 = _iterator2.next()).done); _iteratorNormalCompletion2 = true) {
						var rtp = _step2.value;
	
						var codec = {
							name: rtp.codec,
							mimeType: kind + '/' + rtp.codec,
							kind: kind,
							clockRate: rtp.rate,
							preferredPayloadType: rtp.payload,
							channels: rtp.encoding,
							rtcpFeedback: [],
							parameters: {}
						};
	
						if (codec.kind !== 'audio') delete codec.channels;else if (!codec.channels) codec.channels = 1;
	
						codecsMap.set(codec.preferredPayloadType, codec);
					}
	
					// Get codec parameters.
				} catch (err) {
					_didIteratorError2 = true;
					_iteratorError2 = err;
				} finally {
					try {
						if (!_iteratorNormalCompletion2 && _iterator2.return) {
							_iterator2.return();
						}
					} finally {
						if (_didIteratorError2) {
							throw _iteratorError2;
						}
					}
				}
	
				var _iteratorNormalCompletion3 = true;
				var _didIteratorError3 = false;
				var _iteratorError3 = undefined;
	
				try {
					for (var _iterator3 = (0, _getIterator3.default)(m.fmtp || []), _step3; !(_iteratorNormalCompletion3 = (_step3 = _iterator3.next()).done); _iteratorNormalCompletion3 = true) {
						var fmtp = _step3.value;
	
						var parameters = _sdpTransform2.default.parseFmtpConfig(fmtp.config);
						var _codec = codecsMap.get(fmtp.payload);
	
						if (!_codec) continue;
	
						_codec.parameters = parameters;
					}
	
					// Get RTCP feedback for each codec.
				} catch (err) {
					_didIteratorError3 = true;
					_iteratorError3 = err;
				} finally {
					try {
						if (!_iteratorNormalCompletion3 && _iterator3.return) {
							_iterator3.return();
						}
					} finally {
						if (_didIteratorError3) {
							throw _iteratorError3;
						}
					}
				}
	
				var _iteratorNormalCompletion4 = true;
				var _didIteratorError4 = false;
				var _iteratorError4 = undefined;
	
				try {
					for (var _iterator4 = (0, _getIterator3.default)(m.rtcpFb || []), _step4; !(_iteratorNormalCompletion4 = (_step4 = _iterator4.next()).done); _iteratorNormalCompletion4 = true) {
						var fb = _step4.value;
	
						var _codec2 = codecsMap.get(fb.payload);
	
						if (!_codec2) continue;
	
						var feedback = {
							type: fb.type,
							parameter: fb.subtype
						};
	
						if (!feedback.parameter) delete feedback.parameter;
	
						_codec2.rtcpFeedback.push(feedback);
					}
	
					// Get RTP header extensions.
				} catch (err) {
					_didIteratorError4 = true;
					_iteratorError4 = err;
				} finally {
					try {
						if (!_iteratorNormalCompletion4 && _iterator4.return) {
							_iterator4.return();
						}
					} finally {
						if (_didIteratorError4) {
							throw _iteratorError4;
						}
					}
				}
	
				var _iteratorNormalCompletion5 = true;
				var _didIteratorError5 = false;
				var _iteratorError5 = undefined;
	
				try {
					for (var _iterator5 = (0, _getIterator3.default)(m.ext || []), _step5; !(_iteratorNormalCompletion5 = (_step5 = _iterator5.next()).done); _iteratorNormalCompletion5 = true) {
						var ext = _step5.value;
	
						var headerExtension = {
							kind: kind,
							uri: ext.uri,
							preferredId: ext.value
						};
	
						headerExtensions.push(headerExtension);
					}
				} catch (err) {
					_didIteratorError5 = true;
					_iteratorError5 = err;
				} finally {
					try {
						if (!_iteratorNormalCompletion5 && _iterator5.return) {
							_iterator5.return();
						}
					} finally {
						if (_didIteratorError5) {
							throw _iteratorError5;
						}
					}
				}
			}
		} catch (err) {
			_didIteratorError = true;
			_iteratorError = err;
		} finally {
			try {
				if (!_iteratorNormalCompletion && _iterator.return) {
					_iterator.return();
				}
			} finally {
				if (_didIteratorError) {
					throw _iteratorError;
				}
			}
		}
	
		var rtpCapabilities = {
			codecs: (0, _from2.default)(codecsMap.values()),
			headerExtensions: headerExtensions,
			fecMechanisms: [] // TODO
		};
	
		return rtpCapabilities;
	}
	
	/**
	 * Extract DTLS parameters from a SDP.
	 *
	 * @param {Object} sdpObj - SDP Object generated by sdp-transform.
	 * @return {RTCDtlsParameters}
	 */
	function extractDtlsParameters(sdpObj) {
		var media = getFirstActiveMediaSection(sdpObj);
		var fingerprint = media.fingerprint || sdpObj.fingerprint;
		var role = void 0;
	
		switch (media.setup) {
			case 'active':
				role = 'client';
				break;
			case 'passive':
				role = 'server';
				break;
			case 'actpass':
				role = 'auto';
				break;
		}
	
		var dtlsParameters = {
			role: role,
			fingerprints: [{
				algorithm: fingerprint.type,
				value: fingerprint.hash
			}]
		};
	
		return dtlsParameters;
	}
	
	/**
	 * Get the first acive media section.
	 *
	 * @private
	 * @param {Object} sdpObj - SDP Object generated by sdp-transform.
	 * @return {Object} SDP media section as parsed by sdp-transform.
	 */
	function getFirstActiveMediaSection(sdpObj) {
		return (sdpObj.media || []).find(function (m) {
			return m.iceUfrag && m.port !== 0;
		});
	}
	
	},{"babel-runtime/core-js/array/from":35,"babel-runtime/core-js/get-iterator":36,"babel-runtime/core-js/map":39,"sdp-transform":213}],30:[function(require,module,exports){
	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
		value: true
	});
	
	var _slicedToArray2 = require('babel-runtime/helpers/slicedToArray');
	
	var _slicedToArray3 = _interopRequireDefault(_slicedToArray2);
	
	var _getIterator2 = require('babel-runtime/core-js/get-iterator');
	
	var _getIterator3 = _interopRequireDefault(_getIterator2);
	
	var _map = require('babel-runtime/core-js/map');
	
	var _map2 = _interopRequireDefault(_map);
	
	var _set = require('babel-runtime/core-js/set');
	
	var _set2 = _interopRequireDefault(_set);
	
	exports.fillRtpParametersForTrack = fillRtpParametersForTrack;
	exports.addSimulcastForTrack = addSimulcastForTrack;
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	/**
	 * Fill the given RTP parameters for the given track.
	 *
	 * @param {RTCRtpParameters} rtpParameters -  RTP parameters to be filled.
	 * @param {Object} sdpObj - Local SDP Object generated by sdp-transform.
	 * @param {MediaStreamTrack} track
	 */
	function fillRtpParametersForTrack(rtpParameters, sdpObj, track) {
		var kind = track.kind;
		var rtcp = {
			cname: null,
			reducedSize: true,
			mux: true
		};
	
		var mSection = (sdpObj.media || []).find(function (m) {
			return m.type === kind;
		});
	
		if (!mSection) throw new Error('m=' + kind + ' section not found');
	
		// First media SSRC (or the only one).
		var firstSsrc = void 0;
	
		// Get all the SSRCs.
	
		var ssrcs = new _set2.default();
	
		var _iteratorNormalCompletion = true;
		var _didIteratorError = false;
		var _iteratorError = undefined;
	
		try {
			for (var _iterator = (0, _getIterator3.default)(mSection.ssrcs || []), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
				var line = _step.value;
	
				if (line.attribute !== 'msid') continue;
	
				var trackId = line.value.split(' ')[1];
	
				if (trackId === track.id) {
					var ssrc = line.id;
	
					ssrcs.add(ssrc);
	
					if (!firstSsrc) firstSsrc = ssrc;
				}
			}
		} catch (err) {
			_didIteratorError = true;
			_iteratorError = err;
		} finally {
			try {
				if (!_iteratorNormalCompletion && _iterator.return) {
					_iterator.return();
				}
			} finally {
				if (_didIteratorError) {
					throw _iteratorError;
				}
			}
		}
	
		if (ssrcs.size === 0) throw new Error('a=ssrc line not found for local track [track.id:' + track.id + ']');
	
		// Get media and RTX SSRCs.
	
		var ssrcToRtxSsrc = new _map2.default();
	
		// First assume RTX is used.
		var _iteratorNormalCompletion2 = true;
		var _didIteratorError2 = false;
		var _iteratorError2 = undefined;
	
		try {
			for (var _iterator2 = (0, _getIterator3.default)(mSection.ssrcGroups || []), _step2; !(_iteratorNormalCompletion2 = (_step2 = _iterator2.next()).done); _iteratorNormalCompletion2 = true) {
				var _line = _step2.value;
	
				if (_line.semantics !== 'FID') continue;
	
				var _line$ssrcs$split = _line.ssrcs.split(/\s+/),
						_line$ssrcs$split2 = (0, _slicedToArray3.default)(_line$ssrcs$split, 2),
						_ssrc = _line$ssrcs$split2[0],
						rtxSsrc = _line$ssrcs$split2[1];
	
				_ssrc = Number(_ssrc);
				rtxSsrc = Number(rtxSsrc);
	
				if (ssrcs.has(_ssrc)) {
					// Remove both the SSRC and RTX SSRC from the Set so later we know that they
					// are already handled.
					ssrcs.delete(_ssrc);
					ssrcs.delete(rtxSsrc);
	
					// Add to the map.
					ssrcToRtxSsrc.set(_ssrc, rtxSsrc);
				}
			}
	
			// If the Set of SSRCs is not empty it means that RTX is not being used, so take
			// media SSRCs from there.
		} catch (err) {
			_didIteratorError2 = true;
			_iteratorError2 = err;
		} finally {
			try {
				if (!_iteratorNormalCompletion2 && _iterator2.return) {
					_iterator2.return();
				}
			} finally {
				if (_didIteratorError2) {
					throw _iteratorError2;
				}
			}
		}
	
		var _iteratorNormalCompletion3 = true;
		var _didIteratorError3 = false;
		var _iteratorError3 = undefined;
	
		try {
			for (var _iterator3 = (0, _getIterator3.default)(ssrcs), _step3; !(_iteratorNormalCompletion3 = (_step3 = _iterator3.next()).done); _iteratorNormalCompletion3 = true) {
				var _ssrc2 = _step3.value;
	
				// Add to the map.
				ssrcToRtxSsrc.set(_ssrc2, null);
			}
	
			// Get RTCP info.
		} catch (err) {
			_didIteratorError3 = true;
			_iteratorError3 = err;
		} finally {
			try {
				if (!_iteratorNormalCompletion3 && _iterator3.return) {
					_iterator3.return();
				}
			} finally {
				if (_didIteratorError3) {
					throw _iteratorError3;
				}
			}
		}
	
		var ssrcCnameLine = mSection.ssrcs.find(function (line) {
			return line.attribute === 'cname' && line.id === firstSsrc;
		});
	
		if (ssrcCnameLine) rtcp.cname = ssrcCnameLine.value;
	
		// Fill RTP parameters.
	
		rtpParameters.rtcp = rtcp;
		rtpParameters.encodings = [];
	
		var simulcast = ssrcToRtxSsrc.size > 1;
		var simulcastProfiles = ['low', 'medium', 'high'];
	
		var _iteratorNormalCompletion4 = true;
		var _didIteratorError4 = false;
		var _iteratorError4 = undefined;
	
		try {
			for (var _iterator4 = (0, _getIterator3.default)(ssrcToRtxSsrc), _step4; !(_iteratorNormalCompletion4 = (_step4 = _iterator4.next()).done); _iteratorNormalCompletion4 = true) {
				var _step4$value = (0, _slicedToArray3.default)(_step4.value, 2),
						_ssrc3 = _step4$value[0],
						rtxSsrc = _step4$value[1];
	
				var encoding = { ssrc: _ssrc3 };
	
				if (rtxSsrc) encoding.rtx = { ssrc: rtxSsrc };
	
				if (simulcast) encoding.profile = simulcastProfiles.shift();
	
				rtpParameters.encodings.push(encoding);
			}
		} catch (err) {
			_didIteratorError4 = true;
			_iteratorError4 = err;
		} finally {
			try {
				if (!_iteratorNormalCompletion4 && _iterator4.return) {
					_iterator4.return();
				}
			} finally {
				if (_didIteratorError4) {
					throw _iteratorError4;
				}
			}
		}
	}
	
	/**
	 * Adds simulcast into the given SDP for the given track.
	 *
	 * @param {Object} sdpObj - Local SDP Object generated by sdp-transform.
	 * @param {MediaStreamTrack} track
	 */
	function addSimulcastForTrack(sdpObj, track) {
		var kind = track.kind;
	
		var mSection = (sdpObj.media || []).find(function (m) {
			return m.type === kind;
		});
	
		if (!mSection) throw new Error('m=' + kind + ' section not found');
	
		var ssrc = void 0;
		var rtxSsrc = void 0;
		var msid = void 0;
	
		// Get the SSRC.
	
		var ssrcMsidLine = (mSection.ssrcs || []).find(function (line) {
			if (line.attribute !== 'msid') return false;
	
			var trackId = line.value.split(' ')[1];
	
			if (trackId === track.id) {
				ssrc = line.id;
				msid = line.value.split(' ')[0];
	
				return true;
			}
		});
	
		if (!ssrcMsidLine) throw new Error('a=ssrc line not found for local track [track.id:' + track.id + ']');
	
		// Get the SSRC for RTX.
	
		(mSection.ssrcGroups || []).some(function (line) {
			if (line.semantics !== 'FID') return;
	
			var ssrcs = line.ssrcs.split(/\s+/);
	
			if (Number(ssrcs[0]) === ssrc) {
				rtxSsrc = Number(ssrcs[1]);
	
				return true;
			}
		});
	
		var ssrcCnameLine = mSection.ssrcs.find(function (line) {
			return line.attribute === 'cname' && line.id === ssrc;
		});
	
		if (!ssrcCnameLine) throw new Error('CNAME line not found for local track [track.id:' + track.id + ']');
	
		var cname = ssrcCnameLine.value;
		var ssrc2 = ssrc + 1;
		var ssrc3 = ssrc + 2;
	
		mSection.ssrcGroups = mSection.ssrcGroups || [];
	
		mSection.ssrcGroups.push({
			semantics: 'SIM',
			ssrcs: ssrc + ' ' + ssrc2 + ' ' + ssrc3
		});
	
		mSection.ssrcs.push({
			id: ssrc2,
			attribute: 'cname',
			value: cname
		});
	
		mSection.ssrcs.push({
			id: ssrc2,
			attribute: 'msid',
			value: msid + ' ' + track.id
		});
	
		mSection.ssrcs.push({
			id: ssrc3,
			attribute: 'cname',
			value: cname
		});
	
		mSection.ssrcs.push({
			id: ssrc3,
			attribute: 'msid',
			value: msid + ' ' + track.id
		});
	
		if (rtxSsrc) {
			var rtxSsrc2 = rtxSsrc + 1;
			var rtxSsrc3 = rtxSsrc + 2;
	
			mSection.ssrcGroups.push({
				semantics: 'FID',
				ssrcs: ssrc2 + ' ' + rtxSsrc2
			});
	
			mSection.ssrcs.push({
				id: rtxSsrc2,
				attribute: 'cname',
				value: cname
			});
	
			mSection.ssrcs.push({
				id: rtxSsrc2,
				attribute: 'msid',
				value: msid + ' ' + track.id
			});
	
			mSection.ssrcGroups.push({
				semantics: 'FID',
				ssrcs: ssrc3 + ' ' + rtxSsrc3
			});
	
			mSection.ssrcs.push({
				id: rtxSsrc3,
				attribute: 'cname',
				value: cname
			});
	
			mSection.ssrcs.push({
				id: rtxSsrc3,
				attribute: 'msid',
				value: msid + ' ' + track.id
			});
		}
	}
	
	},{"babel-runtime/core-js/get-iterator":36,"babel-runtime/core-js/map":39,"babel-runtime/core-js/set":48,"babel-runtime/helpers/slicedToArray":56}],31:[function(require,module,exports){
	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
		value: true
	});
	
	var _getIterator2 = require('babel-runtime/core-js/get-iterator');
	
	var _getIterator3 = _interopRequireDefault(_getIterator2);
	
	exports.fillRtpParametersForTrack = fillRtpParametersForTrack;
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	/**
	 * Fill the given RTP parameters for the given track.
	 *
	 * @param {RTCRtpParameters} rtpParameters -  RTP parameters to be filled.
	 * @param {Object} sdpObj - Local SDP Object generated by sdp-transform.
	 * @param {MediaStreamTrack} track
	 */
	function fillRtpParametersForTrack(rtpParameters, sdpObj, track) {
		var kind = track.kind;
		var rtcp = {
			cname: null,
			reducedSize: true,
			mux: true
		};
	
		var mSection = (sdpObj.media || []).find(function (m) {
			if (m.type !== kind) return;
	
			var msidLine = m.msid;
	
			if (!msidLine) return;
	
			var trackId = msidLine.split(' ')[1];
	
			if (trackId === track.id) return true;
		});
	
		if (!mSection) throw new Error('m=' + kind + ' section not found');
	
		// Get the SSRC and CNAME.
	
		var ssrcCnameLine = (mSection.ssrcs || []).find(function (line) {
			return line.attribute === 'cname';
		});
	
		var ssrc = void 0;
	
		if (ssrcCnameLine) {
			ssrc = ssrcCnameLine.id;
			rtcp.cname = ssrcCnameLine.value;
		}
	
		// Get a=rid lines.
	
		// Array of Objects with rid and profile keys.
		var simulcastStreams = [];
	
		var _iteratorNormalCompletion = true;
		var _didIteratorError = false;
		var _iteratorError = undefined;
	
		try {
			for (var _iterator = (0, _getIterator3.default)(mSection.rids || []), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
				var rid = _step.value;
	
				if (rid.direction !== 'send') continue;
	
				if (/^low/.test(rid.id)) simulcastStreams.push({ rid: rid.id, profile: 'low' });else if (/^medium/.test(rid.id)) simulcastStreams.push({ rid: rid.id, profile: 'medium' });
				if (/^high/.test(rid.id)) simulcastStreams.push({ rid: rid.id, profile: 'high' });
			}
	
			// Fill RTP parameters.
		} catch (err) {
			_didIteratorError = true;
			_iteratorError = err;
		} finally {
			try {
				if (!_iteratorNormalCompletion && _iterator.return) {
					_iterator.return();
				}
			} finally {
				if (_didIteratorError) {
					throw _iteratorError;
				}
			}
		}
	
		rtpParameters.rtcp = rtcp;
		rtpParameters.encodings = [];
	
		if (simulcastStreams.length === 0) {
			var encoding = { ssrc: ssrc };
	
			rtpParameters.encodings.push(encoding);
		} else {
			var _iteratorNormalCompletion2 = true;
			var _didIteratorError2 = false;
			var _iteratorError2 = undefined;
	
			try {
				for (var _iterator2 = (0, _getIterator3.default)(simulcastStreams), _step2; !(_iteratorNormalCompletion2 = (_step2 = _iterator2.next()).done); _iteratorNormalCompletion2 = true) {
					var simulcastStream = _step2.value;
	
					var _encoding = {
						encodingId: simulcastStream.rid,
						profile: simulcastStream.profile
					};
	
					rtpParameters.encodings.push(_encoding);
				}
			} catch (err) {
				_didIteratorError2 = true;
				_iteratorError2 = err;
			} finally {
				try {
					if (!_iteratorNormalCompletion2 && _iterator2.return) {
						_iterator2.return();
					}
				} finally {
					if (_didIteratorError2) {
						throw _iteratorError2;
					}
				}
			}
		}
	}
	
	},{"babel-runtime/core-js/get-iterator":36}],32:[function(require,module,exports){
	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
		value: true
	});
	exports.Room = undefined;
	
	var _promise = require('babel-runtime/core-js/promise');
	
	var _promise2 = _interopRequireDefault(_promise);
	
	exports.isDeviceSupported = isDeviceSupported;
	exports.getDeviceInfo = getDeviceInfo;
	exports.checkCapabilitiesForRoom = checkCapabilitiesForRoom;
	
	var _ortc = require('./ortc');
	
	var ortc = _interopRequireWildcard(_ortc);
	
	var _Device = require('./Device');
	
	var _Device2 = _interopRequireDefault(_Device);
	
	var _Room = require('./Room');
	
	var _Room2 = _interopRequireDefault(_Room);
	
	function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	/**
	 * Whether the current browser or device is supported.
	 *
	 * @return {Boolean}
	 *
	 * @example
	 * isDeviceSupported()
	 * // => true
	 */
	function isDeviceSupported() {
		return _Device2.default.isSupported();
	}
	
	/**
	 * Get information regarding the current browser or device.
	 *
	 * @return {Object} - Object with `name` (String) and version {String}.
	 *
	 * @example
	 * getDeviceInfo()
	 * // => { flag: 'chrome', name: 'Chrome', version: '59.0', bowser: {} }
	 */
	function getDeviceInfo() {
		return {
			flag: _Device2.default.getFlag(),
			name: _Device2.default.getName(),
			version: _Device2.default.getVersion(),
			bowser: _Device2.default.getBowser()
		};
	}
	
	/**
	 * Check whether this device/browser can send/receive audio/video in a room
	 * whose RTP capabilities are given.
	 *
	 * @param {Object} Room RTP capabilities.
	 *
	 * @return {Promise} Resolves to an Object with 'audio' and 'video' Booleans.
	 */
	function checkCapabilitiesForRoom(roomRtpCapabilities) {
		if (!_Device2.default.isSupported()) return _promise2.default.reject(new Error('current browser/device not supported'));
	
		return _Device2.default.Handler.getNativeRtpCapabilities().then(function (nativeRtpCapabilities) {
			var extendedRtpCapabilities = ortc.getExtendedRtpCapabilities(nativeRtpCapabilities, roomRtpCapabilities);
	
			return {
				audio: ortc.canSend('audio', extendedRtpCapabilities),
				video: ortc.canSend('video', extendedRtpCapabilities)
			};
		});
	}
	
	/**
	 * Expose the Room class.
	 *
	 * @example
	 * const room = new Room();`
	 */
	exports.Room = _Room2.default;
	
	},{"./Device":11,"./Room":16,"./ortc":33,"babel-runtime/core-js/promise":47}],33:[function(require,module,exports){
	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
		value: true
	});
	
	var _getIterator2 = require('babel-runtime/core-js/get-iterator');
	
	var _getIterator3 = _interopRequireDefault(_getIterator2);
	
	exports.getExtendedRtpCapabilities = getExtendedRtpCapabilities;
	exports.getRtpCapabilities = getRtpCapabilities;
	exports.getUnsupportedCodecs = getUnsupportedCodecs;
	exports.canSend = canSend;
	exports.canReceive = canReceive;
	exports.getSendingRtpParameters = getSendingRtpParameters;
	exports.getReceivingFullRtpParameters = getReceivingFullRtpParameters;
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	/**
	 * Generate extended RTP capabilities for sending and receiving.
	 *
	 * @param {RTCRtpCapabilities} localCaps - Local capabilities.
	 * @param {RTCRtpCapabilities} remoteCaps - Remote capabilities.
	 *
	 * @return {RTCExtendedRtpCapabilities}
	 */
	function getExtendedRtpCapabilities(localCaps, remoteCaps) {
		var extendedCaps = {
			codecs: [],
			headerExtensions: [],
			fecMechanisms: []
		};
	
		// Match media codecs and keep the order preferred by remoteCaps.
		var _iteratorNormalCompletion = true;
		var _didIteratorError = false;
		var _iteratorError = undefined;
	
		try {
			var _loop = function _loop() {
				var remoteCodec = _step.value;
	
				// TODO: Ignore pseudo-codecs and feature codecs.
				if (remoteCodec.name === 'rtx') return 'continue';
	
				var matchingLocalCodec = (localCaps.codecs || []).find(function (localCodec) {
					return matchCapCodecs(localCodec, remoteCodec);
				});
	
				if (matchingLocalCodec) {
					var extendedCodec = {
						name: remoteCodec.name,
						mimeType: remoteCodec.mimeType,
						kind: remoteCodec.kind,
						clockRate: remoteCodec.clockRate,
						sendPayloadType: matchingLocalCodec.preferredPayloadType,
						sendRtxPayloadType: null,
						recvPayloadType: remoteCodec.preferredPayloadType,
						recvRtxPayloadType: null,
						channels: remoteCodec.channels,
						rtcpFeedback: reduceRtcpFeedback(matchingLocalCodec, remoteCodec),
						parameters: remoteCodec.parameters
					};
	
					if (!extendedCodec.channels) delete extendedCodec.channels;
	
					extendedCaps.codecs.push(extendedCodec);
				}
			};
	
			for (var _iterator = (0, _getIterator3.default)(remoteCaps.codecs || []), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
				var _ret = _loop();
	
				if (_ret === 'continue') continue;
			}
	
			// Match RTX codecs.
		} catch (err) {
			_didIteratorError = true;
			_iteratorError = err;
		} finally {
			try {
				if (!_iteratorNormalCompletion && _iterator.return) {
					_iterator.return();
				}
			} finally {
				if (_didIteratorError) {
					throw _iteratorError;
				}
			}
		}
	
		var _iteratorNormalCompletion2 = true;
		var _didIteratorError2 = false;
		var _iteratorError2 = undefined;
	
		try {
			var _loop2 = function _loop2() {
				var extendedCodec = _step2.value;
	
				var matchingLocalRtxCodec = (localCaps.codecs || []).find(function (localCodec) {
					return localCodec.name === 'rtx' && localCodec.parameters.apt === extendedCodec.sendPayloadType;
				});
	
				var matchingRemoteRtxCodec = (remoteCaps.codecs || []).find(function (remoteCodec) {
					return remoteCodec.name === 'rtx' && remoteCodec.parameters.apt === extendedCodec.recvPayloadType;
				});
	
				if (matchingLocalRtxCodec && matchingRemoteRtxCodec) {
					extendedCodec.sendRtxPayloadType = matchingLocalRtxCodec.preferredPayloadType;
					extendedCodec.recvRtxPayloadType = matchingRemoteRtxCodec.preferredPayloadType;
				}
			};
	
			for (var _iterator2 = (0, _getIterator3.default)(extendedCaps.codecs || []), _step2; !(_iteratorNormalCompletion2 = (_step2 = _iterator2.next()).done); _iteratorNormalCompletion2 = true) {
				_loop2();
			}
	
			// Match header extensions.
		} catch (err) {
			_didIteratorError2 = true;
			_iteratorError2 = err;
		} finally {
			try {
				if (!_iteratorNormalCompletion2 && _iterator2.return) {
					_iterator2.return();
				}
			} finally {
				if (_didIteratorError2) {
					throw _iteratorError2;
				}
			}
		}
	
		var _iteratorNormalCompletion3 = true;
		var _didIteratorError3 = false;
		var _iteratorError3 = undefined;
	
		try {
			var _loop3 = function _loop3() {
				var remoteExt = _step3.value;
	
				var matchingLocalExt = (localCaps.headerExtensions || []).find(function (localExt) {
					return matchCapHeaderExtensions(localExt, remoteExt);
				});
	
				if (matchingLocalExt) {
					var extendedExt = {
						kind: remoteExt.kind,
						uri: remoteExt.uri,
						sendId: matchingLocalExt.preferredId,
						recvId: remoteExt.preferredId
					};
	
					extendedCaps.headerExtensions.push(extendedExt);
				}
			};
	
			for (var _iterator3 = (0, _getIterator3.default)(remoteCaps.headerExtensions || []), _step3; !(_iteratorNormalCompletion3 = (_step3 = _iterator3.next()).done); _iteratorNormalCompletion3 = true) {
				_loop3();
			}
		} catch (err) {
			_didIteratorError3 = true;
			_iteratorError3 = err;
		} finally {
			try {
				if (!_iteratorNormalCompletion3 && _iterator3.return) {
					_iterator3.return();
				}
			} finally {
				if (_didIteratorError3) {
					throw _iteratorError3;
				}
			}
		}
	
		return extendedCaps;
	}
	
	/**
	 * Generate RTP capabilities for receiving media based on the given extended
	 * RTP capabilities.
	 *
	 * @param {RTCExtendedRtpCapabilities} extendedRtpCapabilities
	 *
	 * @return {RTCRtpCapabilities}
	 */
	function getRtpCapabilities(extendedRtpCapabilities) {
		var caps = {
			codecs: [],
			headerExtensions: [],
			fecMechanisms: []
		};
	
		var _iteratorNormalCompletion4 = true;
		var _didIteratorError4 = false;
		var _iteratorError4 = undefined;
	
		try {
			for (var _iterator4 = (0, _getIterator3.default)(extendedRtpCapabilities.codecs), _step4; !(_iteratorNormalCompletion4 = (_step4 = _iterator4.next()).done); _iteratorNormalCompletion4 = true) {
				var capCodec = _step4.value;
	
				var codec = {
					name: capCodec.name,
					mimeType: capCodec.mimeType,
					kind: capCodec.kind,
					clockRate: capCodec.clockRate,
					preferredPayloadType: capCodec.recvPayloadType,
					channels: capCodec.channels,
					rtcpFeedback: capCodec.rtcpFeedback,
					parameters: capCodec.parameters
				};
	
				if (!codec.channels) delete codec.channels;
	
				caps.codecs.push(codec);
	
				// Add RTX codec.
				if (capCodec.recvRtxPayloadType) {
					var rtxCapCodec = {
						name: 'rtx',
						mimeType: capCodec.kind + '/rtx',
						kind: capCodec.kind,
						clockRate: capCodec.clockRate,
						preferredPayloadType: capCodec.recvRtxPayloadType,
						parameters: {
							apt: capCodec.recvPayloadType
						}
					};
	
					caps.codecs.push(rtxCapCodec);
				}
	
				// TODO: In the future, we need to add FEC, CN, etc, codecs.
			}
		} catch (err) {
			_didIteratorError4 = true;
			_iteratorError4 = err;
		} finally {
			try {
				if (!_iteratorNormalCompletion4 && _iterator4.return) {
					_iterator4.return();
				}
			} finally {
				if (_didIteratorError4) {
					throw _iteratorError4;
				}
			}
		}
	
		var _iteratorNormalCompletion5 = true;
		var _didIteratorError5 = false;
		var _iteratorError5 = undefined;
	
		try {
			for (var _iterator5 = (0, _getIterator3.default)(extendedRtpCapabilities.headerExtensions), _step5; !(_iteratorNormalCompletion5 = (_step5 = _iterator5.next()).done); _iteratorNormalCompletion5 = true) {
				var capExt = _step5.value;
	
				var ext = {
					kind: capExt.kind,
					uri: capExt.uri,
					preferredId: capExt.recvId
				};
	
				caps.headerExtensions.push(ext);
			}
		} catch (err) {
			_didIteratorError5 = true;
			_iteratorError5 = err;
		} finally {
			try {
				if (!_iteratorNormalCompletion5 && _iterator5.return) {
					_iterator5.return();
				}
			} finally {
				if (_didIteratorError5) {
					throw _iteratorError5;
				}
			}
		}
	
		caps.fecMechanisms = extendedRtpCapabilities.fecMechanisms;
	
		return caps;
	}
	
	/**
	 * Get unsupported remote codecs.
	 *
	 * @param {RTCRtpCapabilities} remoteCaps - Remote capabilities.
	 * @param {Array<Number>} mandatoryCodecPayloadTypes - List of codec PT values.
	 * @param {RTCExtendedRtpCapabilities} extendedRtpCapabilities
	 *
	 * @return {Boolean}
	 */
	function getUnsupportedCodecs(remoteCaps, mandatoryCodecPayloadTypes, extendedRtpCapabilities) {
		// If not given just ignore.
		if (!Array.isArray(mandatoryCodecPayloadTypes)) return [];
	
		var unsupportedCodecs = [];
		var remoteCodecs = remoteCaps.codecs;
		var supportedCodecs = extendedRtpCapabilities.codecs;
	
		var _iteratorNormalCompletion6 = true;
		var _didIteratorError6 = false;
		var _iteratorError6 = undefined;
	
		try {
			var _loop4 = function _loop4() {
				var pt = _step6.value;
	
				if (!supportedCodecs.some(function (codec) {
					return codec.recvPayloadType === pt;
				})) {
					var unsupportedCodec = remoteCodecs.find(function (codec) {
						return codec.preferredPayloadType === pt;
					});
	
					if (!unsupportedCodec) throw new Error('mandatory codec PT ' + pt + ' not found in remote codecs');
	
					unsupportedCodecs.push(unsupportedCodec);
				}
			};
	
			for (var _iterator6 = (0, _getIterator3.default)(mandatoryCodecPayloadTypes), _step6; !(_iteratorNormalCompletion6 = (_step6 = _iterator6.next()).done); _iteratorNormalCompletion6 = true) {
				_loop4();
			}
		} catch (err) {
			_didIteratorError6 = true;
			_iteratorError6 = err;
		} finally {
			try {
				if (!_iteratorNormalCompletion6 && _iterator6.return) {
					_iterator6.return();
				}
			} finally {
				if (_didIteratorError6) {
					throw _iteratorError6;
				}
			}
		}
	
		return unsupportedCodecs;
	}
	
	/**
	 * Whether media can be sent based on the given RTP capabilities.
	 *
	 * @param {String} kind
	 * @param {RTCExtendedRtpCapabilities} extendedRtpCapabilities
	 *
	 * @return {Boolean}
	 */
	function canSend(kind, extendedRtpCapabilities) {
		return extendedRtpCapabilities.codecs.some(function (codec) {
			return codec.kind === kind;
		});
	}
	
	/**
	 * Whether the given RTP parameters can be received with the given RTP
	 * capabilities.
	 *
	 * @param {RTCRtpParameters} rtpParameters
	 * @param {RTCExtendedRtpCapabilities} extendedRtpCapabilities
	 *
	 * @return {Boolean}
	 */
	function canReceive(rtpParameters, extendedRtpCapabilities) {
		if (rtpParameters.codecs.length === 0) return false;
	
		var firstMediaCodec = rtpParameters.codecs[0];
	
		return extendedRtpCapabilities.codecs.some(function (codec) {
			return codec.recvPayloadType === firstMediaCodec.payloadType;
		});
	}
	
	/**
	 * Generate RTP parameters of the given kind for sending media.
	 * Just the first media codec per kind is considered.
	 * NOTE: muxId, encodings and rtcp fields are left empty.
	 *
	 * @param {kind} kind
	 * @param {RTCExtendedRtpCapabilities} extendedRtpCapabilities
	 *
	 * @return {RTCRtpParameters}
	 */
	function getSendingRtpParameters(kind, extendedRtpCapabilities) {
		var params = {
			muxId: null,
			codecs: [],
			headerExtensions: [],
			encodings: [],
			rtcp: {}
		};
	
		var _iteratorNormalCompletion7 = true;
		var _didIteratorError7 = false;
		var _iteratorError7 = undefined;
	
		try {
			for (var _iterator7 = (0, _getIterator3.default)(extendedRtpCapabilities.codecs), _step7; !(_iteratorNormalCompletion7 = (_step7 = _iterator7.next()).done); _iteratorNormalCompletion7 = true) {
				var capCodec = _step7.value;
	
				if (capCodec.kind !== kind) continue;
	
				var codec = {
					name: capCodec.name,
					mimeType: capCodec.mimeType,
					clockRate: capCodec.clockRate,
					payloadType: capCodec.sendPayloadType,
					channels: capCodec.channels,
					rtcpFeedback: capCodec.rtcpFeedback,
					parameters: capCodec.parameters
				};
	
				if (!codec.channels) delete codec.channels;
	
				params.codecs.push(codec);
	
				// Add RTX codec.
				if (capCodec.sendRtxPayloadType) {
					var rtxCodec = {
						name: 'rtx',
						mimeType: capCodec.kind + '/rtx',
						clockRate: capCodec.clockRate,
						payloadType: capCodec.sendRtxPayloadType,
						parameters: {
							apt: capCodec.sendPayloadType
						}
					};
	
					params.codecs.push(rtxCodec);
				}
	
				// NOTE: We assume a single media codec plus an optional RTX codec for now.
				// TODO: In the future, we need to add FEC, CN, etc, codecs.
				break;
			}
		} catch (err) {
			_didIteratorError7 = true;
			_iteratorError7 = err;
		} finally {
			try {
				if (!_iteratorNormalCompletion7 && _iterator7.return) {
					_iterator7.return();
				}
			} finally {
				if (_didIteratorError7) {
					throw _iteratorError7;
				}
			}
		}
	
		var _iteratorNormalCompletion8 = true;
		var _didIteratorError8 = false;
		var _iteratorError8 = undefined;
	
		try {
			for (var _iterator8 = (0, _getIterator3.default)(extendedRtpCapabilities.headerExtensions), _step8; !(_iteratorNormalCompletion8 = (_step8 = _iterator8.next()).done); _iteratorNormalCompletion8 = true) {
				var capExt = _step8.value;
	
				if (capExt.kind && capExt.kind !== kind) continue;
	
				var ext = {
					uri: capExt.uri,
					id: capExt.sendId
				};
	
				params.headerExtensions.push(ext);
			}
		} catch (err) {
			_didIteratorError8 = true;
			_iteratorError8 = err;
		} finally {
			try {
				if (!_iteratorNormalCompletion8 && _iterator8.return) {
					_iterator8.return();
				}
			} finally {
				if (_didIteratorError8) {
					throw _iteratorError8;
				}
			}
		}
	
		return params;
	}
	
	/**
	 * Generate RTP parameters of the given kind for receiving media.
	 * All the media codecs per kind are considered. This is useful for generating
	 * a SDP remote offer.
	 * NOTE: muxId, encodings and rtcp fields are left empty.
	 *
	 * @param {String} kind
	 * @param {RTCExtendedRtpCapabilities} extendedRtpCapabilities
	 *
	 * @return {RTCRtpParameters}
	 */
	function getReceivingFullRtpParameters(kind, extendedRtpCapabilities) {
		var params = {
			muxId: null,
			codecs: [],
			headerExtensions: [],
			encodings: [],
			rtcp: {}
		};
	
		var _iteratorNormalCompletion9 = true;
		var _didIteratorError9 = false;
		var _iteratorError9 = undefined;
	
		try {
			for (var _iterator9 = (0, _getIterator3.default)(extendedRtpCapabilities.codecs), _step9; !(_iteratorNormalCompletion9 = (_step9 = _iterator9.next()).done); _iteratorNormalCompletion9 = true) {
				var capCodec = _step9.value;
	
				if (capCodec.kind !== kind) continue;
	
				var codec = {
					name: capCodec.name,
					mimeType: capCodec.mimeType,
					clockRate: capCodec.clockRate,
					payloadType: capCodec.recvPayloadType,
					channels: capCodec.channels,
					rtcpFeedback: capCodec.rtcpFeedback,
					parameters: capCodec.parameters
				};
	
				if (!codec.channels) delete codec.channels;
	
				params.codecs.push(codec);
	
				// Add RTX codec.
				if (capCodec.recvRtxPayloadType) {
					var rtxCodec = {
						name: 'rtx',
						mimeType: capCodec.kind + '/rtx',
						clockRate: capCodec.clockRate,
						payloadType: capCodec.recvRtxPayloadType,
						parameters: {
							apt: capCodec.recvPayloadType
						}
					};
	
					params.codecs.push(rtxCodec);
				}
	
				// TODO: In the future, we need to add FEC, CN, etc, codecs.
			}
		} catch (err) {
			_didIteratorError9 = true;
			_iteratorError9 = err;
		} finally {
			try {
				if (!_iteratorNormalCompletion9 && _iterator9.return) {
					_iterator9.return();
				}
			} finally {
				if (_didIteratorError9) {
					throw _iteratorError9;
				}
			}
		}
	
		var _iteratorNormalCompletion10 = true;
		var _didIteratorError10 = false;
		var _iteratorError10 = undefined;
	
		try {
			for (var _iterator10 = (0, _getIterator3.default)(extendedRtpCapabilities.headerExtensions), _step10; !(_iteratorNormalCompletion10 = (_step10 = _iterator10.next()).done); _iteratorNormalCompletion10 = true) {
				var capExt = _step10.value;
	
				if (capExt.kind && capExt.kind !== kind) continue;
	
				var ext = {
					uri: capExt.uri,
					id: capExt.recvId
				};
	
				params.headerExtensions.push(ext);
			}
		} catch (err) {
			_didIteratorError10 = true;
			_iteratorError10 = err;
		} finally {
			try {
				if (!_iteratorNormalCompletion10 && _iterator10.return) {
					_iterator10.return();
				}
			} finally {
				if (_didIteratorError10) {
					throw _iteratorError10;
				}
			}
		}
	
		return params;
	}
	
	function matchCapCodecs(aCodec, bCodec) {
		var aMimeType = aCodec.mimeType.toLowerCase();
		var bMimeType = bCodec.mimeType.toLowerCase();
	
		if (aMimeType !== bMimeType) return false;
	
		if (aCodec.clockRate !== bCodec.clockRate) return false;
	
		if (aCodec.channels !== bCodec.channels) return false;
	
		// Match H264 parameters.
		if (aMimeType === 'video/h264') {
			var aPacketizationMode = (aCodec.parameters || {})['packetization-mode'] || 0;
			var bPacketizationMode = (bCodec.parameters || {})['packetization-mode'] || 0;
	
			if (aPacketizationMode !== bPacketizationMode) return false;
		}
	
		return true;
	}
	
	function matchCapHeaderExtensions(aExt, bExt) {
		if (aExt.kind && bExt.kind && aExt.kind !== bExt.kind) return false;
	
		if (aExt.uri !== bExt.uri) return false;
	
		return true;
	}
	
	function reduceRtcpFeedback(codecA, codecB) {
		var reducedRtcpFeedback = [];
	
		var _iteratorNormalCompletion11 = true;
		var _didIteratorError11 = false;
		var _iteratorError11 = undefined;
	
		try {
			var _loop5 = function _loop5() {
				var aFb = _step11.value;
	
				var matchingBFb = (codecB.rtcpFeedback || []).find(function (bFb) {
					return bFb.type === aFb.type && bFb.parameter === aFb.parameter;
				});
	
				if (matchingBFb) reducedRtcpFeedback.push(matchingBFb);
			};
	
			for (var _iterator11 = (0, _getIterator3.default)(codecA.rtcpFeedback || []), _step11; !(_iteratorNormalCompletion11 = (_step11 = _iterator11.next()).done); _iteratorNormalCompletion11 = true) {
				_loop5();
			}
		} catch (err) {
			_didIteratorError11 = true;
			_iteratorError11 = err;
		} finally {
			try {
				if (!_iteratorNormalCompletion11 && _iterator11.return) {
					_iterator11.return();
				}
			} finally {
				if (_didIteratorError11) {
					throw _iteratorError11;
				}
			}
		}
	
		return reducedRtcpFeedback;
	}
	
	},{"babel-runtime/core-js/get-iterator":36}],34:[function(require,module,exports){
	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
		value: true
	});
	
	var _stringify = require('babel-runtime/core-js/json/stringify');
	
	var _stringify2 = _interopRequireDefault(_stringify);
	
	exports.randomNumber = randomNumber;
	exports.clone = clone;
	
	var _randomNumber = require('random-number');
	
	var _randomNumber2 = _interopRequireDefault(_randomNumber);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	var randomNumberGenerator = _randomNumber2.default.generator({
		min: 10000000,
		max: 99999999,
		integer: true
	});
	
	/**
	 * Generates a random positive number between 10000000 and 99999999.
	 *
	 * @return {Number}
	 */
	function randomNumber() {
		return randomNumberGenerator();
	}
	
	/**
	 * Clones the given Object/Array.
	 *
	 * @param {Object|Array} obj
	 *
	 * @return {Object|Array}
	 */
	function clone(obj) {
		return JSON.parse((0, _stringify2.default)(obj));
	}
	
	},{"babel-runtime/core-js/json/stringify":38,"random-number":207}],35:[function(require,module,exports){
	module.exports = { "default": require("core-js/library/fn/array/from"), __esModule: true };
	},{"core-js/library/fn/array/from":61}],36:[function(require,module,exports){
	module.exports = { "default": require("core-js/library/fn/get-iterator"), __esModule: true };
	},{"core-js/library/fn/get-iterator":62}],37:[function(require,module,exports){
	module.exports = { "default": require("core-js/library/fn/is-iterable"), __esModule: true };
	},{"core-js/library/fn/is-iterable":63}],38:[function(require,module,exports){
	module.exports = { "default": require("core-js/library/fn/json/stringify"), __esModule: true };
	},{"core-js/library/fn/json/stringify":64}],39:[function(require,module,exports){
	module.exports = { "default": require("core-js/library/fn/map"), __esModule: true };
	},{"core-js/library/fn/map":65}],40:[function(require,module,exports){
	module.exports = { "default": require("core-js/library/fn/object/assign"), __esModule: true };
	},{"core-js/library/fn/object/assign":66}],41:[function(require,module,exports){
	module.exports = { "default": require("core-js/library/fn/object/create"), __esModule: true };
	},{"core-js/library/fn/object/create":67}],42:[function(require,module,exports){
	module.exports = { "default": require("core-js/library/fn/object/define-property"), __esModule: true };
	},{"core-js/library/fn/object/define-property":68}],43:[function(require,module,exports){
	module.exports = { "default": require("core-js/library/fn/object/get-prototype-of"), __esModule: true };
	},{"core-js/library/fn/object/get-prototype-of":69}],44:[function(require,module,exports){
	module.exports = { "default": require("core-js/library/fn/object/keys"), __esModule: true };
	},{"core-js/library/fn/object/keys":70}],45:[function(require,module,exports){
	module.exports = { "default": require("core-js/library/fn/object/set-prototype-of"), __esModule: true };
	},{"core-js/library/fn/object/set-prototype-of":71}],46:[function(require,module,exports){
	module.exports = { "default": require("core-js/library/fn/object/values"), __esModule: true };
	},{"core-js/library/fn/object/values":72}],47:[function(require,module,exports){
	module.exports = { "default": require("core-js/library/fn/promise"), __esModule: true };
	},{"core-js/library/fn/promise":73}],48:[function(require,module,exports){
	module.exports = { "default": require("core-js/library/fn/set"), __esModule: true };
	},{"core-js/library/fn/set":74}],49:[function(require,module,exports){
	module.exports = { "default": require("core-js/library/fn/symbol"), __esModule: true };
	},{"core-js/library/fn/symbol":75}],50:[function(require,module,exports){
	module.exports = { "default": require("core-js/library/fn/symbol/iterator"), __esModule: true };
	},{"core-js/library/fn/symbol/iterator":76}],51:[function(require,module,exports){
	"use strict";
	
	exports.__esModule = true;
	
	exports.default = function (instance, Constructor) {
		if (!(instance instanceof Constructor)) {
			throw new TypeError("Cannot call a class as a function");
		}
	};
	},{}],52:[function(require,module,exports){
	"use strict";
	
	exports.__esModule = true;
	
	var _defineProperty = require("../core-js/object/define-property");
	
	var _defineProperty2 = _interopRequireDefault(_defineProperty);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	exports.default = function () {
		function defineProperties(target, props) {
			for (var i = 0; i < props.length; i++) {
				var descriptor = props[i];
				descriptor.enumerable = descriptor.enumerable || false;
				descriptor.configurable = true;
				if ("value" in descriptor) descriptor.writable = true;
				(0, _defineProperty2.default)(target, descriptor.key, descriptor);
			}
		}
	
		return function (Constructor, protoProps, staticProps) {
			if (protoProps) defineProperties(Constructor.prototype, protoProps);
			if (staticProps) defineProperties(Constructor, staticProps);
			return Constructor;
		};
	}();
	},{"../core-js/object/define-property":42}],53:[function(require,module,exports){
	"use strict";
	
	exports.__esModule = true;
	
	var _assign = require("../core-js/object/assign");
	
	var _assign2 = _interopRequireDefault(_assign);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	exports.default = _assign2.default || function (target) {
		for (var i = 1; i < arguments.length; i++) {
			var source = arguments[i];
	
			for (var key in source) {
				if (Object.prototype.hasOwnProperty.call(source, key)) {
					target[key] = source[key];
				}
			}
		}
	
		return target;
	};
	},{"../core-js/object/assign":40}],54:[function(require,module,exports){
	"use strict";
	
	exports.__esModule = true;
	
	var _setPrototypeOf = require("../core-js/object/set-prototype-of");
	
	var _setPrototypeOf2 = _interopRequireDefault(_setPrototypeOf);
	
	var _create = require("../core-js/object/create");
	
	var _create2 = _interopRequireDefault(_create);
	
	var _typeof2 = require("../helpers/typeof");
	
	var _typeof3 = _interopRequireDefault(_typeof2);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	exports.default = function (subClass, superClass) {
		if (typeof superClass !== "function" && superClass !== null) {
			throw new TypeError("Super expression must either be null or a function, not " + (typeof superClass === "undefined" ? "undefined" : (0, _typeof3.default)(superClass)));
		}
	
		subClass.prototype = (0, _create2.default)(superClass && superClass.prototype, {
			constructor: {
				value: subClass,
				enumerable: false,
				writable: true,
				configurable: true
			}
		});
		if (superClass) _setPrototypeOf2.default ? (0, _setPrototypeOf2.default)(subClass, superClass) : subClass.__proto__ = superClass;
	};
	},{"../core-js/object/create":41,"../core-js/object/set-prototype-of":45,"../helpers/typeof":58}],55:[function(require,module,exports){
	"use strict";
	
	exports.__esModule = true;
	
	var _typeof2 = require("../helpers/typeof");
	
	var _typeof3 = _interopRequireDefault(_typeof2);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	exports.default = function (self, call) {
		if (!self) {
			throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
		}
	
		return call && ((typeof call === "undefined" ? "undefined" : (0, _typeof3.default)(call)) === "object" || typeof call === "function") ? call : self;
	};
	},{"../helpers/typeof":58}],56:[function(require,module,exports){
	"use strict";
	
	exports.__esModule = true;
	
	var _isIterable2 = require("../core-js/is-iterable");
	
	var _isIterable3 = _interopRequireDefault(_isIterable2);
	
	var _getIterator2 = require("../core-js/get-iterator");
	
	var _getIterator3 = _interopRequireDefault(_getIterator2);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	exports.default = function () {
		function sliceIterator(arr, i) {
			var _arr = [];
			var _n = true;
			var _d = false;
			var _e = undefined;
	
			try {
				for (var _i = (0, _getIterator3.default)(arr), _s; !(_n = (_s = _i.next()).done); _n = true) {
					_arr.push(_s.value);
	
					if (i && _arr.length === i) break;
				}
			} catch (err) {
				_d = true;
				_e = err;
			} finally {
				try {
					if (!_n && _i["return"]) _i["return"]();
				} finally {
					if (_d) throw _e;
				}
			}
	
			return _arr;
		}
	
		return function (arr, i) {
			if (Array.isArray(arr)) {
				return arr;
			} else if ((0, _isIterable3.default)(Object(arr))) {
				return sliceIterator(arr, i);
			} else {
				throw new TypeError("Invalid attempt to destructure non-iterable instance");
			}
		};
	}();
	},{"../core-js/get-iterator":36,"../core-js/is-iterable":37}],57:[function(require,module,exports){
	"use strict";
	
	exports.__esModule = true;
	
	var _from = require("../core-js/array/from");
	
	var _from2 = _interopRequireDefault(_from);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	exports.default = function (arr) {
		if (Array.isArray(arr)) {
			for (var i = 0, arr2 = Array(arr.length); i < arr.length; i++) {
				arr2[i] = arr[i];
			}
	
			return arr2;
		} else {
			return (0, _from2.default)(arr);
		}
	};
	},{"../core-js/array/from":35}],58:[function(require,module,exports){
	"use strict";
	
	exports.__esModule = true;
	
	var _iterator = require("../core-js/symbol/iterator");
	
	var _iterator2 = _interopRequireDefault(_iterator);
	
	var _symbol = require("../core-js/symbol");
	
	var _symbol2 = _interopRequireDefault(_symbol);
	
	var _typeof = typeof _symbol2.default === "function" && typeof _iterator2.default === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof _symbol2.default === "function" && obj.constructor === _symbol2.default && obj !== _symbol2.default.prototype ? "symbol" : typeof obj; };
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	exports.default = typeof _symbol2.default === "function" && _typeof(_iterator2.default) === "symbol" ? function (obj) {
		return typeof obj === "undefined" ? "undefined" : _typeof(obj);
	} : function (obj) {
		return obj && typeof _symbol2.default === "function" && obj.constructor === _symbol2.default && obj !== _symbol2.default.prototype ? "symbol" : typeof obj === "undefined" ? "undefined" : _typeof(obj);
	};
	},{"../core-js/symbol":49,"../core-js/symbol/iterator":50}],59:[function(require,module,exports){
	/*!
	 * Bowser - a browser detector
	 * https://github.com/ded/bowser
	 * MIT License | (c) Dustin Diaz 2015
	 */
	
	!function (root, name, definition) {
		if (typeof module != 'undefined' && module.exports) module.exports = definition()
		else if (typeof define == 'function' && define.amd) define(name, definition)
		else root[name] = definition()
	}(this, 'bowser', function () {
		/**
			* See useragents.js for examples of navigator.userAgent
			*/
	
		var t = true
	
		function detect(ua) {
	
			function getFirstMatch(regex) {
				var match = ua.match(regex);
				return (match && match.length > 1 && match[1]) || '';
			}
	
			function getSecondMatch(regex) {
				var match = ua.match(regex);
				return (match && match.length > 1 && match[2]) || '';
			}
	
			var iosdevice = getFirstMatch(/(ipod|iphone|ipad)/i).toLowerCase()
				, likeAndroid = /like android/i.test(ua)
				, android = !likeAndroid && /android/i.test(ua)
				, nexusMobile = /nexus\s*[0-6]\s*/i.test(ua)
				, nexusTablet = !nexusMobile && /nexus\s*[0-9]+/i.test(ua)
				, chromeos = /CrOS/.test(ua)
				, silk = /silk/i.test(ua)
				, sailfish = /sailfish/i.test(ua)
				, tizen = /tizen/i.test(ua)
				, webos = /(web|hpw)os/i.test(ua)
				, windowsphone = /windows phone/i.test(ua)
				, samsungBrowser = /SamsungBrowser/i.test(ua)
				, windows = !windowsphone && /windows/i.test(ua)
				, mac = !iosdevice && !silk && /macintosh/i.test(ua)
				, linux = !android && !sailfish && !tizen && !webos && /linux/i.test(ua)
				, edgeVersion = getSecondMatch(/edg([ea]|ios)\/(\d+(\.\d+)?)/i)
				, versionIdentifier = getFirstMatch(/version\/(\d+(\.\d+)?)/i)
				, tablet = /tablet/i.test(ua) && !/tablet pc/i.test(ua)
				, mobile = !tablet && /[^-]mobi/i.test(ua)
				, xbox = /xbox/i.test(ua)
				, result
	
			if (/opera/i.test(ua)) {
				//  an old Opera
				result = {
					name: 'Opera'
				, opera: t
				, version: versionIdentifier || getFirstMatch(/(?:opera|opr|opios)[\s\/](\d+(\.\d+)?)/i)
				}
			} else if (/opr\/|opios/i.test(ua)) {
				// a new Opera
				result = {
					name: 'Opera'
					, opera: t
					, version: getFirstMatch(/(?:opr|opios)[\s\/](\d+(\.\d+)?)/i) || versionIdentifier
				}
			}
			else if (/SamsungBrowser/i.test(ua)) {
				result = {
					name: 'Samsung Internet for Android'
					, samsungBrowser: t
					, version: versionIdentifier || getFirstMatch(/(?:SamsungBrowser)[\s\/](\d+(\.\d+)?)/i)
				}
			}
			else if (/coast/i.test(ua)) {
				result = {
					name: 'Opera Coast'
					, coast: t
					, version: versionIdentifier || getFirstMatch(/(?:coast)[\s\/](\d+(\.\d+)?)/i)
				}
			}
			else if (/yabrowser/i.test(ua)) {
				result = {
					name: 'Yandex Browser'
				, yandexbrowser: t
				, version: versionIdentifier || getFirstMatch(/(?:yabrowser)[\s\/](\d+(\.\d+)?)/i)
				}
			}
			else if (/ucbrowser/i.test(ua)) {
				result = {
						name: 'UC Browser'
					, ucbrowser: t
					, version: getFirstMatch(/(?:ucbrowser)[\s\/](\d+(?:\.\d+)+)/i)
				}
			}
			else if (/mxios/i.test(ua)) {
				result = {
					name: 'Maxthon'
					, maxthon: t
					, version: getFirstMatch(/(?:mxios)[\s\/](\d+(?:\.\d+)+)/i)
				}
			}
			else if (/epiphany/i.test(ua)) {
				result = {
					name: 'Epiphany'
					, epiphany: t
					, version: getFirstMatch(/(?:epiphany)[\s\/](\d+(?:\.\d+)+)/i)
				}
			}
			else if (/puffin/i.test(ua)) {
				result = {
					name: 'Puffin'
					, puffin: t
					, version: getFirstMatch(/(?:puffin)[\s\/](\d+(?:\.\d+)?)/i)
				}
			}
			else if (/sleipnir/i.test(ua)) {
				result = {
					name: 'Sleipnir'
					, sleipnir: t
					, version: getFirstMatch(/(?:sleipnir)[\s\/](\d+(?:\.\d+)+)/i)
				}
			}
			else if (/k-meleon/i.test(ua)) {
				result = {
					name: 'K-Meleon'
					, kMeleon: t
					, version: getFirstMatch(/(?:k-meleon)[\s\/](\d+(?:\.\d+)+)/i)
				}
			}
			else if (windowsphone) {
				result = {
					name: 'Windows Phone'
				, osname: 'Windows Phone'
				, windowsphone: t
				}
				if (edgeVersion) {
					result.msedge = t
					result.version = edgeVersion
				}
				else {
					result.msie = t
					result.version = getFirstMatch(/iemobile\/(\d+(\.\d+)?)/i)
				}
			}
			else if (/msie|trident/i.test(ua)) {
				result = {
					name: 'Internet Explorer'
				, msie: t
				, version: getFirstMatch(/(?:msie |rv:)(\d+(\.\d+)?)/i)
				}
			} else if (chromeos) {
				result = {
					name: 'Chrome'
				, osname: 'Chrome OS'
				, chromeos: t
				, chromeBook: t
				, chrome: t
				, version: getFirstMatch(/(?:chrome|crios|crmo)\/(\d+(\.\d+)?)/i)
				}
			} else if (/edg([ea]|ios)/i.test(ua)) {
				result = {
					name: 'Microsoft Edge'
				, msedge: t
				, version: edgeVersion
				}
			}
			else if (/vivaldi/i.test(ua)) {
				result = {
					name: 'Vivaldi'
					, vivaldi: t
					, version: getFirstMatch(/vivaldi\/(\d+(\.\d+)?)/i) || versionIdentifier
				}
			}
			else if (sailfish) {
				result = {
					name: 'Sailfish'
				, osname: 'Sailfish OS'
				, sailfish: t
				, version: getFirstMatch(/sailfish\s?browser\/(\d+(\.\d+)?)/i)
				}
			}
			else if (/seamonkey\//i.test(ua)) {
				result = {
					name: 'SeaMonkey'
				, seamonkey: t
				, version: getFirstMatch(/seamonkey\/(\d+(\.\d+)?)/i)
				}
			}
			else if (/firefox|iceweasel|fxios/i.test(ua)) {
				result = {
					name: 'Firefox'
				, firefox: t
				, version: getFirstMatch(/(?:firefox|iceweasel|fxios)[ \/](\d+(\.\d+)?)/i)
				}
				if (/\((mobile|tablet);[^\)]*rv:[\d\.]+\)/i.test(ua)) {
					result.firefoxos = t
					result.osname = 'Firefox OS'
				}
			}
			else if (silk) {
				result =  {
					name: 'Amazon Silk'
				, silk: t
				, version : getFirstMatch(/silk\/(\d+(\.\d+)?)/i)
				}
			}
			else if (/phantom/i.test(ua)) {
				result = {
					name: 'PhantomJS'
				, phantom: t
				, version: getFirstMatch(/phantomjs\/(\d+(\.\d+)?)/i)
				}
			}
			else if (/slimerjs/i.test(ua)) {
				result = {
					name: 'SlimerJS'
					, slimer: t
					, version: getFirstMatch(/slimerjs\/(\d+(\.\d+)?)/i)
				}
			}
			else if (/blackberry|\bbb\d+/i.test(ua) || /rim\stablet/i.test(ua)) {
				result = {
					name: 'BlackBerry'
				, osname: 'BlackBerry OS'
				, blackberry: t
				, version: versionIdentifier || getFirstMatch(/blackberry[\d]+\/(\d+(\.\d+)?)/i)
				}
			}
			else if (webos) {
				result = {
					name: 'WebOS'
				, osname: 'WebOS'
				, webos: t
				, version: versionIdentifier || getFirstMatch(/w(?:eb)?osbrowser\/(\d+(\.\d+)?)/i)
				};
				/touchpad\//i.test(ua) && (result.touchpad = t)
			}
			else if (/bada/i.test(ua)) {
				result = {
					name: 'Bada'
				, osname: 'Bada'
				, bada: t
				, version: getFirstMatch(/dolfin\/(\d+(\.\d+)?)/i)
				};
			}
			else if (tizen) {
				result = {
					name: 'Tizen'
				, osname: 'Tizen'
				, tizen: t
				, version: getFirstMatch(/(?:tizen\s?)?browser\/(\d+(\.\d+)?)/i) || versionIdentifier
				};
			}
			else if (/qupzilla/i.test(ua)) {
				result = {
					name: 'QupZilla'
					, qupzilla: t
					, version: getFirstMatch(/(?:qupzilla)[\s\/](\d+(?:\.\d+)+)/i) || versionIdentifier
				}
			}
			else if (/chromium/i.test(ua)) {
				result = {
					name: 'Chromium'
					, chromium: t
					, version: getFirstMatch(/(?:chromium)[\s\/](\d+(?:\.\d+)?)/i) || versionIdentifier
				}
			}
			else if (/chrome|crios|crmo/i.test(ua)) {
				result = {
					name: 'Chrome'
					, chrome: t
					, version: getFirstMatch(/(?:chrome|crios|crmo)\/(\d+(\.\d+)?)/i)
				}
			}
			else if (android) {
				result = {
					name: 'Android'
					, version: versionIdentifier
				}
			}
			else if (/safari|applewebkit/i.test(ua)) {
				result = {
					name: 'Safari'
				, safari: t
				}
				if (versionIdentifier) {
					result.version = versionIdentifier
				}
			}
			else if (iosdevice) {
				result = {
					name : iosdevice == 'iphone' ? 'iPhone' : iosdevice == 'ipad' ? 'iPad' : 'iPod'
				}
				// WTF: version is not part of user agent in web apps
				if (versionIdentifier) {
					result.version = versionIdentifier
				}
			}
			else if(/googlebot/i.test(ua)) {
				result = {
					name: 'Googlebot'
				, googlebot: t
				, version: getFirstMatch(/googlebot\/(\d+(\.\d+))/i) || versionIdentifier
				}
			}
			else {
				result = {
					name: getFirstMatch(/^(.*)\/(.*) /),
					version: getSecondMatch(/^(.*)\/(.*) /)
			 };
		 }
	
			// set webkit or gecko flag for browsers based on these engines
			if (!result.msedge && /(apple)?webkit/i.test(ua)) {
				if (/(apple)?webkit\/537\.36/i.test(ua)) {
					result.name = result.name || "Blink"
					result.blink = t
				} else {
					result.name = result.name || "Webkit"
					result.webkit = t
				}
				if (!result.version && versionIdentifier) {
					result.version = versionIdentifier
				}
			} else if (!result.opera && /gecko\//i.test(ua)) {
				result.name = result.name || "Gecko"
				result.gecko = t
				result.version = result.version || getFirstMatch(/gecko\/(\d+(\.\d+)?)/i)
			}
	
			// set OS flags for platforms that have multiple browsers
			if (!result.windowsphone && (android || result.silk)) {
				result.android = t
				result.osname = 'Android'
			} else if (!result.windowsphone && iosdevice) {
				result[iosdevice] = t
				result.ios = t
				result.osname = 'iOS'
			} else if (mac) {
				result.mac = t
				result.osname = 'macOS'
			} else if (xbox) {
				result.xbox = t
				result.osname = 'Xbox'
			} else if (windows) {
				result.windows = t
				result.osname = 'Windows'
			} else if (linux) {
				result.linux = t
				result.osname = 'Linux'
			}
	
			function getWindowsVersion (s) {
				switch (s) {
					case 'NT': return 'NT'
					case 'XP': return 'XP'
					case 'NT 5.0': return '2000'
					case 'NT 5.1': return 'XP'
					case 'NT 5.2': return '2003'
					case 'NT 6.0': return 'Vista'
					case 'NT 6.1': return '7'
					case 'NT 6.2': return '8'
					case 'NT 6.3': return '8.1'
					case 'NT 10.0': return '10'
					default: return undefined
				}
			}
	
			// OS version extraction
			var osVersion = '';
			if (result.windows) {
				osVersion = getWindowsVersion(getFirstMatch(/Windows ((NT|XP)( \d\d?.\d)?)/i))
			} else if (result.windowsphone) {
				osVersion = getFirstMatch(/windows phone (?:os)?\s?(\d+(\.\d+)*)/i);
			} else if (result.mac) {
				osVersion = getFirstMatch(/Mac OS X (\d+([_\.\s]\d+)*)/i);
				osVersion = osVersion.replace(/[_\s]/g, '.');
			} else if (iosdevice) {
				osVersion = getFirstMatch(/os (\d+([_\s]\d+)*) like mac os x/i);
				osVersion = osVersion.replace(/[_\s]/g, '.');
			} else if (android) {
				osVersion = getFirstMatch(/android[ \/-](\d+(\.\d+)*)/i);
			} else if (result.webos) {
				osVersion = getFirstMatch(/(?:web|hpw)os\/(\d+(\.\d+)*)/i);
			} else if (result.blackberry) {
				osVersion = getFirstMatch(/rim\stablet\sos\s(\d+(\.\d+)*)/i);
			} else if (result.bada) {
				osVersion = getFirstMatch(/bada\/(\d+(\.\d+)*)/i);
			} else if (result.tizen) {
				osVersion = getFirstMatch(/tizen[\/\s](\d+(\.\d+)*)/i);
			}
			if (osVersion) {
				result.osversion = osVersion;
			}
	
			// device type extraction
			var osMajorVersion = !result.windows && osVersion.split('.')[0];
			if (
					 tablet
				|| nexusTablet
				|| iosdevice == 'ipad'
				|| (android && (osMajorVersion == 3 || (osMajorVersion >= 4 && !mobile)))
				|| result.silk
			) {
				result.tablet = t
			} else if (
					 mobile
				|| iosdevice == 'iphone'
				|| iosdevice == 'ipod'
				|| android
				|| nexusMobile
				|| result.blackberry
				|| result.webos
				|| result.bada
			) {
				result.mobile = t
			}
	
			// Graded Browser Support
			// http://developer.yahoo.com/yui/articles/gbs
			if (result.msedge ||
					(result.msie && result.version >= 10) ||
					(result.yandexbrowser && result.version >= 15) ||
					(result.vivaldi && result.version >= 1.0) ||
					(result.chrome && result.version >= 20) ||
					(result.samsungBrowser && result.version >= 4) ||
					(result.firefox && result.version >= 20.0) ||
					(result.safari && result.version >= 6) ||
					(result.opera && result.version >= 10.0) ||
					(result.ios && result.osversion && result.osversion.split(".")[0] >= 6) ||
					(result.blackberry && result.version >= 10.1)
					|| (result.chromium && result.version >= 20)
					) {
				result.a = t;
			}
			else if ((result.msie && result.version < 10) ||
					(result.chrome && result.version < 20) ||
					(result.firefox && result.version < 20.0) ||
					(result.safari && result.version < 6) ||
					(result.opera && result.version < 10.0) ||
					(result.ios && result.osversion && result.osversion.split(".")[0] < 6)
					|| (result.chromium && result.version < 20)
					) {
				result.c = t
			} else result.x = t
	
			return result
		}
	
		var bowser = detect(typeof navigator !== 'undefined' ? navigator.userAgent || '' : '')
	
		bowser.test = function (browserList) {
			for (var i = 0; i < browserList.length; ++i) {
				var browserItem = browserList[i];
				if (typeof browserItem=== 'string') {
					if (browserItem in bowser) {
						return true;
					}
				}
			}
			return false;
		}
	
		/**
		 * Get version precisions count
		 *
		 * @example
		 *   getVersionPrecision("1.10.3") // 3
		 *
		 * @param  {string} version
		 * @return {number}
		 */
		function getVersionPrecision(version) {
			return version.split(".").length;
		}
	
		/**
		 * Array::map polyfill
		 *
		 * @param  {Array} arr
		 * @param  {Function} iterator
		 * @return {Array}
		 */
		function map(arr, iterator) {
			var result = [], i;
			if (Array.prototype.map) {
				return Array.prototype.map.call(arr, iterator);
			}
			for (i = 0; i < arr.length; i++) {
				result.push(iterator(arr[i]));
			}
			return result;
		}
	
		/**
		 * Calculate browser version weight
		 *
		 * @example
		 *   compareVersions(['1.10.2.1',  '1.8.2.1.90'])    // 1
		 *   compareVersions(['1.010.2.1', '1.09.2.1.90']);  // 1
		 *   compareVersions(['1.10.2.1',  '1.10.2.1']);     // 0
		 *   compareVersions(['1.10.2.1',  '1.0800.2']);     // -1
		 *
		 * @param  {Array<String>} versions versions to compare
		 * @return {Number} comparison result
		 */
		function compareVersions(versions) {
			// 1) get common precision for both versions, for example for "10.0" and "9" it should be 2
			var precision = Math.max(getVersionPrecision(versions[0]), getVersionPrecision(versions[1]));
			var chunks = map(versions, function (version) {
				var delta = precision - getVersionPrecision(version);
	
				// 2) "9" -> "9.0" (for precision = 2)
				version = version + new Array(delta + 1).join(".0");
	
				// 3) "9.0" -> ["000000000"", "000000009"]
				return map(version.split("."), function (chunk) {
					return new Array(20 - chunk.length).join("0") + chunk;
				}).reverse();
			});
	
			// iterate in reverse order by reversed chunks array
			while (--precision >= 0) {
				// 4) compare: "000000009" > "000000010" = false (but "9" > "10" = true)
				if (chunks[0][precision] > chunks[1][precision]) {
					return 1;
				}
				else if (chunks[0][precision] === chunks[1][precision]) {
					if (precision === 0) {
						// all version chunks are same
						return 0;
					}
				}
				else {
					return -1;
				}
			}
		}
	
		/**
		 * Check if browser is unsupported
		 *
		 * @example
		 *   bowser.isUnsupportedBrowser({
		 *     msie: "10",
		 *     firefox: "23",
		 *     chrome: "29",
		 *     safari: "5.1",
		 *     opera: "16",
		 *     phantom: "534"
		 *   });
		 *
		 * @param  {Object}  minVersions map of minimal version to browser
		 * @param  {Boolean} [strictMode = false] flag to return false if browser wasn't found in map
		 * @param  {String}  [ua] user agent string
		 * @return {Boolean}
		 */
		function isUnsupportedBrowser(minVersions, strictMode, ua) {
			var _bowser = bowser;
	
			// make strictMode param optional with ua param usage
			if (typeof strictMode === 'string') {
				ua = strictMode;
				strictMode = void(0);
			}
	
			if (strictMode === void(0)) {
				strictMode = false;
			}
			if (ua) {
				_bowser = detect(ua);
			}
	
			var version = "" + _bowser.version;
			for (var browser in minVersions) {
				if (minVersions.hasOwnProperty(browser)) {
					if (_bowser[browser]) {
						if (typeof minVersions[browser] !== 'string') {
							throw new Error('Browser version in the minVersion map should be a string: ' + browser + ': ' + String(minVersions));
						}
	
						// browser version and min supported version.
						return compareVersions([version, minVersions[browser]]) < 0;
					}
				}
			}
	
			return strictMode; // not found
		}
	
		/**
		 * Check if browser is supported
		 *
		 * @param  {Object} minVersions map of minimal version to browser
		 * @param  {Boolean} [strictMode = false] flag to return false if browser wasn't found in map
		 * @param  {String}  [ua] user agent string
		 * @return {Boolean}
		 */
		function check(minVersions, strictMode, ua) {
			return !isUnsupportedBrowser(minVersions, strictMode, ua);
		}
	
		bowser.isUnsupportedBrowser = isUnsupportedBrowser;
		bowser.compareVersions = compareVersions;
		bowser.check = check;
	
		/*
		 * Set our detect method to the main bowser object so we can
		 * reuse it to test other user agents.
		 * This is needed to implement future tests.
		 */
		bowser._detect = detect;
	
		/*
		 * Set our detect public method to the main bowser object
		 * This is needed to implement bowser in server side
		 */
		bowser.detect = detect;
		return bowser
	});
	
	},{}],60:[function(require,module,exports){
	// Copyright Joyent, Inc. and other Node contributors.
	//
	// Permission is hereby granted, free of charge, to any person obtaining a
	// copy of this software and associated documentation files (the
	// "Software"), to deal in the Software without restriction, including
	// without limitation the rights to use, copy, modify, merge, publish,
	// distribute, sublicense, and/or sell copies of the Software, and to permit
	// persons to whom the Software is furnished to do so, subject to the
	// following conditions:
	//
	// The above copyright notice and this permission notice shall be included
	// in all copies or substantial portions of the Software.
	//
	// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
	// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
	// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
	// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
	// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
	// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
	// USE OR OTHER DEALINGS IN THE SOFTWARE.
	
	var objectCreate = Object.create || objectCreatePolyfill
	var objectKeys = Object.keys || objectKeysPolyfill
	var bind = Function.prototype.bind || functionBindPolyfill
	
	function EventEmitter() {
		if (!this._events || !Object.prototype.hasOwnProperty.call(this, '_events')) {
			this._events = objectCreate(null);
			this._eventsCount = 0;
		}
	
		this._maxListeners = this._maxListeners || undefined;
	}
	module.exports = EventEmitter;
	
	// Backwards-compat with node 0.10.x
	EventEmitter.EventEmitter = EventEmitter;
	
	EventEmitter.prototype._events = undefined;
	EventEmitter.prototype._maxListeners = undefined;
	
	// By default EventEmitters will print a warning if more than 10 listeners are
	// added to it. This is a useful default which helps finding memory leaks.
	var defaultMaxListeners = 10;
	
	var hasDefineProperty;
	try {
		var o = {};
		if (Object.defineProperty) Object.defineProperty(o, 'x', { value: 0 });
		hasDefineProperty = o.x === 0;
	} catch (err) { hasDefineProperty = false }
	if (hasDefineProperty) {
		Object.defineProperty(EventEmitter, 'defaultMaxListeners', {
			enumerable: true,
			get: function() {
				return defaultMaxListeners;
			},
			set: function(arg) {
				// check whether the input is a positive number (whose value is zero or
				// greater and not a NaN).
				if (typeof arg !== 'number' || arg < 0 || arg !== arg)
					throw new TypeError('"defaultMaxListeners" must be a positive number');
				defaultMaxListeners = arg;
			}
		});
	} else {
		EventEmitter.defaultMaxListeners = defaultMaxListeners;
	}
	
	// Obviously not all Emitters should be limited to 10. This function allows
	// that to be increased. Set to zero for unlimited.
	EventEmitter.prototype.setMaxListeners = function setMaxListeners(n) {
		if (typeof n !== 'number' || n < 0 || isNaN(n))
			throw new TypeError('"n" argument must be a positive number');
		this._maxListeners = n;
		return this;
	};
	
	function $getMaxListeners(that) {
		if (that._maxListeners === undefined)
			return EventEmitter.defaultMaxListeners;
		return that._maxListeners;
	}
	
	EventEmitter.prototype.getMaxListeners = function getMaxListeners() {
		return $getMaxListeners(this);
	};
	
	// These standalone emit* functions are used to optimize calling of event
	// handlers for fast cases because emit() itself often has a variable number of
	// arguments and can be deoptimized because of that. These functions always have
	// the same number of arguments and thus do not get deoptimized, so the code
	// inside them can execute faster.
	function emitNone(handler, isFn, self) {
		if (isFn)
			handler.call(self);
		else {
			var len = handler.length;
			var listeners = arrayClone(handler, len);
			for (var i = 0; i < len; ++i)
				listeners[i].call(self);
		}
	}
	function emitOne(handler, isFn, self, arg1) {
		if (isFn)
			handler.call(self, arg1);
		else {
			var len = handler.length;
			var listeners = arrayClone(handler, len);
			for (var i = 0; i < len; ++i)
				listeners[i].call(self, arg1);
		}
	}
	function emitTwo(handler, isFn, self, arg1, arg2) {
		if (isFn)
			handler.call(self, arg1, arg2);
		else {
			var len = handler.length;
			var listeners = arrayClone(handler, len);
			for (var i = 0; i < len; ++i)
				listeners[i].call(self, arg1, arg2);
		}
	}
	function emitThree(handler, isFn, self, arg1, arg2, arg3) {
		if (isFn)
			handler.call(self, arg1, arg2, arg3);
		else {
			var len = handler.length;
			var listeners = arrayClone(handler, len);
			for (var i = 0; i < len; ++i)
				listeners[i].call(self, arg1, arg2, arg3);
		}
	}
	
	function emitMany(handler, isFn, self, args) {
		if (isFn)
			handler.apply(self, args);
		else {
			var len = handler.length;
			var listeners = arrayClone(handler, len);
			for (var i = 0; i < len; ++i)
				listeners[i].apply(self, args);
		}
	}
	
	EventEmitter.prototype.emit = function emit(type) {
		var er, handler, len, args, i, events;
		var doError = (type === 'error');
	
		events = this._events;
		if (events)
			doError = (doError && events.error == null);
		else if (!doError)
			return false;
	
		// If there is no 'error' event listener then throw.
		if (doError) {
			if (arguments.length > 1)
				er = arguments[1];
			if (er instanceof Error) {
				throw er; // Unhandled 'error' event
			} else {
				// At least give some kind of context to the user
				var err = new Error('Unhandled "error" event. (' + er + ')');
				err.context = er;
				throw err;
			}
			return false;
		}
	
		handler = events[type];
	
		if (!handler)
			return false;
	
		var isFn = typeof handler === 'function';
		len = arguments.length;
		switch (len) {
				// fast cases
			case 1:
				emitNone(handler, isFn, this);
				break;
			case 2:
				emitOne(handler, isFn, this, arguments[1]);
				break;
			case 3:
				emitTwo(handler, isFn, this, arguments[1], arguments[2]);
				break;
			case 4:
				emitThree(handler, isFn, this, arguments[1], arguments[2], arguments[3]);
				break;
				// slower
			default:
				args = new Array(len - 1);
				for (i = 1; i < len; i++)
					args[i - 1] = arguments[i];
				emitMany(handler, isFn, this, args);
		}
	
		return true;
	};
	
	function _addListener(target, type, listener, prepend) {
		var m;
		var events;
		var existing;
	
		if (typeof listener !== 'function')
			throw new TypeError('"listener" argument must be a function');
	
		events = target._events;
		if (!events) {
			events = target._events = objectCreate(null);
			target._eventsCount = 0;
		} else {
			// To avoid recursion in the case that type === "newListener"! Before
			// adding it to the listeners, first emit "newListener".
			if (events.newListener) {
				target.emit('newListener', type,
						listener.listener ? listener.listener : listener);
	
				// Re-assign `events` because a newListener handler could have caused the
				// this._events to be assigned to a new object
				events = target._events;
			}
			existing = events[type];
		}
	
		if (!existing) {
			// Optimize the case of one listener. Don't need the extra array object.
			existing = events[type] = listener;
			++target._eventsCount;
		} else {
			if (typeof existing === 'function') {
				// Adding the second element, need to change to array.
				existing = events[type] =
						prepend ? [listener, existing] : [existing, listener];
			} else {
				// If we've already got an array, just append.
				if (prepend) {
					existing.unshift(listener);
				} else {
					existing.push(listener);
				}
			}
	
			// Check for listener leak
			if (!existing.warned) {
				m = $getMaxListeners(target);
				if (m && m > 0 && existing.length > m) {
					existing.warned = true;
					var w = new Error('Possible EventEmitter memory leak detected. ' +
							existing.length + ' "' + String(type) + '" listeners ' +
							'added. Use emitter.setMaxListeners() to ' +
							'increase limit.');
					w.name = 'MaxListenersExceededWarning';
					w.emitter = target;
					w.type = type;
					w.count = existing.length;
					if (typeof console === 'object' && console.warn) {
						console.warn('%s: %s', w.name, w.message);
					}
				}
			}
		}
	
		return target;
	}
	
	EventEmitter.prototype.addListener = function addListener(type, listener) {
		return _addListener(this, type, listener, false);
	};
	
	EventEmitter.prototype.on = EventEmitter.prototype.addListener;
	
	EventEmitter.prototype.prependListener =
			function prependListener(type, listener) {
				return _addListener(this, type, listener, true);
			};
	
	function onceWrapper() {
		if (!this.fired) {
			this.target.removeListener(this.type, this.wrapFn);
			this.fired = true;
			switch (arguments.length) {
				case 0:
					return this.listener.call(this.target);
				case 1:
					return this.listener.call(this.target, arguments[0]);
				case 2:
					return this.listener.call(this.target, arguments[0], arguments[1]);
				case 3:
					return this.listener.call(this.target, arguments[0], arguments[1],
							arguments[2]);
				default:
					var args = new Array(arguments.length);
					for (var i = 0; i < args.length; ++i)
						args[i] = arguments[i];
					this.listener.apply(this.target, args);
			}
		}
	}
	
	function _onceWrap(target, type, listener) {
		var state = { fired: false, wrapFn: undefined, target: target, type: type, listener: listener };
		var wrapped = bind.call(onceWrapper, state);
		wrapped.listener = listener;
		state.wrapFn = wrapped;
		return wrapped;
	}
	
	EventEmitter.prototype.once = function once(type, listener) {
		if (typeof listener !== 'function')
			throw new TypeError('"listener" argument must be a function');
		this.on(type, _onceWrap(this, type, listener));
		return this;
	};
	
	EventEmitter.prototype.prependOnceListener =
			function prependOnceListener(type, listener) {
				if (typeof listener !== 'function')
					throw new TypeError('"listener" argument must be a function');
				this.prependListener(type, _onceWrap(this, type, listener));
				return this;
			};
	
	// Emits a 'removeListener' event if and only if the listener was removed.
	EventEmitter.prototype.removeListener =
			function removeListener(type, listener) {
				var list, events, position, i, originalListener;
	
				if (typeof listener !== 'function')
					throw new TypeError('"listener" argument must be a function');
	
				events = this._events;
				if (!events)
					return this;
	
				list = events[type];
				if (!list)
					return this;
	
				if (list === listener || list.listener === listener) {
					if (--this._eventsCount === 0)
						this._events = objectCreate(null);
					else {
						delete events[type];
						if (events.removeListener)
							this.emit('removeListener', type, list.listener || listener);
					}
				} else if (typeof list !== 'function') {
					position = -1;
	
					for (i = list.length - 1; i >= 0; i--) {
						if (list[i] === listener || list[i].listener === listener) {
							originalListener = list[i].listener;
							position = i;
							break;
						}
					}
	
					if (position < 0)
						return this;
	
					if (position === 0)
						list.shift();
					else
						spliceOne(list, position);
	
					if (list.length === 1)
						events[type] = list[0];
	
					if (events.removeListener)
						this.emit('removeListener', type, originalListener || listener);
				}
	
				return this;
			};
	
	EventEmitter.prototype.removeAllListeners =
			function removeAllListeners(type) {
				var listeners, events, i;
	
				events = this._events;
				if (!events)
					return this;
	
				// not listening for removeListener, no need to emit
				if (!events.removeListener) {
					if (arguments.length === 0) {
						this._events = objectCreate(null);
						this._eventsCount = 0;
					} else if (events[type]) {
						if (--this._eventsCount === 0)
							this._events = objectCreate(null);
						else
							delete events[type];
					}
					return this;
				}
	
				// emit removeListener for all listeners on all events
				if (arguments.length === 0) {
					var keys = objectKeys(events);
					var key;
					for (i = 0; i < keys.length; ++i) {
						key = keys[i];
						if (key === 'removeListener') continue;
						this.removeAllListeners(key);
					}
					this.removeAllListeners('removeListener');
					this._events = objectCreate(null);
					this._eventsCount = 0;
					return this;
				}
	
				listeners = events[type];
	
				if (typeof listeners === 'function') {
					this.removeListener(type, listeners);
				} else if (listeners) {
					// LIFO order
					for (i = listeners.length - 1; i >= 0; i--) {
						this.removeListener(type, listeners[i]);
					}
				}
	
				return this;
			};
	
	EventEmitter.prototype.listeners = function listeners(type) {
		var evlistener;
		var ret;
		var events = this._events;
	
		if (!events)
			ret = [];
		else {
			evlistener = events[type];
			if (!evlistener)
				ret = [];
			else if (typeof evlistener === 'function')
				ret = [evlistener.listener || evlistener];
			else
				ret = unwrapListeners(evlistener);
		}
	
		return ret;
	};
	
	EventEmitter.listenerCount = function(emitter, type) {
		if (typeof emitter.listenerCount === 'function') {
			return emitter.listenerCount(type);
		} else {
			return listenerCount.call(emitter, type);
		}
	};
	
	EventEmitter.prototype.listenerCount = listenerCount;
	function listenerCount(type) {
		var events = this._events;
	
		if (events) {
			var evlistener = events[type];
	
			if (typeof evlistener === 'function') {
				return 1;
			} else if (evlistener) {
				return evlistener.length;
			}
		}
	
		return 0;
	}
	
	EventEmitter.prototype.eventNames = function eventNames() {
		return this._eventsCount > 0 ? Reflect.ownKeys(this._events) : [];
	};
	
	// About 1.5x faster than the two-arg version of Array#splice().
	function spliceOne(list, index) {
		for (var i = index, k = i + 1, n = list.length; k < n; i += 1, k += 1)
			list[i] = list[k];
		list.pop();
	}
	
	function arrayClone(arr, n) {
		var copy = new Array(n);
		for (var i = 0; i < n; ++i)
			copy[i] = arr[i];
		return copy;
	}
	
	function unwrapListeners(arr) {
		var ret = new Array(arr.length);
		for (var i = 0; i < ret.length; ++i) {
			ret[i] = arr[i].listener || arr[i];
		}
		return ret;
	}
	
	function objectCreatePolyfill(proto) {
		var F = function() {};
		F.prototype = proto;
		return new F;
	}
	function objectKeysPolyfill(obj) {
		var keys = [];
		for (var k in obj) if (Object.prototype.hasOwnProperty.call(obj, k)) {
			keys.push(k);
		}
		return k;
	}
	function functionBindPolyfill(context) {
		var fn = this;
		return function () {
			return fn.apply(context, arguments);
		};
	}
	
	},{}],61:[function(require,module,exports){
	require('../../modules/es6.string.iterator');
	require('../../modules/es6.array.from');
	module.exports = require('../../modules/_core').Array.from;
	
	},{"../../modules/_core":91,"../../modules/es6.array.from":166,"../../modules/es6.string.iterator":178}],62:[function(require,module,exports){
	require('../modules/web.dom.iterable');
	require('../modules/es6.string.iterator');
	module.exports = require('../modules/core.get-iterator');
	
	},{"../modules/core.get-iterator":164,"../modules/es6.string.iterator":178,"../modules/web.dom.iterable":191}],63:[function(require,module,exports){
	require('../modules/web.dom.iterable');
	require('../modules/es6.string.iterator');
	module.exports = require('../modules/core.is-iterable');
	
	},{"../modules/core.is-iterable":165,"../modules/es6.string.iterator":178,"../modules/web.dom.iterable":191}],64:[function(require,module,exports){
	var core = require('../../modules/_core');
	var $JSON = core.JSON || (core.JSON = { stringify: JSON.stringify });
	module.exports = function stringify(it) { // eslint-disable-line no-unused-vars
		return $JSON.stringify.apply($JSON, arguments);
	};
	
	},{"../../modules/_core":91}],65:[function(require,module,exports){
	require('../modules/es6.object.to-string');
	require('../modules/es6.string.iterator');
	require('../modules/web.dom.iterable');
	require('../modules/es6.map');
	require('../modules/es7.map.to-json');
	require('../modules/es7.map.of');
	require('../modules/es7.map.from');
	module.exports = require('../modules/_core').Map;
	
	},{"../modules/_core":91,"../modules/es6.map":168,"../modules/es6.object.to-string":175,"../modules/es6.string.iterator":178,"../modules/es7.map.from":180,"../modules/es7.map.of":181,"../modules/es7.map.to-json":182,"../modules/web.dom.iterable":191}],66:[function(require,module,exports){
	require('../../modules/es6.object.assign');
	module.exports = require('../../modules/_core').Object.assign;
	
	},{"../../modules/_core":91,"../../modules/es6.object.assign":169}],67:[function(require,module,exports){
	require('../../modules/es6.object.create');
	var $Object = require('../../modules/_core').Object;
	module.exports = function create(P, D) {
		return $Object.create(P, D);
	};
	
	},{"../../modules/_core":91,"../../modules/es6.object.create":170}],68:[function(require,module,exports){
	require('../../modules/es6.object.define-property');
	var $Object = require('../../modules/_core').Object;
	module.exports = function defineProperty(it, key, desc) {
		return $Object.defineProperty(it, key, desc);
	};
	
	},{"../../modules/_core":91,"../../modules/es6.object.define-property":171}],69:[function(require,module,exports){
	require('../../modules/es6.object.get-prototype-of');
	module.exports = require('../../modules/_core').Object.getPrototypeOf;
	
	},{"../../modules/_core":91,"../../modules/es6.object.get-prototype-of":172}],70:[function(require,module,exports){
	require('../../modules/es6.object.keys');
	module.exports = require('../../modules/_core').Object.keys;
	
	},{"../../modules/_core":91,"../../modules/es6.object.keys":173}],71:[function(require,module,exports){
	require('../../modules/es6.object.set-prototype-of');
	module.exports = require('../../modules/_core').Object.setPrototypeOf;
	
	},{"../../modules/_core":91,"../../modules/es6.object.set-prototype-of":174}],72:[function(require,module,exports){
	require('../../modules/es7.object.values');
	module.exports = require('../../modules/_core').Object.values;
	
	},{"../../modules/_core":91,"../../modules/es7.object.values":183}],73:[function(require,module,exports){
	require('../modules/es6.object.to-string');
	require('../modules/es6.string.iterator');
	require('../modules/web.dom.iterable');
	require('../modules/es6.promise');
	require('../modules/es7.promise.finally');
	require('../modules/es7.promise.try');
	module.exports = require('../modules/_core').Promise;
	
	},{"../modules/_core":91,"../modules/es6.object.to-string":175,"../modules/es6.promise":176,"../modules/es6.string.iterator":178,"../modules/es7.promise.finally":184,"../modules/es7.promise.try":185,"../modules/web.dom.iterable":191}],74:[function(require,module,exports){
	require('../modules/es6.object.to-string');
	require('../modules/es6.string.iterator');
	require('../modules/web.dom.iterable');
	require('../modules/es6.set');
	require('../modules/es7.set.to-json');
	require('../modules/es7.set.of');
	require('../modules/es7.set.from');
	module.exports = require('../modules/_core').Set;
	
	},{"../modules/_core":91,"../modules/es6.object.to-string":175,"../modules/es6.set":177,"../modules/es6.string.iterator":178,"../modules/es7.set.from":186,"../modules/es7.set.of":187,"../modules/es7.set.to-json":188,"../modules/web.dom.iterable":191}],75:[function(require,module,exports){
	require('../../modules/es6.symbol');
	require('../../modules/es6.object.to-string');
	require('../../modules/es7.symbol.async-iterator');
	require('../../modules/es7.symbol.observable');
	module.exports = require('../../modules/_core').Symbol;
	
	},{"../../modules/_core":91,"../../modules/es6.object.to-string":175,"../../modules/es6.symbol":179,"../../modules/es7.symbol.async-iterator":189,"../../modules/es7.symbol.observable":190}],76:[function(require,module,exports){
	require('../../modules/es6.string.iterator');
	require('../../modules/web.dom.iterable');
	module.exports = require('../../modules/_wks-ext').f('iterator');
	
	},{"../../modules/_wks-ext":161,"../../modules/es6.string.iterator":178,"../../modules/web.dom.iterable":191}],77:[function(require,module,exports){
	module.exports = function (it) {
		if (typeof it != 'function') throw TypeError(it + ' is not a function!');
		return it;
	};
	
	},{}],78:[function(require,module,exports){
	module.exports = function () { /* empty */ };
	
	},{}],79:[function(require,module,exports){
	module.exports = function (it, Constructor, name, forbiddenField) {
		if (!(it instanceof Constructor) || (forbiddenField !== undefined && forbiddenField in it)) {
			throw TypeError(name + ': incorrect invocation!');
		} return it;
	};
	
	},{}],80:[function(require,module,exports){
	var isObject = require('./_is-object');
	module.exports = function (it) {
		if (!isObject(it)) throw TypeError(it + ' is not an object!');
		return it;
	};
	
	},{"./_is-object":111}],81:[function(require,module,exports){
	var forOf = require('./_for-of');
	
	module.exports = function (iter, ITERATOR) {
		var result = [];
		forOf(iter, false, result.push, result, ITERATOR);
		return result;
	};
	
	},{"./_for-of":101}],82:[function(require,module,exports){
	// false -> Array#indexOf
	// true  -> Array#includes
	var toIObject = require('./_to-iobject');
	var toLength = require('./_to-length');
	var toAbsoluteIndex = require('./_to-absolute-index');
	module.exports = function (IS_INCLUDES) {
		return function ($this, el, fromIndex) {
			var O = toIObject($this);
			var length = toLength(O.length);
			var index = toAbsoluteIndex(fromIndex, length);
			var value;
			// Array#includes uses SameValueZero equality algorithm
			// eslint-disable-next-line no-self-compare
			if (IS_INCLUDES && el != el) while (length > index) {
				value = O[index++];
				// eslint-disable-next-line no-self-compare
				if (value != value) return true;
			// Array#indexOf ignores holes, Array#includes - not
			} else for (;length > index; index++) if (IS_INCLUDES || index in O) {
				if (O[index] === el) return IS_INCLUDES || index || 0;
			} return !IS_INCLUDES && -1;
		};
	};
	
	},{"./_to-absolute-index":152,"./_to-iobject":154,"./_to-length":155}],83:[function(require,module,exports){
	// 0 -> Array#forEach
	// 1 -> Array#map
	// 2 -> Array#filter
	// 3 -> Array#some
	// 4 -> Array#every
	// 5 -> Array#find
	// 6 -> Array#findIndex
	var ctx = require('./_ctx');
	var IObject = require('./_iobject');
	var toObject = require('./_to-object');
	var toLength = require('./_to-length');
	var asc = require('./_array-species-create');
	module.exports = function (TYPE, $create) {
		var IS_MAP = TYPE == 1;
		var IS_FILTER = TYPE == 2;
		var IS_SOME = TYPE == 3;
		var IS_EVERY = TYPE == 4;
		var IS_FIND_INDEX = TYPE == 6;
		var NO_HOLES = TYPE == 5 || IS_FIND_INDEX;
		var create = $create || asc;
		return function ($this, callbackfn, that) {
			var O = toObject($this);
			var self = IObject(O);
			var f = ctx(callbackfn, that, 3);
			var length = toLength(self.length);
			var index = 0;
			var result = IS_MAP ? create($this, length) : IS_FILTER ? create($this, 0) : undefined;
			var val, res;
			for (;length > index; index++) if (NO_HOLES || index in self) {
				val = self[index];
				res = f(val, index, O);
				if (TYPE) {
					if (IS_MAP) result[index] = res;   // map
					else if (res) switch (TYPE) {
						case 3: return true;             // some
						case 5: return val;              // find
						case 6: return index;            // findIndex
						case 2: result.push(val);        // filter
					} else if (IS_EVERY) return false; // every
				}
			}
			return IS_FIND_INDEX ? -1 : IS_SOME || IS_EVERY ? IS_EVERY : result;
		};
	};
	
	},{"./_array-species-create":85,"./_ctx":93,"./_iobject":108,"./_to-length":155,"./_to-object":156}],84:[function(require,module,exports){
	var isObject = require('./_is-object');
	var isArray = require('./_is-array');
	var SPECIES = require('./_wks')('species');
	
	module.exports = function (original) {
		var C;
		if (isArray(original)) {
			C = original.constructor;
			// cross-realm fallback
			if (typeof C == 'function' && (C === Array || isArray(C.prototype))) C = undefined;
			if (isObject(C)) {
				C = C[SPECIES];
				if (C === null) C = undefined;
			}
		} return C === undefined ? Array : C;
	};
	
	},{"./_is-array":110,"./_is-object":111,"./_wks":162}],85:[function(require,module,exports){
	// 9.4.2.3 ArraySpeciesCreate(originalArray, length)
	var speciesConstructor = require('./_array-species-constructor');
	
	module.exports = function (original, length) {
		return new (speciesConstructor(original))(length);
	};
	
	},{"./_array-species-constructor":84}],86:[function(require,module,exports){
	// getting tag from 19.1.3.6 Object.prototype.toString()
	var cof = require('./_cof');
	var TAG = require('./_wks')('toStringTag');
	// ES3 wrong here
	var ARG = cof(function () { return arguments; }()) == 'Arguments';
	
	// fallback for IE11 Script Access Denied error
	var tryGet = function (it, key) {
		try {
			return it[key];
		} catch (e) { /* empty */ }
	};
	
	module.exports = function (it) {
		var O, T, B;
		return it === undefined ? 'Undefined' : it === null ? 'Null'
			// @@toStringTag case
			: typeof (T = tryGet(O = Object(it), TAG)) == 'string' ? T
			// builtinTag case
			: ARG ? cof(O)
			// ES3 arguments fallback
			: (B = cof(O)) == 'Object' && typeof O.callee == 'function' ? 'Arguments' : B;
	};
	
	},{"./_cof":87,"./_wks":162}],87:[function(require,module,exports){
	var toString = {}.toString;
	
	module.exports = function (it) {
		return toString.call(it).slice(8, -1);
	};
	
	},{}],88:[function(require,module,exports){
	'use strict';
	var dP = require('./_object-dp').f;
	var create = require('./_object-create');
	var redefineAll = require('./_redefine-all');
	var ctx = require('./_ctx');
	var anInstance = require('./_an-instance');
	var forOf = require('./_for-of');
	var $iterDefine = require('./_iter-define');
	var step = require('./_iter-step');
	var setSpecies = require('./_set-species');
	var DESCRIPTORS = require('./_descriptors');
	var fastKey = require('./_meta').fastKey;
	var validate = require('./_validate-collection');
	var SIZE = DESCRIPTORS ? '_s' : 'size';
	
	var getEntry = function (that, key) {
		// fast case
		var index = fastKey(key);
		var entry;
		if (index !== 'F') return that._i[index];
		// frozen object case
		for (entry = that._f; entry; entry = entry.n) {
			if (entry.k == key) return entry;
		}
	};
	
	module.exports = {
		getConstructor: function (wrapper, NAME, IS_MAP, ADDER) {
			var C = wrapper(function (that, iterable) {
				anInstance(that, C, NAME, '_i');
				that._t = NAME;         // collection type
				that._i = create(null); // index
				that._f = undefined;    // first entry
				that._l = undefined;    // last entry
				that[SIZE] = 0;         // size
				if (iterable != undefined) forOf(iterable, IS_MAP, that[ADDER], that);
			});
			redefineAll(C.prototype, {
				// 23.1.3.1 Map.prototype.clear()
				// 23.2.3.2 Set.prototype.clear()
				clear: function clear() {
					for (var that = validate(this, NAME), data = that._i, entry = that._f; entry; entry = entry.n) {
						entry.r = true;
						if (entry.p) entry.p = entry.p.n = undefined;
						delete data[entry.i];
					}
					that._f = that._l = undefined;
					that[SIZE] = 0;
				},
				// 23.1.3.3 Map.prototype.delete(key)
				// 23.2.3.4 Set.prototype.delete(value)
				'delete': function (key) {
					var that = validate(this, NAME);
					var entry = getEntry(that, key);
					if (entry) {
						var next = entry.n;
						var prev = entry.p;
						delete that._i[entry.i];
						entry.r = true;
						if (prev) prev.n = next;
						if (next) next.p = prev;
						if (that._f == entry) that._f = next;
						if (that._l == entry) that._l = prev;
						that[SIZE]--;
					} return !!entry;
				},
				// 23.2.3.6 Set.prototype.forEach(callbackfn, thisArg = undefined)
				// 23.1.3.5 Map.prototype.forEach(callbackfn, thisArg = undefined)
				forEach: function forEach(callbackfn /* , that = undefined */) {
					validate(this, NAME);
					var f = ctx(callbackfn, arguments.length > 1 ? arguments[1] : undefined, 3);
					var entry;
					while (entry = entry ? entry.n : this._f) {
						f(entry.v, entry.k, this);
						// revert to the last existing entry
						while (entry && entry.r) entry = entry.p;
					}
				},
				// 23.1.3.7 Map.prototype.has(key)
				// 23.2.3.7 Set.prototype.has(value)
				has: function has(key) {
					return !!getEntry(validate(this, NAME), key);
				}
			});
			if (DESCRIPTORS) dP(C.prototype, 'size', {
				get: function () {
					return validate(this, NAME)[SIZE];
				}
			});
			return C;
		},
		def: function (that, key, value) {
			var entry = getEntry(that, key);
			var prev, index;
			// change existing entry
			if (entry) {
				entry.v = value;
			// create new entry
			} else {
				that._l = entry = {
					i: index = fastKey(key, true), // <- index
					k: key,                        // <- key
					v: value,                      // <- value
					p: prev = that._l,             // <- previous entry
					n: undefined,                  // <- next entry
					r: false                       // <- removed
				};
				if (!that._f) that._f = entry;
				if (prev) prev.n = entry;
				that[SIZE]++;
				// add to index
				if (index !== 'F') that._i[index] = entry;
			} return that;
		},
		getEntry: getEntry,
		setStrong: function (C, NAME, IS_MAP) {
			// add .keys, .values, .entries, [@@iterator]
			// 23.1.3.4, 23.1.3.8, 23.1.3.11, 23.1.3.12, 23.2.3.5, 23.2.3.8, 23.2.3.10, 23.2.3.11
			$iterDefine(C, NAME, function (iterated, kind) {
				this._t = validate(iterated, NAME); // target
				this._k = kind;                     // kind
				this._l = undefined;                // previous
			}, function () {
				var that = this;
				var kind = that._k;
				var entry = that._l;
				// revert to the last existing entry
				while (entry && entry.r) entry = entry.p;
				// get next entry
				if (!that._t || !(that._l = entry = entry ? entry.n : that._t._f)) {
					// or finish the iteration
					that._t = undefined;
					return step(1);
				}
				// return step by kind
				if (kind == 'keys') return step(0, entry.k);
				if (kind == 'values') return step(0, entry.v);
				return step(0, [entry.k, entry.v]);
			}, IS_MAP ? 'entries' : 'values', !IS_MAP, true);
	
			// add [@@species], 23.1.2.2, 23.2.2.2
			setSpecies(NAME);
		}
	};
	
	},{"./_an-instance":79,"./_ctx":93,"./_descriptors":95,"./_for-of":101,"./_iter-define":114,"./_iter-step":116,"./_meta":120,"./_object-create":124,"./_object-dp":125,"./_redefine-all":140,"./_set-species":145,"./_validate-collection":159}],89:[function(require,module,exports){
	// https://github.com/DavidBruant/Map-Set.prototype.toJSON
	var classof = require('./_classof');
	var from = require('./_array-from-iterable');
	module.exports = function (NAME) {
		return function toJSON() {
			if (classof(this) != NAME) throw TypeError(NAME + "#toJSON isn't generic");
			return from(this);
		};
	};
	
	},{"./_array-from-iterable":81,"./_classof":86}],90:[function(require,module,exports){
	'use strict';
	var global = require('./_global');
	var $export = require('./_export');
	var meta = require('./_meta');
	var fails = require('./_fails');
	var hide = require('./_hide');
	var redefineAll = require('./_redefine-all');
	var forOf = require('./_for-of');
	var anInstance = require('./_an-instance');
	var isObject = require('./_is-object');
	var setToStringTag = require('./_set-to-string-tag');
	var dP = require('./_object-dp').f;
	var each = require('./_array-methods')(0);
	var DESCRIPTORS = require('./_descriptors');
	
	module.exports = function (NAME, wrapper, methods, common, IS_MAP, IS_WEAK) {
		var Base = global[NAME];
		var C = Base;
		var ADDER = IS_MAP ? 'set' : 'add';
		var proto = C && C.prototype;
		var O = {};
		if (!DESCRIPTORS || typeof C != 'function' || !(IS_WEAK || proto.forEach && !fails(function () {
			new C().entries().next();
		}))) {
			// create collection constructor
			C = common.getConstructor(wrapper, NAME, IS_MAP, ADDER);
			redefineAll(C.prototype, methods);
			meta.NEED = true;
		} else {
			C = wrapper(function (target, iterable) {
				anInstance(target, C, NAME, '_c');
				target._c = new Base();
				if (iterable != undefined) forOf(iterable, IS_MAP, target[ADDER], target);
			});
			each('add,clear,delete,forEach,get,has,set,keys,values,entries,toJSON'.split(','), function (KEY) {
				var IS_ADDER = KEY == 'add' || KEY == 'set';
				if (KEY in proto && !(IS_WEAK && KEY == 'clear')) hide(C.prototype, KEY, function (a, b) {
					anInstance(this, C, KEY);
					if (!IS_ADDER && IS_WEAK && !isObject(a)) return KEY == 'get' ? undefined : false;
					var result = this._c[KEY](a === 0 ? 0 : a, b);
					return IS_ADDER ? this : result;
				});
			});
			IS_WEAK || dP(C.prototype, 'size', {
				get: function () {
					return this._c.size;
				}
			});
		}
	
		setToStringTag(C, NAME);
	
		O[NAME] = C;
		$export($export.G + $export.W + $export.F, O);
	
		if (!IS_WEAK) common.setStrong(C, NAME, IS_MAP);
	
		return C;
	};
	
	},{"./_an-instance":79,"./_array-methods":83,"./_descriptors":95,"./_export":99,"./_fails":100,"./_for-of":101,"./_global":102,"./_hide":104,"./_is-object":111,"./_meta":120,"./_object-dp":125,"./_redefine-all":140,"./_set-to-string-tag":146}],91:[function(require,module,exports){
	var core = module.exports = { version: '2.5.0' };
	if (typeof __e == 'number') __e = core; // eslint-disable-line no-undef
	
	},{}],92:[function(require,module,exports){
	'use strict';
	var $defineProperty = require('./_object-dp');
	var createDesc = require('./_property-desc');
	
	module.exports = function (object, index, value) {
		if (index in object) $defineProperty.f(object, index, createDesc(0, value));
		else object[index] = value;
	};
	
	},{"./_object-dp":125,"./_property-desc":139}],93:[function(require,module,exports){
	// optional / simple context binding
	var aFunction = require('./_a-function');
	module.exports = function (fn, that, length) {
		aFunction(fn);
		if (that === undefined) return fn;
		switch (length) {
			case 1: return function (a) {
				return fn.call(that, a);
			};
			case 2: return function (a, b) {
				return fn.call(that, a, b);
			};
			case 3: return function (a, b, c) {
				return fn.call(that, a, b, c);
			};
		}
		return function (/* ...args */) {
			return fn.apply(that, arguments);
		};
	};
	
	},{"./_a-function":77}],94:[function(require,module,exports){
	// 7.2.1 RequireObjectCoercible(argument)
	module.exports = function (it) {
		if (it == undefined) throw TypeError("Can't call method on  " + it);
		return it;
	};
	
	},{}],95:[function(require,module,exports){
	// Thank's IE8 for his funny defineProperty
	module.exports = !require('./_fails')(function () {
		return Object.defineProperty({}, 'a', { get: function () { return 7; } }).a != 7;
	});
	
	},{"./_fails":100}],96:[function(require,module,exports){
	var isObject = require('./_is-object');
	var document = require('./_global').document;
	// typeof document.createElement is 'object' in old IE
	var is = isObject(document) && isObject(document.createElement);
	module.exports = function (it) {
		return is ? document.createElement(it) : {};
	};
	
	},{"./_global":102,"./_is-object":111}],97:[function(require,module,exports){
	// IE 8- don't enum bug keys
	module.exports = (
		'constructor,hasOwnProperty,isPrototypeOf,propertyIsEnumerable,toLocaleString,toString,valueOf'
	).split(',');
	
	},{}],98:[function(require,module,exports){
	// all enumerable object keys, includes symbols
	var getKeys = require('./_object-keys');
	var gOPS = require('./_object-gops');
	var pIE = require('./_object-pie');
	module.exports = function (it) {
		var result = getKeys(it);
		var getSymbols = gOPS.f;
		if (getSymbols) {
			var symbols = getSymbols(it);
			var isEnum = pIE.f;
			var i = 0;
			var key;
			while (symbols.length > i) if (isEnum.call(it, key = symbols[i++])) result.push(key);
		} return result;
	};
	
	},{"./_object-gops":130,"./_object-keys":133,"./_object-pie":134}],99:[function(require,module,exports){
	var global = require('./_global');
	var core = require('./_core');
	var ctx = require('./_ctx');
	var hide = require('./_hide');
	var PROTOTYPE = 'prototype';
	
	var $export = function (type, name, source) {
		var IS_FORCED = type & $export.F;
		var IS_GLOBAL = type & $export.G;
		var IS_STATIC = type & $export.S;
		var IS_PROTO = type & $export.P;
		var IS_BIND = type & $export.B;
		var IS_WRAP = type & $export.W;
		var exports = IS_GLOBAL ? core : core[name] || (core[name] = {});
		var expProto = exports[PROTOTYPE];
		var target = IS_GLOBAL ? global : IS_STATIC ? global[name] : (global[name] || {})[PROTOTYPE];
		var key, own, out;
		if (IS_GLOBAL) source = name;
		for (key in source) {
			// contains in native
			own = !IS_FORCED && target && target[key] !== undefined;
			if (own && key in exports) continue;
			// export native or passed
			out = own ? target[key] : source[key];
			// prevent global pollution for namespaces
			exports[key] = IS_GLOBAL && typeof target[key] != 'function' ? source[key]
			// bind timers to global for call from export context
			: IS_BIND && own ? ctx(out, global)
			// wrap global constructors for prevent change them in library
			: IS_WRAP && target[key] == out ? (function (C) {
				var F = function (a, b, c) {
					if (this instanceof C) {
						switch (arguments.length) {
							case 0: return new C();
							case 1: return new C(a);
							case 2: return new C(a, b);
						} return new C(a, b, c);
					} return C.apply(this, arguments);
				};
				F[PROTOTYPE] = C[PROTOTYPE];
				return F;
			// make static versions for prototype methods
			})(out) : IS_PROTO && typeof out == 'function' ? ctx(Function.call, out) : out;
			// export proto methods to core.%CONSTRUCTOR%.methods.%NAME%
			if (IS_PROTO) {
				(exports.virtual || (exports.virtual = {}))[key] = out;
				// export proto methods to core.%CONSTRUCTOR%.prototype.%NAME%
				if (type & $export.R && expProto && !expProto[key]) hide(expProto, key, out);
			}
		}
	};
	// type bitmap
	$export.F = 1;   // forced
	$export.G = 2;   // global
	$export.S = 4;   // static
	$export.P = 8;   // proto
	$export.B = 16;  // bind
	$export.W = 32;  // wrap
	$export.U = 64;  // safe
	$export.R = 128; // real proto method for `library`
	module.exports = $export;
	
	},{"./_core":91,"./_ctx":93,"./_global":102,"./_hide":104}],100:[function(require,module,exports){
	module.exports = function (exec) {
		try {
			return !!exec();
		} catch (e) {
			return true;
		}
	};
	
	},{}],101:[function(require,module,exports){
	var ctx = require('./_ctx');
	var call = require('./_iter-call');
	var isArrayIter = require('./_is-array-iter');
	var anObject = require('./_an-object');
	var toLength = require('./_to-length');
	var getIterFn = require('./core.get-iterator-method');
	var BREAK = {};
	var RETURN = {};
	var exports = module.exports = function (iterable, entries, fn, that, ITERATOR) {
		var iterFn = ITERATOR ? function () { return iterable; } : getIterFn(iterable);
		var f = ctx(fn, that, entries ? 2 : 1);
		var index = 0;
		var length, step, iterator, result;
		if (typeof iterFn != 'function') throw TypeError(iterable + ' is not iterable!');
		// fast case for arrays with default iterator
		if (isArrayIter(iterFn)) for (length = toLength(iterable.length); length > index; index++) {
			result = entries ? f(anObject(step = iterable[index])[0], step[1]) : f(iterable[index]);
			if (result === BREAK || result === RETURN) return result;
		} else for (iterator = iterFn.call(iterable); !(step = iterator.next()).done;) {
			result = call(iterator, f, step.value, entries);
			if (result === BREAK || result === RETURN) return result;
		}
	};
	exports.BREAK = BREAK;
	exports.RETURN = RETURN;
	
	},{"./_an-object":80,"./_ctx":93,"./_is-array-iter":109,"./_iter-call":112,"./_to-length":155,"./core.get-iterator-method":163}],102:[function(require,module,exports){
	// https://github.com/zloirock/core-js/issues/86#issuecomment-115759028
	var global = module.exports = typeof window != 'undefined' && window.Math == Math
		? window : typeof self != 'undefined' && self.Math == Math ? self
		// eslint-disable-next-line no-new-func
		: Function('return this')();
	if (typeof __g == 'number') __g = global; // eslint-disable-line no-undef
	
	},{}],103:[function(require,module,exports){
	var hasOwnProperty = {}.hasOwnProperty;
	module.exports = function (it, key) {
		return hasOwnProperty.call(it, key);
	};
	
	},{}],104:[function(require,module,exports){
	var dP = require('./_object-dp');
	var createDesc = require('./_property-desc');
	module.exports = require('./_descriptors') ? function (object, key, value) {
		return dP.f(object, key, createDesc(1, value));
	} : function (object, key, value) {
		object[key] = value;
		return object;
	};
	
	},{"./_descriptors":95,"./_object-dp":125,"./_property-desc":139}],105:[function(require,module,exports){
	var document = require('./_global').document;
	module.exports = document && document.documentElement;
	
	},{"./_global":102}],106:[function(require,module,exports){
	module.exports = !require('./_descriptors') && !require('./_fails')(function () {
		return Object.defineProperty(require('./_dom-create')('div'), 'a', { get: function () { return 7; } }).a != 7;
	});
	
	},{"./_descriptors":95,"./_dom-create":96,"./_fails":100}],107:[function(require,module,exports){
	// fast apply, http://jsperf.lnkit.com/fast-apply/5
	module.exports = function (fn, args, that) {
		var un = that === undefined;
		switch (args.length) {
			case 0: return un ? fn()
												: fn.call(that);
			case 1: return un ? fn(args[0])
												: fn.call(that, args[0]);
			case 2: return un ? fn(args[0], args[1])
												: fn.call(that, args[0], args[1]);
			case 3: return un ? fn(args[0], args[1], args[2])
												: fn.call(that, args[0], args[1], args[2]);
			case 4: return un ? fn(args[0], args[1], args[2], args[3])
												: fn.call(that, args[0], args[1], args[2], args[3]);
		} return fn.apply(that, args);
	};
	
	},{}],108:[function(require,module,exports){
	// fallback for non-array-like ES3 and non-enumerable old V8 strings
	var cof = require('./_cof');
	// eslint-disable-next-line no-prototype-builtins
	module.exports = Object('z').propertyIsEnumerable(0) ? Object : function (it) {
		return cof(it) == 'String' ? it.split('') : Object(it);
	};
	
	},{"./_cof":87}],109:[function(require,module,exports){
	// check on default Array iterator
	var Iterators = require('./_iterators');
	var ITERATOR = require('./_wks')('iterator');
	var ArrayProto = Array.prototype;
	
	module.exports = function (it) {
		return it !== undefined && (Iterators.Array === it || ArrayProto[ITERATOR] === it);
	};
	
	},{"./_iterators":117,"./_wks":162}],110:[function(require,module,exports){
	// 7.2.2 IsArray(argument)
	var cof = require('./_cof');
	module.exports = Array.isArray || function isArray(arg) {
		return cof(arg) == 'Array';
	};
	
	},{"./_cof":87}],111:[function(require,module,exports){
	module.exports = function (it) {
		return typeof it === 'object' ? it !== null : typeof it === 'function';
	};
	
	},{}],112:[function(require,module,exports){
	// call something on iterator step with safe closing on error
	var anObject = require('./_an-object');
	module.exports = function (iterator, fn, value, entries) {
		try {
			return entries ? fn(anObject(value)[0], value[1]) : fn(value);
		// 7.4.6 IteratorClose(iterator, completion)
		} catch (e) {
			var ret = iterator['return'];
			if (ret !== undefined) anObject(ret.call(iterator));
			throw e;
		}
	};
	
	},{"./_an-object":80}],113:[function(require,module,exports){
	'use strict';
	var create = require('./_object-create');
	var descriptor = require('./_property-desc');
	var setToStringTag = require('./_set-to-string-tag');
	var IteratorPrototype = {};
	
	// 25.1.2.1.1 %IteratorPrototype%[@@iterator]()
	require('./_hide')(IteratorPrototype, require('./_wks')('iterator'), function () { return this; });
	
	module.exports = function (Constructor, NAME, next) {
		Constructor.prototype = create(IteratorPrototype, { next: descriptor(1, next) });
		setToStringTag(Constructor, NAME + ' Iterator');
	};
	
	},{"./_hide":104,"./_object-create":124,"./_property-desc":139,"./_set-to-string-tag":146,"./_wks":162}],114:[function(require,module,exports){
	'use strict';
	var LIBRARY = require('./_library');
	var $export = require('./_export');
	var redefine = require('./_redefine');
	var hide = require('./_hide');
	var has = require('./_has');
	var Iterators = require('./_iterators');
	var $iterCreate = require('./_iter-create');
	var setToStringTag = require('./_set-to-string-tag');
	var getPrototypeOf = require('./_object-gpo');
	var ITERATOR = require('./_wks')('iterator');
	var BUGGY = !([].keys && 'next' in [].keys()); // Safari has buggy iterators w/o `next`
	var FF_ITERATOR = '@@iterator';
	var KEYS = 'keys';
	var VALUES = 'values';
	
	var returnThis = function () { return this; };
	
	module.exports = function (Base, NAME, Constructor, next, DEFAULT, IS_SET, FORCED) {
		$iterCreate(Constructor, NAME, next);
		var getMethod = function (kind) {
			if (!BUGGY && kind in proto) return proto[kind];
			switch (kind) {
				case KEYS: return function keys() { return new Constructor(this, kind); };
				case VALUES: return function values() { return new Constructor(this, kind); };
			} return function entries() { return new Constructor(this, kind); };
		};
		var TAG = NAME + ' Iterator';
		var DEF_VALUES = DEFAULT == VALUES;
		var VALUES_BUG = false;
		var proto = Base.prototype;
		var $native = proto[ITERATOR] || proto[FF_ITERATOR] || DEFAULT && proto[DEFAULT];
		var $default = $native || getMethod(DEFAULT);
		var $entries = DEFAULT ? !DEF_VALUES ? $default : getMethod('entries') : undefined;
		var $anyNative = NAME == 'Array' ? proto.entries || $native : $native;
		var methods, key, IteratorPrototype;
		// Fix native
		if ($anyNative) {
			IteratorPrototype = getPrototypeOf($anyNative.call(new Base()));
			if (IteratorPrototype !== Object.prototype && IteratorPrototype.next) {
				// Set @@toStringTag to native iterators
				setToStringTag(IteratorPrototype, TAG, true);
				// fix for some old engines
				if (!LIBRARY && !has(IteratorPrototype, ITERATOR)) hide(IteratorPrototype, ITERATOR, returnThis);
			}
		}
		// fix Array#{values, @@iterator}.name in V8 / FF
		if (DEF_VALUES && $native && $native.name !== VALUES) {
			VALUES_BUG = true;
			$default = function values() { return $native.call(this); };
		}
		// Define iterator
		if ((!LIBRARY || FORCED) && (BUGGY || VALUES_BUG || !proto[ITERATOR])) {
			hide(proto, ITERATOR, $default);
		}
		// Plug for library
		Iterators[NAME] = $default;
		Iterators[TAG] = returnThis;
		if (DEFAULT) {
			methods = {
				values: DEF_VALUES ? $default : getMethod(VALUES),
				keys: IS_SET ? $default : getMethod(KEYS),
				entries: $entries
			};
			if (FORCED) for (key in methods) {
				if (!(key in proto)) redefine(proto, key, methods[key]);
			} else $export($export.P + $export.F * (BUGGY || VALUES_BUG), NAME, methods);
		}
		return methods;
	};
	
	},{"./_export":99,"./_has":103,"./_hide":104,"./_iter-create":113,"./_iterators":117,"./_library":119,"./_object-gpo":131,"./_redefine":141,"./_set-to-string-tag":146,"./_wks":162}],115:[function(require,module,exports){
	var ITERATOR = require('./_wks')('iterator');
	var SAFE_CLOSING = false;
	
	try {
		var riter = [7][ITERATOR]();
		riter['return'] = function () { SAFE_CLOSING = true; };
		// eslint-disable-next-line no-throw-literal
		Array.from(riter, function () { throw 2; });
	} catch (e) { /* empty */ }
	
	module.exports = function (exec, skipClosing) {
		if (!skipClosing && !SAFE_CLOSING) return false;
		var safe = false;
		try {
			var arr = [7];
			var iter = arr[ITERATOR]();
			iter.next = function () { return { done: safe = true }; };
			arr[ITERATOR] = function () { return iter; };
			exec(arr);
		} catch (e) { /* empty */ }
		return safe;
	};
	
	},{"./_wks":162}],116:[function(require,module,exports){
	module.exports = function (done, value) {
		return { value: value, done: !!done };
	};
	
	},{}],117:[function(require,module,exports){
	module.exports = {};
	
	},{}],118:[function(require,module,exports){
	var getKeys = require('./_object-keys');
	var toIObject = require('./_to-iobject');
	module.exports = function (object, el) {
		var O = toIObject(object);
		var keys = getKeys(O);
		var length = keys.length;
		var index = 0;
		var key;
		while (length > index) if (O[key = keys[index++]] === el) return key;
	};
	
	},{"./_object-keys":133,"./_to-iobject":154}],119:[function(require,module,exports){
	module.exports = true;
	
	},{}],120:[function(require,module,exports){
	var META = require('./_uid')('meta');
	var isObject = require('./_is-object');
	var has = require('./_has');
	var setDesc = require('./_object-dp').f;
	var id = 0;
	var isExtensible = Object.isExtensible || function () {
		return true;
	};
	var FREEZE = !require('./_fails')(function () {
		return isExtensible(Object.preventExtensions({}));
	});
	var setMeta = function (it) {
		setDesc(it, META, { value: {
			i: 'O' + ++id, // object ID
			w: {}          // weak collections IDs
		} });
	};
	var fastKey = function (it, create) {
		// return primitive with prefix
		if (!isObject(it)) return typeof it == 'symbol' ? it : (typeof it == 'string' ? 'S' : 'P') + it;
		if (!has(it, META)) {
			// can't set metadata to uncaught frozen object
			if (!isExtensible(it)) return 'F';
			// not necessary to add metadata
			if (!create) return 'E';
			// add missing metadata
			setMeta(it);
		// return object ID
		} return it[META].i;
	};
	var getWeak = function (it, create) {
		if (!has(it, META)) {
			// can't set metadata to uncaught frozen object
			if (!isExtensible(it)) return true;
			// not necessary to add metadata
			if (!create) return false;
			// add missing metadata
			setMeta(it);
		// return hash weak collections IDs
		} return it[META].w;
	};
	// add metadata on freeze-family methods calling
	var onFreeze = function (it) {
		if (FREEZE && meta.NEED && isExtensible(it) && !has(it, META)) setMeta(it);
		return it;
	};
	var meta = module.exports = {
		KEY: META,
		NEED: false,
		fastKey: fastKey,
		getWeak: getWeak,
		onFreeze: onFreeze
	};
	
	},{"./_fails":100,"./_has":103,"./_is-object":111,"./_object-dp":125,"./_uid":158}],121:[function(require,module,exports){
	var global = require('./_global');
	var macrotask = require('./_task').set;
	var Observer = global.MutationObserver || global.WebKitMutationObserver;
	var process = global.process;
	var Promise = global.Promise;
	var isNode = require('./_cof')(process) == 'process';
	
	module.exports = function () {
		var head, last, notify;
	
		var flush = function () {
			var parent, fn;
			if (isNode && (parent = process.domain)) parent.exit();
			while (head) {
				fn = head.fn;
				head = head.next;
				try {
					fn();
				} catch (e) {
					if (head) notify();
					else last = undefined;
					throw e;
				}
			} last = undefined;
			if (parent) parent.enter();
		};
	
		// Node.js
		if (isNode) {
			notify = function () {
				process.nextTick(flush);
			};
		// browsers with MutationObserver
		} else if (Observer) {
			var toggle = true;
			var node = document.createTextNode('');
			new Observer(flush).observe(node, { characterData: true }); // eslint-disable-line no-new
			notify = function () {
				node.data = toggle = !toggle;
			};
		// environments with maybe non-completely correct, but existent Promise
		} else if (Promise && Promise.resolve) {
			var promise = Promise.resolve();
			notify = function () {
				promise.then(flush);
			};
		// for other environments - macrotask based on:
		// - setImmediate
		// - MessageChannel
		// - window.postMessag
		// - onreadystatechange
		// - setTimeout
		} else {
			notify = function () {
				// strange IE + webpack dev server bug - use .call(global)
				macrotask.call(global, flush);
			};
		}
	
		return function (fn) {
			var task = { fn: fn, next: undefined };
			if (last) last.next = task;
			if (!head) {
				head = task;
				notify();
			} last = task;
		};
	};
	
	},{"./_cof":87,"./_global":102,"./_task":151}],122:[function(require,module,exports){
	'use strict';
	// 25.4.1.5 NewPromiseCapability(C)
	var aFunction = require('./_a-function');
	
	function PromiseCapability(C) {
		var resolve, reject;
		this.promise = new C(function ($$resolve, $$reject) {
			if (resolve !== undefined || reject !== undefined) throw TypeError('Bad Promise constructor');
			resolve = $$resolve;
			reject = $$reject;
		});
		this.resolve = aFunction(resolve);
		this.reject = aFunction(reject);
	}
	
	module.exports.f = function (C) {
		return new PromiseCapability(C);
	};
	
	},{"./_a-function":77}],123:[function(require,module,exports){
	'use strict';
	// 19.1.2.1 Object.assign(target, source, ...)
	var getKeys = require('./_object-keys');
	var gOPS = require('./_object-gops');
	var pIE = require('./_object-pie');
	var toObject = require('./_to-object');
	var IObject = require('./_iobject');
	var $assign = Object.assign;
	
	// should work with symbols and should have deterministic property order (V8 bug)
	module.exports = !$assign || require('./_fails')(function () {
		var A = {};
		var B = {};
		// eslint-disable-next-line no-undef
		var S = Symbol();
		var K = 'abcdefghijklmnopqrst';
		A[S] = 7;
		K.split('').forEach(function (k) { B[k] = k; });
		return $assign({}, A)[S] != 7 || Object.keys($assign({}, B)).join('') != K;
	}) ? function assign(target, source) { // eslint-disable-line no-unused-vars
		var T = toObject(target);
		var aLen = arguments.length;
		var index = 1;
		var getSymbols = gOPS.f;
		var isEnum = pIE.f;
		while (aLen > index) {
			var S = IObject(arguments[index++]);
			var keys = getSymbols ? getKeys(S).concat(getSymbols(S)) : getKeys(S);
			var length = keys.length;
			var j = 0;
			var key;
			while (length > j) if (isEnum.call(S, key = keys[j++])) T[key] = S[key];
		} return T;
	} : $assign;
	
	},{"./_fails":100,"./_iobject":108,"./_object-gops":130,"./_object-keys":133,"./_object-pie":134,"./_to-object":156}],124:[function(require,module,exports){
	// 19.1.2.2 / 15.2.3.5 Object.create(O [, Properties])
	var anObject = require('./_an-object');
	var dPs = require('./_object-dps');
	var enumBugKeys = require('./_enum-bug-keys');
	var IE_PROTO = require('./_shared-key')('IE_PROTO');
	var Empty = function () { /* empty */ };
	var PROTOTYPE = 'prototype';
	
	// Create object with fake `null` prototype: use iframe Object with cleared prototype
	var createDict = function () {
		// Thrash, waste and sodomy: IE GC bug
		var iframe = require('./_dom-create')('iframe');
		var i = enumBugKeys.length;
		var lt = '<';
		var gt = '>';
		var iframeDocument;
		iframe.style.display = 'none';
		require('./_html').appendChild(iframe);
		iframe.src = 'javascript:'; // eslint-disable-line no-script-url
		// createDict = iframe.contentWindow.Object;
		// html.removeChild(iframe);
		iframeDocument = iframe.contentWindow.document;
		iframeDocument.open();
		iframeDocument.write(lt + 'script' + gt + 'document.F=Object' + lt + '/script' + gt);
		iframeDocument.close();
		createDict = iframeDocument.F;
		while (i--) delete createDict[PROTOTYPE][enumBugKeys[i]];
		return createDict();
	};
	
	module.exports = Object.create || function create(O, Properties) {
		var result;
		if (O !== null) {
			Empty[PROTOTYPE] = anObject(O);
			result = new Empty();
			Empty[PROTOTYPE] = null;
			// add "__proto__" for Object.getPrototypeOf polyfill
			result[IE_PROTO] = O;
		} else result = createDict();
		return Properties === undefined ? result : dPs(result, Properties);
	};
	
	},{"./_an-object":80,"./_dom-create":96,"./_enum-bug-keys":97,"./_html":105,"./_object-dps":126,"./_shared-key":147}],125:[function(require,module,exports){
	var anObject = require('./_an-object');
	var IE8_DOM_DEFINE = require('./_ie8-dom-define');
	var toPrimitive = require('./_to-primitive');
	var dP = Object.defineProperty;
	
	exports.f = require('./_descriptors') ? Object.defineProperty : function defineProperty(O, P, Attributes) {
		anObject(O);
		P = toPrimitive(P, true);
		anObject(Attributes);
		if (IE8_DOM_DEFINE) try {
			return dP(O, P, Attributes);
		} catch (e) { /* empty */ }
		if ('get' in Attributes || 'set' in Attributes) throw TypeError('Accessors not supported!');
		if ('value' in Attributes) O[P] = Attributes.value;
		return O;
	};
	
	},{"./_an-object":80,"./_descriptors":95,"./_ie8-dom-define":106,"./_to-primitive":157}],126:[function(require,module,exports){
	var dP = require('./_object-dp');
	var anObject = require('./_an-object');
	var getKeys = require('./_object-keys');
	
	module.exports = require('./_descriptors') ? Object.defineProperties : function defineProperties(O, Properties) {
		anObject(O);
		var keys = getKeys(Properties);
		var length = keys.length;
		var i = 0;
		var P;
		while (length > i) dP.f(O, P = keys[i++], Properties[P]);
		return O;
	};
	
	},{"./_an-object":80,"./_descriptors":95,"./_object-dp":125,"./_object-keys":133}],127:[function(require,module,exports){
	var pIE = require('./_object-pie');
	var createDesc = require('./_property-desc');
	var toIObject = require('./_to-iobject');
	var toPrimitive = require('./_to-primitive');
	var has = require('./_has');
	var IE8_DOM_DEFINE = require('./_ie8-dom-define');
	var gOPD = Object.getOwnPropertyDescriptor;
	
	exports.f = require('./_descriptors') ? gOPD : function getOwnPropertyDescriptor(O, P) {
		O = toIObject(O);
		P = toPrimitive(P, true);
		if (IE8_DOM_DEFINE) try {
			return gOPD(O, P);
		} catch (e) { /* empty */ }
		if (has(O, P)) return createDesc(!pIE.f.call(O, P), O[P]);
	};
	
	},{"./_descriptors":95,"./_has":103,"./_ie8-dom-define":106,"./_object-pie":134,"./_property-desc":139,"./_to-iobject":154,"./_to-primitive":157}],128:[function(require,module,exports){
	// fallback for IE11 buggy Object.getOwnPropertyNames with iframe and window
	var toIObject = require('./_to-iobject');
	var gOPN = require('./_object-gopn').f;
	var toString = {}.toString;
	
	var windowNames = typeof window == 'object' && window && Object.getOwnPropertyNames
		? Object.getOwnPropertyNames(window) : [];
	
	var getWindowNames = function (it) {
		try {
			return gOPN(it);
		} catch (e) {
			return windowNames.slice();
		}
	};
	
	module.exports.f = function getOwnPropertyNames(it) {
		return windowNames && toString.call(it) == '[object Window]' ? getWindowNames(it) : gOPN(toIObject(it));
	};
	
	},{"./_object-gopn":129,"./_to-iobject":154}],129:[function(require,module,exports){
	// 19.1.2.7 / 15.2.3.4 Object.getOwnPropertyNames(O)
	var $keys = require('./_object-keys-internal');
	var hiddenKeys = require('./_enum-bug-keys').concat('length', 'prototype');
	
	exports.f = Object.getOwnPropertyNames || function getOwnPropertyNames(O) {
		return $keys(O, hiddenKeys);
	};
	
	},{"./_enum-bug-keys":97,"./_object-keys-internal":132}],130:[function(require,module,exports){
	exports.f = Object.getOwnPropertySymbols;
	
	},{}],131:[function(require,module,exports){
	// 19.1.2.9 / 15.2.3.2 Object.getPrototypeOf(O)
	var has = require('./_has');
	var toObject = require('./_to-object');
	var IE_PROTO = require('./_shared-key')('IE_PROTO');
	var ObjectProto = Object.prototype;
	
	module.exports = Object.getPrototypeOf || function (O) {
		O = toObject(O);
		if (has(O, IE_PROTO)) return O[IE_PROTO];
		if (typeof O.constructor == 'function' && O instanceof O.constructor) {
			return O.constructor.prototype;
		} return O instanceof Object ? ObjectProto : null;
	};
	
	},{"./_has":103,"./_shared-key":147,"./_to-object":156}],132:[function(require,module,exports){
	var has = require('./_has');
	var toIObject = require('./_to-iobject');
	var arrayIndexOf = require('./_array-includes')(false);
	var IE_PROTO = require('./_shared-key')('IE_PROTO');
	
	module.exports = function (object, names) {
		var O = toIObject(object);
		var i = 0;
		var result = [];
		var key;
		for (key in O) if (key != IE_PROTO) has(O, key) && result.push(key);
		// Don't enum bug & hidden keys
		while (names.length > i) if (has(O, key = names[i++])) {
			~arrayIndexOf(result, key) || result.push(key);
		}
		return result;
	};
	
	},{"./_array-includes":82,"./_has":103,"./_shared-key":147,"./_to-iobject":154}],133:[function(require,module,exports){
	// 19.1.2.14 / 15.2.3.14 Object.keys(O)
	var $keys = require('./_object-keys-internal');
	var enumBugKeys = require('./_enum-bug-keys');
	
	module.exports = Object.keys || function keys(O) {
		return $keys(O, enumBugKeys);
	};
	
	},{"./_enum-bug-keys":97,"./_object-keys-internal":132}],134:[function(require,module,exports){
	exports.f = {}.propertyIsEnumerable;
	
	},{}],135:[function(require,module,exports){
	// most Object methods by ES6 should accept primitives
	var $export = require('./_export');
	var core = require('./_core');
	var fails = require('./_fails');
	module.exports = function (KEY, exec) {
		var fn = (core.Object || {})[KEY] || Object[KEY];
		var exp = {};
		exp[KEY] = exec(fn);
		$export($export.S + $export.F * fails(function () { fn(1); }), 'Object', exp);
	};
	
	},{"./_core":91,"./_export":99,"./_fails":100}],136:[function(require,module,exports){
	var getKeys = require('./_object-keys');
	var toIObject = require('./_to-iobject');
	var isEnum = require('./_object-pie').f;
	module.exports = function (isEntries) {
		return function (it) {
			var O = toIObject(it);
			var keys = getKeys(O);
			var length = keys.length;
			var i = 0;
			var result = [];
			var key;
			while (length > i) if (isEnum.call(O, key = keys[i++])) {
				result.push(isEntries ? [key, O[key]] : O[key]);
			} return result;
		};
	};
	
	},{"./_object-keys":133,"./_object-pie":134,"./_to-iobject":154}],137:[function(require,module,exports){
	module.exports = function (exec) {
		try {
			return { e: false, v: exec() };
		} catch (e) {
			return { e: true, v: e };
		}
	};
	
	},{}],138:[function(require,module,exports){
	var newPromiseCapability = require('./_new-promise-capability');
	
	module.exports = function (C, x) {
		var promiseCapability = newPromiseCapability.f(C);
		var resolve = promiseCapability.resolve;
		resolve(x);
		return promiseCapability.promise;
	};
	
	},{"./_new-promise-capability":122}],139:[function(require,module,exports){
	module.exports = function (bitmap, value) {
		return {
			enumerable: !(bitmap & 1),
			configurable: !(bitmap & 2),
			writable: !(bitmap & 4),
			value: value
		};
	};
	
	},{}],140:[function(require,module,exports){
	var hide = require('./_hide');
	module.exports = function (target, src, safe) {
		for (var key in src) {
			if (safe && target[key]) target[key] = src[key];
			else hide(target, key, src[key]);
		} return target;
	};
	
	},{"./_hide":104}],141:[function(require,module,exports){
	module.exports = require('./_hide');
	
	},{"./_hide":104}],142:[function(require,module,exports){
	'use strict';
	// https://tc39.github.io/proposal-setmap-offrom/
	var $export = require('./_export');
	var aFunction = require('./_a-function');
	var ctx = require('./_ctx');
	var forOf = require('./_for-of');
	
	module.exports = function (COLLECTION) {
		$export($export.S, COLLECTION, { from: function from(source /* , mapFn, thisArg */) {
			var mapFn = arguments[1];
			var mapping, A, n, cb;
			aFunction(this);
			mapping = mapFn !== undefined;
			if (mapping) aFunction(mapFn);
			if (source == undefined) return new this();
			A = [];
			if (mapping) {
				n = 0;
				cb = ctx(mapFn, arguments[2], 2);
				forOf(source, false, function (nextItem) {
					A.push(cb(nextItem, n++));
				});
			} else {
				forOf(source, false, A.push, A);
			}
			return new this(A);
		} });
	};
	
	},{"./_a-function":77,"./_ctx":93,"./_export":99,"./_for-of":101}],143:[function(require,module,exports){
	'use strict';
	// https://tc39.github.io/proposal-setmap-offrom/
	var $export = require('./_export');
	
	module.exports = function (COLLECTION) {
		$export($export.S, COLLECTION, { of: function of() {
			var length = arguments.length;
			var A = Array(length);
			while (length--) A[length] = arguments[length];
			return new this(A);
		} });
	};
	
	},{"./_export":99}],144:[function(require,module,exports){
	// Works with __proto__ only. Old v8 can't work with null proto objects.
	/* eslint-disable no-proto */
	var isObject = require('./_is-object');
	var anObject = require('./_an-object');
	var check = function (O, proto) {
		anObject(O);
		if (!isObject(proto) && proto !== null) throw TypeError(proto + ": can't set as prototype!");
	};
	module.exports = {
		set: Object.setPrototypeOf || ('__proto__' in {} ? // eslint-disable-line
			function (test, buggy, set) {
				try {
					set = require('./_ctx')(Function.call, require('./_object-gopd').f(Object.prototype, '__proto__').set, 2);
					set(test, []);
					buggy = !(test instanceof Array);
				} catch (e) { buggy = true; }
				return function setPrototypeOf(O, proto) {
					check(O, proto);
					if (buggy) O.__proto__ = proto;
					else set(O, proto);
					return O;
				};
			}({}, false) : undefined),
		check: check
	};
	
	},{"./_an-object":80,"./_ctx":93,"./_is-object":111,"./_object-gopd":127}],145:[function(require,module,exports){
	'use strict';
	var global = require('./_global');
	var core = require('./_core');
	var dP = require('./_object-dp');
	var DESCRIPTORS = require('./_descriptors');
	var SPECIES = require('./_wks')('species');
	
	module.exports = function (KEY) {
		var C = typeof core[KEY] == 'function' ? core[KEY] : global[KEY];
		if (DESCRIPTORS && C && !C[SPECIES]) dP.f(C, SPECIES, {
			configurable: true,
			get: function () { return this; }
		});
	};
	
	},{"./_core":91,"./_descriptors":95,"./_global":102,"./_object-dp":125,"./_wks":162}],146:[function(require,module,exports){
	var def = require('./_object-dp').f;
	var has = require('./_has');
	var TAG = require('./_wks')('toStringTag');
	
	module.exports = function (it, tag, stat) {
		if (it && !has(it = stat ? it : it.prototype, TAG)) def(it, TAG, { configurable: true, value: tag });
	};
	
	},{"./_has":103,"./_object-dp":125,"./_wks":162}],147:[function(require,module,exports){
	var shared = require('./_shared')('keys');
	var uid = require('./_uid');
	module.exports = function (key) {
		return shared[key] || (shared[key] = uid(key));
	};
	
	},{"./_shared":148,"./_uid":158}],148:[function(require,module,exports){
	var global = require('./_global');
	var SHARED = '__core-js_shared__';
	var store = global[SHARED] || (global[SHARED] = {});
	module.exports = function (key) {
		return store[key] || (store[key] = {});
	};
	
	},{"./_global":102}],149:[function(require,module,exports){
	// 7.3.20 SpeciesConstructor(O, defaultConstructor)
	var anObject = require('./_an-object');
	var aFunction = require('./_a-function');
	var SPECIES = require('./_wks')('species');
	module.exports = function (O, D) {
		var C = anObject(O).constructor;
		var S;
		return C === undefined || (S = anObject(C)[SPECIES]) == undefined ? D : aFunction(S);
	};
	
	},{"./_a-function":77,"./_an-object":80,"./_wks":162}],150:[function(require,module,exports){
	var toInteger = require('./_to-integer');
	var defined = require('./_defined');
	// true  -> String#at
	// false -> String#codePointAt
	module.exports = function (TO_STRING) {
		return function (that, pos) {
			var s = String(defined(that));
			var i = toInteger(pos);
			var l = s.length;
			var a, b;
			if (i < 0 || i >= l) return TO_STRING ? '' : undefined;
			a = s.charCodeAt(i);
			return a < 0xd800 || a > 0xdbff || i + 1 === l || (b = s.charCodeAt(i + 1)) < 0xdc00 || b > 0xdfff
				? TO_STRING ? s.charAt(i) : a
				: TO_STRING ? s.slice(i, i + 2) : (a - 0xd800 << 10) + (b - 0xdc00) + 0x10000;
		};
	};
	
	},{"./_defined":94,"./_to-integer":153}],151:[function(require,module,exports){
	var ctx = require('./_ctx');
	var invoke = require('./_invoke');
	var html = require('./_html');
	var cel = require('./_dom-create');
	var global = require('./_global');
	var process = global.process;
	var setTask = global.setImmediate;
	var clearTask = global.clearImmediate;
	var MessageChannel = global.MessageChannel;
	var Dispatch = global.Dispatch;
	var counter = 0;
	var queue = {};
	var ONREADYSTATECHANGE = 'onreadystatechange';
	var defer, channel, port;
	var run = function () {
		var id = +this;
		// eslint-disable-next-line no-prototype-builtins
		if (queue.hasOwnProperty(id)) {
			var fn = queue[id];
			delete queue[id];
			fn();
		}
	};
	var listener = function (event) {
		run.call(event.data);
	};
	// Node.js 0.9+ & IE10+ has setImmediate, otherwise:
	if (!setTask || !clearTask) {
		setTask = function setImmediate(fn) {
			var args = [];
			var i = 1;
			while (arguments.length > i) args.push(arguments[i++]);
			queue[++counter] = function () {
				// eslint-disable-next-line no-new-func
				invoke(typeof fn == 'function' ? fn : Function(fn), args);
			};
			defer(counter);
			return counter;
		};
		clearTask = function clearImmediate(id) {
			delete queue[id];
		};
		// Node.js 0.8-
		if (require('./_cof')(process) == 'process') {
			defer = function (id) {
				process.nextTick(ctx(run, id, 1));
			};
		// Sphere (JS game engine) Dispatch API
		} else if (Dispatch && Dispatch.now) {
			defer = function (id) {
				Dispatch.now(ctx(run, id, 1));
			};
		// Browsers with MessageChannel, includes WebWorkers
		} else if (MessageChannel) {
			channel = new MessageChannel();
			port = channel.port2;
			channel.port1.onmessage = listener;
			defer = ctx(port.postMessage, port, 1);
		// Browsers with postMessage, skip WebWorkers
		// IE8 has postMessage, but it's sync & typeof its postMessage is 'object'
		} else if (global.addEventListener && typeof postMessage == 'function' && !global.importScripts) {
			defer = function (id) {
				global.postMessage(id + '', '*');
			};
			global.addEventListener('message', listener, false);
		// IE8-
		} else if (ONREADYSTATECHANGE in cel('script')) {
			defer = function (id) {
				html.appendChild(cel('script'))[ONREADYSTATECHANGE] = function () {
					html.removeChild(this);
					run.call(id);
				};
			};
		// Rest old browsers
		} else {
			defer = function (id) {
				setTimeout(ctx(run, id, 1), 0);
			};
		}
	}
	module.exports = {
		set: setTask,
		clear: clearTask
	};
	
	},{"./_cof":87,"./_ctx":93,"./_dom-create":96,"./_global":102,"./_html":105,"./_invoke":107}],152:[function(require,module,exports){
	var toInteger = require('./_to-integer');
	var max = Math.max;
	var min = Math.min;
	module.exports = function (index, length) {
		index = toInteger(index);
		return index < 0 ? max(index + length, 0) : min(index, length);
	};
	
	},{"./_to-integer":153}],153:[function(require,module,exports){
	// 7.1.4 ToInteger
	var ceil = Math.ceil;
	var floor = Math.floor;
	module.exports = function (it) {
		return isNaN(it = +it) ? 0 : (it > 0 ? floor : ceil)(it);
	};
	
	},{}],154:[function(require,module,exports){
	// to indexed object, toObject with fallback for non-array-like ES3 strings
	var IObject = require('./_iobject');
	var defined = require('./_defined');
	module.exports = function (it) {
		return IObject(defined(it));
	};
	
	},{"./_defined":94,"./_iobject":108}],155:[function(require,module,exports){
	// 7.1.15 ToLength
	var toInteger = require('./_to-integer');
	var min = Math.min;
	module.exports = function (it) {
		return it > 0 ? min(toInteger(it), 0x1fffffffffffff) : 0; // pow(2, 53) - 1 == 9007199254740991
	};
	
	},{"./_to-integer":153}],156:[function(require,module,exports){
	// 7.1.13 ToObject(argument)
	var defined = require('./_defined');
	module.exports = function (it) {
		return Object(defined(it));
	};
	
	},{"./_defined":94}],157:[function(require,module,exports){
	// 7.1.1 ToPrimitive(input [, PreferredType])
	var isObject = require('./_is-object');
	// instead of the ES6 spec version, we didn't implement @@toPrimitive case
	// and the second argument - flag - preferred type is a string
	module.exports = function (it, S) {
		if (!isObject(it)) return it;
		var fn, val;
		if (S && typeof (fn = it.toString) == 'function' && !isObject(val = fn.call(it))) return val;
		if (typeof (fn = it.valueOf) == 'function' && !isObject(val = fn.call(it))) return val;
		if (!S && typeof (fn = it.toString) == 'function' && !isObject(val = fn.call(it))) return val;
		throw TypeError("Can't convert object to primitive value");
	};
	
	},{"./_is-object":111}],158:[function(require,module,exports){
	var id = 0;
	var px = Math.random();
	module.exports = function (key) {
		return 'Symbol('.concat(key === undefined ? '' : key, ')_', (++id + px).toString(36));
	};
	
	},{}],159:[function(require,module,exports){
	var isObject = require('./_is-object');
	module.exports = function (it, TYPE) {
		if (!isObject(it) || it._t !== TYPE) throw TypeError('Incompatible receiver, ' + TYPE + ' required!');
		return it;
	};
	
	},{"./_is-object":111}],160:[function(require,module,exports){
	var global = require('./_global');
	var core = require('./_core');
	var LIBRARY = require('./_library');
	var wksExt = require('./_wks-ext');
	var defineProperty = require('./_object-dp').f;
	module.exports = function (name) {
		var $Symbol = core.Symbol || (core.Symbol = LIBRARY ? {} : global.Symbol || {});
		if (name.charAt(0) != '_' && !(name in $Symbol)) defineProperty($Symbol, name, { value: wksExt.f(name) });
	};
	
	},{"./_core":91,"./_global":102,"./_library":119,"./_object-dp":125,"./_wks-ext":161}],161:[function(require,module,exports){
	exports.f = require('./_wks');
	
	},{"./_wks":162}],162:[function(require,module,exports){
	var store = require('./_shared')('wks');
	var uid = require('./_uid');
	var Symbol = require('./_global').Symbol;
	var USE_SYMBOL = typeof Symbol == 'function';
	
	var $exports = module.exports = function (name) {
		return store[name] || (store[name] =
			USE_SYMBOL && Symbol[name] || (USE_SYMBOL ? Symbol : uid)('Symbol.' + name));
	};
	
	$exports.store = store;
	
	},{"./_global":102,"./_shared":148,"./_uid":158}],163:[function(require,module,exports){
	var classof = require('./_classof');
	var ITERATOR = require('./_wks')('iterator');
	var Iterators = require('./_iterators');
	module.exports = require('./_core').getIteratorMethod = function (it) {
		if (it != undefined) return it[ITERATOR]
			|| it['@@iterator']
			|| Iterators[classof(it)];
	};
	
	},{"./_classof":86,"./_core":91,"./_iterators":117,"./_wks":162}],164:[function(require,module,exports){
	var anObject = require('./_an-object');
	var get = require('./core.get-iterator-method');
	module.exports = require('./_core').getIterator = function (it) {
		var iterFn = get(it);
		if (typeof iterFn != 'function') throw TypeError(it + ' is not iterable!');
		return anObject(iterFn.call(it));
	};
	
	},{"./_an-object":80,"./_core":91,"./core.get-iterator-method":163}],165:[function(require,module,exports){
	var classof = require('./_classof');
	var ITERATOR = require('./_wks')('iterator');
	var Iterators = require('./_iterators');
	module.exports = require('./_core').isIterable = function (it) {
		var O = Object(it);
		return O[ITERATOR] !== undefined
			|| '@@iterator' in O
			// eslint-disable-next-line no-prototype-builtins
			|| Iterators.hasOwnProperty(classof(O));
	};
	
	},{"./_classof":86,"./_core":91,"./_iterators":117,"./_wks":162}],166:[function(require,module,exports){
	'use strict';
	var ctx = require('./_ctx');
	var $export = require('./_export');
	var toObject = require('./_to-object');
	var call = require('./_iter-call');
	var isArrayIter = require('./_is-array-iter');
	var toLength = require('./_to-length');
	var createProperty = require('./_create-property');
	var getIterFn = require('./core.get-iterator-method');
	
	$export($export.S + $export.F * !require('./_iter-detect')(function (iter) { Array.from(iter); }), 'Array', {
		// 22.1.2.1 Array.from(arrayLike, mapfn = undefined, thisArg = undefined)
		from: function from(arrayLike /* , mapfn = undefined, thisArg = undefined */) {
			var O = toObject(arrayLike);
			var C = typeof this == 'function' ? this : Array;
			var aLen = arguments.length;
			var mapfn = aLen > 1 ? arguments[1] : undefined;
			var mapping = mapfn !== undefined;
			var index = 0;
			var iterFn = getIterFn(O);
			var length, result, step, iterator;
			if (mapping) mapfn = ctx(mapfn, aLen > 2 ? arguments[2] : undefined, 2);
			// if object isn't iterable or it's array with default iterator - use simple case
			if (iterFn != undefined && !(C == Array && isArrayIter(iterFn))) {
				for (iterator = iterFn.call(O), result = new C(); !(step = iterator.next()).done; index++) {
					createProperty(result, index, mapping ? call(iterator, mapfn, [step.value, index], true) : step.value);
				}
			} else {
				length = toLength(O.length);
				for (result = new C(length); length > index; index++) {
					createProperty(result, index, mapping ? mapfn(O[index], index) : O[index]);
				}
			}
			result.length = index;
			return result;
		}
	});
	
	},{"./_create-property":92,"./_ctx":93,"./_export":99,"./_is-array-iter":109,"./_iter-call":112,"./_iter-detect":115,"./_to-length":155,"./_to-object":156,"./core.get-iterator-method":163}],167:[function(require,module,exports){
	'use strict';
	var addToUnscopables = require('./_add-to-unscopables');
	var step = require('./_iter-step');
	var Iterators = require('./_iterators');
	var toIObject = require('./_to-iobject');
	
	// 22.1.3.4 Array.prototype.entries()
	// 22.1.3.13 Array.prototype.keys()
	// 22.1.3.29 Array.prototype.values()
	// 22.1.3.30 Array.prototype[@@iterator]()
	module.exports = require('./_iter-define')(Array, 'Array', function (iterated, kind) {
		this._t = toIObject(iterated); // target
		this._i = 0;                   // next index
		this._k = kind;                // kind
	// 22.1.5.2.1 %ArrayIteratorPrototype%.next()
	}, function () {
		var O = this._t;
		var kind = this._k;
		var index = this._i++;
		if (!O || index >= O.length) {
			this._t = undefined;
			return step(1);
		}
		if (kind == 'keys') return step(0, index);
		if (kind == 'values') return step(0, O[index]);
		return step(0, [index, O[index]]);
	}, 'values');
	
	// argumentsList[@@iterator] is %ArrayProto_values% (9.4.4.6, 9.4.4.7)
	Iterators.Arguments = Iterators.Array;
	
	addToUnscopables('keys');
	addToUnscopables('values');
	addToUnscopables('entries');
	
	},{"./_add-to-unscopables":78,"./_iter-define":114,"./_iter-step":116,"./_iterators":117,"./_to-iobject":154}],168:[function(require,module,exports){
	'use strict';
	var strong = require('./_collection-strong');
	var validate = require('./_validate-collection');
	var MAP = 'Map';
	
	// 23.1 Map Objects
	module.exports = require('./_collection')(MAP, function (get) {
		return function Map() { return get(this, arguments.length > 0 ? arguments[0] : undefined); };
	}, {
		// 23.1.3.6 Map.prototype.get(key)
		get: function get(key) {
			var entry = strong.getEntry(validate(this, MAP), key);
			return entry && entry.v;
		},
		// 23.1.3.9 Map.prototype.set(key, value)
		set: function set(key, value) {
			return strong.def(validate(this, MAP), key === 0 ? 0 : key, value);
		}
	}, strong, true);
	
	},{"./_collection":90,"./_collection-strong":88,"./_validate-collection":159}],169:[function(require,module,exports){
	// 19.1.3.1 Object.assign(target, source)
	var $export = require('./_export');
	
	$export($export.S + $export.F, 'Object', { assign: require('./_object-assign') });
	
	},{"./_export":99,"./_object-assign":123}],170:[function(require,module,exports){
	var $export = require('./_export');
	// 19.1.2.2 / 15.2.3.5 Object.create(O [, Properties])
	$export($export.S, 'Object', { create: require('./_object-create') });
	
	},{"./_export":99,"./_object-create":124}],171:[function(require,module,exports){
	var $export = require('./_export');
	// 19.1.2.4 / 15.2.3.6 Object.defineProperty(O, P, Attributes)
	$export($export.S + $export.F * !require('./_descriptors'), 'Object', { defineProperty: require('./_object-dp').f });
	
	},{"./_descriptors":95,"./_export":99,"./_object-dp":125}],172:[function(require,module,exports){
	// 19.1.2.9 Object.getPrototypeOf(O)
	var toObject = require('./_to-object');
	var $getPrototypeOf = require('./_object-gpo');
	
	require('./_object-sap')('getPrototypeOf', function () {
		return function getPrototypeOf(it) {
			return $getPrototypeOf(toObject(it));
		};
	});
	
	},{"./_object-gpo":131,"./_object-sap":135,"./_to-object":156}],173:[function(require,module,exports){
	// 19.1.2.14 Object.keys(O)
	var toObject = require('./_to-object');
	var $keys = require('./_object-keys');
	
	require('./_object-sap')('keys', function () {
		return function keys(it) {
			return $keys(toObject(it));
		};
	});
	
	},{"./_object-keys":133,"./_object-sap":135,"./_to-object":156}],174:[function(require,module,exports){
	// 19.1.3.19 Object.setPrototypeOf(O, proto)
	var $export = require('./_export');
	$export($export.S, 'Object', { setPrototypeOf: require('./_set-proto').set });
	
	},{"./_export":99,"./_set-proto":144}],175:[function(require,module,exports){
	
	},{}],176:[function(require,module,exports){
	'use strict';
	var LIBRARY = require('./_library');
	var global = require('./_global');
	var ctx = require('./_ctx');
	var classof = require('./_classof');
	var $export = require('./_export');
	var isObject = require('./_is-object');
	var aFunction = require('./_a-function');
	var anInstance = require('./_an-instance');
	var forOf = require('./_for-of');
	var speciesConstructor = require('./_species-constructor');
	var task = require('./_task').set;
	var microtask = require('./_microtask')();
	var newPromiseCapabilityModule = require('./_new-promise-capability');
	var perform = require('./_perform');
	var promiseResolve = require('./_promise-resolve');
	var PROMISE = 'Promise';
	var TypeError = global.TypeError;
	var process = global.process;
	var $Promise = global[PROMISE];
	var isNode = classof(process) == 'process';
	var empty = function () { /* empty */ };
	var Internal, newGenericPromiseCapability, OwnPromiseCapability, Wrapper;
	var newPromiseCapability = newGenericPromiseCapability = newPromiseCapabilityModule.f;
	
	var USE_NATIVE = !!function () {
		try {
			// correct subclassing with @@species support
			var promise = $Promise.resolve(1);
			var FakePromise = (promise.constructor = {})[require('./_wks')('species')] = function (exec) {
				exec(empty, empty);
			};
			// unhandled rejections tracking support, NodeJS Promise without it fails @@species test
			return (isNode || typeof PromiseRejectionEvent == 'function') && promise.then(empty) instanceof FakePromise;
		} catch (e) { /* empty */ }
	}();
	
	// helpers
	var sameConstructor = LIBRARY ? function (a, b) {
		// with library wrapper special case
		return a === b || a === $Promise && b === Wrapper;
	} : function (a, b) {
		return a === b;
	};
	var isThenable = function (it) {
		var then;
		return isObject(it) && typeof (then = it.then) == 'function' ? then : false;
	};
	var notify = function (promise, isReject) {
		if (promise._n) return;
		promise._n = true;
		var chain = promise._c;
		microtask(function () {
			var value = promise._v;
			var ok = promise._s == 1;
			var i = 0;
			var run = function (reaction) {
				var handler = ok ? reaction.ok : reaction.fail;
				var resolve = reaction.resolve;
				var reject = reaction.reject;
				var domain = reaction.domain;
				var result, then;
				try {
					if (handler) {
						if (!ok) {
							if (promise._h == 2) onHandleUnhandled(promise);
							promise._h = 1;
						}
						if (handler === true) result = value;
						else {
							if (domain) domain.enter();
							result = handler(value);
							if (domain) domain.exit();
						}
						if (result === reaction.promise) {
							reject(TypeError('Promise-chain cycle'));
						} else if (then = isThenable(result)) {
							then.call(result, resolve, reject);
						} else resolve(result);
					} else reject(value);
				} catch (e) {
					reject(e);
				}
			};
			while (chain.length > i) run(chain[i++]); // variable length - can't use forEach
			promise._c = [];
			promise._n = false;
			if (isReject && !promise._h) onUnhandled(promise);
		});
	};
	var onUnhandled = function (promise) {
		task.call(global, function () {
			var value = promise._v;
			var unhandled = isUnhandled(promise);
			var result, handler, console;
			if (unhandled) {
				result = perform(function () {
					if (isNode) {
						process.emit('unhandledRejection', value, promise);
					} else if (handler = global.onunhandledrejection) {
						handler({ promise: promise, reason: value });
					} else if ((console = global.console) && console.error) {
						console.error('Unhandled promise rejection', value);
					}
				});
				// Browsers should not trigger `rejectionHandled` event if it was handled here, NodeJS - should
				promise._h = isNode || isUnhandled(promise) ? 2 : 1;
			} promise._a = undefined;
			if (unhandled && result.e) throw result.v;
		});
	};
	var isUnhandled = function (promise) {
		if (promise._h == 1) return false;
		var chain = promise._a || promise._c;
		var i = 0;
		var reaction;
		while (chain.length > i) {
			reaction = chain[i++];
			if (reaction.fail || !isUnhandled(reaction.promise)) return false;
		} return true;
	};
	var onHandleUnhandled = function (promise) {
		task.call(global, function () {
			var handler;
			if (isNode) {
				process.emit('rejectionHandled', promise);
			} else if (handler = global.onrejectionhandled) {
				handler({ promise: promise, reason: promise._v });
			}
		});
	};
	var $reject = function (value) {
		var promise = this;
		if (promise._d) return;
		promise._d = true;
		promise = promise._w || promise; // unwrap
		promise._v = value;
		promise._s = 2;
		if (!promise._a) promise._a = promise._c.slice();
		notify(promise, true);
	};
	var $resolve = function (value) {
		var promise = this;
		var then;
		if (promise._d) return;
		promise._d = true;
		promise = promise._w || promise; // unwrap
		try {
			if (promise === value) throw TypeError("Promise can't be resolved itself");
			if (then = isThenable(value)) {
				microtask(function () {
					var wrapper = { _w: promise, _d: false }; // wrap
					try {
						then.call(value, ctx($resolve, wrapper, 1), ctx($reject, wrapper, 1));
					} catch (e) {
						$reject.call(wrapper, e);
					}
				});
			} else {
				promise._v = value;
				promise._s = 1;
				notify(promise, false);
			}
		} catch (e) {
			$reject.call({ _w: promise, _d: false }, e); // wrap
		}
	};
	
	// constructor polyfill
	if (!USE_NATIVE) {
		// 25.4.3.1 Promise(executor)
		$Promise = function Promise(executor) {
			anInstance(this, $Promise, PROMISE, '_h');
			aFunction(executor);
			Internal.call(this);
			try {
				executor(ctx($resolve, this, 1), ctx($reject, this, 1));
			} catch (err) {
				$reject.call(this, err);
			}
		};
		// eslint-disable-next-line no-unused-vars
		Internal = function Promise(executor) {
			this._c = [];             // <- awaiting reactions
			this._a = undefined;      // <- checked in isUnhandled reactions
			this._s = 0;              // <- state
			this._d = false;          // <- done
			this._v = undefined;      // <- value
			this._h = 0;              // <- rejection state, 0 - default, 1 - handled, 2 - unhandled
			this._n = false;          // <- notify
		};
		Internal.prototype = require('./_redefine-all')($Promise.prototype, {
			// 25.4.5.3 Promise.prototype.then(onFulfilled, onRejected)
			then: function then(onFulfilled, onRejected) {
				var reaction = newPromiseCapability(speciesConstructor(this, $Promise));
				reaction.ok = typeof onFulfilled == 'function' ? onFulfilled : true;
				reaction.fail = typeof onRejected == 'function' && onRejected;
				reaction.domain = isNode ? process.domain : undefined;
				this._c.push(reaction);
				if (this._a) this._a.push(reaction);
				if (this._s) notify(this, false);
				return reaction.promise;
			},
			// 25.4.5.1 Promise.prototype.catch(onRejected)
			'catch': function (onRejected) {
				return this.then(undefined, onRejected);
			}
		});
		OwnPromiseCapability = function () {
			var promise = new Internal();
			this.promise = promise;
			this.resolve = ctx($resolve, promise, 1);
			this.reject = ctx($reject, promise, 1);
		};
		newPromiseCapabilityModule.f = newPromiseCapability = function (C) {
			return sameConstructor($Promise, C)
				? new OwnPromiseCapability(C)
				: newGenericPromiseCapability(C);
		};
	}
	
	$export($export.G + $export.W + $export.F * !USE_NATIVE, { Promise: $Promise });
	require('./_set-to-string-tag')($Promise, PROMISE);
	require('./_set-species')(PROMISE);
	Wrapper = require('./_core')[PROMISE];
	
	// statics
	$export($export.S + $export.F * !USE_NATIVE, PROMISE, {
		// 25.4.4.5 Promise.reject(r)
		reject: function reject(r) {
			var capability = newPromiseCapability(this);
			var $$reject = capability.reject;
			$$reject(r);
			return capability.promise;
		}
	});
	$export($export.S + $export.F * (LIBRARY || !USE_NATIVE), PROMISE, {
		// 25.4.4.6 Promise.resolve(x)
		resolve: function resolve(x) {
			// instanceof instead of internal slot check because we should fix it without replacement native Promise core
			if (x instanceof $Promise && sameConstructor(x.constructor, this)) return x;
			return promiseResolve(this, x);
		}
	});
	$export($export.S + $export.F * !(USE_NATIVE && require('./_iter-detect')(function (iter) {
		$Promise.all(iter)['catch'](empty);
	})), PROMISE, {
		// 25.4.4.1 Promise.all(iterable)
		all: function all(iterable) {
			var C = this;
			var capability = newPromiseCapability(C);
			var resolve = capability.resolve;
			var reject = capability.reject;
			var result = perform(function () {
				var values = [];
				var index = 0;
				var remaining = 1;
				forOf(iterable, false, function (promise) {
					var $index = index++;
					var alreadyCalled = false;
					values.push(undefined);
					remaining++;
					C.resolve(promise).then(function (value) {
						if (alreadyCalled) return;
						alreadyCalled = true;
						values[$index] = value;
						--remaining || resolve(values);
					}, reject);
				});
				--remaining || resolve(values);
			});
			if (result.e) reject(result.v);
			return capability.promise;
		},
		// 25.4.4.4 Promise.race(iterable)
		race: function race(iterable) {
			var C = this;
			var capability = newPromiseCapability(C);
			var reject = capability.reject;
			var result = perform(function () {
				forOf(iterable, false, function (promise) {
					C.resolve(promise).then(capability.resolve, reject);
				});
			});
			if (result.e) reject(result.v);
			return capability.promise;
		}
	});
	
	},{"./_a-function":77,"./_an-instance":79,"./_classof":86,"./_core":91,"./_ctx":93,"./_export":99,"./_for-of":101,"./_global":102,"./_is-object":111,"./_iter-detect":115,"./_library":119,"./_microtask":121,"./_new-promise-capability":122,"./_perform":137,"./_promise-resolve":138,"./_redefine-all":140,"./_set-species":145,"./_set-to-string-tag":146,"./_species-constructor":149,"./_task":151,"./_wks":162}],177:[function(require,module,exports){
	'use strict';
	var strong = require('./_collection-strong');
	var validate = require('./_validate-collection');
	var SET = 'Set';
	
	// 23.2 Set Objects
	module.exports = require('./_collection')(SET, function (get) {
		return function Set() { return get(this, arguments.length > 0 ? arguments[0] : undefined); };
	}, {
		// 23.2.3.1 Set.prototype.add(value)
		add: function add(value) {
			return strong.def(validate(this, SET), value = value === 0 ? 0 : value, value);
		}
	}, strong);
	
	},{"./_collection":90,"./_collection-strong":88,"./_validate-collection":159}],178:[function(require,module,exports){
	'use strict';
	var $at = require('./_string-at')(true);
	
	// 21.1.3.27 String.prototype[@@iterator]()
	require('./_iter-define')(String, 'String', function (iterated) {
		this._t = String(iterated); // target
		this._i = 0;                // next index
	// 21.1.5.2.1 %StringIteratorPrototype%.next()
	}, function () {
		var O = this._t;
		var index = this._i;
		var point;
		if (index >= O.length) return { value: undefined, done: true };
		point = $at(O, index);
		this._i += point.length;
		return { value: point, done: false };
	});
	
	},{"./_iter-define":114,"./_string-at":150}],179:[function(require,module,exports){
	'use strict';
	// ECMAScript 6 symbols shim
	var global = require('./_global');
	var has = require('./_has');
	var DESCRIPTORS = require('./_descriptors');
	var $export = require('./_export');
	var redefine = require('./_redefine');
	var META = require('./_meta').KEY;
	var $fails = require('./_fails');
	var shared = require('./_shared');
	var setToStringTag = require('./_set-to-string-tag');
	var uid = require('./_uid');
	var wks = require('./_wks');
	var wksExt = require('./_wks-ext');
	var wksDefine = require('./_wks-define');
	var keyOf = require('./_keyof');
	var enumKeys = require('./_enum-keys');
	var isArray = require('./_is-array');
	var anObject = require('./_an-object');
	var toIObject = require('./_to-iobject');
	var toPrimitive = require('./_to-primitive');
	var createDesc = require('./_property-desc');
	var _create = require('./_object-create');
	var gOPNExt = require('./_object-gopn-ext');
	var $GOPD = require('./_object-gopd');
	var $DP = require('./_object-dp');
	var $keys = require('./_object-keys');
	var gOPD = $GOPD.f;
	var dP = $DP.f;
	var gOPN = gOPNExt.f;
	var $Symbol = global.Symbol;
	var $JSON = global.JSON;
	var _stringify = $JSON && $JSON.stringify;
	var PROTOTYPE = 'prototype';
	var HIDDEN = wks('_hidden');
	var TO_PRIMITIVE = wks('toPrimitive');
	var isEnum = {}.propertyIsEnumerable;
	var SymbolRegistry = shared('symbol-registry');
	var AllSymbols = shared('symbols');
	var OPSymbols = shared('op-symbols');
	var ObjectProto = Object[PROTOTYPE];
	var USE_NATIVE = typeof $Symbol == 'function';
	var QObject = global.QObject;
	// Don't use setters in Qt Script, https://github.com/zloirock/core-js/issues/173
	var setter = !QObject || !QObject[PROTOTYPE] || !QObject[PROTOTYPE].findChild;
	
	// fallback for old Android, https://code.google.com/p/v8/issues/detail?id=687
	var setSymbolDesc = DESCRIPTORS && $fails(function () {
		return _create(dP({}, 'a', {
			get: function () { return dP(this, 'a', { value: 7 }).a; }
		})).a != 7;
	}) ? function (it, key, D) {
		var protoDesc = gOPD(ObjectProto, key);
		if (protoDesc) delete ObjectProto[key];
		dP(it, key, D);
		if (protoDesc && it !== ObjectProto) dP(ObjectProto, key, protoDesc);
	} : dP;
	
	var wrap = function (tag) {
		var sym = AllSymbols[tag] = _create($Symbol[PROTOTYPE]);
		sym._k = tag;
		return sym;
	};
	
	var isSymbol = USE_NATIVE && typeof $Symbol.iterator == 'symbol' ? function (it) {
		return typeof it == 'symbol';
	} : function (it) {
		return it instanceof $Symbol;
	};
	
	var $defineProperty = function defineProperty(it, key, D) {
		if (it === ObjectProto) $defineProperty(OPSymbols, key, D);
		anObject(it);
		key = toPrimitive(key, true);
		anObject(D);
		if (has(AllSymbols, key)) {
			if (!D.enumerable) {
				if (!has(it, HIDDEN)) dP(it, HIDDEN, createDesc(1, {}));
				it[HIDDEN][key] = true;
			} else {
				if (has(it, HIDDEN) && it[HIDDEN][key]) it[HIDDEN][key] = false;
				D = _create(D, { enumerable: createDesc(0, false) });
			} return setSymbolDesc(it, key, D);
		} return dP(it, key, D);
	};
	var $defineProperties = function defineProperties(it, P) {
		anObject(it);
		var keys = enumKeys(P = toIObject(P));
		var i = 0;
		var l = keys.length;
		var key;
		while (l > i) $defineProperty(it, key = keys[i++], P[key]);
		return it;
	};
	var $create = function create(it, P) {
		return P === undefined ? _create(it) : $defineProperties(_create(it), P);
	};
	var $propertyIsEnumerable = function propertyIsEnumerable(key) {
		var E = isEnum.call(this, key = toPrimitive(key, true));
		if (this === ObjectProto && has(AllSymbols, key) && !has(OPSymbols, key)) return false;
		return E || !has(this, key) || !has(AllSymbols, key) || has(this, HIDDEN) && this[HIDDEN][key] ? E : true;
	};
	var $getOwnPropertyDescriptor = function getOwnPropertyDescriptor(it, key) {
		it = toIObject(it);
		key = toPrimitive(key, true);
		if (it === ObjectProto && has(AllSymbols, key) && !has(OPSymbols, key)) return;
		var D = gOPD(it, key);
		if (D && has(AllSymbols, key) && !(has(it, HIDDEN) && it[HIDDEN][key])) D.enumerable = true;
		return D;
	};
	var $getOwnPropertyNames = function getOwnPropertyNames(it) {
		var names = gOPN(toIObject(it));
		var result = [];
		var i = 0;
		var key;
		while (names.length > i) {
			if (!has(AllSymbols, key = names[i++]) && key != HIDDEN && key != META) result.push(key);
		} return result;
	};
	var $getOwnPropertySymbols = function getOwnPropertySymbols(it) {
		var IS_OP = it === ObjectProto;
		var names = gOPN(IS_OP ? OPSymbols : toIObject(it));
		var result = [];
		var i = 0;
		var key;
		while (names.length > i) {
			if (has(AllSymbols, key = names[i++]) && (IS_OP ? has(ObjectProto, key) : true)) result.push(AllSymbols[key]);
		} return result;
	};
	
	// 19.4.1.1 Symbol([description])
	if (!USE_NATIVE) {
		$Symbol = function Symbol() {
			if (this instanceof $Symbol) throw TypeError('Symbol is not a constructor!');
			var tag = uid(arguments.length > 0 ? arguments[0] : undefined);
			var $set = function (value) {
				if (this === ObjectProto) $set.call(OPSymbols, value);
				if (has(this, HIDDEN) && has(this[HIDDEN], tag)) this[HIDDEN][tag] = false;
				setSymbolDesc(this, tag, createDesc(1, value));
			};
			if (DESCRIPTORS && setter) setSymbolDesc(ObjectProto, tag, { configurable: true, set: $set });
			return wrap(tag);
		};
		redefine($Symbol[PROTOTYPE], 'toString', function toString() {
			return this._k;
		});
	
		$GOPD.f = $getOwnPropertyDescriptor;
		$DP.f = $defineProperty;
		require('./_object-gopn').f = gOPNExt.f = $getOwnPropertyNames;
		require('./_object-pie').f = $propertyIsEnumerable;
		require('./_object-gops').f = $getOwnPropertySymbols;
	
		if (DESCRIPTORS && !require('./_library')) {
			redefine(ObjectProto, 'propertyIsEnumerable', $propertyIsEnumerable, true);
		}
	
		wksExt.f = function (name) {
			return wrap(wks(name));
		};
	}
	
	$export($export.G + $export.W + $export.F * !USE_NATIVE, { Symbol: $Symbol });
	
	for (var es6Symbols = (
		// 19.4.2.2, 19.4.2.3, 19.4.2.4, 19.4.2.6, 19.4.2.8, 19.4.2.9, 19.4.2.10, 19.4.2.11, 19.4.2.12, 19.4.2.13, 19.4.2.14
		'hasInstance,isConcatSpreadable,iterator,match,replace,search,species,split,toPrimitive,toStringTag,unscopables'
	).split(','), j = 0; es6Symbols.length > j;)wks(es6Symbols[j++]);
	
	for (var wellKnownSymbols = $keys(wks.store), k = 0; wellKnownSymbols.length > k;) wksDefine(wellKnownSymbols[k++]);
	
	$export($export.S + $export.F * !USE_NATIVE, 'Symbol', {
		// 19.4.2.1 Symbol.for(key)
		'for': function (key) {
			return has(SymbolRegistry, key += '')
				? SymbolRegistry[key]
				: SymbolRegistry[key] = $Symbol(key);
		},
		// 19.4.2.5 Symbol.keyFor(sym)
		keyFor: function keyFor(key) {
			if (isSymbol(key)) return keyOf(SymbolRegistry, key);
			throw TypeError(key + ' is not a symbol!');
		},
		useSetter: function () { setter = true; },
		useSimple: function () { setter = false; }
	});
	
	$export($export.S + $export.F * !USE_NATIVE, 'Object', {
		// 19.1.2.2 Object.create(O [, Properties])
		create: $create,
		// 19.1.2.4 Object.defineProperty(O, P, Attributes)
		defineProperty: $defineProperty,
		// 19.1.2.3 Object.defineProperties(O, Properties)
		defineProperties: $defineProperties,
		// 19.1.2.6 Object.getOwnPropertyDescriptor(O, P)
		getOwnPropertyDescriptor: $getOwnPropertyDescriptor,
		// 19.1.2.7 Object.getOwnPropertyNames(O)
		getOwnPropertyNames: $getOwnPropertyNames,
		// 19.1.2.8 Object.getOwnPropertySymbols(O)
		getOwnPropertySymbols: $getOwnPropertySymbols
	});
	
	// 24.3.2 JSON.stringify(value [, replacer [, space]])
	$JSON && $export($export.S + $export.F * (!USE_NATIVE || $fails(function () {
		var S = $Symbol();
		// MS Edge converts symbol values to JSON as {}
		// WebKit converts symbol values to JSON as null
		// V8 throws on boxed symbols
		return _stringify([S]) != '[null]' || _stringify({ a: S }) != '{}' || _stringify(Object(S)) != '{}';
	})), 'JSON', {
		stringify: function stringify(it) {
			if (it === undefined || isSymbol(it)) return; // IE8 returns string on undefined
			var args = [it];
			var i = 1;
			var replacer, $replacer;
			while (arguments.length > i) args.push(arguments[i++]);
			replacer = args[1];
			if (typeof replacer == 'function') $replacer = replacer;
			if ($replacer || !isArray(replacer)) replacer = function (key, value) {
				if ($replacer) value = $replacer.call(this, key, value);
				if (!isSymbol(value)) return value;
			};
			args[1] = replacer;
			return _stringify.apply($JSON, args);
		}
	});
	
	// 19.4.3.4 Symbol.prototype[@@toPrimitive](hint)
	$Symbol[PROTOTYPE][TO_PRIMITIVE] || require('./_hide')($Symbol[PROTOTYPE], TO_PRIMITIVE, $Symbol[PROTOTYPE].valueOf);
	// 19.4.3.5 Symbol.prototype[@@toStringTag]
	setToStringTag($Symbol, 'Symbol');
	// 20.2.1.9 Math[@@toStringTag]
	setToStringTag(Math, 'Math', true);
	// 24.3.3 JSON[@@toStringTag]
	setToStringTag(global.JSON, 'JSON', true);
	
	},{"./_an-object":80,"./_descriptors":95,"./_enum-keys":98,"./_export":99,"./_fails":100,"./_global":102,"./_has":103,"./_hide":104,"./_is-array":110,"./_keyof":118,"./_library":119,"./_meta":120,"./_object-create":124,"./_object-dp":125,"./_object-gopd":127,"./_object-gopn":129,"./_object-gopn-ext":128,"./_object-gops":130,"./_object-keys":133,"./_object-pie":134,"./_property-desc":139,"./_redefine":141,"./_set-to-string-tag":146,"./_shared":148,"./_to-iobject":154,"./_to-primitive":157,"./_uid":158,"./_wks":162,"./_wks-define":160,"./_wks-ext":161}],180:[function(require,module,exports){
	// https://tc39.github.io/proposal-setmap-offrom/#sec-map.from
	require('./_set-collection-from')('Map');
	
	},{"./_set-collection-from":142}],181:[function(require,module,exports){
	// https://tc39.github.io/proposal-setmap-offrom/#sec-map.of
	require('./_set-collection-of')('Map');
	
	},{"./_set-collection-of":143}],182:[function(require,module,exports){
	// https://github.com/DavidBruant/Map-Set.prototype.toJSON
	var $export = require('./_export');
	
	$export($export.P + $export.R, 'Map', { toJSON: require('./_collection-to-json')('Map') });
	
	},{"./_collection-to-json":89,"./_export":99}],183:[function(require,module,exports){
	// https://github.com/tc39/proposal-object-values-entries
	var $export = require('./_export');
	var $values = require('./_object-to-array')(false);
	
	$export($export.S, 'Object', {
		values: function values(it) {
			return $values(it);
		}
	});
	
	},{"./_export":99,"./_object-to-array":136}],184:[function(require,module,exports){
	// https://github.com/tc39/proposal-promise-finally
	'use strict';
	var $export = require('./_export');
	var core = require('./_core');
	var global = require('./_global');
	var speciesConstructor = require('./_species-constructor');
	var promiseResolve = require('./_promise-resolve');
	
	$export($export.P + $export.R, 'Promise', { 'finally': function (onFinally) {
		var C = speciesConstructor(this, core.Promise || global.Promise);
		var isFunction = typeof onFinally == 'function';
		return this.then(
			isFunction ? function (x) {
				return promiseResolve(C, onFinally()).then(function () { return x; });
			} : onFinally,
			isFunction ? function (e) {
				return promiseResolve(C, onFinally()).then(function () { throw e; });
			} : onFinally
		);
	} });
	
	},{"./_core":91,"./_export":99,"./_global":102,"./_promise-resolve":138,"./_species-constructor":149}],185:[function(require,module,exports){
	'use strict';
	// https://github.com/tc39/proposal-promise-try
	var $export = require('./_export');
	var newPromiseCapability = require('./_new-promise-capability');
	var perform = require('./_perform');
	
	$export($export.S, 'Promise', { 'try': function (callbackfn) {
		var promiseCapability = newPromiseCapability.f(this);
		var result = perform(callbackfn);
		(result.e ? promiseCapability.reject : promiseCapability.resolve)(result.v);
		return promiseCapability.promise;
	} });
	
	},{"./_export":99,"./_new-promise-capability":122,"./_perform":137}],186:[function(require,module,exports){
	// https://tc39.github.io/proposal-setmap-offrom/#sec-set.from
	require('./_set-collection-from')('Set');
	
	},{"./_set-collection-from":142}],187:[function(require,module,exports){
	// https://tc39.github.io/proposal-setmap-offrom/#sec-set.of
	require('./_set-collection-of')('Set');
	
	},{"./_set-collection-of":143}],188:[function(require,module,exports){
	// https://github.com/DavidBruant/Map-Set.prototype.toJSON
	var $export = require('./_export');
	
	$export($export.P + $export.R, 'Set', { toJSON: require('./_collection-to-json')('Set') });
	
	},{"./_collection-to-json":89,"./_export":99}],189:[function(require,module,exports){
	require('./_wks-define')('asyncIterator');
	
	},{"./_wks-define":160}],190:[function(require,module,exports){
	require('./_wks-define')('observable');
	
	},{"./_wks-define":160}],191:[function(require,module,exports){
	require('./es6.array.iterator');
	var global = require('./_global');
	var hide = require('./_hide');
	var Iterators = require('./_iterators');
	var TO_STRING_TAG = require('./_wks')('toStringTag');
	
	var DOMIterables = ('CSSRuleList,CSSStyleDeclaration,CSSValueList,ClientRectList,DOMRectList,DOMStringList,' +
		'DOMTokenList,DataTransferItemList,FileList,HTMLAllCollection,HTMLCollection,HTMLFormElement,HTMLSelectElement,' +
		'MediaList,MimeTypeArray,NamedNodeMap,NodeList,PaintRequestList,Plugin,PluginArray,SVGLengthList,SVGNumberList,' +
		'SVGPathSegList,SVGPointList,SVGStringList,SVGTransformList,SourceBufferList,StyleSheetList,TextTrackCueList,' +
		'TextTrackList,TouchList').split(',');
	
	for (var i = 0; i < DOMIterables.length; i++) {
		var NAME = DOMIterables[i];
		var Collection = global[NAME];
		var proto = Collection && Collection.prototype;
		if (proto && !proto[TO_STRING_TAG]) hide(proto, TO_STRING_TAG, NAME);
		Iterators[NAME] = Iterators.Array;
	}
	
	},{"./_global":102,"./_hide":104,"./_iterators":117,"./_wks":162,"./es6.array.iterator":167}],192:[function(require,module,exports){
	(function (process){
	/**
	 * This is the web browser implementation of `debug()`.
	 *
	 * Expose `debug()` as the module.
	 */
	
	exports = module.exports = require('./debug');
	exports.log = log;
	exports.formatArgs = formatArgs;
	exports.save = save;
	exports.load = load;
	exports.useColors = useColors;
	exports.storage = 'undefined' != typeof chrome
								 && 'undefined' != typeof chrome.storage
										? chrome.storage.local
										: localstorage();
	
	/**
	 * Colors.
	 */
	
	exports.colors = [
		'#0000CC', '#0000FF', '#0033CC', '#0033FF', '#0066CC', '#0066FF', '#0099CC',
		'#0099FF', '#00CC00', '#00CC33', '#00CC66', '#00CC99', '#00CCCC', '#00CCFF',
		'#3300CC', '#3300FF', '#3333CC', '#3333FF', '#3366CC', '#3366FF', '#3399CC',
		'#3399FF', '#33CC00', '#33CC33', '#33CC66', '#33CC99', '#33CCCC', '#33CCFF',
		'#6600CC', '#6600FF', '#6633CC', '#6633FF', '#66CC00', '#66CC33', '#9900CC',
		'#9900FF', '#9933CC', '#9933FF', '#99CC00', '#99CC33', '#CC0000', '#CC0033',
		'#CC0066', '#CC0099', '#CC00CC', '#CC00FF', '#CC3300', '#CC3333', '#CC3366',
		'#CC3399', '#CC33CC', '#CC33FF', '#CC6600', '#CC6633', '#CC9900', '#CC9933',
		'#CCCC00', '#CCCC33', '#FF0000', '#FF0033', '#FF0066', '#FF0099', '#FF00CC',
		'#FF00FF', '#FF3300', '#FF3333', '#FF3366', '#FF3399', '#FF33CC', '#FF33FF',
		'#FF6600', '#FF6633', '#FF9900', '#FF9933', '#FFCC00', '#FFCC33'
	];
	
	/**
	 * Currently only WebKit-based Web Inspectors, Firefox >= v31,
	 * and the Firebug extension (any Firefox version) are known
	 * to support "%c" CSS customizations.
	 *
	 * TODO: add a `localStorage` variable to explicitly enable/disable colors
	 */
	
	function useColors() {
		// NB: In an Electron preload script, document will be defined but not fully
		// initialized. Since we know we're in Chrome, we'll just detect this case
		// explicitly
		if (typeof window !== 'undefined' && window.process && window.process.type === 'renderer') {
			return true;
		}
	
		// Internet Explorer and Edge do not support colors.
		if (typeof navigator !== 'undefined' && navigator.userAgent && navigator.userAgent.toLowerCase().match(/(edge|trident)\/(\d+)/)) {
			return false;
		}
	
		// is webkit? http://stackoverflow.com/a/16459606/376773
		// document is undefined in react-native: https://github.com/facebook/react-native/pull/1632
		return (typeof document !== 'undefined' && document.documentElement && document.documentElement.style && document.documentElement.style.WebkitAppearance) ||
			// is firebug? http://stackoverflow.com/a/398120/376773
			(typeof window !== 'undefined' && window.console && (window.console.firebug || (window.console.exception && window.console.table))) ||
			// is firefox >= v31?
			// https://developer.mozilla.org/en-US/docs/Tools/Web_Console#Styling_messages
			(typeof navigator !== 'undefined' && navigator.userAgent && navigator.userAgent.toLowerCase().match(/firefox\/(\d+)/) && parseInt(RegExp.$1, 10) >= 31) ||
			// double check webkit in userAgent just in case we are in a worker
			(typeof navigator !== 'undefined' && navigator.userAgent && navigator.userAgent.toLowerCase().match(/applewebkit\/(\d+)/));
	}
	
	/**
	 * Map %j to `JSON.stringify()`, since no Web Inspectors do that by default.
	 */
	
	exports.formatters.j = function(v) {
		try {
			return JSON.stringify(v);
		} catch (err) {
			return '[UnexpectedJSONParseError]: ' + err.message;
		}
	};
	
	
	/**
	 * Colorize log arguments if enabled.
	 *
	 * @api public
	 */
	
	function formatArgs(args) {
		var useColors = this.useColors;
	
		args[0] = (useColors ? '%c' : '')
			+ this.namespace
			+ (useColors ? ' %c' : ' ')
			+ args[0]
			+ (useColors ? '%c ' : ' ')
			+ '+' + exports.humanize(this.diff);
	
		if (!useColors) return;
	
		var c = 'color: ' + this.color;
		args.splice(1, 0, c, 'color: inherit')
	
		// the final "%c" is somewhat tricky, because there could be other
		// arguments passed either before or after the %c, so we need to
		// figure out the correct index to insert the CSS into
		var index = 0;
		var lastC = 0;
		args[0].replace(/%[a-zA-Z%]/g, function(match) {
			if ('%%' === match) return;
			index++;
			if ('%c' === match) {
				// we only are interested in the *last* %c
				// (the user may have provided their own)
				lastC = index;
			}
		});
	
		args.splice(lastC, 0, c);
	}
	
	/**
	 * Invokes `console.log()` when available.
	 * No-op when `console.log` is not a "function".
	 *
	 * @api public
	 */
	
	function log() {
		// this hackery is required for IE8/9, where
		// the `console.log` function doesn't have 'apply'
		return 'object' === typeof console
			&& console.log
			&& Function.prototype.apply.call(console.log, console, arguments);
	}
	
	/**
	 * Save `namespaces`.
	 *
	 * @param {String} namespaces
	 * @api private
	 */
	
	function save(namespaces) {
		try {
			if (null == namespaces) {
				exports.storage.removeItem('debug');
			} else {
				exports.storage.debug = namespaces;
			}
		} catch(e) {}
	}
	
	/**
	 * Load `namespaces`.
	 *
	 * @return {String} returns the previously persisted debug modes
	 * @api private
	 */
	
	function load() {
		var r;
		try {
			r = exports.storage.debug;
		} catch(e) {}
	
		// If debug isn't set in LS, and we're in Electron, try to load $DEBUG
		if (!r && typeof process !== 'undefined' && 'env' in process) {
			r = process.env.DEBUG;
		}
	
		return r;
	}
	
	/**
	 * Enable namespaces listed in `localStorage.debug` initially.
	 */
	
	exports.enable(load());
	
	/**
	 * Localstorage attempts to return the localstorage.
	 *
	 * This is necessary because safari throws
	 * when a user disables cookies/localstorage
	 * and you attempt to access it.
	 *
	 * @return {LocalStorage}
	 * @api private
	 */
	
	function localstorage() {
		try {
			return window.localStorage;
		} catch (e) {}
	}
	
	}).call(this,require('_process'))
	
	},{"./debug":193,"_process":198}],193:[function(require,module,exports){
	
	/**
	 * This is the common logic for both the Node.js and web browser
	 * implementations of `debug()`.
	 *
	 * Expose `debug()` as the module.
	 */
	
	exports = module.exports = createDebug.debug = createDebug['default'] = createDebug;
	exports.coerce = coerce;
	exports.disable = disable;
	exports.enable = enable;
	exports.enabled = enabled;
	exports.humanize = require('ms');
	
	/**
	 * Active `debug` instances.
	 */
	exports.instances = [];
	
	/**
	 * The currently active debug mode names, and names to skip.
	 */
	
	exports.names = [];
	exports.skips = [];
	
	/**
	 * Map of special "%n" handling functions, for the debug "format" argument.
	 *
	 * Valid key names are a single, lower or upper-case letter, i.e. "n" and "N".
	 */
	
	exports.formatters = {};
	
	/**
	 * Select a color.
	 * @param {String} namespace
	 * @return {Number}
	 * @api private
	 */
	
	function selectColor(namespace) {
		var hash = 0, i;
	
		for (i in namespace) {
			hash  = ((hash << 5) - hash) + namespace.charCodeAt(i);
			hash |= 0; // Convert to 32bit integer
		}
	
		return exports.colors[Math.abs(hash) % exports.colors.length];
	}
	
	/**
	 * Create a debugger with the given `namespace`.
	 *
	 * @param {String} namespace
	 * @return {Function}
	 * @api public
	 */
	
	function createDebug(namespace) {
	
		var prevTime;
	
		function debug() {
			// disabled?
			if (!debug.enabled) return;
	
			var self = debug;
	
			// set `diff` timestamp
			var curr = +new Date();
			var ms = curr - (prevTime || curr);
			self.diff = ms;
			self.prev = prevTime;
			self.curr = curr;
			prevTime = curr;
	
			// turn the `arguments` into a proper Array
			var args = new Array(arguments.length);
			for (var i = 0; i < args.length; i++) {
				args[i] = arguments[i];
			}
	
			args[0] = exports.coerce(args[0]);
	
			if ('string' !== typeof args[0]) {
				// anything else let's inspect with %O
				args.unshift('%O');
			}
	
			// apply any `formatters` transformations
			var index = 0;
			args[0] = args[0].replace(/%([a-zA-Z%])/g, function(match, format) {
				// if we encounter an escaped % then don't increase the array index
				if (match === '%%') return match;
				index++;
				var formatter = exports.formatters[format];
				if ('function' === typeof formatter) {
					var val = args[index];
					match = formatter.call(self, val);
	
					// now we need to remove `args[index]` since it's inlined in the `format`
					args.splice(index, 1);
					index--;
				}
				return match;
			});
	
			// apply env-specific formatting (colors, etc.)
			exports.formatArgs.call(self, args);
	
			var logFn = debug.log || exports.log || console.log.bind(console);
			logFn.apply(self, args);
		}
	
		debug.namespace = namespace;
		debug.enabled = exports.enabled(namespace);
		debug.useColors = exports.useColors();
		debug.color = selectColor(namespace);
		debug.destroy = destroy;
	
		// env-specific initialization logic for debug instances
		if ('function' === typeof exports.init) {
			exports.init(debug);
		}
	
		exports.instances.push(debug);
	
		return debug;
	}
	
	function destroy () {
		var index = exports.instances.indexOf(this);
		if (index !== -1) {
			exports.instances.splice(index, 1);
			return true;
		} else {
			return false;
		}
	}
	
	/**
	 * Enables a debug mode by namespaces. This can include modes
	 * separated by a colon and wildcards.
	 *
	 * @param {String} namespaces
	 * @api public
	 */
	
	function enable(namespaces) {
		exports.save(namespaces);
	
		exports.names = [];
		exports.skips = [];
	
		var i;
		var split = (typeof namespaces === 'string' ? namespaces : '').split(/[\s,]+/);
		var len = split.length;
	
		for (i = 0; i < len; i++) {
			if (!split[i]) continue; // ignore empty strings
			namespaces = split[i].replace(/\*/g, '.*?');
			if (namespaces[0] === '-') {
				exports.skips.push(new RegExp('^' + namespaces.substr(1) + '$'));
			} else {
				exports.names.push(new RegExp('^' + namespaces + '$'));
			}
		}
	
		for (i = 0; i < exports.instances.length; i++) {
			var instance = exports.instances[i];
			instance.enabled = exports.enabled(instance.namespace);
		}
	}
	
	/**
	 * Disable debug output.
	 *
	 * @api public
	 */
	
	function disable() {
		exports.enable('');
	}
	
	/**
	 * Returns true if the given mode name is enabled, false otherwise.
	 *
	 * @param {String} name
	 * @return {Boolean}
	 * @api public
	 */
	
	function enabled(name) {
		if (name[name.length - 1] === '*') {
			return true;
		}
		var i, len;
		for (i = 0, len = exports.skips.length; i < len; i++) {
			if (exports.skips[i].test(name)) {
				return false;
			}
		}
		for (i = 0, len = exports.names.length; i < len; i++) {
			if (exports.names[i].test(name)) {
				return true;
			}
		}
		return false;
	}
	
	/**
	 * Coerce `val`.
	 *
	 * @param {Mixed} val
	 * @return {Mixed}
	 * @api private
	 */
	
	function coerce(val) {
		if (val instanceof Error) return val.stack || val.message;
		return val;
	}
	
	},{"ms":197}],194:[function(require,module,exports){
	/*!
		* domready (c) Dustin Diaz 2014 - License MIT
		*/
	!function (name, definition) {
	
		if (typeof module != 'undefined') module.exports = definition()
		else if (typeof define == 'function' && typeof define.amd == 'object') define(definition)
		else this[name] = definition()
	
	}('domready', function () {
	
		var fns = [], listener
			, doc = document
			, hack = doc.documentElement.doScroll
			, domContentLoaded = 'DOMContentLoaded'
			, loaded = (hack ? /^loaded|^c/ : /^loaded|^i|^c/).test(doc.readyState)
	
	
		if (!loaded)
		doc.addEventListener(domContentLoaded, listener = function () {
			doc.removeEventListener(domContentLoaded, listener)
			loaded = 1
			while (listener = fns.shift()) listener()
		})
	
		return function (fn) {
			loaded ? setTimeout(fn, 0) : fns.push(fn)
		}
	
	});
	
	},{}],195:[function(require,module,exports){
	var WildEmitter = require('wildemitter');
	
	function getMaxVolume (analyser, fftBins) {
		var maxVolume = -Infinity;
		analyser.getFloatFrequencyData(fftBins);
	
		for(var i=4, ii=fftBins.length; i < ii; i++) {
			if (fftBins[i] > maxVolume && fftBins[i] < 0) {
				maxVolume = fftBins[i];
			}
		};
	
		return maxVolume;
	}
	
	
	var audioContextType;
	if (typeof window !== 'undefined') {
		audioContextType = window.AudioContext || window.webkitAudioContext;
	}
	// use a single audio context due to hardware limits
	var audioContext = null;
	module.exports = function(stream, options) {
		var harker = new WildEmitter();
	
		// make it not break in non-supported browsers
		if (!audioContextType) return harker;
	
		//Config
		var options = options || {},
				smoothing = (options.smoothing || 0.1),
				interval = (options.interval || 50),
				threshold = options.threshold,
				play = options.play,
				history = options.history || 10,
				running = true;
	
		// Ensure that just a single AudioContext is internally created
		audioContext = options.audioContext || audioContext || new audioContextType();
	
		var sourceNode, fftBins, analyser;
	
		analyser = audioContext.createAnalyser();
		analyser.fftSize = 512;
		analyser.smoothingTimeConstant = smoothing;
		fftBins = new Float32Array(analyser.frequencyBinCount);
	
		if (stream.jquery) stream = stream[0];
		if (stream instanceof HTMLAudioElement || stream instanceof HTMLVideoElement) {
			//Audio Tag
			sourceNode = audioContext.createMediaElementSource(stream);
			if (typeof play === 'undefined') play = true;
			threshold = threshold || -50;
		} else {
			//WebRTC Stream
			sourceNode = audioContext.createMediaStreamSource(stream);
			threshold = threshold || -50;
		}
	
		sourceNode.connect(analyser);
		if (play) analyser.connect(audioContext.destination);
	
		harker.speaking = false;
	
		harker.suspend = function() {
			return audioContext.suspend();
		}
		harker.resume = function() {
			return audioContext.resume();
		}
		Object.defineProperty(harker, 'state', { get: function() {
			return audioContext.state;
		}});
		audioContext.onstatechange = function() {
			harker.emit('state_change', audioContext.state);
		}
	
		harker.setThreshold = function(t) {
			threshold = t;
		};
	
		harker.setInterval = function(i) {
			interval = i;
		};
	
		harker.stop = function() {
			running = false;
			harker.emit('volume_change', -100, threshold);
			if (harker.speaking) {
				harker.speaking = false;
				harker.emit('stopped_speaking');
			}
			analyser.disconnect();
			sourceNode.disconnect();
		};
		harker.speakingHistory = [];
		for (var i = 0; i < history; i++) {
				harker.speakingHistory.push(0);
		}
	
		// Poll the analyser node to determine if speaking
		// and emit events if changed
		var looper = function() {
			setTimeout(function() {
	
				//check if stop has been called
				if(!running) {
					return;
				}
	
				var currentVolume = getMaxVolume(analyser, fftBins);
	
				harker.emit('volume_change', currentVolume, threshold);
	
				var history = 0;
				if (currentVolume > threshold && !harker.speaking) {
					// trigger quickly, short history
					for (var i = harker.speakingHistory.length - 3; i < harker.speakingHistory.length; i++) {
						history += harker.speakingHistory[i];
					}
					if (history >= 2) {
						harker.speaking = true;
						harker.emit('speaking');
					}
				} else if (currentVolume < threshold && harker.speaking) {
					for (var i = 0; i < harker.speakingHistory.length; i++) {
						history += harker.speakingHistory[i];
					}
					if (history == 0) {
						harker.speaking = false;
						harker.emit('stopped_speaking');
					}
				}
				harker.speakingHistory.shift();
				harker.speakingHistory.push(0 + (currentVolume > threshold));
	
				looper();
			}, interval);
		};
		looper();
	
		return harker;
	}
	
	},{"wildemitter":221}],196:[function(require,module,exports){
	var support = require('webrtcsupport');
	
	
	function GainController(stream) {
			this.support = support.webAudio && support.mediaStream;
	
			// set our starting value
			this.gain = 1;
	
			if (this.support) {
					var context = this.context = new support.AudioContext();
					this.microphone = context.createMediaStreamSource(stream);
					this.gainFilter = context.createGain();
					this.destination = context.createMediaStreamDestination();
					this.outputStream = this.destination.stream;
					this.microphone.connect(this.gainFilter);
					this.gainFilter.connect(this.destination);
					stream.addTrack(this.outputStream.getAudioTracks()[0]);
					stream.removeTrack(stream.getAudioTracks()[0]);
			}
			this.stream = stream;
	}
	
	// setting
	GainController.prototype.setGain = function (val) {
			// check for support
			if (!this.support) return;
			this.gainFilter.gain.value = val;
			this.gain = val;
	};
	
	GainController.prototype.getGain = function () {
			return this.gain;
	};
	
	GainController.prototype.off = function () {
			return this.setGain(0);
	};
	
	GainController.prototype.on = function () {
			this.setGain(1);
	};
	
	
	module.exports = GainController;
	
	},{"webrtcsupport":217}],197:[function(require,module,exports){
	/**
	 * Helpers.
	 */
	
	var s = 1000;
	var m = s * 60;
	var h = m * 60;
	var d = h * 24;
	var y = d * 365.25;
	
	/**
	 * Parse or format the given `val`.
	 *
	 * Options:
	 *
	 *  - `long` verbose formatting [false]
	 *
	 * @param {String|Number} val
	 * @param {Object} [options]
	 * @throws {Error} throw an error if val is not a non-empty string or a number
	 * @return {String|Number}
	 * @api public
	 */
	
	module.exports = function(val, options) {
		options = options || {};
		var type = typeof val;
		if (type === 'string' && val.length > 0) {
			return parse(val);
		} else if (type === 'number' && isNaN(val) === false) {
			return options.long ? fmtLong(val) : fmtShort(val);
		}
		throw new Error(
			'val is not a non-empty string or a valid number. val=' +
				JSON.stringify(val)
		);
	};
	
	/**
	 * Parse the given `str` and return milliseconds.
	 *
	 * @param {String} str
	 * @return {Number}
	 * @api private
	 */
	
	function parse(str) {
		str = String(str);
		if (str.length > 100) {
			return;
		}
		var match = /^((?:\d+)?\.?\d+) *(milliseconds?|msecs?|ms|seconds?|secs?|s|minutes?|mins?|m|hours?|hrs?|h|days?|d|years?|yrs?|y)?$/i.exec(
			str
		);
		if (!match) {
			return;
		}
		var n = parseFloat(match[1]);
		var type = (match[2] || 'ms').toLowerCase();
		switch (type) {
			case 'years':
			case 'year':
			case 'yrs':
			case 'yr':
			case 'y':
				return n * y;
			case 'days':
			case 'day':
			case 'd':
				return n * d;
			case 'hours':
			case 'hour':
			case 'hrs':
			case 'hr':
			case 'h':
				return n * h;
			case 'minutes':
			case 'minute':
			case 'mins':
			case 'min':
			case 'm':
				return n * m;
			case 'seconds':
			case 'second':
			case 'secs':
			case 'sec':
			case 's':
				return n * s;
			case 'milliseconds':
			case 'millisecond':
			case 'msecs':
			case 'msec':
			case 'ms':
				return n;
			default:
				return undefined;
		}
	}
	
	/**
	 * Short format for `ms`.
	 *
	 * @param {Number} ms
	 * @return {String}
	 * @api private
	 */
	
	function fmtShort(ms) {
		if (ms >= d) {
			return Math.round(ms / d) + 'd';
		}
		if (ms >= h) {
			return Math.round(ms / h) + 'h';
		}
		if (ms >= m) {
			return Math.round(ms / m) + 'm';
		}
		if (ms >= s) {
			return Math.round(ms / s) + 's';
		}
		return ms + 'ms';
	}
	
	/**
	 * Long format for `ms`.
	 *
	 * @param {Number} ms
	 * @return {String}
	 * @api private
	 */
	
	function fmtLong(ms) {
		return plural(ms, d, 'day') ||
			plural(ms, h, 'hour') ||
			plural(ms, m, 'minute') ||
			plural(ms, s, 'second') ||
			ms + ' ms';
	}
	
	/**
	 * Pluralization helper.
	 */
	
	function plural(ms, n, name) {
		if (ms < n) {
			return;
		}
		if (ms < n * 1.5) {
			return Math.floor(ms / n) + ' ' + name;
		}
		return Math.ceil(ms / n) + ' ' + name + 's';
	}
	
	},{}],198:[function(require,module,exports){
	// shim for using process in browser
	var process = module.exports = {};
	
	// cached from whatever global is present so that test runners that stub it
	// don't break things.  But we need to wrap it in a try catch in case it is
	// wrapped in strict mode code which doesn't define any globals.  It's inside a
	// function because try/catches deoptimize in certain engines.
	
	var cachedSetTimeout;
	var cachedClearTimeout;
	
	function defaultSetTimout() {
			throw new Error('setTimeout has not been defined');
	}
	function defaultClearTimeout () {
			throw new Error('clearTimeout has not been defined');
	}
	(function () {
			try {
					if (typeof setTimeout === 'function') {
							cachedSetTimeout = setTimeout;
					} else {
							cachedSetTimeout = defaultSetTimout;
					}
			} catch (e) {
					cachedSetTimeout = defaultSetTimout;
			}
			try {
					if (typeof clearTimeout === 'function') {
							cachedClearTimeout = clearTimeout;
					} else {
							cachedClearTimeout = defaultClearTimeout;
					}
			} catch (e) {
					cachedClearTimeout = defaultClearTimeout;
			}
	} ())
	function runTimeout(fun) {
			if (cachedSetTimeout === setTimeout) {
					//normal enviroments in sane situations
					return setTimeout(fun, 0);
			}
			// if setTimeout wasn't available but was latter defined
			if ((cachedSetTimeout === defaultSetTimout || !cachedSetTimeout) && setTimeout) {
					cachedSetTimeout = setTimeout;
					return setTimeout(fun, 0);
			}
			try {
					// when when somebody has screwed with setTimeout but no I.E. maddness
					return cachedSetTimeout(fun, 0);
			} catch(e){
					try {
							// When we are in I.E. but the script has been evaled so I.E. doesn't trust the global object when called normally
							return cachedSetTimeout.call(null, fun, 0);
					} catch(e){
							// same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error
							return cachedSetTimeout.call(this, fun, 0);
					}
			}
	
	
	}
	function runClearTimeout(marker) {
			if (cachedClearTimeout === clearTimeout) {
					//normal enviroments in sane situations
					return clearTimeout(marker);
			}
			// if clearTimeout wasn't available but was latter defined
			if ((cachedClearTimeout === defaultClearTimeout || !cachedClearTimeout) && clearTimeout) {
					cachedClearTimeout = clearTimeout;
					return clearTimeout(marker);
			}
			try {
					// when when somebody has screwed with setTimeout but no I.E. maddness
					return cachedClearTimeout(marker);
			} catch (e){
					try {
							// When we are in I.E. but the script has been evaled so I.E. doesn't  trust the global object when called normally
							return cachedClearTimeout.call(null, marker);
					} catch (e){
							// same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error.
							// Some versions of I.E. have different rules for clearTimeout vs setTimeout
							return cachedClearTimeout.call(this, marker);
					}
			}
	
	
	
	}
	var queue = [];
	var draining = false;
	var currentQueue;
	var queueIndex = -1;
	
	function cleanUpNextTick() {
			if (!draining || !currentQueue) {
					return;
			}
			draining = false;
			if (currentQueue.length) {
					queue = currentQueue.concat(queue);
			} else {
					queueIndex = -1;
			}
			if (queue.length) {
					drainQueue();
			}
	}
	
	function drainQueue() {
			if (draining) {
					return;
			}
			var timeout = runTimeout(cleanUpNextTick);
			draining = true;
	
			var len = queue.length;
			while(len) {
					currentQueue = queue;
					queue = [];
					while (++queueIndex < len) {
							if (currentQueue) {
									currentQueue[queueIndex].run();
							}
					}
					queueIndex = -1;
					len = queue.length;
			}
			currentQueue = null;
			draining = false;
			runClearTimeout(timeout);
	}
	
	process.nextTick = function (fun) {
			var args = new Array(arguments.length - 1);
			if (arguments.length > 1) {
					for (var i = 1; i < arguments.length; i++) {
							args[i - 1] = arguments[i];
					}
			}
			queue.push(new Item(fun, args));
			if (queue.length === 1 && !draining) {
					runTimeout(drainQueue);
			}
	};
	
	// v8 likes predictible objects
	function Item(fun, array) {
			this.fun = fun;
			this.array = array;
	}
	Item.prototype.run = function () {
			this.fun.apply(null, this.array);
	};
	process.title = 'browser';
	process.browser = true;
	process.env = {};
	process.argv = [];
	process.version = ''; // empty string to avoid regexp issues
	process.versions = {};
	
	function noop() {}
	
	process.on = noop;
	process.addListener = noop;
	process.once = noop;
	process.off = noop;
	process.removeListener = noop;
	process.removeAllListeners = noop;
	process.emit = noop;
	process.prependListener = noop;
	process.prependOnceListener = noop;
	
	process.listeners = function (name) { return [] }
	
	process.binding = function (name) {
			throw new Error('process.binding is not supported');
	};
	
	process.cwd = function () { return '/' };
	process.chdir = function (dir) {
			throw new Error('process.chdir is not supported');
	};
	process.umask = function() { return 0; };
	
	},{}],199:[function(require,module,exports){
	'use strict';
	
	var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };
	
	var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();
	
	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
	
	var logger = require('./logger')('Message');
	var utils = require('./utils');
	
	var Message = function () {
		function Message() {
			_classCallCheck(this, Message);
		}
	
		_createClass(Message, null, [{
			key: 'parse',
			value: function parse(raw) {
				var object = void 0;
				var message = {};
	
				try {
					object = JSON.parse(raw);
				} catch (error) {
					logger.error('parse() | invalid JSON: %s', error);
	
					return;
				}
	
				if ((typeof object === 'undefined' ? 'undefined' : _typeof(object)) !== 'object' || Array.isArray(object)) {
					logger.error('parse() | not an object');
	
					return;
				}
	
				if (typeof object.id !== 'number') {
					logger.error('parse() | missing/invalid id field');
	
					return;
				}
	
				message.id = object.id;
	
				// Request.
				if (object.request) {
					message.request = true;
	
					if (typeof object.method !== 'string') {
						logger.error('parse() | missing/invalid method field');
	
						return;
					}
	
					message.method = object.method;
					message.data = object.data || {};
				}
				// Response.
				else if (object.response) {
						message.response = true;
	
						// Success.
						if (object.ok) {
							message.ok = true;
							message.data = object.data || {};
						}
						// Error.
						else {
								message.errorCode = object.errorCode;
								message.errorReason = object.errorReason;
							}
					}
					// Invalid.
					else {
							logger.error('parse() | missing request/response field');
	
							return;
						}
	
				return message;
			}
		}, {
			key: 'requestFactory',
			value: function requestFactory(method, data) {
				var request = {
					request: true,
					id: utils.randomNumber(),
					method: method,
					data: data || {}
				};
	
				return request;
			}
		}, {
			key: 'successResponseFactory',
			value: function successResponseFactory(request, data) {
				var response = {
					response: true,
					id: request.id,
					ok: true,
					data: data || {}
				};
	
				return response;
			}
		}, {
			key: 'errorResponseFactory',
			value: function errorResponseFactory(request, errorCode, errorReason) {
				var response = {
					response: true,
					id: request.id,
					errorCode: errorCode,
					errorReason: errorReason
				};
	
				return response;
			}
		}]);
	
		return Message;
	}();
	
	module.exports = Message;
	},{"./logger":202,"./utils":205}],200:[function(require,module,exports){
	'use strict';
	
	var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();
	
	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
	
	function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }
	
	function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }
	
	var EventEmitter = require('events').EventEmitter;
	var logger = require('./logger')('Peer');
	var Message = require('./Message');
	
	// Max time waiting for a response.
	var REQUEST_TIMEOUT = 20000;
	
	var Peer = function (_EventEmitter) {
		_inherits(Peer, _EventEmitter);
	
		function Peer(transport) {
			_classCallCheck(this, Peer);
	
			logger.debug('constructor()');
	
			var _this = _possibleConstructorReturn(this, (Peer.__proto__ || Object.getPrototypeOf(Peer)).call(this));
	
			_this.setMaxListeners(Infinity);
	
			// Transport.
			_this._transport = transport;
	
			// Closed flag.
			_this._closed = false;
	
			// Custom data object.
			_this._data = {};
	
			// Map of sent requests' handlers indexed by request.id.
			_this._requestHandlers = new Map();
	
			// Handle transport.
			_this._handleTransport();
			return _this;
		}
	
		_createClass(Peer, [{
			key: 'send',
			value: function send(method, data) {
				var _this2 = this;
	
				var request = Message.requestFactory(method, data);
	
				return this._transport.send(request).then(function () {
					return new Promise(function (pResolve, pReject) {
						var handler = {
							resolve: function resolve(data2) {
								if (!_this2._requestHandlers.delete(request.id)) return;
	
								clearTimeout(handler.timer);
								pResolve(data2);
							},
	
							reject: function reject(error) {
								if (!_this2._requestHandlers.delete(request.id)) return;
	
								clearTimeout(handler.timer);
								pReject(error);
							},
	
							timer: setTimeout(function () {
								if (!_this2._requestHandlers.delete(request.id)) return;
	
								pReject(new Error('request timeout'));
							}, REQUEST_TIMEOUT),
	
							close: function close() {
								clearTimeout(handler.timer);
								pReject(new Error('peer closed'));
							}
						};
	
						// Add handler stuff to the Map.
						_this2._requestHandlers.set(request.id, handler);
					});
				});
			}
		}, {
			key: 'close',
			value: function close() {
				logger.debug('close()');
	
				if (this._closed) return;
	
				this._closed = true;
	
				// Close transport.
				this._transport.close();
	
				// Close every pending request handler.
				this._requestHandlers.forEach(function (handler) {
					return handler.close();
				});
	
				// Emit 'close' event.
				this.emit('close');
			}
		}, {
			key: '_handleTransport',
			value: function _handleTransport() {
				var _this3 = this;
	
				if (this._transport.closed) {
					this._closed = true;
					setTimeout(function () {
						return _this3.emit('close');
					});
	
					return;
				}
	
				this._transport.on('connecting', function (currentAttempt) {
					_this3.emit('connecting', currentAttempt);
				});
	
				this._transport.on('open', function () {
					if (_this3._closed) return;
	
					// Emit 'open' event.
					_this3.emit('open');
				});
	
				this._transport.on('disconnected', function () {
					_this3.emit('disconnected');
				});
	
				this._transport.on('failed', function (currentAttempt) {
					_this3.emit('failed', currentAttempt);
				});
	
				this._transport.on('close', function () {
					if (_this3._closed) return;
	
					_this3._closed = true;
	
					// Emit 'close' event.
					_this3.emit('close');
				});
	
				this._transport.on('message', function (message) {
					if (message.response) {
						_this3._handleResponse(message);
					} else if (message.request) {
						_this3._handleRequest(message);
					}
				});
			}
		}, {
			key: '_handleResponse',
			value: function _handleResponse(response) {
				var handler = this._requestHandlers.get(response.id);
	
				if (!handler) {
					logger.error('received response does not match any sent request');
	
					return;
				}
	
				if (response.ok) {
					handler.resolve(response.data);
				} else {
					var error = new Error(response.errorReason);
	
					error.code = response.errorCode;
					handler.reject(error);
				}
			}
		}, {
			key: '_handleRequest',
			value: function _handleRequest(request) {
				var _this4 = this;
	
				this.emit('request',
				// Request.
				request,
				// accept() function.
				function (data) {
					var response = Message.successResponseFactory(request, data);
	
					_this4._transport.send(response).catch(function (error) {
						logger.warn('accept() failed, response could not be sent: %o', error);
					});
				},
				// reject() function.
				function (errorCode, errorReason) {
					if (errorCode instanceof Error) {
						errorReason = errorCode.toString();
						errorCode = 500;
					} else if (typeof errorCode === 'number' && errorReason instanceof Error) {
						errorReason = errorReason.toString();
					}
	
					var response = Message.errorResponseFactory(request, errorCode, errorReason);
	
					_this4._transport.send(response).catch(function (error) {
						logger.warn('reject() failed, response could not be sent: %o', error);
					});
				});
			}
		}, {
			key: 'data',
			get: function get() {
				return this._data;
			},
			set: function set(obj) {
				this._data = obj || {};
			}
		}, {
			key: 'closed',
			get: function get() {
				return this._closed;
			}
		}]);
	
		return Peer;
	}(EventEmitter);
	
	module.exports = Peer;
	},{"./Message":199,"./logger":202,"events":60}],201:[function(require,module,exports){
	'use strict';
	
	var Peer = require('./Peer');
	var transports = require('./transports');
	
	module.exports = {
		/**
		* Expose Peer.
		*/
		Peer: Peer,
	
		/**
		* Expose the built-in WebSocketTransport.
		*/
		WebSocketTransport: transports.WebSocketTransport
	};
	},{"./Peer":200,"./transports":204}],202:[function(require,module,exports){
	'use strict';
	
	var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();
	
	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
	
	var debug = require('debug');
	
	var APP_NAME = 'protoo-client';
	
	var Logger = function () {
		function Logger(prefix) {
			_classCallCheck(this, Logger);
	
			if (prefix) {
				this._debug = debug(APP_NAME + ':' + prefix);
				this._warn = debug(APP_NAME + ':WARN:' + prefix);
				this._error = debug(APP_NAME + ':ERROR:' + prefix);
			} else {
				this._debug = debug(APP_NAME);
				this._warn = debug(APP_NAME + ':WARN');
				this._error = debug(APP_NAME + ':ERROR');
			}
	
			/* eslint-disable no-console */
			this._debug.log = console.info.bind(console);
			this._warn.log = console.warn.bind(console);
			this._error.log = console.error.bind(console);
			/* eslint-enable no-console */
		}
	
		_createClass(Logger, [{
			key: 'debug',
			get: function get() {
				return this._debug;
			}
		}, {
			key: 'warn',
			get: function get() {
				return this._warn;
			}
		}, {
			key: 'error',
			get: function get() {
				return this._error;
			}
		}]);
	
		return Logger;
	}();
	
	module.exports = function (prefix) {
		return new Logger(prefix);
	};
	},{"debug":192}],203:[function(require,module,exports){
	'use strict';
	
	var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();
	
	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
	
	function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }
	
	function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }
	
	var EventEmitter = require('events').EventEmitter;
	var W3CWebSocket = require('websocket').w3cwebsocket;
	var retry = require('retry');
	var logger = require('../logger')('WebSocketTransport');
	var Message = require('../Message');
	
	var WS_SUBPROTOCOL = 'protoo';
	var DEFAULT_RETRY_OPTIONS = {
		retries: 10,
		factor: 2,
		minTimeout: 1 * 1000,
		maxTimeout: 8 * 1000
	};
	
	var WebSocketTransport = function (_EventEmitter) {
		_inherits(WebSocketTransport, _EventEmitter);
	
		function WebSocketTransport(url, options) {
			_classCallCheck(this, WebSocketTransport);
	
			logger.debug('constructor() [url:"%s", options:%o]', url, options);
	
			var _this = _possibleConstructorReturn(this, (WebSocketTransport.__proto__ || Object.getPrototypeOf(WebSocketTransport)).call(this));
	
			_this.setMaxListeners(Infinity);
	
			// Save URL and options.
			_this._url = url;
			_this._options = options || {};
	
			// WebSocket instance.
			_this._ws = null;
	
			// Closed flag.
			_this._closed = false;
	
			// Set WebSocket
			_this._setWebSocket();
			return _this;
		}
	
		_createClass(WebSocketTransport, [{
			key: 'send',
			value: function send(message) {
				if (this._closed) return Promise.reject(new Error('transport closed'));
	
				try {
					this._ws.send(JSON.stringify(message));
	
					return Promise.resolve();
				} catch (error) {
					logger.error('send() | error sending message: %o', error);
	
					return Promise.reject(error);
				}
			}
		}, {
			key: 'close',
			value: function close() {
				logger.debug('close()');
	
				if (this._closed) return;
	
				// Don't wait for the WebSocket 'close' event, do it now.
				this._closed = true;
				this.emit('close');
	
				try {
					this._ws.onopen = null;
					this._ws.onclose = null;
					this._ws.onerror = null;
					this._ws.onmessage = null;
					this._ws.close();
				} catch (error) {
					logger.error('close() | error closing the WebSocket: %o', error);
				}
			}
		}, {
			key: '_setWebSocket',
			value: function _setWebSocket() {
				var _this2 = this;
	
				var options = this._options;
				var operation = retry.operation(this._options.retry || DEFAULT_RETRY_OPTIONS);
				var wasConnected = false;
	
				operation.attempt(function (currentAttempt) {
					if (_this2._closed) {
						operation.stop();
	
						return;
					}
	
					logger.debug('_setWebSocket() [currentAttempt:%s]', currentAttempt);
	
					_this2._ws = new W3CWebSocket(_this2._url, WS_SUBPROTOCOL, options.origin, options.headers, options.requestOptions, options.clientConfig);
	
					_this2.emit('connecting', currentAttempt);
	
					_this2._ws.onopen = function () {
						if (_this2._closed) return;
	
						wasConnected = true;
	
						// Emit 'open' event.
						_this2.emit('open');
					};
	
					_this2._ws.onclose = function (event) {
						if (_this2._closed) return;
	
						logger.warn('WebSocket "close" event [wasClean:%s, code:%s, reason:"%s"]', event.wasClean, event.code, event.reason);
	
						// Don't retry if code is 4000 (closed by the server).
						if (event.code !== 4000) {
							// If it was not connected, try again.
							if (!wasConnected) {
								_this2.emit('failed', currentAttempt);
	
								if (operation.retry(true)) return;
							}
							// If it was connected, start from scratch.
							else {
									operation.stop();
	
									_this2.emit('disconnected');
									_this2._setWebSocket();
	
									return;
								}
						}
	
						_this2._closed = true;
	
						// Emit 'close' event.
						_this2.emit('close');
					};
	
					_this2._ws.onerror = function () {
						if (_this2._closed) return;
	
						logger.error('WebSocket "error" event');
					};
	
					_this2._ws.onmessage = function (event) {
						if (_this2._closed) return;
	
						var message = Message.parse(event.data);
	
						if (!message) return;
	
						if (_this2.listenerCount('message') === 0) {
							logger.error('no listeners for WebSocket "message" event, ignoring received message');
	
							return;
						}
	
						// Emit 'message' event.
						_this2.emit('message', message);
					};
				});
			}
		}, {
			key: 'closed',
			get: function get() {
				return this._closed;
			}
		}]);
	
		return WebSocketTransport;
	}(EventEmitter);
	
	module.exports = WebSocketTransport;
	},{"../Message":199,"../logger":202,"events":60,"retry":209,"websocket":218}],204:[function(require,module,exports){
	'use strict';
	
	var WebSocketTransport = require('./WebSocketTransport');
	
	module.exports = {
		WebSocketTransport: WebSocketTransport
	};
	},{"./WebSocketTransport":203}],205:[function(require,module,exports){
	'use strict';
	
	var randomNumber = require('random-number');
	
	var randomNumberGenerator = randomNumber.generator({
		min: 1000000,
		max: 9999999,
		integer: true
	});
	
	module.exports = {
		randomNumber: randomNumberGenerator
	};
	},{"random-number":207}],206:[function(require,module,exports){
	'use strict';
	
	var has = Object.prototype.hasOwnProperty;
	
	/**
	 * Decode a URI encoded string.
	 *
	 * @param {String} input The URI encoded string.
	 * @returns {String} The decoded string.
	 * @api private
	 */
	function decode(input) {
		return decodeURIComponent(input.replace(/\+/g, ' '));
	}
	
	/**
	 * Simple query string parser.
	 *
	 * @param {String} query The query string that needs to be parsed.
	 * @returns {Object}
	 * @api public
	 */
	function querystring(query) {
		var parser = /([^=?&]+)=?([^&]*)/g
			, result = {}
			, part;
	
		//
		// Little nifty parsing hack, leverage the fact that RegExp.exec increments
		// the lastIndex property so we can continue executing this loop until we've
		// parsed all results.
		//
		for (;
			part = parser.exec(query);
			result[decode(part[1])] = decode(part[2])
		);
	
		return result;
	}
	
	/**
	 * Transform a query string to an object.
	 *
	 * @param {Object} obj Object that should be transformed.
	 * @param {String} prefix Optional prefix.
	 * @returns {String}
	 * @api public
	 */
	function querystringify(obj, prefix) {
		prefix = prefix || '';
	
		var pairs = [];
	
		//
		// Optionally prefix with a '?' if needed
		//
		if ('string' !== typeof prefix) prefix = '?';
	
		for (var key in obj) {
			if (has.call(obj, key)) {
				pairs.push(encodeURIComponent(key) +'='+ encodeURIComponent(obj[key]));
			}
		}
	
		return pairs.length ? prefix + pairs.join('&') : '';
	}
	
	//
	// Expose the module.
	//
	exports.stringify = querystringify;
	exports.parse = querystring;
	
	},{}],207:[function(require,module,exports){
	void function(root){
	
		function defaults(options){
			var options = options || {}
			var min = options.min
			var max = options.max
			var integer = options.integer || false
			if ( min == null && max == null ) {
				min = 0
				max = 1
			} else if ( min == null ) {
				min = max - 1
			} else if ( max == null ) {
				max = min + 1
			}
			if ( max < min ) throw new Error('invalid options, max must be >= min')
			return {
				min:     min
			, max:     max
			, integer: integer
			}
		}
	
		function random(options){
			options = defaults(options)
			if ( options.max === options.min ) return options.min
			var r = Math.random() * (options.max - options.min + Number(!!options.integer)) + options.min
			return options.integer ? Math.floor(r) : r
		}
	
		function generator(options){
			options = defaults(options)
			return function(min, max, integer){
				options.min     = min != null ? min : options.min
				options.max     = max != null ? max : options.max
				options.integer = integer != null ? integer : options.integer
				return random(options)
			}
		}
	
		module.exports =  random
		module.exports.generator = generator
		module.exports.defaults = defaults
	}(this)
	
	},{}],208:[function(require,module,exports){
	'use strict';
	
	/**
	 * Check if we're required to add a port number.
	 *
	 * @see https://url.spec.whatwg.org/#default-port
	 * @param {Number|String} port Port number we need to check
	 * @param {String} protocol Protocol we need to check against.
	 * @returns {Boolean} Is it a default port for the given protocol
	 * @api private
	 */
	module.exports = function required(port, protocol) {
		protocol = protocol.split(':')[0];
		port = +port;
	
		if (!port) return false;
	
		switch (protocol) {
			case 'http':
			case 'ws':
			return port !== 80;
	
			case 'https':
			case 'wss':
			return port !== 443;
	
			case 'ftp':
			return port !== 21;
	
			case 'gopher':
			return port !== 70;
	
			case 'file':
			return false;
		}
	
		return port !== 0;
	};
	
	},{}],209:[function(require,module,exports){
	module.exports = require('./lib/retry');
	},{"./lib/retry":210}],210:[function(require,module,exports){
	var RetryOperation = require('./retry_operation');
	
	exports.operation = function(options) {
		var timeouts = exports.timeouts(options);
		return new RetryOperation(timeouts, {
				forever: options && options.forever,
				unref: options && options.unref
		});
	};
	
	exports.timeouts = function(options) {
		if (options instanceof Array) {
			return [].concat(options);
		}
	
		var opts = {
			retries: 10,
			factor: 2,
			minTimeout: 1 * 1000,
			maxTimeout: Infinity,
			randomize: false
		};
		for (var key in options) {
			opts[key] = options[key];
		}
	
		if (opts.minTimeout > opts.maxTimeout) {
			throw new Error('minTimeout is greater than maxTimeout');
		}
	
		var timeouts = [];
		for (var i = 0; i < opts.retries; i++) {
			timeouts.push(this.createTimeout(i, opts));
		}
	
		if (options && options.forever && !timeouts.length) {
			timeouts.push(this.createTimeout(i, opts));
		}
	
		// sort the array numerically ascending
		timeouts.sort(function(a,b) {
			return a - b;
		});
	
		return timeouts;
	};
	
	exports.createTimeout = function(attempt, opts) {
		var random = (opts.randomize)
			? (Math.random() + 1)
			: 1;
	
		var timeout = Math.round(random * opts.minTimeout * Math.pow(opts.factor, attempt));
		timeout = Math.min(timeout, opts.maxTimeout);
	
		return timeout;
	};
	
	exports.wrap = function(obj, options, methods) {
		if (options instanceof Array) {
			methods = options;
			options = null;
		}
	
		if (!methods) {
			methods = [];
			for (var key in obj) {
				if (typeof obj[key] === 'function') {
					methods.push(key);
				}
			}
		}
	
		for (var i = 0; i < methods.length; i++) {
			var method   = methods[i];
			var original = obj[method];
	
			obj[method] = function retryWrapper() {
				var op       = exports.operation(options);
				var args     = Array.prototype.slice.call(arguments);
				var callback = args.pop();
	
				args.push(function(err) {
					if (op.retry(err)) {
						return;
					}
					if (err) {
						arguments[0] = op.mainError();
					}
					callback.apply(this, arguments);
				});
	
				op.attempt(function() {
					original.apply(obj, args);
				});
			};
			obj[method].options = options;
		}
	};
	
	},{"./retry_operation":211}],211:[function(require,module,exports){
	function RetryOperation(timeouts, options) {
		// Compatibility for the old (timeouts, retryForever) signature
		if (typeof options === 'boolean') {
			options = { forever: options };
		}
	
		this._timeouts = timeouts;
		this._options = options || {};
		this._fn = null;
		this._errors = [];
		this._attempts = 1;
		this._operationTimeout = null;
		this._operationTimeoutCb = null;
		this._timeout = null;
	
		if (this._options.forever) {
			this._cachedTimeouts = this._timeouts.slice(0);
		}
	}
	module.exports = RetryOperation;
	
	RetryOperation.prototype.stop = function() {
		if (this._timeout) {
			clearTimeout(this._timeout);
		}
	
		this._timeouts       = [];
		this._cachedTimeouts = null;
	};
	
	RetryOperation.prototype.retry = function(err) {
		if (this._timeout) {
			clearTimeout(this._timeout);
		}
	
		if (!err) {
			return false;
		}
	
		this._errors.push(err);
	
		var timeout = this._timeouts.shift();
		if (timeout === undefined) {
			if (this._cachedTimeouts) {
				// retry forever, only keep last error
				this._errors.splice(this._errors.length - 1, this._errors.length);
				this._timeouts = this._cachedTimeouts.slice(0);
				timeout = this._timeouts.shift();
			} else {
				return false;
			}
		}
	
		var self = this;
		var timer = setTimeout(function() {
			self._attempts++;
	
			if (self._operationTimeoutCb) {
				self._timeout = setTimeout(function() {
					self._operationTimeoutCb(self._attempts);
				}, self._operationTimeout);
	
				if (this._options.unref) {
						self._timeout.unref();
				}
			}
	
			self._fn(self._attempts);
		}, timeout);
	
		if (this._options.unref) {
				timer.unref();
		}
	
		return true;
	};
	
	RetryOperation.prototype.attempt = function(fn, timeoutOps) {
		this._fn = fn;
	
		if (timeoutOps) {
			if (timeoutOps.timeout) {
				this._operationTimeout = timeoutOps.timeout;
			}
			if (timeoutOps.cb) {
				this._operationTimeoutCb = timeoutOps.cb;
			}
		}
	
		var self = this;
		if (this._operationTimeoutCb) {
			this._timeout = setTimeout(function() {
				self._operationTimeoutCb();
			}, self._operationTimeout);
		}
	
		this._fn(this._attempts);
	};
	
	RetryOperation.prototype.try = function(fn) {
		console.log('Using RetryOperation.try() is deprecated');
		this.attempt(fn);
	};
	
	RetryOperation.prototype.start = function(fn) {
		console.log('Using RetryOperation.start() is deprecated');
		this.attempt(fn);
	};
	
	RetryOperation.prototype.start = RetryOperation.prototype.try;
	
	RetryOperation.prototype.errors = function() {
		return this._errors;
	};
	
	RetryOperation.prototype.attempts = function() {
		return this._attempts;
	};
	
	RetryOperation.prototype.mainError = function() {
		if (this._errors.length === 0) {
			return null;
		}
	
		var counts = {};
		var mainError = null;
		var mainErrorCount = 0;
	
		for (var i = 0; i < this._errors.length; i++) {
			var error = this._errors[i];
			var message = error.message;
			var count = (counts[message] || 0) + 1;
	
			counts[message] = count;
	
			if (count >= mainErrorCount) {
				mainError = error;
				mainErrorCount = count;
			}
		}
	
		return mainError;
	};
	
	},{}],212:[function(require,module,exports){
	var grammar = module.exports = {
		v: [{
			name: 'version',
			reg: /^(\d*)$/
		}],
		o: [{ //o=- 20518 0 IN IP4 203.0.113.1
			// NB: sessionId will be a String in most cases because it is huge
			name: 'origin',
			reg: /^(\S*) (\d*) (\d*) (\S*) IP(\d) (\S*)/,
			names: ['username', 'sessionId', 'sessionVersion', 'netType', 'ipVer', 'address'],
			format: '%s %s %d %s IP%d %s'
		}],
		// default parsing of these only (though some of these feel outdated)
		s: [{ name: 'name' }],
		i: [{ name: 'description' }],
		u: [{ name: 'uri' }],
		e: [{ name: 'email' }],
		p: [{ name: 'phone' }],
		z: [{ name: 'timezones' }], // TODO: this one can actually be parsed properly..
		r: [{ name: 'repeats' }],   // TODO: this one can also be parsed properly
		//k: [{}], // outdated thing ignored
		t: [{ //t=0 0
			name: 'timing',
			reg: /^(\d*) (\d*)/,
			names: ['start', 'stop'],
			format: '%d %d'
		}],
		c: [{ //c=IN IP4 10.47.197.26
			name: 'connection',
			reg: /^IN IP(\d) (\S*)/,
			names: ['version', 'ip'],
			format: 'IN IP%d %s'
		}],
		b: [{ //b=AS:4000
			push: 'bandwidth',
			reg: /^(TIAS|AS|CT|RR|RS):(\d*)/,
			names: ['type', 'limit'],
			format: '%s:%s'
		}],
		m: [{ //m=video 51744 RTP/AVP 126 97 98 34 31
			// NB: special - pushes to session
			// TODO: rtp/fmtp should be filtered by the payloads found here?
			reg: /^(\w*) (\d*) ([\w\/]*)(?: (.*))?/,
			names: ['type', 'port', 'protocol', 'payloads'],
			format: '%s %d %s %s'
		}],
		a: [
			{ //a=rtpmap:110 opus/48000/2
				push: 'rtp',
				reg: /^rtpmap:(\d*) ([\w\-\.]*)(?:\s*\/(\d*)(?:\s*\/(\S*))?)?/,
				names: ['payload', 'codec', 'rate', 'encoding'],
				format: function (o) {
					return (o.encoding) ?
						'rtpmap:%d %s/%s/%s':
						o.rate ?
						'rtpmap:%d %s/%s':
						'rtpmap:%d %s';
				}
			},
			{ //a=fmtp:108 profile-level-id=24;object=23;bitrate=64000
				//a=fmtp:111 minptime=10; useinbandfec=1
				push: 'fmtp',
				reg: /^fmtp:(\d*) ([\S| ]*)/,
				names: ['payload', 'config'],
				format: 'fmtp:%d %s'
			},
			{ //a=control:streamid=0
				name: 'control',
				reg: /^control:(.*)/,
				format: 'control:%s'
			},
			{ //a=rtcp:65179 IN IP4 193.84.77.194
				name: 'rtcp',
				reg: /^rtcp:(\d*)(?: (\S*) IP(\d) (\S*))?/,
				names: ['port', 'netType', 'ipVer', 'address'],
				format: function (o) {
					return (o.address != null) ?
						'rtcp:%d %s IP%d %s':
						'rtcp:%d';
				}
			},
			{ //a=rtcp-fb:98 trr-int 100
				push: 'rtcpFbTrrInt',
				reg: /^rtcp-fb:(\*|\d*) trr-int (\d*)/,
				names: ['payload', 'value'],
				format: 'rtcp-fb:%d trr-int %d'
			},
			{ //a=rtcp-fb:98 nack rpsi
				push: 'rtcpFb',
				reg: /^rtcp-fb:(\*|\d*) ([\w-_]*)(?: ([\w-_]*))?/,
				names: ['payload', 'type', 'subtype'],
				format: function (o) {
					return (o.subtype != null) ?
						'rtcp-fb:%s %s %s':
						'rtcp-fb:%s %s';
				}
			},
			{ //a=extmap:2 urn:ietf:params:rtp-hdrext:toffset
				//a=extmap:1/recvonly URI-gps-string
				push: 'ext',
				reg: /^extmap:(\d+)(?:\/(\w+))? (\S*)(?: (\S*))?/,
				names: ['value', 'direction', 'uri', 'config'],
				format: function (o) {
					return 'extmap:%d' + (o.direction ? '/%s' : '%v') + ' %s' + (o.config ? ' %s' : '');
				}
			},
			{ //a=crypto:1 AES_CM_128_HMAC_SHA1_80 inline:PS1uQCVeeCFCanVmcjkpPywjNWhcYD0mXXtxaVBR|2^20|1:32
				push: 'crypto',
				reg: /^crypto:(\d*) ([\w_]*) (\S*)(?: (\S*))?/,
				names: ['id', 'suite', 'config', 'sessionConfig'],
				format: function (o) {
					return (o.sessionConfig != null) ?
						'crypto:%d %s %s %s':
						'crypto:%d %s %s';
				}
			},
			{ //a=setup:actpass
				name: 'setup',
				reg: /^setup:(\w*)/,
				format: 'setup:%s'
			},
			{ //a=mid:1
				name: 'mid',
				reg: /^mid:([^\s]*)/,
				format: 'mid:%s'
			},
			{ //a=msid:0c8b064d-d807-43b4-b434-f92a889d8587 98178685-d409-46e0-8e16-7ef0db0db64a
				name: 'msid',
				reg: /^msid:(.*)/,
				format: 'msid:%s'
			},
			{ //a=ptime:20
				name: 'ptime',
				reg: /^ptime:(\d*)/,
				format: 'ptime:%d'
			},
			{ //a=maxptime:60
				name: 'maxptime',
				reg: /^maxptime:(\d*)/,
				format: 'maxptime:%d'
			},
			{ //a=sendrecv
				name: 'direction',
				reg: /^(sendrecv|recvonly|sendonly|inactive)/
			},
			{ //a=ice-lite
				name: 'icelite',
				reg: /^(ice-lite)/
			},
			{ //a=ice-ufrag:F7gI
				name: 'iceUfrag',
				reg: /^ice-ufrag:(\S*)/,
				format: 'ice-ufrag:%s'
			},
			{ //a=ice-pwd:x9cml/YzichV2+XlhiMu8g
				name: 'icePwd',
				reg: /^ice-pwd:(\S*)/,
				format: 'ice-pwd:%s'
			},
			{ //a=fingerprint:SHA-1 00:11:22:33:44:55:66:77:88:99:AA:BB:CC:DD:EE:FF:00:11:22:33
				name: 'fingerprint',
				reg: /^fingerprint:(\S*) (\S*)/,
				names: ['type', 'hash'],
				format: 'fingerprint:%s %s'
			},
			{ //a=candidate:0 1 UDP 2113667327 203.0.113.1 54400 typ host
				//a=candidate:1162875081 1 udp 2113937151 192.168.34.75 60017 typ host generation 0 network-id 3 network-cost 10
				//a=candidate:3289912957 2 udp 1845501695 193.84.77.194 60017 typ srflx raddr 192.168.34.75 rport 60017 generation 0 network-id 3 network-cost 10
				//a=candidate:229815620 1 tcp 1518280447 192.168.150.19 60017 typ host tcptype active generation 0 network-id 3 network-cost 10
				//a=candidate:3289912957 2 tcp 1845501695 193.84.77.194 60017 typ srflx raddr 192.168.34.75 rport 60017 tcptype passive generation 0 network-id 3 network-cost 10
				push:'candidates',
				reg: /^candidate:(\S*) (\d*) (\S*) (\d*) (\S*) (\d*) typ (\S*)(?: raddr (\S*) rport (\d*))?(?: tcptype (\S*))?(?: generation (\d*))?(?: network-id (\d*))?(?: network-cost (\d*))?/,
				names: ['foundation', 'component', 'transport', 'priority', 'ip', 'port', 'type', 'raddr', 'rport', 'tcptype', 'generation', 'network-id', 'network-cost'],
				format: function (o) {
					var str = 'candidate:%s %d %s %d %s %d typ %s';
	
					str += (o.raddr != null) ? ' raddr %s rport %d' : '%v%v';
	
					// NB: candidate has three optional chunks, so %void middles one if it's missing
					str += (o.tcptype != null) ? ' tcptype %s' : '%v';
	
					if (o.generation != null) {
						str += ' generation %d';
					}
	
					str += (o['network-id'] != null) ? ' network-id %d' : '%v';
					str += (o['network-cost'] != null) ? ' network-cost %d' : '%v';
					return str;
				}
			},
			{ //a=end-of-candidates (keep after the candidates line for readability)
				name: 'endOfCandidates',
				reg: /^(end-of-candidates)/
			},
			{ //a=remote-candidates:1 203.0.113.1 54400 2 203.0.113.1 54401 ...
				name: 'remoteCandidates',
				reg: /^remote-candidates:(.*)/,
				format: 'remote-candidates:%s'
			},
			{ //a=ice-options:google-ice
				name: 'iceOptions',
				reg: /^ice-options:(\S*)/,
				format: 'ice-options:%s'
			},
			{ //a=ssrc:2566107569 cname:t9YU8M1UxTF8Y1A1
				push: 'ssrcs',
				reg: /^ssrc:(\d*) ([\w_-]*)(?::(.*))?/,
				names: ['id', 'attribute', 'value'],
				format: function (o) {
					var str = 'ssrc:%d';
					if (o.attribute != null) {
						str += ' %s';
						if (o.value != null) {
							str += ':%s';
						}
					}
					return str;
				}
			},
			{ //a=ssrc-group:FEC 1 2
				//a=ssrc-group:FEC-FR 3004364195 1080772241
				push: 'ssrcGroups',
				// token-char = %x21 / %x23-27 / %x2A-2B / %x2D-2E / %x30-39 / %x41-5A / %x5E-7E
				reg: /^ssrc-group:([\x21\x23\x24\x25\x26\x27\x2A\x2B\x2D\x2E\w]*) (.*)/,
				names: ['semantics', 'ssrcs'],
				format: 'ssrc-group:%s %s'
			},
			{ //a=msid-semantic: WMS Jvlam5X3SX1OP6pn20zWogvaKJz5Hjf9OnlV
				name: 'msidSemantic',
				reg: /^msid-semantic:\s?(\w*) (\S*)/,
				names: ['semantic', 'token'],
				format: 'msid-semantic: %s %s' // space after ':' is not accidental
			},
			{ //a=group:BUNDLE audio video
				push: 'groups',
				reg: /^group:(\w*) (.*)/,
				names: ['type', 'mids'],
				format: 'group:%s %s'
			},
			{ //a=rtcp-mux
				name: 'rtcpMux',
				reg: /^(rtcp-mux)/
			},
			{ //a=rtcp-rsize
				name: 'rtcpRsize',
				reg: /^(rtcp-rsize)/
			},
			{ //a=sctpmap:5000 webrtc-datachannel 1024
				name: 'sctpmap',
				reg: /^sctpmap:([\w_\/]*) (\S*)(?: (\S*))?/,
				names: ['sctpmapNumber', 'app', 'maxMessageSize'],
				format: function (o) {
					return (o.maxMessageSize != null) ?
						'sctpmap:%s %s %s' :
						'sctpmap:%s %s';
				}
			},
			{ //a=x-google-flag:conference
				name: 'xGoogleFlag',
				reg: /^x-google-flag:([^\s]*)/,
				format: 'x-google-flag:%s'
			},
			{ //a=rid:1 send max-width=1280;max-height=720;max-fps=30;depend=0
				push: 'rids',
				reg: /^rid:([\d\w]+) (\w+)(?: ([\S| ]*))?/,
				names: ['id', 'direction', 'params'],
				format: function (o) {
					return (o.params) ? 'rid:%s %s %s' : 'rid:%s %s';
				}
			},
			{ //a=imageattr:97 send [x=800,y=640,sar=1.1,q=0.6] [x=480,y=320] recv [x=330,y=250]
				//a=imageattr:* send [x=800,y=640] recv *
				//a=imageattr:100 recv [x=320,y=240]
				push: 'imageattrs',
				reg: new RegExp(
					//a=imageattr:97
					'^imageattr:(\\d+|\\*)' +
					//send [x=800,y=640,sar=1.1,q=0.6] [x=480,y=320]
					'[\\s\\t]+(send|recv)[\\s\\t]+(\\*|\\[\\S+\\](?:[\\s\\t]+\\[\\S+\\])*)' +
					//recv [x=330,y=250]
					'(?:[\\s\\t]+(recv|send)[\\s\\t]+(\\*|\\[\\S+\\](?:[\\s\\t]+\\[\\S+\\])*))?'
				),
				names: ['pt', 'dir1', 'attrs1', 'dir2', 'attrs2'],
				format: function (o) {
					return 'imageattr:%s %s %s' + (o.dir2 ? ' %s %s' : '');
				}
			},
			{ //a=simulcast:send 1,2,3;~4,~5 recv 6;~7,~8
				//a=simulcast:recv 1;4,5 send 6;7
				name: 'simulcast',
				reg: new RegExp(
					//a=simulcast:
					'^simulcast:' +
					//send 1,2,3;~4,~5
					'(send|recv) ([a-zA-Z0-9\\-_~;,]+)' +
					//space + recv 6;~7,~8
					'(?:\\s?(send|recv) ([a-zA-Z0-9\\-_~;,]+))?' +
					//end
					'$'
				),
				names: ['dir1', 'list1', 'dir2', 'list2'],
				format: function (o) {
					return 'simulcast:%s %s' + (o.dir2 ? ' %s %s' : '');
				}
			},
			{ //Old simulcast draft 03 (implemented by Firefox)
				//  https://tools.ietf.org/html/draft-ietf-mmusic-sdp-simulcast-03
				//a=simulcast: recv pt=97;98 send pt=97
				//a=simulcast: send rid=5;6;7 paused=6,7
				name: 'simulcast_03',
				reg: /^simulcast:[\s\t]+([\S+\s\t]+)$/,
				names: ['value'],
				format: 'simulcast: %s'
			},
			{
				//a=framerate:25
				//a=framerate:29.97
				name: 'framerate',
				reg: /^framerate:(\d+(?:$|\.\d+))/,
				format: 'framerate:%s'
			},
			{ // RFC4570
				//a=source-filter: incl IN IP4 239.5.2.31 10.1.15.5
				name: 'sourceFilter',
				reg: /^source-filter: *(excl|incl) (\S*) (IP4|IP6|\*) (\S*) (.*)/,
				names: ['filterMode', 'netType', 'addressTypes', 'destAddress', 'srcList'],
				format: 'source-filter: %s %s %s %s %s'
			},
			{ // any a= that we don't understand is kepts verbatim on media.invalid
				push: 'invalid',
				names: ['value']
			}
		]
	};
	
	// set sensible defaults to avoid polluting the grammar with boring details
	Object.keys(grammar).forEach(function (key) {
		var objs = grammar[key];
		objs.forEach(function (obj) {
			if (!obj.reg) {
				obj.reg = /(.*)/;
			}
			if (!obj.format) {
				obj.format = '%s';
			}
		});
	});
	
	},{}],213:[function(require,module,exports){
	var parser = require('./parser');
	var writer = require('./writer');
	
	exports.write = writer;
	exports.parse = parser.parse;
	exports.parseFmtpConfig = parser.parseFmtpConfig;
	exports.parseParams = parser.parseParams;
	exports.parsePayloads = parser.parsePayloads;
	exports.parseRemoteCandidates = parser.parseRemoteCandidates;
	exports.parseImageAttributes = parser.parseImageAttributes;
	exports.parseSimulcastStreamList = parser.parseSimulcastStreamList;
	
	},{"./parser":214,"./writer":215}],214:[function(require,module,exports){
	var toIntIfInt = function (v) {
		return String(Number(v)) === v ? Number(v) : v;
	};
	
	var attachProperties = function (match, location, names, rawName) {
		if (rawName && !names) {
			location[rawName] = toIntIfInt(match[1]);
		}
		else {
			for (var i = 0; i < names.length; i += 1) {
				if (match[i+1] != null) {
					location[names[i]] = toIntIfInt(match[i+1]);
				}
			}
		}
	};
	
	var parseReg = function (obj, location, content) {
		var needsBlank = obj.name && obj.names;
		if (obj.push && !location[obj.push]) {
			location[obj.push] = [];
		}
		else if (needsBlank && !location[obj.name]) {
			location[obj.name] = {};
		}
		var keyLocation = obj.push ?
			{} :  // blank object that will be pushed
			needsBlank ? location[obj.name] : location; // otherwise, named location or root
	
		attachProperties(content.match(obj.reg), keyLocation, obj.names, obj.name);
	
		if (obj.push) {
			location[obj.push].push(keyLocation);
		}
	};
	
	var grammar = require('./grammar');
	var validLine = RegExp.prototype.test.bind(/^([a-z])=(.*)/);
	
	exports.parse = function (sdp) {
		var session = {}
			, media = []
			, location = session; // points at where properties go under (one of the above)
	
		// parse lines we understand
		sdp.split(/(\r\n|\r|\n)/).filter(validLine).forEach(function (l) {
			var type = l[0];
			var content = l.slice(2);
			if (type === 'm') {
				media.push({rtp: [], fmtp: []});
				location = media[media.length-1]; // point at latest media line
			}
	
			for (var j = 0; j < (grammar[type] || []).length; j += 1) {
				var obj = grammar[type][j];
				if (obj.reg.test(content)) {
					return parseReg(obj, location, content);
				}
			}
		});
	
		session.media = media; // link it up
		return session;
	};
	
	var paramReducer = function (acc, expr) {
		var s = expr.split(/=(.+)/, 2);
		if (s.length === 2) {
			acc[s[0]] = toIntIfInt(s[1]);
		}
		return acc;
	};
	
	exports.parseParams = function (str) {
		return str.split(/\;\s?/).reduce(paramReducer, {});
	};
	
	// For backward compatibility - alias will be removed in 3.0.0
	exports.parseFmtpConfig = exports.parseParams;
	
	exports.parsePayloads = function (str) {
		return str.split(' ').map(Number);
	};
	
	exports.parseRemoteCandidates = function (str) {
		var candidates = [];
		var parts = str.split(' ').map(toIntIfInt);
		for (var i = 0; i < parts.length; i += 3) {
			candidates.push({
				component: parts[i],
				ip: parts[i + 1],
				port: parts[i + 2]
			});
		}
		return candidates;
	};
	
	exports.parseImageAttributes = function (str) {
		return str.split(' ').map(function (item) {
			return item.substring(1, item.length-1).split(',').reduce(paramReducer, {});
		});
	};
	
	exports.parseSimulcastStreamList = function (str) {
		return str.split(';').map(function (stream) {
			return stream.split(',').map(function (format) {
				var scid, paused = false;
	
				if (format[0] !== '~') {
					scid = toIntIfInt(format);
				} else {
					scid = toIntIfInt(format.substring(1, format.length));
					paused = true;
				}
	
				return {
					scid: scid,
					paused: paused
				};
			});
		});
	};
	
	},{"./grammar":212}],215:[function(require,module,exports){
	var grammar = require('./grammar');
	
	// customized util.format - discards excess arguments and can void middle ones
	var formatRegExp = /%[sdv%]/g;
	var format = function (formatStr) {
		var i = 1;
		var args = arguments;
		var len = args.length;
		return formatStr.replace(formatRegExp, function (x) {
			if (i >= len) {
				return x; // missing argument
			}
			var arg = args[i];
			i += 1;
			switch (x) {
			case '%%':
				return '%';
			case '%s':
				return String(arg);
			case '%d':
				return Number(arg);
			case '%v':
				return '';
			}
		});
		// NB: we discard excess arguments - they are typically undefined from makeLine
	};
	
	var makeLine = function (type, obj, location) {
		var str = obj.format instanceof Function ?
			(obj.format(obj.push ? location : location[obj.name])) :
			obj.format;
	
		var args = [type + '=' + str];
		if (obj.names) {
			for (var i = 0; i < obj.names.length; i += 1) {
				var n = obj.names[i];
				if (obj.name) {
					args.push(location[obj.name][n]);
				}
				else { // for mLine and push attributes
					args.push(location[obj.names[i]]);
				}
			}
		}
		else {
			args.push(location[obj.name]);
		}
		return format.apply(null, args);
	};
	
	// RFC specified order
	// TODO: extend this with all the rest
	var defaultOuterOrder = [
		'v', 'o', 's', 'i',
		'u', 'e', 'p', 'c',
		'b', 't', 'r', 'z', 'a'
	];
	var defaultInnerOrder = ['i', 'c', 'b', 'a'];
	
	
	module.exports = function (session, opts) {
		opts = opts || {};
		// ensure certain properties exist
		if (session.version == null) {
			session.version = 0; // 'v=0' must be there (only defined version atm)
		}
		if (session.name == null) {
			session.name = ' '; // 's= ' must be there if no meaningful name set
		}
		session.media.forEach(function (mLine) {
			if (mLine.payloads == null) {
				mLine.payloads = '';
			}
		});
	
		var outerOrder = opts.outerOrder || defaultOuterOrder;
		var innerOrder = opts.innerOrder || defaultInnerOrder;
		var sdp = [];
	
		// loop through outerOrder for matching properties on session
		outerOrder.forEach(function (type) {
			grammar[type].forEach(function (obj) {
				if (obj.name in session && session[obj.name] != null) {
					sdp.push(makeLine(type, obj, session));
				}
				else if (obj.push in session && session[obj.push] != null) {
					session[obj.push].forEach(function (el) {
						sdp.push(makeLine(type, obj, el));
					});
				}
			});
		});
	
		// then for each media line, follow the innerOrder
		session.media.forEach(function (mLine) {
			sdp.push(makeLine('m', grammar.m[0], mLine));
	
			innerOrder.forEach(function (type) {
				grammar[type].forEach(function (obj) {
					if (obj.name in mLine && mLine[obj.name] != null) {
						sdp.push(makeLine(type, obj, mLine));
					}
					else if (obj.push in mLine && mLine[obj.push] != null) {
						mLine[obj.push].forEach(function (el) {
							sdp.push(makeLine(type, obj, el));
						});
					}
				});
			});
		});
	
		return sdp.join('\r\n') + '\r\n';
	};
	
	},{"./grammar":212}],216:[function(require,module,exports){
	(function (global){
	'use strict';
	
	var required = require('requires-port')
		, qs = require('querystringify')
		, protocolre = /^([a-z][a-z0-9.+-]*:)?(\/\/)?([\S\s]*)/i
		, slashes = /^[A-Za-z][A-Za-z0-9+-.]*:\/\//;
	
	/**
	 * These are the parse rules for the URL parser, it informs the parser
	 * about:
	 *
	 * 0. The char it Needs to parse, if it's a string it should be done using
	 *    indexOf, RegExp using exec and NaN means set as current value.
	 * 1. The property we should set when parsing this value.
	 * 2. Indication if it's backwards or forward parsing, when set as number it's
	 *    the value of extra chars that should be split off.
	 * 3. Inherit from location if non existing in the parser.
	 * 4. `toLowerCase` the resulting value.
	 */
	var rules = [
		['#', 'hash'],                        // Extract from the back.
		['?', 'query'],                       // Extract from the back.
		['/', 'pathname'],                    // Extract from the back.
		['@', 'auth', 1],                     // Extract from the front.
		[NaN, 'host', undefined, 1, 1],       // Set left over value.
		[/:(\d+)$/, 'port', undefined, 1],    // RegExp the back.
		[NaN, 'hostname', undefined, 1, 1]    // Set left over.
	];
	
	/**
	 * These properties should not be copied or inherited from. This is only needed
	 * for all non blob URL's as a blob URL does not include a hash, only the
	 * origin.
	 *
	 * @type {Object}
	 * @private
	 */
	var ignore = { hash: 1, query: 1 };
	
	/**
	 * The location object differs when your code is loaded through a normal page,
	 * Worker or through a worker using a blob. And with the blobble begins the
	 * trouble as the location object will contain the URL of the blob, not the
	 * location of the page where our code is loaded in. The actual origin is
	 * encoded in the `pathname` so we can thankfully generate a good "default"
	 * location from it so we can generate proper relative URL's again.
	 *
	 * @param {Object|String} loc Optional default location object.
	 * @returns {Object} lolcation object.
	 * @api public
	 */
	function lolcation(loc) {
		loc = loc || global.location || {};
	
		var finaldestination = {}
			, type = typeof loc
			, key;
	
		if ('blob:' === loc.protocol) {
			finaldestination = new URL(unescape(loc.pathname), {});
		} else if ('string' === type) {
			finaldestination = new URL(loc, {});
			for (key in ignore) delete finaldestination[key];
		} else if ('object' === type) {
			for (key in loc) {
				if (key in ignore) continue;
				finaldestination[key] = loc[key];
			}
	
			if (finaldestination.slashes === undefined) {
				finaldestination.slashes = slashes.test(loc.href);
			}
		}
	
		return finaldestination;
	}
	
	/**
	 * @typedef ProtocolExtract
	 * @type Object
	 * @property {String} protocol Protocol matched in the URL, in lowercase.
	 * @property {Boolean} slashes `true` if protocol is followed by "//", else `false`.
	 * @property {String} rest Rest of the URL that is not part of the protocol.
	 */
	
	/**
	 * Extract protocol information from a URL with/without double slash ("//").
	 *
	 * @param {String} address URL we want to extract from.
	 * @return {ProtocolExtract} Extracted information.
	 * @api private
	 */
	function extractProtocol(address) {
		var match = protocolre.exec(address);
	
		return {
			protocol: match[1] ? match[1].toLowerCase() : '',
			slashes: !!match[2],
			rest: match[3]
		};
	}
	
	/**
	 * Resolve a relative URL pathname against a base URL pathname.
	 *
	 * @param {String} relative Pathname of the relative URL.
	 * @param {String} base Pathname of the base URL.
	 * @return {String} Resolved pathname.
	 * @api private
	 */
	function resolve(relative, base) {
		var path = (base || '/').split('/').slice(0, -1).concat(relative.split('/'))
			, i = path.length
			, last = path[i - 1]
			, unshift = false
			, up = 0;
	
		while (i--) {
			if (path[i] === '.') {
				path.splice(i, 1);
			} else if (path[i] === '..') {
				path.splice(i, 1);
				up++;
			} else if (up) {
				if (i === 0) unshift = true;
				path.splice(i, 1);
				up--;
			}
		}
	
		if (unshift) path.unshift('');
		if (last === '.' || last === '..') path.push('');
	
		return path.join('/');
	}
	
	/**
	 * The actual URL instance. Instead of returning an object we've opted-in to
	 * create an actual constructor as it's much more memory efficient and
	 * faster and it pleases my OCD.
	 *
	 * @constructor
	 * @param {String} address URL we want to parse.
	 * @param {Object|String} location Location defaults for relative paths.
	 * @param {Boolean|Function} parser Parser for the query string.
	 * @api public
	 */
	function URL(address, location, parser) {
		if (!(this instanceof URL)) {
			return new URL(address, location, parser);
		}
	
		var relative, extracted, parse, instruction, index, key
			, instructions = rules.slice()
			, type = typeof location
			, url = this
			, i = 0;
	
		//
		// The following if statements allows this module two have compatibility with
		// 2 different API:
		//
		// 1. Node.js's `url.parse` api which accepts a URL, boolean as arguments
		//    where the boolean indicates that the query string should also be parsed.
		//
		// 2. The `URL` interface of the browser which accepts a URL, object as
		//    arguments. The supplied object will be used as default values / fall-back
		//    for relative paths.
		//
		if ('object' !== type && 'string' !== type) {
			parser = location;
			location = null;
		}
	
		if (parser && 'function' !== typeof parser) parser = qs.parse;
	
		location = lolcation(location);
	
		//
		// Extract protocol information before running the instructions.
		//
		extracted = extractProtocol(address || '');
		relative = !extracted.protocol && !extracted.slashes;
		url.slashes = extracted.slashes || relative && location.slashes;
		url.protocol = extracted.protocol || location.protocol || '';
		address = extracted.rest;
	
		//
		// When the authority component is absent the URL starts with a path
		// component.
		//
		if (!extracted.slashes) instructions[2] = [/(.*)/, 'pathname'];
	
		for (; i < instructions.length; i++) {
			instruction = instructions[i];
			parse = instruction[0];
			key = instruction[1];
	
			if (parse !== parse) {
				url[key] = address;
			} else if ('string' === typeof parse) {
				if (~(index = address.indexOf(parse))) {
					if ('number' === typeof instruction[2]) {
						url[key] = address.slice(0, index);
						address = address.slice(index + instruction[2]);
					} else {
						url[key] = address.slice(index);
						address = address.slice(0, index);
					}
				}
			} else if ((index = parse.exec(address))) {
				url[key] = index[1];
				address = address.slice(0, index.index);
			}
	
			url[key] = url[key] || (
				relative && instruction[3] ? location[key] || '' : ''
			);
	
			//
			// Hostname, host and protocol should be lowercased so they can be used to
			// create a proper `origin`.
			//
			if (instruction[4]) url[key] = url[key].toLowerCase();
		}
	
		//
		// Also parse the supplied query string in to an object. If we're supplied
		// with a custom parser as function use that instead of the default build-in
		// parser.
		//
		if (parser) url.query = parser(url.query);
	
		//
		// If the URL is relative, resolve the pathname against the base URL.
		//
		if (
				relative
			&& location.slashes
			&& url.pathname.charAt(0) !== '/'
			&& (url.pathname !== '' || location.pathname !== '')
		) {
			url.pathname = resolve(url.pathname, location.pathname);
		}
	
		//
		// We should not add port numbers if they are already the default port number
		// for a given protocol. As the host also contains the port number we're going
		// override it with the hostname which contains no port number.
		//
		if (!required(url.port, url.protocol)) {
			url.host = url.hostname;
			url.port = '';
		}
	
		//
		// Parse down the `auth` for the username and password.
		//
		url.username = url.password = '';
		if (url.auth) {
			instruction = url.auth.split(':');
			url.username = instruction[0] || '';
			url.password = instruction[1] || '';
		}
	
		url.origin = url.protocol && url.host && url.protocol !== 'file:'
			? url.protocol +'//'+ url.host
			: 'null';
	
		//
		// The href is just the compiled result.
		//
		url.href = url.toString();
	}
	
	/**
	 * This is convenience method for changing properties in the URL instance to
	 * insure that they all propagate correctly.
	 *
	 * @param {String} part          Property we need to adjust.
	 * @param {Mixed} value          The newly assigned value.
	 * @param {Boolean|Function} fn  When setting the query, it will be the function
	 *                               used to parse the query.
	 *                               When setting the protocol, double slash will be
	 *                               removed from the final url if it is true.
	 * @returns {URL}
	 * @api public
	 */
	function set(part, value, fn) {
		var url = this;
	
		switch (part) {
			case 'query':
				if ('string' === typeof value && value.length) {
					value = (fn || qs.parse)(value);
				}
	
				url[part] = value;
				break;
	
			case 'port':
				url[part] = value;
	
				if (!required(value, url.protocol)) {
					url.host = url.hostname;
					url[part] = '';
				} else if (value) {
					url.host = url.hostname +':'+ value;
				}
	
				break;
	
			case 'hostname':
				url[part] = value;
	
				if (url.port) value += ':'+ url.port;
				url.host = value;
				break;
	
			case 'host':
				url[part] = value;
	
				if (/:\d+$/.test(value)) {
					value = value.split(':');
					url.port = value.pop();
					url.hostname = value.join(':');
				} else {
					url.hostname = value;
					url.port = '';
				}
	
				break;
	
			case 'protocol':
				url.protocol = value.toLowerCase();
				url.slashes = !fn;
				break;
	
			case 'pathname':
			case 'hash':
				if (value) {
					var char = part === 'pathname' ? '/' : '#';
					url[part] = value.charAt(0) !== char ? char + value : value;
				} else {
					url[part] = value;
				}
				break;
	
			default:
				url[part] = value;
		}
	
		for (var i = 0; i < rules.length; i++) {
			var ins = rules[i];
	
			if (ins[4]) url[ins[1]] = url[ins[1]].toLowerCase();
		}
	
		url.origin = url.protocol && url.host && url.protocol !== 'file:'
			? url.protocol +'//'+ url.host
			: 'null';
	
		url.href = url.toString();
	
		return url;
	}
	
	/**
	 * Transform the properties back in to a valid and full URL string.
	 *
	 * @param {Function} stringify Optional query stringify function.
	 * @returns {String}
	 * @api public
	 */
	function toString(stringify) {
		if (!stringify || 'function' !== typeof stringify) stringify = qs.stringify;
	
		var query
			, url = this
			, protocol = url.protocol;
	
		if (protocol && protocol.charAt(protocol.length - 1) !== ':') protocol += ':';
	
		var result = protocol + (url.slashes ? '//' : '');
	
		if (url.username) {
			result += url.username;
			if (url.password) result += ':'+ url.password;
			result += '@';
		}
	
		result += url.host + url.pathname;
	
		query = 'object' === typeof url.query ? stringify(url.query) : url.query;
		if (query) result += '?' !== query.charAt(0) ? '?'+ query : query;
	
		if (url.hash) result += url.hash;
	
		return result;
	}
	
	URL.prototype = { set: set, toString: toString };
	
	//
	// Expose the URL parser and some additional properties that might be useful for
	// others or testing.
	//
	URL.extractProtocol = extractProtocol;
	URL.location = lolcation;
	URL.qs = qs;
	
	module.exports = URL;
	
	}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})
	
	},{"querystringify":206,"requires-port":208}],217:[function(require,module,exports){
	// created by @HenrikJoreteg
	var prefix;
	var version;
	
	if (window.mozRTCPeerConnection || navigator.mozGetUserMedia) {
			prefix = 'moz';
			version = parseInt(navigator.userAgent.match(/Firefox\/([0-9]+)\./)[1], 10);
	} else if (window.webkitRTCPeerConnection || navigator.webkitGetUserMedia) {
			prefix = 'webkit';
			version = navigator.userAgent.match(/Chrom(e|ium)/) && parseInt(navigator.userAgent.match(/Chrom(e|ium)\/([0-9]+)\./)[2], 10);
	}
	
	var PC = window.mozRTCPeerConnection || window.webkitRTCPeerConnection;
	var IceCandidate = window.mozRTCIceCandidate || window.RTCIceCandidate;
	var SessionDescription = window.mozRTCSessionDescription || window.RTCSessionDescription;
	var MediaStream = window.webkitMediaStream || window.MediaStream;
	var screenSharing = window.location.protocol === 'https:' &&
			((prefix === 'webkit' && version >= 26) ||
			 (prefix === 'moz' && version >= 33))
	var AudioContext = window.AudioContext || window.webkitAudioContext;
	var videoEl = document.createElement('video');
	var supportVp8 = videoEl && videoEl.canPlayType && videoEl.canPlayType('video/webm; codecs="vp8", vorbis') === "probably";
	var getUserMedia = navigator.getUserMedia || navigator.webkitGetUserMedia || navigator.msGetUserMedia || navigator.mozGetUserMedia;
	
	// export support flags and constructors.prototype && PC
	module.exports = {
			prefix: prefix,
			browserVersion: version,
			support: !!PC && supportVp8 && !!getUserMedia,
			// new support style
			supportRTCPeerConnection: !!PC,
			supportVp8: supportVp8,
			supportGetUserMedia: !!getUserMedia,
			supportDataChannel: !!(PC && PC.prototype && PC.prototype.createDataChannel),
			supportWebAudio: !!(AudioContext && AudioContext.prototype.createMediaStreamSource),
			supportMediaStream: !!(MediaStream && MediaStream.prototype.removeTrack),
			supportScreenSharing: !!screenSharing,
			// old deprecated style. Dont use this anymore
			dataChannel: !!(PC && PC.prototype && PC.prototype.createDataChannel),
			webAudio: !!(AudioContext && AudioContext.prototype.createMediaStreamSource),
			mediaStream: !!(MediaStream && MediaStream.prototype.removeTrack),
			screenSharing: !!screenSharing,
			// constructors
			AudioContext: AudioContext,
			PeerConnection: PC,
			SessionDescription: SessionDescription,
			IceCandidate: IceCandidate,
			MediaStream: MediaStream,
			getUserMedia: getUserMedia
	};
	
	},{}],218:[function(require,module,exports){
	var _global = (function() { return this; })();
	var NativeWebSocket = _global.WebSocket || _global.MozWebSocket;
	var websocket_version = require('./version');
	
	
	/**
	 * Expose a W3C WebSocket class with just one or two arguments.
	 */
	function W3CWebSocket(uri, protocols) {
		var native_instance;
	
		if (protocols) {
			native_instance = new NativeWebSocket(uri, protocols);
		}
		else {
			native_instance = new NativeWebSocket(uri);
		}
	
		/**
		 * 'native_instance' is an instance of nativeWebSocket (the browser's WebSocket
		 * class). Since it is an Object it will be returned as it is when creating an
		 * instance of W3CWebSocket via 'new W3CWebSocket()'.
		 *
		 * ECMAScript 5: http://bclary.com/2004/11/07/#a-13.2.2
		 */
		return native_instance;
	}
	if (NativeWebSocket) {
		['CONNECTING', 'OPEN', 'CLOSING', 'CLOSED'].forEach(function(prop) {
			Object.defineProperty(W3CWebSocket, prop, {
				get: function() { return NativeWebSocket[prop]; }
			});
		});
	}
	
	/**
	 * Module exports.
	 */
	module.exports = {
			'w3cwebsocket' : NativeWebSocket ? W3CWebSocket : null,
			'version'      : websocket_version
	};
	
	},{"./version":219}],219:[function(require,module,exports){
	module.exports = require('../package.json').version;
	
	},{"../package.json":220}],220:[function(require,module,exports){
	module.exports={
		"_args": [
			[
				"websocket@1.0.25",
				"/home/admin/voice/voice-chat/app"
			]
		],
		"_from": "websocket@1.0.25",
		"_id": "websocket@1.0.25",
		"_inBundle": false,
		"_integrity": "sha512-M58njvi6ZxVb5k7kpnHh2BvNKuBWiwIYvsToErBzWhvBZYwlEiLcyLrG41T1jRcrY9ettqPYEqduLI7ul54CVQ==",
		"_location": "/websocket",
		"_optional": true,
		"_phantomChildren": {
			"ms": "2.0.0"
		},
		"_requested": {
			"type": "version",
			"registry": true,
			"raw": "websocket@1.0.25",
			"name": "websocket",
			"escapedName": "websocket",
			"rawSpec": "1.0.25",
			"saveSpec": null,
			"fetchSpec": "1.0.25"
		},
		"_requiredBy": [
			"/protoo-client"
		],
		"_resolved": "https://registry.npmjs.org/websocket/-/websocket-1.0.25.tgz",
		"_spec": "1.0.25",
		"_where": "/home/admin/voice/voice-chat/app",
		"author": {
			"name": "Brian McKelvey",
			"email": "brian@worlize.com",
			"url": "https://www.worlize.com/"
		},
		"browser": "lib/browser.js",
		"bugs": {
			"url": "https://github.com/theturtle32/WebSocket-Node/issues"
		},
		"config": {
			"verbose": false
		},
		"contributors": [
			{
				"name": "Iaki Baz Castillo",
				"email": "ibc@aliax.net",
				"url": "http://dev.sipdoc.net"
			}
		],
		"dependencies": {
			"debug": "^2.2.0",
			"nan": "^2.3.3",
			"typedarray-to-buffer": "^3.1.2",
			"yaeti": "^0.0.6"
		},
		"description": "Websocket Client & Server Library implementing the WebSocket protocol as specified in RFC 6455.",
		"devDependencies": {
			"buffer-equal": "^1.0.0",
			"faucet": "^0.0.1",
			"gulp": "git+https://github.com/gulpjs/gulp.git#4.0",
			"gulp-jshint": "^2.0.4",
			"jshint": "^2.0.0",
			"jshint-stylish": "^2.2.1",
			"tape": "^4.0.1"
		},
		"directories": {
			"lib": "./lib"
		},
		"engines": {
			"node": ">=0.10.0"
		},
		"homepage": "https://github.com/theturtle32/WebSocket-Node",
		"keywords": [
			"websocket",
			"websockets",
			"socket",
			"networking",
			"comet",
			"push",
			"RFC-6455",
			"realtime",
			"server",
			"client"
		],
		"license": "Apache-2.0",
		"main": "index",
		"name": "websocket",
		"repository": {
			"type": "git",
			"url": "git+https://github.com/theturtle32/WebSocket-Node.git"
		},
		"scripts": {
			"gulp": "gulp",
			"install": "(node-gyp rebuild 2> builderror.log) || (exit 0)",
			"test": "faucet test/unit"
		},
		"version": "1.0.25"
	}
	
	},{}],221:[function(require,module,exports){
	/*
	WildEmitter.js is a slim little event emitter by @henrikjoreteg largely based
	on @visionmedia's Emitter from UI Kit.
	
	Why? I wanted it standalone.
	
	I also wanted support for wildcard emitters like this:
	
	emitter.on('*', function (eventName, other, event, payloads) {
	
	});
	
	emitter.on('somenamespace*', function (eventName, payloads) {
	
	});
	
	Please note that callbacks triggered by wildcard registered events also get
	the event name as the first argument.
	*/
	
	module.exports = WildEmitter;
	
	function WildEmitter() { }
	
	WildEmitter.mixin = function (constructor) {
			var prototype = constructor.prototype || constructor;
	
			prototype.isWildEmitter= true;
	
			// Listen on the given `event` with `fn`. Store a group name if present.
			prototype.on = function (event, groupName, fn) {
					this.callbacks = this.callbacks || {};
					var hasGroup = (arguments.length === 3),
							group = hasGroup ? arguments[1] : undefined,
							func = hasGroup ? arguments[2] : arguments[1];
					func._groupName = group;
					(this.callbacks[event] = this.callbacks[event] || []).push(func);
					return this;
			};
	
			// Adds an `event` listener that will be invoked a single
			// time then automatically removed.
			prototype.once = function (event, groupName, fn) {
					var self = this,
							hasGroup = (arguments.length === 3),
							group = hasGroup ? arguments[1] : undefined,
							func = hasGroup ? arguments[2] : arguments[1];
					function on() {
							self.off(event, on);
							func.apply(this, arguments);
					}
					this.on(event, group, on);
					return this;
			};
	
			// Unbinds an entire group
			prototype.releaseGroup = function (groupName) {
					this.callbacks = this.callbacks || {};
					var item, i, len, handlers;
					for (item in this.callbacks) {
							handlers = this.callbacks[item];
							for (i = 0, len = handlers.length; i < len; i++) {
									if (handlers[i]._groupName === groupName) {
											//console.log('removing');
											// remove it and shorten the array we're looping through
											handlers.splice(i, 1);
											i--;
											len--;
									}
							}
					}
					return this;
			};
	
			// Remove the given callback for `event` or all
			// registered callbacks.
			prototype.off = function (event, fn) {
					this.callbacks = this.callbacks || {};
					var callbacks = this.callbacks[event],
							i;
	
					if (!callbacks) return this;
	
					// remove all handlers
					if (arguments.length === 1) {
							delete this.callbacks[event];
							return this;
					}
	
					// remove specific handler
					i = callbacks.indexOf(fn);
					callbacks.splice(i, 1);
					if (callbacks.length === 0) {
							delete this.callbacks[event];
					}
					return this;
			};
	
			/// Emit `event` with the given args.
			// also calls any `*` handlers
			prototype.emit = function (event) {
					this.callbacks = this.callbacks || {};
					var args = [].slice.call(arguments, 1),
							callbacks = this.callbacks[event],
							specialCallbacks = this.getWildcardCallbacks(event),
							i,
							len,
							item,
							listeners;
	
					if (callbacks) {
							listeners = callbacks.slice();
							for (i = 0, len = listeners.length; i < len; ++i) {
									if (!listeners[i]) {
											break;
									}
									listeners[i].apply(this, args);
							}
					}
	
					if (specialCallbacks) {
							len = specialCallbacks.length;
							listeners = specialCallbacks.slice();
							for (i = 0, len = listeners.length; i < len; ++i) {
									if (!listeners[i]) {
											break;
									}
									listeners[i].apply(this, [event].concat(args));
							}
					}
	
					return this;
			};
	
			// Helper for for finding special wildcard event handlers that match the event
			prototype.getWildcardCallbacks = function (eventName) {
					this.callbacks = this.callbacks || {};
					var item,
							split,
							result = [];
	
					for (item in this.callbacks) {
							split = item.split('*');
							if (item === '*' || (split.length === 2 && eventName.slice(0, split[0].length) === split[0])) {
									result = result.concat(this.callbacks[item]);
							}
					}
					return result;
			};
	
	};
	
	WildEmitter.mixin(WildEmitter);
	
	},{}]},{},[5])
	//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIm5vZGVfbW9kdWxlcy9icm93c2VyLXBhY2svX3ByZWx1ZGUuanMiLCJsaWIvRGF0YVN0b3JlLmpzIiwibGliL0xvZ2dlci5qcyIsImxpYi9kdW1taWVzL21wLmpzIiwibGliL2hlbHBlcnMvZXZlbnRzLmpzIiwibGliL2luZGV4LmpzIiwibGliL25ld0NsaWVudC5qcyIsImxpYi91cmxGYWN0b3J5LmpzIiwibGliL3V0aWxzLmpzIiwibWVkaWFzb3VwLWNsaWVudC9Db21tYW5kUXVldWUuanMiLCJtZWRpYXNvdXAtY2xpZW50L0NvbnN1bWVyLmpzIiwibWVkaWFzb3VwLWNsaWVudC9EZXZpY2UuanMiLCJtZWRpYXNvdXAtY2xpZW50L0VuaGFuY2VkRXZlbnRFbWl0dGVyLmpzIiwibWVkaWFzb3VwLWNsaWVudC9Mb2dnZXIuanMiLCJtZWRpYXNvdXAtY2xpZW50L1BlZXIuanMiLCJtZWRpYXNvdXAtY2xpZW50L1Byb2R1Y2VyLmpzIiwibWVkaWFzb3VwLWNsaWVudC9Sb29tLmpzIiwibWVkaWFzb3VwLWNsaWVudC9UcmFuc3BvcnQuanMiLCJtZWRpYXNvdXAtY2xpZW50L2Vycm9ycy5qcyIsIm1lZGlhc291cC1jbGllbnQvaGFuZGxlcnMvQ2hyb21lNTUuanMiLCJtZWRpYXNvdXAtY2xpZW50L2hhbmRsZXJzL0Nocm9tZTY3LmpzIiwibWVkaWFzb3VwLWNsaWVudC9oYW5kbGVycy9FZGdlMTEuanMiLCJtZWRpYXNvdXAtY2xpZW50L2hhbmRsZXJzL0ZpcmVmb3g1MC5qcyIsIm1lZGlhc291cC1jbGllbnQvaGFuZGxlcnMvRmlyZWZveDU5LmpzIiwibWVkaWFzb3VwLWNsaWVudC9oYW5kbGVycy9SZWFjdE5hdGl2ZS5qcyIsIm1lZGlhc291cC1jbGllbnQvaGFuZGxlcnMvU2FmYXJpMTEuanMiLCJtZWRpYXNvdXAtY2xpZW50L2hhbmRsZXJzL29ydGMvZWRnZVV0aWxzLmpzIiwibWVkaWFzb3VwLWNsaWVudC9oYW5kbGVycy9zZHAvUmVtb3RlUGxhbkJTZHAuanMiLCJtZWRpYXNvdXAtY2xpZW50L2hhbmRsZXJzL3NkcC9SZW1vdGVVbmlmaWVkUGxhblNkcC5qcyIsIm1lZGlhc291cC1jbGllbnQvaGFuZGxlcnMvc2RwL2NvbW1vblV0aWxzLmpzIiwibWVkaWFzb3VwLWNsaWVudC9oYW5kbGVycy9zZHAvcGxhbkJVdGlscy5qcyIsIm1lZGlhc291cC1jbGllbnQvaGFuZGxlcnMvc2RwL3VuaWZpZWRQbGFuVXRpbHMuanMiLCJtZWRpYXNvdXAtY2xpZW50L2luZGV4LmpzIiwibWVkaWFzb3VwLWNsaWVudC9vcnRjLmpzIiwibWVkaWFzb3VwLWNsaWVudC91dGlscy5qcyIsIm5vZGVfbW9kdWxlcy9iYWJlbC1ydW50aW1lL2NvcmUtanMvYXJyYXkvZnJvbS5qcyIsIm5vZGVfbW9kdWxlcy9iYWJlbC1ydW50aW1lL2NvcmUtanMvZ2V0LWl0ZXJhdG9yLmpzIiwibm9kZV9tb2R1bGVzL2JhYmVsLXJ1bnRpbWUvY29yZS1qcy9pcy1pdGVyYWJsZS5qcyIsIm5vZGVfbW9kdWxlcy9iYWJlbC1ydW50aW1lL2NvcmUtanMvanNvbi9zdHJpbmdpZnkuanMiLCJub2RlX21vZHVsZXMvYmFiZWwtcnVudGltZS9jb3JlLWpzL21hcC5qcyIsIm5vZGVfbW9kdWxlcy9iYWJlbC1ydW50aW1lL2NvcmUtanMvb2JqZWN0L2Fzc2lnbi5qcyIsIm5vZGVfbW9kdWxlcy9iYWJlbC1ydW50aW1lL2NvcmUtanMvb2JqZWN0L2NyZWF0ZS5qcyIsIm5vZGVfbW9kdWxlcy9iYWJlbC1ydW50aW1lL2NvcmUtanMvb2JqZWN0L2RlZmluZS1wcm9wZXJ0eS5qcyIsIm5vZGVfbW9kdWxlcy9iYWJlbC1ydW50aW1lL2NvcmUtanMvb2JqZWN0L2dldC1wcm90b3R5cGUtb2YuanMiLCJub2RlX21vZHVsZXMvYmFiZWwtcnVudGltZS9jb3JlLWpzL29iamVjdC9rZXlzLmpzIiwibm9kZV9tb2R1bGVzL2JhYmVsLXJ1bnRpbWUvY29yZS1qcy9vYmplY3Qvc2V0LXByb3RvdHlwZS1vZi5qcyIsIm5vZGVfbW9kdWxlcy9iYWJlbC1ydW50aW1lL2NvcmUtanMvb2JqZWN0L3ZhbHVlcy5qcyIsIm5vZGVfbW9kdWxlcy9iYWJlbC1ydW50aW1lL2NvcmUtanMvcHJvbWlzZS5qcyIsIm5vZGVfbW9kdWxlcy9iYWJlbC1ydW50aW1lL2NvcmUtanMvc2V0LmpzIiwibm9kZV9tb2R1bGVzL2JhYmVsLXJ1bnRpbWUvY29yZS1qcy9zeW1ib2wuanMiLCJub2RlX21vZHVsZXMvYmFiZWwtcnVudGltZS9jb3JlLWpzL3N5bWJvbC9pdGVyYXRvci5qcyIsIm5vZGVfbW9kdWxlcy9iYWJlbC1ydW50aW1lL2hlbHBlcnMvY2xhc3NDYWxsQ2hlY2suanMiLCJub2RlX21vZHVsZXMvYmFiZWwtcnVudGltZS9oZWxwZXJzL2NyZWF0ZUNsYXNzLmpzIiwibm9kZV9tb2R1bGVzL2JhYmVsLXJ1bnRpbWUvaGVscGVycy9leHRlbmRzLmpzIiwibm9kZV9tb2R1bGVzL2JhYmVsLXJ1bnRpbWUvaGVscGVycy9pbmhlcml0cy5qcyIsIm5vZGVfbW9kdWxlcy9iYWJlbC1ydW50aW1lL2hlbHBlcnMvcG9zc2libGVDb25zdHJ1Y3RvclJldHVybi5qcyIsIm5vZGVfbW9kdWxlcy9iYWJlbC1ydW50aW1lL2hlbHBlcnMvc2xpY2VkVG9BcnJheS5qcyIsIm5vZGVfbW9kdWxlcy9iYWJlbC1ydW50aW1lL2hlbHBlcnMvdG9Db25zdW1hYmxlQXJyYXkuanMiLCJub2RlX21vZHVsZXMvYmFiZWwtcnVudGltZS9oZWxwZXJzL3R5cGVvZi5qcyIsIm5vZGVfbW9kdWxlcy9ib3dzZXIvc3JjL2Jvd3Nlci5qcyIsIm5vZGVfbW9kdWxlcy9icm93c2VyaWZ5L25vZGVfbW9kdWxlcy9ldmVudHMvZXZlbnRzLmpzIiwibm9kZV9tb2R1bGVzL2NvcmUtanMvbGlicmFyeS9mbi9hcnJheS9mcm9tLmpzIiwibm9kZV9tb2R1bGVzL2NvcmUtanMvbGlicmFyeS9mbi9nZXQtaXRlcmF0b3IuanMiLCJub2RlX21vZHVsZXMvY29yZS1qcy9saWJyYXJ5L2ZuL2lzLWl0ZXJhYmxlLmpzIiwibm9kZV9tb2R1bGVzL2NvcmUtanMvbGlicmFyeS9mbi9qc29uL3N0cmluZ2lmeS5qcyIsIm5vZGVfbW9kdWxlcy9jb3JlLWpzL2xpYnJhcnkvZm4vbWFwLmpzIiwibm9kZV9tb2R1bGVzL2NvcmUtanMvbGlicmFyeS9mbi9vYmplY3QvYXNzaWduLmpzIiwibm9kZV9tb2R1bGVzL2NvcmUtanMvbGlicmFyeS9mbi9vYmplY3QvY3JlYXRlLmpzIiwibm9kZV9tb2R1bGVzL2NvcmUtanMvbGlicmFyeS9mbi9vYmplY3QvZGVmaW5lLXByb3BlcnR5LmpzIiwibm9kZV9tb2R1bGVzL2NvcmUtanMvbGlicmFyeS9mbi9vYmplY3QvZ2V0LXByb3RvdHlwZS1vZi5qcyIsIm5vZGVfbW9kdWxlcy9jb3JlLWpzL2xpYnJhcnkvZm4vb2JqZWN0L2tleXMuanMiLCJub2RlX21vZHVsZXMvY29yZS1qcy9saWJyYXJ5L2ZuL29iamVjdC9zZXQtcHJvdG90eXBlLW9mLmpzIiwibm9kZV9tb2R1bGVzL2NvcmUtanMvbGlicmFyeS9mbi9vYmplY3QvdmFsdWVzLmpzIiwibm9kZV9tb2R1bGVzL2NvcmUtanMvbGlicmFyeS9mbi9wcm9taXNlLmpzIiwibm9kZV9tb2R1bGVzL2NvcmUtanMvbGlicmFyeS9mbi9zZXQuanMiLCJub2RlX21vZHVsZXMvY29yZS1qcy9saWJyYXJ5L2ZuL3N5bWJvbC9pbmRleC5qcyIsIm5vZGVfbW9kdWxlcy9jb3JlLWpzL2xpYnJhcnkvZm4vc3ltYm9sL2l0ZXJhdG9yLmpzIiwibm9kZV9tb2R1bGVzL2NvcmUtanMvbGlicmFyeS9tb2R1bGVzL19hLWZ1bmN0aW9uLmpzIiwibm9kZV9tb2R1bGVzL2NvcmUtanMvbGlicmFyeS9tb2R1bGVzL19hZGQtdG8tdW5zY29wYWJsZXMuanMiLCJub2RlX21vZHVsZXMvY29yZS1qcy9saWJyYXJ5L21vZHVsZXMvX2FuLWluc3RhbmNlLmpzIiwibm9kZV9tb2R1bGVzL2NvcmUtanMvbGlicmFyeS9tb2R1bGVzL19hbi1vYmplY3QuanMiLCJub2RlX21vZHVsZXMvY29yZS1qcy9saWJyYXJ5L21vZHVsZXMvX2FycmF5LWZyb20taXRlcmFibGUuanMiLCJub2RlX21vZHVsZXMvY29yZS1qcy9saWJyYXJ5L21vZHVsZXMvX2FycmF5LWluY2x1ZGVzLmpzIiwibm9kZV9tb2R1bGVzL2NvcmUtanMvbGlicmFyeS9tb2R1bGVzL19hcnJheS1tZXRob2RzLmpzIiwibm9kZV9tb2R1bGVzL2NvcmUtanMvbGlicmFyeS9tb2R1bGVzL19hcnJheS1zcGVjaWVzLWNvbnN0cnVjdG9yLmpzIiwibm9kZV9tb2R1bGVzL2NvcmUtanMvbGlicmFyeS9tb2R1bGVzL19hcnJheS1zcGVjaWVzLWNyZWF0ZS5qcyIsIm5vZGVfbW9kdWxlcy9jb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy9fY2xhc3NvZi5qcyIsIm5vZGVfbW9kdWxlcy9jb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy9fY29mLmpzIiwibm9kZV9tb2R1bGVzL2NvcmUtanMvbGlicmFyeS9tb2R1bGVzL19jb2xsZWN0aW9uLXN0cm9uZy5qcyIsIm5vZGVfbW9kdWxlcy9jb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy9fY29sbGVjdGlvbi10by1qc29uLmpzIiwibm9kZV9tb2R1bGVzL2NvcmUtanMvbGlicmFyeS9tb2R1bGVzL19jb2xsZWN0aW9uLmpzIiwibm9kZV9tb2R1bGVzL2NvcmUtanMvbGlicmFyeS9tb2R1bGVzL19jb3JlLmpzIiwibm9kZV9tb2R1bGVzL2NvcmUtanMvbGlicmFyeS9tb2R1bGVzL19jcmVhdGUtcHJvcGVydHkuanMiLCJub2RlX21vZHVsZXMvY29yZS1qcy9saWJyYXJ5L21vZHVsZXMvX2N0eC5qcyIsIm5vZGVfbW9kdWxlcy9jb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy9fZGVmaW5lZC5qcyIsIm5vZGVfbW9kdWxlcy9jb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy9fZGVzY3JpcHRvcnMuanMiLCJub2RlX21vZHVsZXMvY29yZS1qcy9saWJyYXJ5L21vZHVsZXMvX2RvbS1jcmVhdGUuanMiLCJub2RlX21vZHVsZXMvY29yZS1qcy9saWJyYXJ5L21vZHVsZXMvX2VudW0tYnVnLWtleXMuanMiLCJub2RlX21vZHVsZXMvY29yZS1qcy9saWJyYXJ5L21vZHVsZXMvX2VudW0ta2V5cy5qcyIsIm5vZGVfbW9kdWxlcy9jb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy9fZXhwb3J0LmpzIiwibm9kZV9tb2R1bGVzL2NvcmUtanMvbGlicmFyeS9tb2R1bGVzL19mYWlscy5qcyIsIm5vZGVfbW9kdWxlcy9jb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy9fZm9yLW9mLmpzIiwibm9kZV9tb2R1bGVzL2NvcmUtanMvbGlicmFyeS9tb2R1bGVzL19nbG9iYWwuanMiLCJub2RlX21vZHVsZXMvY29yZS1qcy9saWJyYXJ5L21vZHVsZXMvX2hhcy5qcyIsIm5vZGVfbW9kdWxlcy9jb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy9faGlkZS5qcyIsIm5vZGVfbW9kdWxlcy9jb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy9faHRtbC5qcyIsIm5vZGVfbW9kdWxlcy9jb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy9faWU4LWRvbS1kZWZpbmUuanMiLCJub2RlX21vZHVsZXMvY29yZS1qcy9saWJyYXJ5L21vZHVsZXMvX2ludm9rZS5qcyIsIm5vZGVfbW9kdWxlcy9jb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy9faW9iamVjdC5qcyIsIm5vZGVfbW9kdWxlcy9jb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy9faXMtYXJyYXktaXRlci5qcyIsIm5vZGVfbW9kdWxlcy9jb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy9faXMtYXJyYXkuanMiLCJub2RlX21vZHVsZXMvY29yZS1qcy9saWJyYXJ5L21vZHVsZXMvX2lzLW9iamVjdC5qcyIsIm5vZGVfbW9kdWxlcy9jb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy9faXRlci1jYWxsLmpzIiwibm9kZV9tb2R1bGVzL2NvcmUtanMvbGlicmFyeS9tb2R1bGVzL19pdGVyLWNyZWF0ZS5qcyIsIm5vZGVfbW9kdWxlcy9jb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy9faXRlci1kZWZpbmUuanMiLCJub2RlX21vZHVsZXMvY29yZS1qcy9saWJyYXJ5L21vZHVsZXMvX2l0ZXItZGV0ZWN0LmpzIiwibm9kZV9tb2R1bGVzL2NvcmUtanMvbGlicmFyeS9tb2R1bGVzL19pdGVyLXN0ZXAuanMiLCJub2RlX21vZHVsZXMvY29yZS1qcy9saWJyYXJ5L21vZHVsZXMvX2l0ZXJhdG9ycy5qcyIsIm5vZGVfbW9kdWxlcy9jb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy9fa2V5b2YuanMiLCJub2RlX21vZHVsZXMvY29yZS1qcy9saWJyYXJ5L21vZHVsZXMvX2xpYnJhcnkuanMiLCJub2RlX21vZHVsZXMvY29yZS1qcy9saWJyYXJ5L21vZHVsZXMvX21ldGEuanMiLCJub2RlX21vZHVsZXMvY29yZS1qcy9saWJyYXJ5L21vZHVsZXMvX21pY3JvdGFzay5qcyIsIm5vZGVfbW9kdWxlcy9jb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy9fbmV3LXByb21pc2UtY2FwYWJpbGl0eS5qcyIsIm5vZGVfbW9kdWxlcy9jb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy9fb2JqZWN0LWFzc2lnbi5qcyIsIm5vZGVfbW9kdWxlcy9jb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy9fb2JqZWN0LWNyZWF0ZS5qcyIsIm5vZGVfbW9kdWxlcy9jb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy9fb2JqZWN0LWRwLmpzIiwibm9kZV9tb2R1bGVzL2NvcmUtanMvbGlicmFyeS9tb2R1bGVzL19vYmplY3QtZHBzLmpzIiwibm9kZV9tb2R1bGVzL2NvcmUtanMvbGlicmFyeS9tb2R1bGVzL19vYmplY3QtZ29wZC5qcyIsIm5vZGVfbW9kdWxlcy9jb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy9fb2JqZWN0LWdvcG4tZXh0LmpzIiwibm9kZV9tb2R1bGVzL2NvcmUtanMvbGlicmFyeS9tb2R1bGVzL19vYmplY3QtZ29wbi5qcyIsIm5vZGVfbW9kdWxlcy9jb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy9fb2JqZWN0LWdvcHMuanMiLCJub2RlX21vZHVsZXMvY29yZS1qcy9saWJyYXJ5L21vZHVsZXMvX29iamVjdC1ncG8uanMiLCJub2RlX21vZHVsZXMvY29yZS1qcy9saWJyYXJ5L21vZHVsZXMvX29iamVjdC1rZXlzLWludGVybmFsLmpzIiwibm9kZV9tb2R1bGVzL2NvcmUtanMvbGlicmFyeS9tb2R1bGVzL19vYmplY3Qta2V5cy5qcyIsIm5vZGVfbW9kdWxlcy9jb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy9fb2JqZWN0LXBpZS5qcyIsIm5vZGVfbW9kdWxlcy9jb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy9fb2JqZWN0LXNhcC5qcyIsIm5vZGVfbW9kdWxlcy9jb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy9fb2JqZWN0LXRvLWFycmF5LmpzIiwibm9kZV9tb2R1bGVzL2NvcmUtanMvbGlicmFyeS9tb2R1bGVzL19wZXJmb3JtLmpzIiwibm9kZV9tb2R1bGVzL2NvcmUtanMvbGlicmFyeS9tb2R1bGVzL19wcm9taXNlLXJlc29sdmUuanMiLCJub2RlX21vZHVsZXMvY29yZS1qcy9saWJyYXJ5L21vZHVsZXMvX3Byb3BlcnR5LWRlc2MuanMiLCJub2RlX21vZHVsZXMvY29yZS1qcy9saWJyYXJ5L21vZHVsZXMvX3JlZGVmaW5lLWFsbC5qcyIsIm5vZGVfbW9kdWxlcy9jb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy9fcmVkZWZpbmUuanMiLCJub2RlX21vZHVsZXMvY29yZS1qcy9saWJyYXJ5L21vZHVsZXMvX3NldC1jb2xsZWN0aW9uLWZyb20uanMiLCJub2RlX21vZHVsZXMvY29yZS1qcy9saWJyYXJ5L21vZHVsZXMvX3NldC1jb2xsZWN0aW9uLW9mLmpzIiwibm9kZV9tb2R1bGVzL2NvcmUtanMvbGlicmFyeS9tb2R1bGVzL19zZXQtcHJvdG8uanMiLCJub2RlX21vZHVsZXMvY29yZS1qcy9saWJyYXJ5L21vZHVsZXMvX3NldC1zcGVjaWVzLmpzIiwibm9kZV9tb2R1bGVzL2NvcmUtanMvbGlicmFyeS9tb2R1bGVzL19zZXQtdG8tc3RyaW5nLXRhZy5qcyIsIm5vZGVfbW9kdWxlcy9jb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy9fc2hhcmVkLWtleS5qcyIsIm5vZGVfbW9kdWxlcy9jb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy9fc2hhcmVkLmpzIiwibm9kZV9tb2R1bGVzL2NvcmUtanMvbGlicmFyeS9tb2R1bGVzL19zcGVjaWVzLWNvbnN0cnVjdG9yLmpzIiwibm9kZV9tb2R1bGVzL2NvcmUtanMvbGlicmFyeS9tb2R1bGVzL19zdHJpbmctYXQuanMiLCJub2RlX21vZHVsZXMvY29yZS1qcy9saWJyYXJ5L21vZHVsZXMvX3Rhc2suanMiLCJub2RlX21vZHVsZXMvY29yZS1qcy9saWJyYXJ5L21vZHVsZXMvX3RvLWFic29sdXRlLWluZGV4LmpzIiwibm9kZV9tb2R1bGVzL2NvcmUtanMvbGlicmFyeS9tb2R1bGVzL190by1pbnRlZ2VyLmpzIiwibm9kZV9tb2R1bGVzL2NvcmUtanMvbGlicmFyeS9tb2R1bGVzL190by1pb2JqZWN0LmpzIiwibm9kZV9tb2R1bGVzL2NvcmUtanMvbGlicmFyeS9tb2R1bGVzL190by1sZW5ndGguanMiLCJub2RlX21vZHVsZXMvY29yZS1qcy9saWJyYXJ5L21vZHVsZXMvX3RvLW9iamVjdC5qcyIsIm5vZGVfbW9kdWxlcy9jb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy9fdG8tcHJpbWl0aXZlLmpzIiwibm9kZV9tb2R1bGVzL2NvcmUtanMvbGlicmFyeS9tb2R1bGVzL191aWQuanMiLCJub2RlX21vZHVsZXMvY29yZS1qcy9saWJyYXJ5L21vZHVsZXMvX3ZhbGlkYXRlLWNvbGxlY3Rpb24uanMiLCJub2RlX21vZHVsZXMvY29yZS1qcy9saWJyYXJ5L21vZHVsZXMvX3drcy1kZWZpbmUuanMiLCJub2RlX21vZHVsZXMvY29yZS1qcy9saWJyYXJ5L21vZHVsZXMvX3drcy1leHQuanMiLCJub2RlX21vZHVsZXMvY29yZS1qcy9saWJyYXJ5L21vZHVsZXMvX3drcy5qcyIsIm5vZGVfbW9kdWxlcy9jb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy9jb3JlLmdldC1pdGVyYXRvci1tZXRob2QuanMiLCJub2RlX21vZHVsZXMvY29yZS1qcy9saWJyYXJ5L21vZHVsZXMvY29yZS5nZXQtaXRlcmF0b3IuanMiLCJub2RlX21vZHVsZXMvY29yZS1qcy9saWJyYXJ5L21vZHVsZXMvY29yZS5pcy1pdGVyYWJsZS5qcyIsIm5vZGVfbW9kdWxlcy9jb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy9lczYuYXJyYXkuZnJvbS5qcyIsIm5vZGVfbW9kdWxlcy9jb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy9lczYuYXJyYXkuaXRlcmF0b3IuanMiLCJub2RlX21vZHVsZXMvY29yZS1qcy9saWJyYXJ5L21vZHVsZXMvZXM2Lm1hcC5qcyIsIm5vZGVfbW9kdWxlcy9jb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy9lczYub2JqZWN0LmFzc2lnbi5qcyIsIm5vZGVfbW9kdWxlcy9jb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy9lczYub2JqZWN0LmNyZWF0ZS5qcyIsIm5vZGVfbW9kdWxlcy9jb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy9lczYub2JqZWN0LmRlZmluZS1wcm9wZXJ0eS5qcyIsIm5vZGVfbW9kdWxlcy9jb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy9lczYub2JqZWN0LmdldC1wcm90b3R5cGUtb2YuanMiLCJub2RlX21vZHVsZXMvY29yZS1qcy9saWJyYXJ5L21vZHVsZXMvZXM2Lm9iamVjdC5rZXlzLmpzIiwibm9kZV9tb2R1bGVzL2NvcmUtanMvbGlicmFyeS9tb2R1bGVzL2VzNi5vYmplY3Quc2V0LXByb3RvdHlwZS1vZi5qcyIsIm5vZGVfbW9kdWxlcy9jb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy9lczYub2JqZWN0LnRvLXN0cmluZy5qcyIsIm5vZGVfbW9kdWxlcy9jb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy9lczYucHJvbWlzZS5qcyIsIm5vZGVfbW9kdWxlcy9jb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy9lczYuc2V0LmpzIiwibm9kZV9tb2R1bGVzL2NvcmUtanMvbGlicmFyeS9tb2R1bGVzL2VzNi5zdHJpbmcuaXRlcmF0b3IuanMiLCJub2RlX21vZHVsZXMvY29yZS1qcy9saWJyYXJ5L21vZHVsZXMvZXM2LnN5bWJvbC5qcyIsIm5vZGVfbW9kdWxlcy9jb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy9lczcubWFwLmZyb20uanMiLCJub2RlX21vZHVsZXMvY29yZS1qcy9saWJyYXJ5L21vZHVsZXMvZXM3Lm1hcC5vZi5qcyIsIm5vZGVfbW9kdWxlcy9jb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy9lczcubWFwLnRvLWpzb24uanMiLCJub2RlX21vZHVsZXMvY29yZS1qcy9saWJyYXJ5L21vZHVsZXMvZXM3Lm9iamVjdC52YWx1ZXMuanMiLCJub2RlX21vZHVsZXMvY29yZS1qcy9saWJyYXJ5L21vZHVsZXMvZXM3LnByb21pc2UuZmluYWxseS5qcyIsIm5vZGVfbW9kdWxlcy9jb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy9lczcucHJvbWlzZS50cnkuanMiLCJub2RlX21vZHVsZXMvY29yZS1qcy9saWJyYXJ5L21vZHVsZXMvZXM3LnNldC5mcm9tLmpzIiwibm9kZV9tb2R1bGVzL2NvcmUtanMvbGlicmFyeS9tb2R1bGVzL2VzNy5zZXQub2YuanMiLCJub2RlX21vZHVsZXMvY29yZS1qcy9saWJyYXJ5L21vZHVsZXMvZXM3LnNldC50by1qc29uLmpzIiwibm9kZV9tb2R1bGVzL2NvcmUtanMvbGlicmFyeS9tb2R1bGVzL2VzNy5zeW1ib2wuYXN5bmMtaXRlcmF0b3IuanMiLCJub2RlX21vZHVsZXMvY29yZS1qcy9saWJyYXJ5L21vZHVsZXMvZXM3LnN5bWJvbC5vYnNlcnZhYmxlLmpzIiwibm9kZV9tb2R1bGVzL2NvcmUtanMvbGlicmFyeS9tb2R1bGVzL3dlYi5kb20uaXRlcmFibGUuanMiLCJub2RlX21vZHVsZXMvZGVidWcvc3JjL2Jyb3dzZXIuanMiLCJub2RlX21vZHVsZXMvZGVidWcvc3JjL2RlYnVnLmpzIiwibm9kZV9tb2R1bGVzL2RvbXJlYWR5L3JlYWR5LmpzIiwibm9kZV9tb2R1bGVzL2hhcmsvaGFyay5qcyIsIm5vZGVfbW9kdWxlcy9tZWRpYXN0cmVhbS1nYWluL21lZGlhc3RyZWFtLWdhaW4uanMiLCJub2RlX21vZHVsZXMvbXMvaW5kZXguanMiLCJub2RlX21vZHVsZXMvcHJvY2Vzcy9icm93c2VyLmpzIiwibm9kZV9tb2R1bGVzL3Byb3Rvby1jbGllbnQvbGliLWVzNS9NZXNzYWdlLmpzIiwibm9kZV9tb2R1bGVzL3Byb3Rvby1jbGllbnQvbGliLWVzNS9QZWVyLmpzIiwibm9kZV9tb2R1bGVzL3Byb3Rvby1jbGllbnQvbGliLWVzNS9pbmRleC5qcyIsIm5vZGVfbW9kdWxlcy9wcm90b28tY2xpZW50L2xpYi1lczUvbG9nZ2VyLmpzIiwibm9kZV9tb2R1bGVzL3Byb3Rvby1jbGllbnQvbGliLWVzNS90cmFuc3BvcnRzL1dlYlNvY2tldFRyYW5zcG9ydC5qcyIsIm5vZGVfbW9kdWxlcy9wcm90b28tY2xpZW50L2xpYi1lczUvdHJhbnNwb3J0cy9pbmRleC5qcyIsIm5vZGVfbW9kdWxlcy9wcm90b28tY2xpZW50L2xpYi1lczUvdXRpbHMuanMiLCJub2RlX21vZHVsZXMvcXVlcnlzdHJpbmdpZnkvaW5kZXguanMiLCJub2RlX21vZHVsZXMvcmFuZG9tLW51bWJlci9pbmRleC5qcyIsIm5vZGVfbW9kdWxlcy9yZXF1aXJlcy1wb3J0L2luZGV4LmpzIiwibm9kZV9tb2R1bGVzL3JldHJ5L2luZGV4LmpzIiwibm9kZV9tb2R1bGVzL3JldHJ5L2xpYi9yZXRyeS5qcyIsIm5vZGVfbW9kdWxlcy9yZXRyeS9saWIvcmV0cnlfb3BlcmF0aW9uLmpzIiwibm9kZV9tb2R1bGVzL3NkcC10cmFuc2Zvcm0vbGliL2dyYW1tYXIuanMiLCJub2RlX21vZHVsZXMvc2RwLXRyYW5zZm9ybS9saWIvaW5kZXguanMiLCJub2RlX21vZHVsZXMvc2RwLXRyYW5zZm9ybS9saWIvcGFyc2VyLmpzIiwibm9kZV9tb2R1bGVzL3NkcC10cmFuc2Zvcm0vbGliL3dyaXRlci5qcyIsIm5vZGVfbW9kdWxlcy91cmwtcGFyc2UvaW5kZXguanMiLCJub2RlX21vZHVsZXMvd2VicnRjc3VwcG9ydC9pbmRleC1icm93c2VyLmpzIiwibm9kZV9tb2R1bGVzL3dlYnNvY2tldC9saWIvYnJvd3Nlci5qcyIsIm5vZGVfbW9kdWxlcy93ZWJzb2NrZXQvbGliL3ZlcnNpb24uanMiLCJub2RlX21vZHVsZXMvd2Vic29ja2V0L3BhY2thZ2UuanNvbiIsIm5vZGVfbW9kdWxlcy93aWxkZW1pdHRlci93aWxkZW1pdHRlci5qcyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBQTs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQ0NBOztBQUNBOzs7O0FBQ0E7Ozs7QUFDQTs7Ozs7O0lBRU0sUztBQUNGLHlCQUFjO0FBQUE7OztBQUVWLGFBQUssV0FBTCxHQUFtQixJQUFJLFlBQUosRUFBbkI7QUFDQSxhQUFLLFVBQUwsR0FBa0IsS0FBSyxXQUFMLENBQWlCLFVBQWpCLEVBQWxCOztBQUVBLGFBQUssVUFBTCxDQUFnQixPQUFoQixDQUF3QixLQUFLLFdBQUwsQ0FBaUIsV0FBekM7QUFDQSxhQUFLLFVBQUwsQ0FBZ0IsSUFBaEIsQ0FBcUIsY0FBckIsQ0FBb0MsQ0FBcEMsRUFBdUMsS0FBSyxXQUFMLENBQWlCLFdBQXhEOztBQUVBLGFBQUssTUFBTCxHQUFjLG1CQUFkO0FBQ0EsYUFBSyxVQUFMLEdBQWtCLEVBQWxCO0FBQ0EsYUFBSyxVQUFMLEdBQWtCLEVBQWxCOztBQUVBO0FBQ0EsYUFBSyxhQUFMLEdBQXFCLElBQXJCOztBQUVBLGFBQUssYUFBTCxHQUFxQixJQUFyQjs7QUFFQSxhQUFLLGVBQUwsR0FBdUIsSUFBdkI7O0FBRUEsYUFBSyxnQkFBTCxHQUF3QixLQUFLLEdBQUwsRUFBeEI7QUFDQSxhQUFLLG9CQUFMLEdBQTRCLEVBQTVCO0FBQ0g7Ozs7MENBTWlCLGEsRUFBZTtBQUM3QixpQkFBSyxhQUFMLEdBQXFCLGFBQXJCO0FBQ0g7O0FBRUQ7Ozs7eUNBRWlCLE0sRUFBUTtBQUNy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QVA7QUFDQTs7O0FDN0JEOztBQ0FBOztBQ0FBOztBQ0FBOztBQ0FBOztBQ0FBOztBQ0FBOztBQ0FBOztBQ0FBOztBQ0FBOztBQ0FBOztBQ0FBOztBQ0FBOztBQ0FBOztBQ0FBOztBQ0FBOztBQ0FBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNSQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDMUJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDdEJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNoQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNoQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2xEQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDcEJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNwQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzVtQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDdmdCQTtBQUNBO0FBQ0E7QUFDQTs7QUNIQTtBQUNBO0FBQ0E7QUFDQTs7QUNIQTtBQUNBO0FBQ0E7QUFDQTs7QUNIQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDTEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ1JBO0FBQ0E7QUFDQTs7QUNGQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDTEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ0xBO0FBQ0E7QUFDQTs7QUNGQTtBQUNBO0FBQ0E7O0FDRkE7QUFDQTtBQUNBOztBQ0ZBO0FBQ0E7QUFDQTs7QUNGQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ1BBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNSQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDTEE7QUFDQTtBQUNBO0FBQ0E7O0FDSEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNKQTtBQUNBOztBQ0RBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNMQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDTEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNQQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDdkJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUM1Q0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNoQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDTkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3ZCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDTEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDaEpBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ1RBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUMzREE7QUFDQTtBQUNBOztBQ0ZBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNSQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDcEJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNMQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ0pBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDUEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNKQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNmQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzdEQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ1BBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDekJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ05BO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDSkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ1JBO0FBQ0E7QUFDQTs7QUNGQTtBQUNBO0FBQ0E7QUFDQTs7QUNIQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2hCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNOQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDUkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ0xBO0FBQ0E7QUFDQTtBQUNBOztBQ0hBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ1pBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDYkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN0RUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN0QkE7QUFDQTtBQUNBO0FBQ0E7O0FDSEE7QUFDQTs7QUNEQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ1ZBO0FBQ0E7O0FDREE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3JEQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDcEVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2xCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2xDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDekNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDaEJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDYkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNoQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNuQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNQQTtBQUNBOztBQ0RBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDYkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2pCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ1BBO0FBQ0E7O0FDREE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNWQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2hCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ1BBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNSQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDUkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNQQTtBQUNBOztBQ0RBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDNUJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ1pBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDekJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNkQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ1BBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNMQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNOQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNUQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDakJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3BGQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ1BBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ05BO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ05BO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ05BO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNMQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNaQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDTEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ0xBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ1RBO0FBQ0E7O0FDREE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ1hBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNSQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ1BBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDVkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNyQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNsQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNuQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNKQTtBQUNBO0FBQ0E7QUFDQTs7QUNIQTtBQUNBO0FBQ0E7QUFDQTs7QUNIQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNUQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNUQTtBQUNBO0FBQ0E7QUFDQTs7QUNIQTs7QUNBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNoU0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2RBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNqQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUMzT0E7QUFDQTtBQUNBOztBQ0ZBO0FBQ0E7QUFDQTs7QUNGQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ0pBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ1RBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNwQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDWkE7QUFDQTtBQUNBOztBQ0ZBO0FBQ0E7QUFDQTs7QUNGQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ0pBO0FBQ0E7O0FDREE7QUFDQTs7QUNEQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUNuQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7QUNuTUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDak9BO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzlCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDL0lBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzdDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDeEpBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDeExBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUMxSEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ25PQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNmQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDckRBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN0TEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDTkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDWkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDeEVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUM1Q0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3RDQTs7QUNBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNuR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQy9JQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDM1ZBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNYQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDMUhBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUNsSEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7OztBQzVaQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDbERBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzFDQTtBQUNBOztBQ0RBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDcEdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwiZmlsZSI6ImdlbmVyYXRlZC5qcyIsInNvdXJjZVJvb3QiOiIiLCJzb3VyY2VzQ29udGVudCI6WyIoZnVuY3Rpb24gZSh0LG4scil7ZnVuY3Rpb24gcyhvLHUpe2lmKCFuW29dKXtpZighdFtvXSl7dmFyIGE9dHlwZW9mIHJlcXVpcmU9PVwiZnVuY3Rpb25cIiYmcmVxdWlyZTtpZighdSYmYSlyZXR1cm4gYShvLCEwKTtpZihpKXJldHVybiBpKG8sITApO3ZhciBmPW5ldyBFcnJvcihcIkNhbm5vdCBmaW5kIG1vZHVsZSAnXCIrbytcIidcIik7dGhyb3cgZi5jb2RlPVwiTU9EVUxFX05PVF9GT1VORFwiLGZ9dmFyIGw9bltvXT17ZXhwb3J0czp7fX07dFtvXVswXS5jYWxsKGwuZXhwb3J0cyxmdW5jdGlvbihlKXt2YXIgbj10W29dWzFdW2VdO3JldHVybiBzKG4/bjplKX0sbCxsLmV4cG9ydHMsZSx0LG4scil9cmV0dXJuIG5bb10uZXhwb3J0c312YXIgaT10eXBlb2YgcmVxdWlyZT09XCJmdW5jdGlvblwiJiZyZXF1aXJlO2Zvcih2YXIgbz0wO288ci5sZW5ndGg7bysrKXMocltvXSk7cmV0dXJuIHN9KSIsIlxuaW1wb3J0IHsgY2xhbXAsIGxlcnAgfSBmcm9tICcuL3V0aWxzJztcbmltcG9ydCBoYXJrIGZyb20gJ2hhcmsnO1xuaW1wb3J0IE1pY0dhaW5Db250cm9sbGVyIGZyb20gJ21lZGlhc3RyZWFtLWdhaW4nO1xuaW1wb3J0IE1wRXZlbnRzIGZyb20gJy4vaGVscGVycy9ldmVudHMnO1xuXG5jbGFzcyBEYXRhU3RvcmUge1xuICAgIGNvbnN0cnVjdG9yKCkge1xuXG4gICAgICAgIHRoaXMubWFpbkNvbnRleHQgPSBuZXcgQXVkaW9Db250ZXh0KCk7XG4gICAgICAgIHRoaXMubWFpblZvbHVtZSA9IHRoaXMubWFpbkNvbnRleHQuY3JlYXRlR2FpbigpO1xuXG4gICAgICAgIHRoaXMubWFpblZvbHVtZS5jb25uZWN0KHRoaXMubWFpbkNvbnRleHQuZGVzdGluYXRpb24pO1xuICAgICAgICB0aGlzLm1haW5Wb2x1bWUuZ2Fpbi5zZXRWYWx1ZUF0VGltZSgxLCB0aGlzLm1haW5Db250ZXh0LmN1cnJlbnRUaW1lKTtcblxuICAgICAgICB0aGlzLl9wZWVycyA9IG5ldyBNYXAoKTtcbiAgICAgICAgdGhpcy5fY29uc3VtZXJzID0ge307XG4gICAgICAgIHRoaXMuX3Byb2R1Y2VycyA9IHt9O1xuXG4gICAgICAgIC8qKiBAdHlwZSB7T2JqZWN0fSAqL1xuICAgICAgICB0aGlzLl9wcm9kdWNlckhhcmsgPSBudWxsO1xuXG4gICAgICAgIHRoaXMuaXNQb3NpdGlvbmluZyA9IHRydWU7XG5cbiAgICAgICAgdGhpcy5fcHJvZHVjZXJWb2x1bWUgPSBudWxsO1xuXG4gICAgICAgIHRoaXMubGFzdFZvbHVtZVVwZGF0ZSA9IERhdGUubm93KCk7XG4gICAgICAgIHRoaXMuY29uc3VtZXJzVm9sdW1lUXVldWUgPSB7fTtcbiAgICB9XG5cbiAgICBnZXQgcHJvZHVjZXJzKCkge1xuICAgICAgICByZXR1cm4gQXJyYXkuZnJvbSh0aGlzLl9wcm9kdWNlcnMpO1xuICAgIH1cblxuICAgIGNoYW5nZVBvc2l0aW9uaW5nKGlzUG9zaXRpb25pbmcpIHtcbiAgICAgICAgdGhpcy5pc1Bvc2l0aW9uaW5nID0gaXNQb3NpdGlvbmluZztcbiAgICB9XG5cbiAgICAvKiBNQUlOIC0gU1RBUlQgKi9cblxuICAgIGNoYW5nZU1haW5Wb2x1bWUodm9sdW1lKSB7XG4gICAgICAgIGlmICh0eXBlb2YgdGhpcy5tYWluVm9sdW1lICE9PSAndW5kZWZpbmVkJyAmJiB0eXBlb2YgdGhpcy5tYWluVm9sdW1lLmdhaW4gIT09ICd1bmRlZmluZWQnICYmICFpc05hTih2b2x1bWUpKSB7XG4gICAgICAgICAgICB0aGlzLm1haW5Wb2x1bWUuZ2Fpbi5zZXRWYWx1ZUF0VGltZSh2b2x1bWUsIHRoaXMubWFpbkNvbnRleHQuY3VycmVudFRpbWUpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgLyogTUFJTiAtIEVORCAqL1xuXG4gICAgLyogUFJPRFVDRVJTIC0gU1RBUlQgKi9cblxuICAgIGFkZFByb2R1Y2VyKHByb2R1Y2VyKSB7XG5cbiAgICAgICAgaWYgKHRoaXMuX3Byb2R1Y2VySGFyaykge1xuICAgICAgICAgICAgdGhpcy5fcHJvZHVjZXJIYXJrLnN0b3AoKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGNvbnN0IHN0cmVhbSA9IG5ldyBNZWRpYVN0cmVhbSgpO1xuXG4gICAgICAgIGlmIChwcm9kdWNlci50cmFjaykge1xuICAgICAgICAgICAgc3RyZWFtLmFkZFRyYWNrKHByb2R1Y2VyLnRyYWNrKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHRoaXMuX3Byb2R1Y2VyVm9sdW1lID0gbmV3IE1pY0dhaW5Db250cm9sbGVyKHN0cmVhbSk7XG5cbiAgICAgICAgdGhpcy5fcHJvZHVjZXJIYXJrID0gaGFyayhzdHJlYW0sIHsgcGxheTogZmFsc2UgfSk7XG5cbiAgICAgICAgdGhpcy5fcHJvZHVjZXJIYXJrLm9uKCd2b2x1bWVfY2hhbmdlJywgKGRCcywgdGhyZXNob2xkKSA9PiB7XG4gICAgICAgICAgICBsZXQgdm9sdW1lID0gTWF0aC5yb3VuZChNYXRoLnBvdygxMCwgZEJzIC8gODUpICogMTApO1xuXG4gICAgICAgICAgICBpZiAodm9sdW1lID09PSAxKSB7XG4gICAgICAgICAgICAgICAgdm9sdW1lID0gMDtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgY29uc3QgY3VycmVudFRpbWUgPSBEYXRlLm5vdygpO1xuXG4gICAgICAgICAgICBpZiAoY3VycmVudFRpbWUgPj0gdGhpcy5sYXN0Vm9sdW1lVXBkYXRlICsgMTAwMCkge1xuICAgICAgICAgICAgICAgIC8vTXBFdmVudHMudHJpZ2dlckNsaWVudENoYW5nZVByb2R1Y2VyVm9sdW1lKHZvbHVtZSk7XG5cbiAgICAgICAgICAgICAgICAvL01wRXZlbnRzLnRyaWdnZXJDbGllbnRDaGFuZ2VDb25zdW1lcnNWb2x1bWUodGhpcy5jb25zdW1lcnNWb2x1bWVRdWV1ZSk7XG4gICAgICAgICAgICAgICAgdGhpcy5jb25zdW1lcnNWb2x1bWVRdWV1ZSA9IHt9O1xuXG4gICAgICAgICAgICAgICAgdGhpcy5sYXN0Vm9sdW1lVXBkYXRlID0gY3VycmVudFRpbWU7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgfSk7XG5cbiAgICAgICAgdGhpcy5fcHJvZHVjZXJzW3Byb2R1Y2VyLmlkXSA9IHByb2R1Y2VyO1xuICAgIH1cblxuICAgIHJlbW92ZVByb2R1Y2VyKHByb2R1Y2VySWQpIHtcblxuICAgICAgICBpZiAodGhpcy5fcHJvZHVjZXJIYXJrKSB7XG4gICAgICAgICAgICB0aGlzLl9wcm9kdWNlckhhcmsuc3RvcCgpO1xuICAgICAgICB9XG5cbiAgICAgICAgZGVsZXRlIHRoaXMuX3Byb2R1Y2VyVm9sdW1lO1xuICAgICAgICBkZWxldGUgdGhpcy5fcHJvZHVjZXJzW3Byb2R1Y2VySWRdO1xuICAgIH1cblxuICAgIHNldFByb2R1Y2VyUGF1c2VkKHByb2R1Y2VySWQsIG9yaWdpbmF0b3IpIHtcbiAgICAgICAgY29uc3QgcHJvZHVjZXIgPSB0aGlzLl9wcm9kdWNlcnNbcHJvZHVjZXJJZF07XG5cbiAgICAgICAgaWYgKG9yaWdpbmF0b3IgPT09ICdsb2NhbCcpIHtcbiAgICAgICAgICAgIHByb2R1Y2VyLmxvY2FsbHlQYXVzZWQgPSB0cnVlO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcHJvZHVjZXIucmVtb3RlbHlQYXVzZWQgPSB0cnVlO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgc2V0UHJvZHVjZXJSZXN1bWVkKHByb2R1Y2VySWQsIG9yaWdpbmF0b3IpIHtcbiAgICAgICAgY29uc3QgcHJvZHVjZXIgPSB0aGlzLl9wcm9kdWNlcnNbcHJvZHVjZXJJZF07XG5cbiAgICAgICAgaWYgKG9yaWdpbmF0b3IgPT09ICdsb2NhbCcpIHtcbiAgICAgICAgICAgIHByb2R1Y2VyLmxvY2FsbHlQYXVzZWQgPSBmYWxzZTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHByb2R1Y2VyLnJlbW90ZWx5UGF1c2VkID0gZmFsc2U7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBzZXRQcm9kdWNlclRyYWNrKHByb2R1Y2VySWQsIHRyYWNrKSB7XG4gICAgICAgIGNvbnN0IHByb2R1Y2VyID0gdGhpcy5fcHJvZHVjZXJzW3Byb2R1Y2VySWRdO1xuICAgICAgICBwcm9kdWNlci50cmFjayA9IHRyYWNrO1xuICAgIH1cblxuICAgIGNoYW5nZVByb2R1Y2VyVm9sdW1lKHZvbHVtZSkge1xuICAgICAgICBmb3IgKGNvbnN0IHByb2R1Y2VyIG9mIE9iamVjdC52YWx1ZXModGhpcy5fcHJvZHVjZXJzKSkge1xuICAgICAgICAgICAgaWYgKHR5cGVvZiB0aGlzLl9wcm9kdWNlclZvbHVtZSAhPT0gJ3VuZGVmaW5lZCcgJiYgIWlzTmFOKHZvbHVtZSkpIHtcbiAgICAgICAgICAgICAgICB0aGlzLl9wcm9kdWNlclZvbHVtZS5zZXRHYWluKHZvbHVtZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvKiBQUk9EVUNFUlMgLSBFTkQgKi9cblxuICAgIC8qIFBFRVJTIC0gU1RBUlQgKi9cblxuICAgIGFkZFBlZXIocGVlcikge1xuICAgICAgICB0aGlzLl9wZWVycy5zZXQocGVlci5uYW1lLCBwZWVyKTtcbiAgICB9XG5cbiAgICByZW1vdmVQZWVyKHBlZXJOYW1lKSB7XG4gICAgICAgIHRoaXMuX3BlZXJzLmRlbGV0ZShwZWVyTmFtZSk7XG4gICAgfVxuXG4gICAgLyogUEVFUlMgLSBFTkQgKi9cblxuICAgIC8qIENPTlNVTUVSUyAtIFNUQVJUICovXG5cbiAgICBhZGRDb25zdW1lcihjb25zdW1lcikge1xuICAgICAgICBjb25zdW1lci52b2x1bWUgPSAwO1xuICAgICAgICBjb25zdW1lci5iYWxhbmNlID0gMDtcblxuICAgICAgICB0aGlzLl9jb25zdW1lcnNbY29uc3VtZXIuaWRdID0gY29uc3VtZXI7XG4gICAgfVxuXG4gICAgcmVtb3ZlQ29uc3VtZXIoY29uc3VtZXJJZCkge1xuXG4gICAgICAgIGNvbnN0IGNvbnN1bWVyID0gdGhpcy5fY29uc3VtZXJzW2NvbnN1bWVySWRdO1xuXG4gICAgICAgIGlmICghY29uc3VtZXIpIHtcbiAgICAgICAgICAgIGNvbnNvbGUubG9nKGAke2NvbnN1bWVySWR9IGlzIG5vdCBmb3VuZGApO1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHR5cGVvZiBjb25zdW1lci5hdWRpb0VsZW1lbnQgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICBjb25zdW1lci5hdWRpb0VsZW1lbnQucmVtb3ZlKCk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoY29uc3VtZXIuaGFyaykge1xuICAgICAgICAgICAgY29uc3VtZXIuaGFyay5zdG9wKCk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAodHlwZW9mIGNvbnN1bWVyLnN0cmVhbVNvdXJjZSAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgIGNvbnN1bWVyLmdhaW5Ob2RlLmRpc2Nvbm5lY3QodGhpcy5tYWluVm9sdW1lKTtcbiAgICAgICAgICAgIGNvbnN1bWVyLnN0cmVhbVNvdXJjZS5kaXNjb25uZWN0KGNvbnN1bWVyLmdhaW5Ob2RlKTtcbiAgICAgICAgICAgIGNvbnN1bWVyLmdhaW5Ob2RlLmRpc2Nvbm5lY3QoY29uc3VtZXIucGFubmVyKTtcbiAgICAgICAgICAgIGNvbnN1bWVyLnBhbm5lci5kaXNjb25uZWN0KHRoaXMubWFpblZvbHVtZSk7XG4gICAgICAgIH1cblxuICAgICAgICBkZWxldGUgdGhpcy5fY29uc3VtZXJzW2NvbnN1bWVySWRdO1xuICAgIH1cblxuICAgIHNldENvbnN1bWVyUGF1c2VkKGNvbnN1bWVySWQsIG9yaWdpbmF0b3IpIHtcbiAgICAgICAgY29uc3QgY29uc3VtZXIgPSB0aGlzLl9jb25zdW1lcnNbY29uc3VtZXJJZF07XG5cbiAgICAgICAgaWYgKCFjb25zdW1lcikge1xuICAgICAgICAgICAgY29uc29sZS5sb2coYCR7Y29uc3VtZXJJZH0gaXMgbm90IGZvdW5kYCk7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAob3JpZ2luYXRvciA9PT0gJ2xvY2FsJykge1xuICAgICAgICAgICAgY29uc3VtZXIubG9jYWxseVBhdXNlZCA9IHRydWU7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBjb25zdW1lci5yZW1vdGVseVBhdXNlZCA9IHRydWU7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBzZXRDb25zdW1lclJlc3VtZWQoY29uc3VtZXJJZCwgb3JpZ2luYXRvcikge1xuICAgICAgICBjb25zdCBjb25zdW1lciA9IHRoaXMuX2NvbnN1bWVyc1tjb25zdW1lcklkXTtcblxuICAgICAgICBpZiAoIWNvbnN1bWVyKSB7XG4gICAgICAgICAgICBjb25zb2xlLmxvZyhgJHtjb25zdW1lcklkfSBpcyBub3QgZm91bmRgKTtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChvcmlnaW5hdG9yID09PSAnbG9jYWwnKSB7XG4gICAgICAgICAgICBjb25zdW1lci5sb2NhbGx5UGF1c2VkID0gZmFsc2U7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBjb25zdW1lci5yZW1vdGVseVBhdXNlZCA9IGZhbHNlO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgc2V0Q29uc3VtZXJFZmZlY3RpdmVQcm9maWxlKGNvbnN1bWVySWQsIHByb2ZpbGUpIHtcbiAgICAgICAgY29uc3QgY29uc3VtZXIgPSB0aGlzLl9jb25zdW1lcnNbY29uc3VtZXJJZF07XG5cbiAgICAgICAgaWYgKCFjb25zdW1lcikge1xuICAgICAgICAgICAgY29uc29sZS5sb2coYCR7Y29uc3VtZXJJZH0gaXMgbm90IGZvdW5kYCk7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cblxuICAgICAgICBjb25zdW1lci5wcm9maWxlID0gcHJvZmlsZTtcbiAgICB9XG5cbiAgICBzZXRDb25zdW1lclRyYWNrKGNvbnN1bWVySWQsIHRyYWNrKSB7XG4gICAgICAgIGNvbnN0IGNvbnN1bWVyID0gdGhpcy5fY29uc3VtZXJzW2NvbnN1bWVySWRdO1xuXG4gICAgICAgIGlmICghY29uc3VtZXIpIHtcbiAgICAgICAgICAgIGNvbnNvbGUubG9nKGAke2NvbnN1bWVySWR9IGlzIG5vdCBmb3VuZGApO1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG5cbiAgICAgICAgY29uc3QgYXVkaW8gPSBuZXcgQXVkaW8oKTtcbiAgICAgICAgYXVkaW8uYXV0b3BsYXkgPSAhdGhpcy5pc1Bvc2l0aW9uaW5nO1xuICAgICAgICBhdWRpby52b2x1bWUgPSAwO1xuXG4gICAgICAgIGNvbnN0IHN0cmVhbSA9IG5ldyBNZWRpYVN0cmVhbSgpO1xuXG4gICAgICAgIGlmICh0cmFjaykge1xuICAgICAgICAgICAgc3RyZWFtLmFkZFRyYWNrKHRyYWNrKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGF1ZGlvLnNyY09iamVjdCA9IHN0cmVhbTtcblxuICAgICAgICBpZiAoY29uc3VtZXIuaGFyaykge1xuICAgICAgICAgICAgY29uc3VtZXIuaGFyay5zdG9wKCk7XG4gICAgICAgIH1cblxuICAgICAgICBjb25zdCBjb25zdW1lckhhcmsgPSBoYXJrKHN0cmVhbSwgeyBwbGF5OiBmYWxzZSB9KVxuXG4gICAgICAgIGNvbnN1bWVySGFyay5vbigndm9sdW1lX2NoYW5nZScsIChkQnMsIHRocmVzaG9sZCkgPT4ge1xuICAgICAgICAgICAgbGV0IHZvbHVtZSA9IE1hdGgucm91bmQoTWF0aC5wb3coMTAsIGRCcyAvIDg1KSAqIDEwKTtcblxuICAgICAgICAgICAgaWYgKHZvbHVtZSA9PT0gMSkge1xuICAgICAgICAgICAgICAgIHZvbHVtZSA9IDA7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHRoaXMuY29uc3VtZXJzVm9sdW1lUXVldWVbY29uc3VtZXIucGVlck5hbWVdID0gdm9sdW1lO1xuXG4gICAgICAgIH0pO1xuXG4gICAgICAgIGlmICh0aGlzLmlzUG9zaXRpb25pbmcpIHtcbiAgICAgICAgICAgIGNvbnN0IHNvdXJjZSA9IHRoaXMubWFpbkNvbnRleHQuY3JlYXRlTWVkaWFTdHJlYW1Tb3VyY2Uoc3RyZWFtKTtcblxuICAgICAgICAgICAgLy8gR2Fpbk5vZGUgKHByb3hpbWl0eSlcbiAgICAgICAgICAgIGNvbnN1bWVyLmdhaW5Ob2RlID0gdGhpcy5tYWluQ29udGV4dC5jcmVhdGVHYWluKCk7XG4gICAgICAgICAgICBzb3VyY2UuY29ubmVjdChjb25zdW1lci5nYWluTm9kZSk7XG4gICAgICAgICAgICBjb25zdW1lci5nYWluTm9kZS5jb25uZWN0KHRoaXMubWFpblZvbHVtZSk7XG4gICAgICAgICAgICBjb25zdW1lci5nYWluTm9kZS5nYWluLnNldFZhbHVlQXRUaW1lKDAsIHRoaXMubWFpbkNvbnRleHQuY3VycmVudFRpbWUpO1xuXG4gICAgICAgICAgICAvLyBQYW5uZXJOb2RlIChzdGVyZW8pXG4gICAgICAgICAgICBjb25zdCBwYW5uZXIgPSB0aGlzLm1haW5Db250ZXh0LmNyZWF0ZVBhbm5lcigpO1xuICAgICAgICAgICAgY29uc3VtZXIucGFubmVyID0gcGFubmVyO1xuICAgICAgICAgICAgY29uc3VtZXIuZ2Fpbk5vZGUuY29ubmVjdChjb25zdW1lci5wYW5uZXIpO1xuICAgICAgICAgICAgY29uc3VtZXIucGFubmVyLmNvbm5lY3QodGhpcy5tYWluVm9sdW1lKTtcbiAgICAgICAgICAgIGNvbnN1bWVyLnBhbm5lci5zZXRPcmllbnRhdGlvbigwLCAwLCAxKTtcblxuICAgICAgICAgICAgY29uc3VtZXIuc3RyZWFtU291cmNlID0gc291cmNlO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgY29uc3VtZXIuYXVkaW9FbGVtZW50ID0gYXVkaW87XG4gICAgICAgIH1cblxuXG4gICAgICAgIGNvbnN1bWVyLmhhcmsgPSBjb25zdW1lckhhcms7XG4gICAgICAgIGNvbnN1bWVyLnRyYWNrID0gdHJhY2s7XG4gICAgfVxuXG4gICAgY2hhbmdlQ29uc3VtZXJWb2x1bWUocGVlck5hbWUsIHZvbHVtZSwgYmFsYW5jZSkge1xuICAgICAgICBmb3IgKGNvbnN0IGNvbnN1bWVyIG9mIE9iamVjdC52YWx1ZXModGhpcy5fY29uc3VtZXJzKSkge1xuICAgICAgICAgICAgaWYgKGNvbnN1bWVyLnBlZXJOYW1lID09PSBwZWVyTmFtZSkge1xuXG4gICAgICAgICAgICAgICAgaWYgKGNvbnN1bWVyLmF1ZGlvRWxlbWVudCkge1xuICAgICAgICAgICAgICAgICAgICBjb25zdW1lci5hdWRpb0VsZW1lbnQudm9sdW1lID0gdm9sdW1lO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIGlmICh0eXBlb2YgY29uc3VtZXIuZ2Fpbk5vZGUgIT09ICd1bmRlZmluZWQnICYmIHR5cGVvZiBjb25zdW1lci5nYWluTm9kZS5nYWluICE9PSAndW5kZWZpbmVkJyAmJiAhaXNOYU4odm9sdW1lKSkge1xuICAgICAgICAgICAgICAgICAgICBjb25zdW1lci5nYWluTm9kZS5nYWluLnNldFZhbHVlQXRUaW1lKHZvbHVtZSwgdGhpcy5tYWluQ29udGV4dC5jdXJyZW50VGltZSk7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN1bWVyLnZvbHVtZSA9IHZvbHVtZTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBpZiAodHlwZW9mIGNvbnN1bWVyLnBhbm5lciAhPT0gJ3VuZGVmaW5lZCcgJiYgIWlzTmFOKGJhbGFuY2UpKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN1bWVyLnBhbm5lci5zZXRQb3NpdGlvbihiYWxhbmNlLCAwLCAoMSAtIE1hdGguYWJzKGJhbGFuY2UpKSk7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN1bWVyLmJhbGFuY2UgPSBiYWxhbmNlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8qIENPTlNVTUVSUyAtIEVORCAqL1xuXG59XG5cbmV4cG9ydCBkZWZhdWx0IG5ldyBEYXRhU3RvcmUoKTtcbiIsImltcG9ydCBkZWJ1ZyBmcm9tICdkZWJ1Zyc7XG5cbmNvbnN0IEFQUF9OQU1FID0gJ21lZGlhc291cC1kZW1vJztcblxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgTG9nZ2VyXG57XG5cdGNvbnN0cnVjdG9yKHByZWZpeClcblx0e1xuXHRcdGlmIChwcmVmaXgpXG5cdFx0e1xuXHRcdFx0dGhpcy5fZGVidWcgPSBkZWJ1ZyhgJHtBUFBfTkFNRX06JHtwcmVmaXh9YCk7XG5cdFx0XHR0aGlzLl93YXJuID0gZGVidWcoYCR7QVBQX05BTUV9OldBUk46JHtwcmVmaXh9YCk7XG5cdFx0XHR0aGlzLl9lcnJvciA9IGRlYnVnKGAke0FQUF9OQU1FfTpFUlJPUjoke3ByZWZpeH1gKTtcblx0XHR9XG5cdFx0ZWxzZVxuXHRcdHtcblx0XHRcdHRoaXMuX2RlYnVnID0gZGVidWcoQVBQX05BTUUpO1xuXHRcdFx0dGhpcy5fd2FybiA9IGRlYnVnKGAke0FQUF9OQU1FfTpXQVJOYCk7XG5cdFx0XHR0aGlzLl9lcnJvciA9IGRlYnVnKGAke0FQUF9OQU1FfTpFUlJPUmApO1xuXHRcdH1cblxuXHRcdC8qIGVzbGludC1kaXNhYmxlIG5vLWNvbnNvbGUgKi9cblx0XHR0aGlzLl9kZWJ1Zy5sb2cgPSBjb25zb2xlLmluZm8uYmluZChjb25zb2xlKTtcblx0XHR0aGlzLl93YXJuLmxvZyA9IGNvbnNvbGUud2Fybi5iaW5kKGNvbnNvbGUpO1xuXHRcdHRoaXMuX2Vycm9yLmxvZyA9IGNvbnNvbGUuZXJyb3IuYmluZChjb25zb2xlKTtcblx0XHQvKiBlc2xpbnQtZW5hYmxlIG5vLWNvbnNvbGUgKi9cblx0fVxuXG5cdGdldCBkZWJ1ZygpXG5cdHtcblx0XHRyZXR1cm4gdGhpcy5fZGVidWc7XG5cdH1cblxuXHRnZXQgd2FybigpXG5cdHtcblx0XHRyZXR1cm4gdGhpcy5fd2Fybjtcblx0fVxuXG5cdGdldCBlcnJvcigpXG5cdHtcblx0XHRyZXR1cm4gdGhpcy5fZXJyb3I7XG5cdH1cbn1cbiIsIlxuaWYgKHR5cGVvZiB3aW5kb3cubXAgPT09ICd1bmRlZmluZWQnKSB7XG4gICAgd2luZG93Lm1wID0ge1xuICAgICAgICBpbnZva2U6IChuYW1lLCAuLi5hcmdzKSA9PiB7XG4gICAgICAgICAgICBjb25zb2xlLmxvZygnaW52b2tlJywgbmFtZSwgLi4uYXJncyk7XG4gICAgICAgIH0sXG4gICAgICAgIHRyaWdnZXI6IChuYW1lLCAuLi5hcmdzKSA9PiB7XG4gICAgICAgICAgICBjb25zb2xlLmxvZygndHJpZ2dlcicsIG5hbWUsIC4uLmFyZ3MpO1xuICAgICAgICB9LFxuICAgICAgICBlbmFibGVEZWJ1Z2dpbmdBbGVydHM6ICguLi5hcmdzKSA9PiB7XG4gICAgICAgIH1cbiAgICB9O1xufVxuIiwiLyoqXG4gKiBAdHlwZSB7TWFwPFN0cmluZywgU2V0PEZ1bmN0aW9uPj59XG4qL1xuY29uc3QgX19ldmVudHMgPSBuZXcgTWFwKCk7XG5cbmlmICghd2luZG93LmlzUmFnZU1wKSB7XG4gICAgd2luZG93LmFkZEV2ZW50TGlzdGVuZXIoJ21lc3NhZ2UnLCAoZXZlbnQpID0+IHtcbiAgICAgICAgY29uc3QgZGF0YSA9IGV2ZW50LmRhdGE7XG4gICAgICAgIGlmIChfX2V2ZW50cy5oYXMoZGF0YS50eXBlKSkge1xuICAgICAgICAgICAgY29uc3QgYXJncyA9IGRhdGEuYXJncyB8fCBbXTtcbiAgICAgICAgICAgIGNhbGxFdmVudChkYXRhLnR5cGUsIC4uLmFyZ3MpO1xuICAgICAgICB9XG4gICAgfSk7XG59XG5cblxuY29uc3QgbGlzdGVuRXZlbnQgPSAoZXZlbnROYW1lLCBldmVudEZ1bmN0aW9uKSA9PiB7XG4gICAgaWYgKF9fZXZlbnRzLmhhcyhldmVudE5hbWUpKSB7XG4gICAgICAgIGNvbnN0IGV2ZW50ID0gX19ldmVudHMuZ2V0KGV2ZW50TmFtZSk7XG5cbiAgICAgICAgaWYgKCFldmVudC5oYXMoZXZlbnRGdW5jdGlvbikpIHtcbiAgICAgICAgICAgIGV2ZW50LmFkZChldmVudEZ1bmN0aW9uKTtcbiAgICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICAgIF9fZXZlbnRzLnNldChldmVudE5hbWUsIG5ldyBTZXQoW2V2ZW50RnVuY3Rpb25dKSk7XG4gICAgfVxufTtcblxuY29uc3QgY2FsbEV2ZW50ID0gKGV2ZW50TmFtZSwgLi4uYXJncykgPT4ge1xuICAgIGlmIChfX2V2ZW50cy5oYXMoZXZlbnROYW1lKSkge1xuICAgICAgICBjb25zdCBldmVudCA9IF9fZXZlbnRzLmdldChldmVudE5hbWUpO1xuXG4gICAgICAgIGV2ZW50LmZvckVhY2goZXZlbnRGdW5jdGlvbiA9PiB7XG4gICAgICAgICAgICBldmVudEZ1bmN0aW9uKC4uLmFyZ3MpO1xuICAgICAgICB9KTtcbiAgICB9XG59O1xuXG5jb25zdCByZW1vdmVFdmVudCA9IChldmVudE5hbWUsIGV2ZW50RnVuY3Rpb24pID0+IHtcbiAgICBpZiAoX19ldmVudHMuaGFzKGV2ZW50TmFtZSkpIHtcbiAgICAgICAgY29uc3QgZXZlbnQgPSBfX2V2ZW50cy5nZXQoZXZlbnROYW1lKTtcblxuICAgICAgICBpZiAoZXZlbnQuaGFzKGV2ZW50RnVuY3Rpb24pKSB7XG4gICAgICAgICAgICBldmVudC5kZWxldGUoZXZlbnRGdW5jdGlvbik7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBldmVudC5jbGVhcigpO1xuICAgICAgICB9XG4gICAgfVxufTtcblxuY29uc3QgRml2ZU1UcmlnZ2VyID0gKGV2ZW50TmFtZSwgYXJncykgPT4ge1xuICAgIGFyZ3MgPSB7IC4uLmFyZ3MgfTtcblxuICAgIGZldGNoKGBodHRwOi8vJHtldmVudE5hbWV9YCwge1xuICAgICAgICBtZXRob2Q6ICdQT1NUJyxcbiAgICAgICAgYm9keTogSlNPTi5zdHJpbmdpZnkoYXJncylcbiAgICB9KTtcbn1cblxuY29uc3QgdHJpZ2dlckNsaWVudENoYW5nZVN0YXRlQ29ubmVjdGlvbiA9IChzdGF0ZSkgPT4ge1xuICAgIGlmIChpc1JhZ2VNcCkge1xuICAgICAgICBtcC50cmlnZ2VyKCd2b2ljZS5jaGFuZ2VTdGF0ZUNvbm5lY3Rpb24nLCBzdGF0ZSk7XG4gICAgfSBlbHNlIHtcbiAgICAgICAgRml2ZU1UcmlnZ2VyKCd2b2ljZS9jaGFuZ2VTdGF0ZUNvbm5lY3Rpb24nLCB7IHN0YXRlIH0pO1xuICAgIH1cbn07XG5cbmNvbnN0IHRyaWdnZXJDbGllbnRSZXF1ZXN0TWVkaWFQZWVyUmVzcG9uc2UgPSAocGVlck5hbWUsIHN0YXR1cykgPT4ge1xuICAgIGlmIChpc1JhZ2VNcCkge1xuICAgICAgICBtcC50cmlnZ2VyKCd2b2ljZS5yZXF1ZXN0TWVkaWFQZWVyUmVzcG9uc2UnLCBwZWVyTmFtZSwgc3RhdHVzKTtcbiAgICB9IGVsc2Uge1xuICAgICAgICBGaXZlTVRyaWdnZXIoJ3ZvaWNlL3JlcXVlc3RNZWRpYVBlZXJSZXNwb25zZScsIHsgcGVlck5hbWUsIHN0YXR1cyB9KTtcbiAgICB9XG59O1xuXG5jb25zdCB0cmlnZ2VyQ2xpZW50UmVxdWVzdENsb3NlTWVkaWFQZWVyUmVzcG9uc2UgPSAocGVlck5hbWUsIHN0YXR1cykgPT4ge1xuICAgIGlmIChpc1JhZ2VNcCkge1xuICAgICAgICBtcC50cmlnZ2VyKCd2b2ljZS5yZXF1ZXN0Q2xvc2VNZWRpYVBlZXJSZXNwb25zZScsIHBlZXJOYW1lLCBzdGF0dXMpO1xuICAgIH0gZWxzZSB7XG4gICAgICAgIEZpdmVNVHJpZ2dlcigndm9pY2UvcmVxdWVzdENsb3NlTWVkaWFQZWVyUmVzcG9uc2UnLCB7IHBlZXJOYW1lLCBzdGF0dXMgfSk7XG4gICAgfVxufTtcblxuY29uc3QgdHJpZ2dlckNsaWVudENoYW5nZVByb2R1Y2VyVm9sdW1lID0gKHZvbHVtZSkgPT4ge1xuICAgIGlmIChpc1JhZ2VNcCkge1xuICAgICAgICBtcC50cmlnZ2VyKCd2b2ljZS5jaGFuZ2VQcm9kdWNlclZvbHVtZScsIHZvbHVtZSk7XG4gICAgfSBlbHNlIHtcbiAgICAgICAgRml2ZU1UcmlnZ2VyKCd2b2ljZS9jaGFuZ2VQcm9kdWNlclZvbHVtZScsIHsgdm9sdW1lIH0pO1xuICAgIH1cbn07XG5cbmNvbnN0IHRyaWdnZXJDbGllbnRDaGFuZ2VDb25zdW1lclZvbHVtZSA9IChwZWVyTmFtZSwgdm9sdW1lKSA9PiB7XG4gICAgaWYgKGlzUmFnZU1wKSB7XG4gICAgICAgIG1wLnRyaWdnZXIoJ3ZvaWNlLmNoYW5nZUNvbnN1bWVyVm9sdW1lJywgcGVlck5hbWUsIHZvbHVtZSk7XG4gICAgfSBlbHNlIHtcbiAgICAgICAgRml2ZU1UcmlnZ2VyKCd2b2ljZS9jaGFuZ2VDb25zdW1lclZvbHVtZScsIHsgcGVlck5hbWUsIHZvbHVtZSB9KTtcbiAgICB9XG59XG5cbmNvbnN0IHRyaWdnZXJDbGllbnRDaGFuZ2VDb25zdW1lcnNWb2x1bWUgPSAoY29uc3VtZXJzKSA9PiB7XG4gICAgaWYgKGlzUmFnZU1wKSB7XG4gICAgICAgIG1wLnRyaWdnZXIoJ3ZvaWNlLmNoYW5nZUNvbnN1bWVyc1ZvbHVtZScsIEpTT04uc3RyaW5naWZ5KGNvbnN1bWVycykpO1xuICAgIH0gZWxzZSB7XG4gICAgICAgIEZpdmVNVHJpZ2dlcigndm9pY2UvY2hhbmdlQ29uc3VtZXJzVm9sdW1lJywgeyBjb25zdW1lcnMgfSk7XG4gICAgfVxufVxuXG5jb25zdCB0cmlnZ2VyQ2xpZW50TWljcm9waG9uZUVuYWJsZWQgPSAocGVlck5hbWUsIGlzRW5hYmxlZCkgPT4ge1xuICAgIGlmIChpc1JhZ2VNcCkge1xuICAgICAgICBtcC50cmlnZ2VyKCd2b2ljZS50b2dnbGVNaWNyb3Bob25lJywgcGVlck5hbWUsIGlzRW5hYmxlZCk7XG4gICAgfSBlbHNlIHtcbiAgICAgICAgRml2ZU1UcmlnZ2VyKCd2b2ljZS90b2dnbGVNaWNyb3Bob25lJywgeyBwZWVyTmFtZSwgaXNFbmFibGVkIH0pO1xuICAgIH1cbn07XG5cbmV4cG9ydCBkZWZhdWx0IHtcbiAgICBvbjogbGlzdGVuRXZlbnQsXG4gICAgY2FsbDogY2FsbEV2ZW50LFxuICAgIHJlbW92ZTogcmVtb3ZlRXZlbnQsXG4gICAgdHJpZ2dlckNsaWVudENoYW5nZVN0YXRlQ29ubmVjdGlvbixcbiAgICB0cmlnZ2VyQ2xpZW50UmVxdWVzdE1lZGlhUGVlclJlc3BvbnNlLFxuICAgIHRyaWdnZXJDbGllbnRSZXF1ZXN0Q2xvc2VNZWRpYVBlZXJSZXNwb25zZSxcbiAgICB0cmlnZ2VyQ2xpZW50Q2hhbmdlUHJvZHVjZXJWb2x1bWUsXG4gICAgdHJpZ2dlckNsaWVudENoYW5nZUNvbnN1bWVyVm9sdW1lLFxuICAgIHRyaWdnZXJDbGllbnRDaGFuZ2VDb25zdW1lcnNWb2x1bWUsXG4gICAgdHJpZ2dlckNsaWVudE1pY3JvcGhvbmVFbmFibGVkLFxuICAgIF9fZXZlbnRzXG59O1xuIiwiaW1wb3J0IGRvbXJlYWR5IGZyb20gJ2RvbXJlYWR5JztcbmltcG9ydCBVcmxQYXJzZSBmcm9tICd1cmwtcGFyc2UnO1xuaW1wb3J0IHsgZ2V0RGV2aWNlSW5mbyB9IGZyb20gJy4uL21lZGlhc291cC1jbGllbnQvJztcbmltcG9ydCBMb2dnZXIgZnJvbSAnLi9Mb2dnZXInO1xuaW1wb3J0IE1wRXZlbnRzIGZyb20gJy4vaGVscGVycy9ldmVudHMnO1xuaW1wb3J0IE5ld0NsaWVudCBmcm9tICcuL25ld0NsaWVudCc7XG5pbXBvcnQgKiBhcyB1dGlscyBmcm9tICcuL3V0aWxzJztcbmltcG9ydCAnLi9kdW1taWVzL21wJztcblxubXAuZW5hYmxlRGVidWdnaW5nQWxlcnRzKHRydWUpO1xubXAuZXZlbnRzID0gTXBFdmVudHM7XG5cbmNvbnN0IGxvZ2dlciA9IG5ldyBMb2dnZXIoKTtcblxuLyoqIEB0eXBlIHtOZXdDbGllbnR9ICovXG5sZXQgY2xpZW50ID0gbnVsbDtcblxuZG9tcmVhZHkoKCkgPT5cbntcblx0bG9nZ2VyLmRlYnVnKCdET00gcmVhZHknKTtcblxuXHQvLyBpbml0KHVuZGVmaW5lZCwgJ2FzZmRzJylcbn0pO1xuXG5mdW5jdGlvbiBpbml0KHBsYXllcklkLCBwbGF5ZXJUb2tlbiwgZGV2aWNlSWQgPSAnZGVmYXVsdCcsIHByb2R1Y2VyVm9sdW1lID0gMSwgaXNVc2IgPSBmYWxzZSwgaXNQb3NpdGlvbmluZyA9IHRydWUpXG57XG5cdGxvZ2dlci5kZWJ1ZygncnVuKCkgW2Vudmlyb25tZW50OiVzXScsIHByb2Nlc3MuZW52Lk5PREVfRU5WKTtcblxuXHRjb25zdCB1cmxQYXJzZXIgPSBuZXcgVXJsUGFyc2Uod2luZG93LmxvY2F0aW9uLmhyZWYsIHRydWUpO1xuXHRjb25zdCBwcm9kdWNlID0gdXJsUGFyc2VyLnF1ZXJ5LnByb2R1Y2UgIT09ICdmYWxzZSc7XG5cdGNvbnN0IGlzU2lwRW5kcG9pbnQgPSB1cmxQYXJzZXIucXVlcnkuc2lwRW5kcG9pbnQgPT09ICd0cnVlJztcblx0Y29uc3QgdXNlU2ltdWxjYXN0ID0gdXJsUGFyc2VyLnF1ZXJ5LnNpbXVsY2FzdCAhPT0gJ2ZhbHNlJztcblx0Y29uc3QgX3VzZXJOYW1lXyA9IHVybFBhcnNlci5xdWVyeS5uYW1lO1xuXG5cdGNvbnN0IHBlZXJOYW1lID0gcGxheWVySWQgfHwgX3VzZXJOYW1lXztcblxuXHRjb25zb2xlLmxvZygnbXlQZWVyTmFtZScsIHBlZXJOYW1lKTtcblxuXHRjb25zdCBkZXZpY2UgPSBnZXREZXZpY2VJbmZvKCk7XG5cblx0aWYgKGlzU2lwRW5kcG9pbnQpXG5cdHtcblx0XHRkZXZpY2UuZmxhZyA9ICdzaXBlbmRwb2ludCc7XG5cdFx0ZGV2aWNlLm5hbWUgPSAnU0lQIEVuZHBvaW50Jztcblx0XHRkZXZpY2UudmVyc2lvbiA9IHVuZGVmaW5lZDtcblx0fVxuXG5cdGNsaWVudCA9IG5ldyBOZXdDbGllbnQoe1xuXHRcdHBlZXJOYW1lLFxuXHRcdHRva2VuOiBwbGF5ZXJUb2tlbixcblx0XHRkZXZpY2UsXG5cdFx0cHJvZHVjZSxcblx0XHR1c2VTaW11bGNhc3QsXG5cdFx0ZGV2aWNlSWQsXG5cdFx0cHJvZHVjZXJWb2x1bWUsXG5cdFx0aXNVc2IsXG5cdFx0aXNQb3NpdGlvbmluZ1xuXHR9KTtcblxuXHR3aW5kb3cuX2NsaWVudCA9IGNsaWVudDtcbn1cblxubXAuZXZlbnRzLm9uKCdpbml0JywgKHBsYXllcklkLCB0b2tlbiwgZGV2aWNlSWQsIHByb2R1Y2VyVm9sdW1lLCBpc1VzYiwgaXNQb3NpdGlvbmluZykgPT4ge1xuXHRpbml0KHBsYXllcklkLCB0b2tlbiwgZGV2aWNlSWQsIHByb2R1Y2VyVm9sdW1lLCBpc1VzYiwgaXNQb3NpdGlvbmluZyk7XG59KTtcblxubXAuZXZlbnRzLm9uKCdzdHJlYW1JbicsIChwbGF5ZXJJZCkgPT4ge1xuXHRpZiAoY2xpZW50ICYmIGNsaWVudC5fc3RhdGVDb25uZWN0aW9uICE9PSAnY2xvc2VkJykge1xuXHRcdGNsaWVudC5yZXF1ZXN0TWVkaWFQZWVyKHBsYXllcklkKTtcblx0fVxufSk7XG5cbm1wLmV2ZW50cy5vbignc3RyZWFtT3V0JywgKHBsYXllcklkKSA9PiB7XG5cdGlmIChjbGllbnQgJiYgY2xpZW50Ll9zdGF0ZUNvbm5lY3Rpb24gIT09ICdjbG9zZWQnKSB7XG5cdFx0Y2xpZW50LnJlcXVlc3RDbG9zZU1lZGlhUGVlcihwbGF5ZXJJZCk7XG5cdH1cbn0pO1xuXG5tcC5ldmVudHMub24oJ2NoYW5nZVZvbHVtZUNvbnN1bWVyJywgKHBsYXllcklkLCB2b2x1bWUsIGJhbGFuY2UpID0+IHtcblx0aWYgKGNsaWVudCAmJiBjbGllbnQuX3N0YXRlQ29ubmVjdGlvbiAhPT0gJ2Nsb3NlZCcpIHtcblx0XHRjbGllbnQuY2hhbmdlQ29uc3VtZXJWb2x1bWUocGxheWVySWQsIHZvbHVtZSwgYmFsYW5jZSk7XG5cdH1cbn0pO1xuXG5tcC5ldmVudHMub24oJ2NoYW5nZVZvbHVtZUNvbnN1bWVycycsIChwZWVycykgPT4ge1xuXHRpZiAoY2xpZW50ICYmIGNsaWVudC5fc3RhdGVDb25uZWN0aW9uICE9PSAnY2xvc2VkJykge1xuXHRcdGNsaWVudC5jaGFuZ2VDb25zdW1lcnNWb2x1bWUocGVlcnMpO1xuXHR9XG59KTtcblxubXAuZXZlbnRzLm9uKCdjaGFuZ2VQcm9kdWNlclZvbHVtZScsICh2b2x1bWUpID0+IHtcblx0aWYgKGNsaWVudCAmJiBjbGllbnQuX3N0YXRlQ29ubmVjdGlvbiAhPT0gJ2Nsb3NlZCcpIHtcblx0XHRjbGllbnQuY2hhbmdlUHJvZHVjZXJWb2x1bWUodm9sdW1lKTtcblx0fVxufSk7XG5cbm1wLmV2ZW50cy5vbignY2hhbmdlTWFpblZvbHVtZScsICh2b2x1bWUpID0+IHtcblx0aWYgKGNsaWVudCAmJiBjbGllbnQuX3N0YXRlQ29ubmVjdGlvbiAhPT0gJ2Nsb3NlZCcpIHtcblx0XHRjbGllbnQuY2hhbmdlTWFpblZvbHVtZSh2b2x1bWUpO1xuXHR9XG59KTtcblxubXAuZXZlbnRzLm9uKCdjaGFuZ2VQcm9kdWNlcicsIChkZXZpY2VJZCwgcHJvZHVjZXJWb2x1bWUgPSAxKSA9PiB7XG5cdGlmIChjbGllbnQgJiYgY2xpZW50Ll9zdGF0ZUNvbm5lY3Rpb24gIT09ICdjbG9zZWQnKSB7XG5cdFx0Y2xpZW50LmNoYW5nZVByb2R1Y2VyKGRldmljZUlkLCBwcm9kdWNlclZvbHVtZSk7XG5cdH1cbn0pO1xuXG5tcC5ldmVudHMub24oJ2NoYW5nZVByb2R1Y2VySXNVc2InLCAoaXNVc2IpID0+IHtcblx0aWYgKGNsaWVudCAmJiBjbGllbnQuX3N0YXRlQ29ubmVjdGlvbiAhPT0gJ2Nsb3NlZCcpIHtcblx0XHRjbGllbnQuY2hhbmdlUHJvZHVjZXJJc1VzYihpc1VzYik7XG5cdH1cbn0pO1xuXG5tcC5ldmVudHMub24oJ2NoYW5nZVBvc2l0aW9uaW5nJywgKGlzUG9zaXRpb25pbmcpID0+IHtcblx0aWYgKGNsaWVudCAmJiBjbGllbnQuX3N0YXRlQ29ubmVjdGlvbiAhPT0gJ2Nsb3NlZCcpIHtcblx0XHRjbGllbnQuY2hhbmdlUG9zaXRpb25pbmcoaXNQb3NpdGlvbmluZyk7XG5cdH1cbn0pO1xuXG5tcC5ldmVudHMub24oJ211dGVNaWMnLCAoKSA9PiB7XG5cdGlmIChjbGllbnQgJiYgY2xpZW50Ll9zdGF0ZUNvbm5lY3Rpb24gIT09ICdjbG9zZWQnKSB7XG5cdFx0Y2xpZW50Lm11dGVNaWMoKTtcblx0fVxufSk7XG5cbm1wLmV2ZW50cy5vbigndW5tdXRlTWljJywgKCkgPT4ge1xuXHRpZiAoY2xpZW50ICYmIGNsaWVudC5fc3RhdGVDb25uZWN0aW9uICE9PSAnY2xvc2VkJykge1xuXHRcdGNsaWVudC51bm11dGVNaWMoKTtcblx0fVxufSk7XG5cbm1wLmV2ZW50cy5vbigncmVzdGFydEljZScsICgpID0+IHtcblx0aWYgKGNsaWVudCAmJiBjbGllbnQuX3N0YXRlQ29ubmVjdGlvbiAhPT0gJ2Nsb3NlZCcpIHtcblx0XHRjbGllbnQucmVzdGFydEljZSgpO1xuXHR9XG59KTtcblxubXAuZXZlbnRzLm9uKCdxdWl0JywgKCkgPT4ge1xuXHRpZiAoY2xpZW50ICYmIGNsaWVudC5fc3RhdGVDb25uZWN0aW9uICE9PSAnY2xvc2VkJykge1xuXHRcdGNsaWVudC5jbG9zZSgpO1xuXHR9XG59KTsiLCJcbmltcG9ydCBwcm90b29DbGllbnQgZnJvbSAncHJvdG9vLWNsaWVudCc7XG5pbXBvcnQgKiBhcyBtZWRpYXNvdXBDbGllbnQgZnJvbSAnLi4vbWVkaWFzb3VwLWNsaWVudC8nO1xuaW1wb3J0IExvZ2dlciBmcm9tICcuL0xvZ2dlcic7XG5pbXBvcnQgeyBnZXRQcm90b29VcmwgfSBmcm9tICcuL3VybEZhY3RvcnknO1xuaW1wb3J0IERhdGFTdG9yZSBmcm9tICcuL0RhdGFTdG9yZSc7XG5pbXBvcnQgTXBFdmVudHMgZnJvbSAnLi9oZWxwZXJzL2V2ZW50cyc7XG5cbmNvbnN0IGxvZ2dlciA9IG5ldyBMb2dnZXIoJ05ld0NsaWVudCcpO1xuXG5jb25zdCBST09NX09QVElPTlMgPVxuXHR7XG5cdFx0cmVxdWVzdFRpbWVvdXQ6IDEwMDAwLFxuXHRcdHRyYW5zcG9ydE9wdGlvbnM6IHtcblx0XHRcdHRjcDogZmFsc2Vcblx0XHR9LFxuXHRcdHR1cm5TZXJ2ZXJzOiBbXG5cdFx0XHR7IHVybHM6IFwic3R1bjp2b2ljZS5mcGdtLnJ1OjM0NzhcIiwgdXNlcm5hbWU6IFwia2VtcGVycnJcIiwgY3JlZGVudGlhbDogXCI2MjUxMDFcIiB9LFxuXHRcdFx0eyB1cmxzOiBcInR1cm46dm9pY2UuZnBnbS5ydTozNDc4XCIsIHVzZXJuYW1lOiBcImtlbXBlcnJyXCIsIGNyZWRlbnRpYWw6IFwiNjI1MTAxXCIgfSxcblx0XHRcdHsgdXJsczogXCJzdHVuOnZvaXAubGliZXJ0eXJvbGVwbGF5LnJ1OjM0NzhcIiwgdXNlcm5hbWU6IFwiZGlzcXVzZVwiLCBjcmVkZW50aWFsOiBcIjYyNTEwMVwiIH0sXG5cdFx0XHR7IHVybHM6IFwidHVybjp2b2lwLmxpYmVydHlyb2xlcGxheS5ydTozNDc4XCIsIHVzZXJuYW1lOiBcImRpc3F1c2VcIiwgY3JlZGVudGlhbDogXCI2MjUxMDFcIiB9LFxuXHRcdFx0eyB1cmxzOiBcInR1cm46dHVybi5rYW5kaWRhdHJwLnJ1OjM0NzhcIiwgdXNlcm5hbWU6IFwia2FuZGlkYXRcIiwgY3JlZGVudGlhbDogXCIxOTkyXCIgfSxcbiAgICAgICAgICAgIHsgdXJsczogXCJzdHVuOnN0dW4ua2FuZGlkYXRycC5ydTozNDc4XCIsIHVzZXJuYW1lOiBcImthbmRpZGF0XCIsIGNyZWRlbnRpYWw6IFwiMTk5MlwiIH0sXG5cdFx0XHR7IHVybHM6IFwic3R1bjp0b3AtZ3RhLmNvbTozNDc4XCIsIHVzZXJuYW1lOiBcImFycFwiLCBjcmVkZW50aWFsOiBcImFycGFycDExXCIgfSxcblx0XHRcdHsgdXJsczogXCJ0dXJuOnRvcC1ndGEuY29tOjM0NzhcIiwgdXNlcm5hbWU6IFwiYXJwXCIsIGNyZWRlbnRpYWw6IFwiYXJwYXJwMTFcIiB9XG5cdFx0XVxuXHR9O1xuXG5jbGFzcyBOZXdDbGllbnQge1xuXHRjb25zdHJ1Y3Rvcih7IHBlZXJOYW1lLCB0b2tlbiwgZGV2aWNlLCB1c2VTaW11bGNhc3QsIHByb2R1Y2UsIGRldmljZUlkLCBwcm9kdWNlclZvbHVtZSwgaXNVc2IsIGlzUG9zaXRpb25pbmcgfSkge1xuXHRcdGxvZ2dlci5kZWJ1ZygnY29uc3RydWN0b3IoKSBbcGVlck5hbWU6XCIlc1wiLCBkZXZpY2U6JXNdJywgcGVlck5hbWUsIGRldmljZS5mbGFnKTtcblxuXHRcdHRoaXMuX2RhdGFTdG9yZSA9IERhdGFTdG9yZTtcblxuXHRcdGNvbnN0IHByb3Rvb1VybCA9IGdldFByb3Rvb1VybChwZWVyTmFtZSwgdG9rZW4pO1xuXHRcdGNvbnN0IHByb3Rvb1RyYW5zcG9ydCA9IG5ldyBwcm90b29DbGllbnQuV2ViU29ja2V0VHJhbnNwb3J0KHByb3Rvb1VybCk7XG5cblx0XHR0aGlzLl90b2tlbiA9IHRva2VuO1xuXG5cdFx0dGhpcy5fY2xvc2VkID0gZmFsc2U7XG5cblx0XHR0aGlzLl9wcm9kdWNlID0gcHJvZHVjZTtcblxuXHRcdHRoaXMuX3VzZVNpbXVsY2FzdCA9IHVzZVNpbXVsY2FzdDtcblxuXHRcdHRoaXMuX3BlZXJOYW1lID0gcGVlck5hbWU7XG5cblx0XHR0aGlzLmRldmljZUlkID0gZGV2aWNlSWQ7XG5cblx0XHR0aGlzLnByb2R1Y2VyVm9sdW1lID0gcHJvZHVjZXJWb2x1bWU7XG5cblx0XHR0aGlzLl9wcm90b28gPSBuZXcgcHJvdG9vQ2xpZW50LlBlZXIocHJvdG9vVHJhbnNwb3J0KTtcblxuXHRcdHRoaXMuX3Jvb20gPSBuZXcgbWVkaWFzb3VwQ2xpZW50LlJvb20oUk9PTV9PUFRJT05TKTtcblxuXHRcdHRoaXMuX3NlbmRUcmFuc3BvcnQgPSBudWxsO1xuXG5cdFx0dGhpcy5fcmVjdlRyYW5zcG9ydCA9IG51bGw7XG5cblx0XHR0aGlzLl9taWNQcm9kdWNlciA9IG51bGw7XG5cblx0XHR0aGlzLmlzVXNiID0gaXNVc2I7XG5cblx0XHR0aGlzLmlzUG9zaXRpb25pbmcgPSBpc1Bvc2l0aW9uaW5nO1xuXHRcdERhdGFTdG9yZS5jaGFuZ2VQb3NpdGlvbmluZyhpc1Bvc2l0aW9uaW5nKTtcblxuXHRcdHRoaXMuX3N0YXRlQ29ubmVjdGlvbiA9ICdjbG9zZWQnO1xuXG5cdFx0dGhpcy5fam9pbih7IGRldmljZSwgdG9rZW4gfSk7XG5cdH1cblxuXHRnZXQgc3RhdGVDb25uZWN0aW9uKCkge1xuXHRcdHJldHVybiB0aGlzLl9zdGF0ZUNvbm5lY3Rpb247XG5cdH1cblxuXHRzZXRTdGF0ZUNvbm5lY3Rpb24oc3RhdGUpIHtcblx0XHR0aGlzLl9zdGF0ZUNvbm5lY3Rpb24gPSBzdGF0ZTtcblx0XHRNcEV2ZW50cy50cmlnZ2VyQ2xpZW50Q2hhbmdlU3RhdGVDb25uZWN0aW9uKHN0YXRlKTtcblx0fVxuXG5cdGNsb3NlKCkge1xuXHRcdGlmICh0aGlzLl9jbG9zZWQpXG5cdFx0XHRyZXR1cm47XG5cblx0XHR0aGlzLl9jbG9zZWQgPSB0cnVlO1xuXG5cdFx0bG9nZ2VyLmRlYnVnKCdjbG9zZSgpJyk7XG5cblx0XHQvLyBMZWF2ZSB0aGUgbWVkaWFzb3VwIFJvb20uXG5cdFx0dGhpcy5fcm9vbS5sZWF2ZSgpO1xuXG5cdFx0Ly8gQ2xvc2UgcHJvdG9vIFBlZXIgKHdhaXQgYSBiaXQgc28gbWVkaWFzb3VwLWNsaWVudCBjYW4gc2VuZFxuXHRcdC8vIHRoZSAnbGVhdmVSb29tJyBub3RpZmljYXRpb24pLlxuXHRcdHNldFRpbWVvdXQoKCkgPT4gdGhpcy5fcHJvdG9vLmNsb3NlKCksIDI1MCk7XG5cblx0XHR0aGlzLnNldFN0YXRlQ29ubmVjdGlvbignY2xvc2VkJyk7XG5cdH1cblxuXHRyZXF1ZXN0TWVkaWFQZWVyKHBlZXJOYW1lKSB7XG5cblx0XHRpZiAoIXRoaXMuX3Jvb20uX3BlZXJzLmhhcyhwZWVyTmFtZSkpIHtcblx0XHRcdHRoaXMuX3Jvb20ucmVxdWVzdE1lZGlhUGVlcihwZWVyTmFtZSlcblx0XHRcdFx0LnRoZW4oKHJlc3BvbnNlKSA9PiB7XG5cdFx0XHRcdFx0TXBFdmVudHMudHJpZ2dlckNsaWVudFJlcXVlc3RNZWRpYVBlZXJSZXNwb25zZShwZWVyTmFtZSwgcmVzcG9uc2Uuc3RhdHVzKTtcblx0XHRcdFx0fSlcblx0XHRcdFx0LmNhdGNoKGVyciA9PiB7XG5cdFx0XHRcdFx0Y29uc29sZS5sb2coJ3JlcXVlc3RNZWRpYVBlZXIgLSBlcnJvcicsIHBlZXJOYW1lLCBlcnIpO1xuXHRcdFx0XHRcdE1wRXZlbnRzLnRyaWdnZXJDbGllbnRSZXF1ZXN0TWVkaWFQZWVyUmVzcG9uc2UocGVlck5hbWUsIGZhbHNlKTtcblx0XHRcdFx0fSk7XG5cdFx0fVxuXHR9XG5cblx0cmVxdWVzdENsb3NlTWVkaWFQZWVyKHBlZXJOYW1lKSB7XG5cdFx0aWYgKHRoaXMuX3Jvb20uX3BlZXJzLmhhcyhwZWVyTmFtZSkpXG5cdFx0XHR0aGlzLl9yb29tLnJlcXVlc3RDbG9zZU1lZGlhUGVlcihwZWVyTmFtZSlcblx0XHRcdFx0LnRoZW4oKHJlc3BvbnNlKSA9PiB7XG5cdFx0XHRcdFx0TXBFdmVudHMudHJpZ2dlckNsaWVudFJlcXVlc3RDbG9zZU1lZGlhUGVlclJlc3BvbnNlKHBlZXJOYW1lLCByZXNwb25zZS5zdGF0dXMpO1xuXHRcdFx0XHR9KVxuXHRcdFx0XHQuY2F0Y2goZXJyID0+IHtcblx0XHRcdFx0XHRjb25zb2xlLmxvZygncmVxdWVzdENsb3NlTWVkaWFQZWVyIC0gZXJyb3InLCBwZWVyTmFtZSwgZXJyKTtcblx0XHRcdFx0XHRNcEV2ZW50cy50cmlnZ2VyQ2xpZW50UmVxdWVzdENsb3NlTWVkaWFQZWVyUmVzcG9uc2UocGVlck5hbWUsIGZhbHNlKTtcblx0XHRcdFx0fSk7XG5cdH1cblxuXHRtdXRlTWljKCkge1xuXHRcdGlmICghdGhpcy5fbWljUHJvZHVjZXIpXG5cdFx0XHRyZXR1cm4gZmFsc2U7XG5cblx0XHRsb2dnZXIuZGVidWcoJ211dGVNaWMoKScpO1xuXG5cdFx0dGhpcy5fbWljUHJvZHVjZXIucGF1c2UoKTtcblx0fVxuXG5cdHVubXV0ZU1pYygpIHtcblx0XHRpZiAoIXRoaXMuX21pY1Byb2R1Y2VyKVxuXHRcdFx0cmV0dXJuIGZhbHNlO1xuXG5cdFx0bG9nZ2VyLmRlYnVnKCd1bm11dGVNaWMoKScpO1xuXG5cdFx0dGhpcy5fbWljUHJvZHVjZXIucmVzdW1lKCk7XG5cdH1cblxuXHRjaGFuZ2VQb3NpdGlvbmluZyhpc1Bvc2l0aW9uaW5nKSB7XG5cdFx0dGhpcy5pc1Bvc2l0aW9uaW5nID0gaXNQb3NpdGlvbmluZztcblx0XHREYXRhU3RvcmUuY2hhbmdlUG9zaXRpb25pbmcoaXNQb3NpdGlvbmluZyk7XG5cdH1cblxuXHRjaGFuZ2VDb25zdW1lclZvbHVtZShjb25zdW1lcklkLCB2b2x1bWUsIGJhbGFuY2UpIHtcblx0XHREYXRhU3RvcmUuY2hhbmdlQ29uc3VtZXJWb2x1bWUoY29uc3VtZXJJZCwgdm9sdW1lLCBiYWxhbmNlKTtcblx0fVxuXG5cdGNoYW5nZUNvbnN1bWVyc1ZvbHVtZShwZWVycykge1xuXHRcdHBlZXJzID0gdHlwZW9mIHBlZXJzID09PSAnc3RyaW5nJyA/IEpTT04ucGFyc2UocGVlcnMpIDogcGVlcnM7XG5cblx0XHRwZWVycy5mb3JFYWNoKHBlZXIgPT4ge1xuXHRcdFx0RGF0YVN0b3JlLmNoYW5nZUNvbnN1bWVyVm9sdW1lKHBlZXIubmFtZSwgcGVlci52b2x1bWUsIHBlZXIuYmFsYW5jZSk7XG5cdFx0fSk7XG5cdH1cblxuXHRjaGFuZ2VQcm9kdWNlclZvbHVtZSh2b2x1bWUpIHtcblx0XHREYXRhU3RvcmUuY2hhbmdlUHJvZHVjZXJWb2x1bWUodm9sdW1lKTtcblx0fVxuXG5cdGNoYW5nZU1haW5Wb2x1bWUodm9sdW1lKSB7XG5cdFx0RGF0YVN0b3JlLmNoYW5nZU1haW5Wb2x1bWUodm9sdW1lKTtcblx0fVxuXG5cdGNoYW5nZVByb2R1Y2VyKGRldmljZUlkLCBwcm9kdWNlclZvbHVtZSkge1xuXG5cdFx0bG9nZ2VyLmRlYnVnKCdjaGFuZ2VQcm9kdWNlcigpIFtkZXZpY2VJZDpcIiVzXCIsIHByb2R1Y2VyVm9sdW1lOiVkXScsIGRldmljZUlkLCBwcm9kdWNlclZvbHVtZSk7XG5cblx0XHR0aGlzLl9taWNQcm9kdWNlci5jbG9zZSgpO1xuXHRcdHRoaXMuZGV2aWNlSWQgPSBkZXZpY2VJZDtcblx0XHR0aGlzLnByb2R1Y2VyVm9sdW1lID0gcHJvZHVjZXJWb2x1bWU7XG5cdFx0dGhpcy5fc2V0TWljUHJvZHVjZXIoZGV2aWNlSWQsIHByb2R1Y2VyVm9sdW1lLCB0aGlzLmlzVXNiKVxuXHRcdFx0LmNhdGNoKCgpID0+IHsgfSk7XG5cdH1cblxuXHRjaGFuZ2VQcm9kdWNlcklzVXNiKGlzVXNiKSB7XG5cdFx0bG9nZ2VyLmRlYnVnKCdjaGFuZ2VQcm9kdWNlcklzVXNiKCkgW2lzVXNiOlwiJXNcIl0nLCBpc1VzYik7XG5cblx0XHR0aGlzLl9taWNQcm9kdWNlci5jbG9zZSgpO1xuXHRcdHRoaXMuaXNVc2IgPSBpc1VzYjtcblx0XHR0aGlzLl9zZXRNaWNQcm9kdWNlcih0aGlzLmRldmljZUlkLCB0aGlzLnByb2R1Y2VyVm9sdW1lLCBpc1VzYilcblx0XHRcdC5jYXRjaCgoKSA9PiB7IH0pO1xuXHR9XG5cblx0cmVzdGFydEljZSgpIHtcblx0XHRsb2dnZXIuZGVidWcoJ3Jlc3RhcnRJY2UoKScpO1xuXG5cdFx0cmV0dXJuIFByb21pc2UucmVzb2x2ZSgpXG5cdFx0XHQudGhlbigoKSA9PiB7XG5cdFx0XHRcdHRoaXMuX3Jvb20ucmVzdGFydEljZSgpO1xuXHRcdFx0fSlcblx0XHRcdC5jYXRjaCgoZXJyb3IpID0+IHtcblx0XHRcdFx0bG9nZ2VyLmVycm9yKCdyZXN0YXJ0SWNlKCkgZmFpbGVkOiAlbycsIGVycm9yKTtcblx0XHRcdH0pO1xuXHR9XG5cblx0X2pvaW4oeyBkZXZpY2UsIHRva2VuIH0pIHtcblxuXHRcdHRoaXMuc2V0U3RhdGVDb25uZWN0aW9uKCdjb25uZWN0aW5nJyk7XG5cblx0XHR0aGlzLl9wcm90b28ub24oJ29wZW4nLCAoKSA9PiB7XG5cdFx0XHRsb2dnZXIuZGVidWcoJ3Byb3RvbyBQZWVyIFwib3BlblwiIGV2ZW50Jyk7XG5cblx0XHRcdHRoaXMuX2pvaW5Sb29tKHsgZGV2aWNlLCB0b2tlbiB9KTtcblx0XHR9KTtcblxuXHRcdHRoaXMuX3Byb3Rvby5vbignZGlzY29ubmVjdGVkJywgKCkgPT4ge1xuXHRcdFx0bG9nZ2VyLndhcm4oJ3Byb3RvbyBQZWVyIFwiZGlzY29ubmVjdGVkXCIgZXZlbnQnKTtcblxuXHRcdFx0Ly8gTGVhdmUgUm9vbS5cblx0XHRcdHRyeSB7IHRoaXMuX3Jvb20ucmVtb3RlQ2xvc2UoeyBjYXVzZTogJ3Byb3RvbyBkaXNjb25uZWN0ZWQnIH0pOyB9XG5cdFx0XHRjYXRjaCAoZXJyb3IpIHsgfVxuXG5cdFx0XHR0aGlzLnNldFN0YXRlQ29ubmVjdGlvbignY29ubmVjdGluZycpO1xuXHRcdH0pO1xuXG5cdFx0dGhpcy5fcHJvdG9vLm9uKCdjbG9zZScsICgpID0+IHtcblx0XHRcdGlmICh0aGlzLl9jbG9zZWQpXG5cdFx0XHRcdHJldHVybjtcblxuXHRcdFx0bG9nZ2VyLndhcm4oJ3Byb3RvbyBQZWVyIFwiY2xvc2VcIiBldmVudCcpO1xuXG5cdFx0XHR0aGlzLmNsb3NlKCk7XG5cdFx0fSk7XG5cblx0XHR0aGlzLl9wcm90b28ub24oJ3JlcXVlc3QnLCAocmVxdWVzdCwgYWNjZXB0LCByZWplY3QpID0+IHtcblx0XHRcdGxvZ2dlci5kZWJ1ZygnX2hhbmRsZVByb3Rvb1JlcXVlc3QoKSBbbWV0aG9kOiVzLCBkYXRhOiVvXScsIHJlcXVlc3QubWV0aG9kLCByZXF1ZXN0LmRhdGEpO1xuXG5cdFx0XHRzd2l0Y2ggKHJlcXVlc3QubWV0aG9kKSB7XG5cdFx0XHRcdGNhc2UgJ21lZGlhc291cC1ub3RpZmljYXRpb24nOlxuXHRcdFx0XHRcdHtcblx0XHRcdFx0XHRcdGFjY2VwdCgpO1xuXG5cdFx0XHRcdFx0XHRjb25zdCBub3RpZmljYXRpb24gPSByZXF1ZXN0LmRhdGE7XG5cblx0XHRcdFx0XHRcdHRoaXMuX3Jvb20ucmVjZWl2ZU5vdGlmaWNhdGlvbihub3RpZmljYXRpb24pO1xuXG5cdFx0XHRcdFx0XHRicmVhaztcblx0XHRcdFx0XHR9XG5cblx0XHRcdFx0ZGVmYXVsdDpcblx0XHRcdFx0XHR7XG5cdFx0XHRcdFx0XHRsb2dnZXIuZXJyb3IoJ3Vua25vd24gcHJvdG9vIG1ldGhvZCBcIiVzXCInLCByZXF1ZXN0Lm1ldGhvZCk7XG5cblx0XHRcdFx0XHRcdHJlamVjdCg0MDQsICd1bmtub3duIG1ldGhvZCcpO1xuXHRcdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9KTtcblxuXHR9XG5cblx0X2pvaW5Sb29tKHsgZGV2aWNlLCB0b2tlbiB9KSB7XG5cdFx0bG9nZ2VyLmRlYnVnKCdfam9pblJvb20oKScpO1xuXG5cdFx0dGhpcy5fcm9vbS5yZW1vdmVBbGxMaXN0ZW5lcnMoKTtcblxuXHRcdHRoaXMuX3Jvb20ub24oJ2Nsb3NlJywgKG9yaWdpbmF0b3IsIGFwcERhdGEpID0+IHtcblx0XHRcdGlmIChvcmlnaW5hdG9yID09PSAncmVtb3RlJykge1xuXHRcdFx0XHRsb2dnZXIud2FybignbWVkaWFzb3VwIFBlZXIvUm9vbSByZW1vdGVseSBjbG9zZWQgW2FwcERhdGE6JW9dJywgYXBwRGF0YSk7XG5cblx0XHRcdFx0dGhpcy5zZXRTdGF0ZUNvbm5lY3Rpb24oJ2Nsb3NlZCcpO1xuXG5cdFx0XHRcdHJldHVybjtcblx0XHRcdH1cblx0XHR9KTtcblxuXHRcdHRoaXMuX3Jvb20ub24oJ3JlcXVlc3QnLCAocmVxdWVzdCwgY2FsbGJhY2ssIGVycmJhY2spID0+IHtcblx0XHRcdGxvZ2dlci5kZWJ1Zygnc2VuZGluZyBtZWRpYXNvdXAgcmVxdWVzdCBbbWV0aG9kOiVzXTolbycsIHJlcXVlc3QubWV0aG9kLCByZXF1ZXN0KTtcblxuXHRcdFx0dGhpcy5fcHJvdG9vLnNlbmQoJ21lZGlhc291cC1yZXF1ZXN0JywgcmVxdWVzdClcblx0XHRcdFx0LnRoZW4oY2FsbGJhY2spXG5cdFx0XHRcdC5jYXRjaChlcnJiYWNrKTtcblx0XHR9KTtcblxuXHRcdHRoaXMuX3Jvb20ub24oJ25vdGlmeScsIChub3RpZmljYXRpb24pID0+IHtcblx0XHRcdGxvZ2dlci5kZWJ1Zygnc2VuZGluZyBtZWRpYXNvdXAgbm90aWZpY2F0aW9uIFttZXRob2Q6JXNdOiVvJywgbm90aWZpY2F0aW9uLm1ldGhvZCwgbm90aWZpY2F0aW9uKTtcblxuXHRcdFx0dGhpcy5fcHJvdG9vLnNlbmQoJ21lZGlhc291cC1ub3RpZmljYXRpb24nLCBub3RpZmljYXRpb24pXG5cdFx0XHRcdC5jYXRjaCgoZXJyb3IpID0+IHtcblx0XHRcdFx0XHRsb2dnZXIud2FybignY291bGQgbm90IHNlbmQgbWVkaWFzb3VwIG5vdGlmaWNhdGlvbjolbycsIGVycm9yKTtcblx0XHRcdFx0fSk7XG5cdFx0fSk7XG5cblx0XHR0aGlzLl9yb29tLm9uKCduZXdwZWVyJywgKHBlZXIpID0+IHtcblx0XHRcdGxvZ2dlci5kZWJ1Zygncm9vbSBcIm5ld3BlZXJcIiBldmVudCBbbmFtZTpcIiVzXCIsIHBlZXI6JW9dJywgcGVlci5uYW1lLCBwZWVyKTtcblx0XHRcdHRoaXMuX2hhbmRsZVBlZXIocGVlcik7XG5cdFx0fSk7XG5cblx0XHR0aGlzLl9yb29tLmpvaW4odGhpcy5fcGVlck5hbWUsIHsgZGV2aWNlLCB0b2tlbiB9KVxuXHRcdFx0LnRoZW4oKCkgPT4ge1xuXHRcdFx0XHQvLyBDcmVhdGUgVHJhbnNwb3J0IGZvciBzZW5kaW5nLlxuXHRcdFx0XHR0aGlzLl9zZW5kVHJhbnNwb3J0ID0gdGhpcy5fcm9vbS5jcmVhdGVUcmFuc3BvcnQoJ3NlbmQnLCB7IG1lZGlhOiAnU0VORF9NSUNfV0VCQ0FNJyB9KTtcblxuXHRcdFx0XHR0aGlzLl9zZW5kVHJhbnNwb3J0Lm9uKCdjbG9zZScsIChvcmlnaW5hdG9yKSA9PiB7XG5cdFx0XHRcdFx0bG9nZ2VyLmRlYnVnKCdUcmFuc3BvcnQgXCJjbG9zZVwiIGV2ZW50IFtvcmlnaW5hdG9yOiVzXScsIG9yaWdpbmF0b3IpO1xuXHRcdFx0XHR9KTtcblxuXHRcdFx0XHR0aGlzLl9zZW5kVHJhbnNwb3J0Lm9uKCdjb25uZWN0aW9uc3RhdGVjaGFuZ2UnLCAoc3RhdGUpID0+IHtcblx0XHRcdFx0XHRpZiAoc3RhdGUgPT09ICdjb25uZWN0ZWQnKSB7XG5cdFx0XHRcdFx0XHR0aGlzLnNldFN0YXRlQ29ubmVjdGlvbignY29ubmVjdGVkJyk7XG5cdFx0XHRcdFx0XHRjb25zb2xlLmxvZygnc3RhdGUgY29ubmVjdGVkJylcblx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0ZWxzZSBpZiAoc3RhdGUgPT09ICdmYWlsZWQnIHx8IHN0YXRlID09PSAnZGlzY29ubmVjdGVkJykge1xuICAgICAgICAgICAgICAgICAgICBcdGxvZ2dlci53YXJuKFwic2VuZFRyYW5zcG9ydCBjb25uZWN0aW9uc3RhdGVjaGFuZ2UgRkFJTEVEIG9yIERJU0NPTk5FQ1RFRCFcIik7XG4gICAgICAgICAgICAgICAgICAgIFx0dGhpcy5yZXN0YXJ0SWNlKCk7XG4gICAgICAgICAgICAgICAgICAgIH1cblx0XHRcdFx0fSk7XG5cblx0XHRcdFx0Ly8gQ3JlYXRlIFRyYW5zcG9ydCBmb3IgcmVjZWl2aW5nLlxuXHRcdFx0XHR0aGlzLl9yZWN2VHJhbnNwb3J0ID0gdGhpcy5fcm9vbS5jcmVhdGVUcmFuc3BvcnQoJ3JlY3YnLCB7IG1lZGlhOiAnUkVDVicgfSk7XG5cblx0XHRcdFx0dGhpcy5fcmVjdlRyYW5zcG9ydC5vbignY2xvc2UnLCAob3JpZ2luYXRvcikgPT4ge1xuXHRcdFx0XHRcdGxvZ2dlci5kZWJ1ZygncmVjZWl2aW5nIFRyYW5zcG9ydCBcImNsb3NlXCIgZXZlbnQgW29yaWdpbmF0b3I6JXNdJywgb3JpZ2luYXRvcik7XG5cdFx0XHRcdH0pO1xuXG5cdFx0XHRcdHRoaXMuX3JlY3ZUcmFuc3BvcnQub24oJ2Nvbm5lY3Rpb25zdGF0ZWNoYW5nZScsIChzdGF0ZSkgPT4ge1xuICAgICAgICAgICAgICAgICAgICBpZiAoc3RhdGUgPT09ICdmYWlsZWQnIHx8IHN0YXRlID09PSAnZGlzY29ubmVjdGVkJykge1xuICAgICAgICAgICAgICAgICAgICAgICAgbG9nZ2VyLndhcm4oXCJfcmVjdlRyYW5zcG9ydCBjb25uZWN0aW9uc3RhdGVjaGFuZ2UgRkFJTEVEIG9yIERJU0NPTk5FQ1RFRCFcIik7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLnJlc3RhcnRJY2UoKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0pO1xuXHRcdFx0fSlcblx0XHRcdC50aGVuKCgpID0+IHtcblx0XHRcdFx0Ly8gRG9uJ3QgcHJvZHVjZSBpZiBleHBsaWNpdGVseSByZXF1ZXN0ZWQgdG8gbm90IHRvIGRvIGl0LlxuXHRcdFx0XHRpZiAoIXRoaXMuX3Byb2R1Y2UpXG5cdFx0XHRcdFx0cmV0dXJuO1xuXG5cdFx0XHRcdC8vIE5PVEU6IERvbid0IGRlcGVuZCBvbiB0aGlzIFByb21pc2UgdG8gY29udGludWUgKHNvIHdlIGRvbid0IGRvIHJldHVybikuXG5cdFx0XHRcdFByb21pc2UucmVzb2x2ZSgpXG5cdFx0XHRcdFx0Ly8gQWRkIG91ciBtaWMuXG5cdFx0XHRcdFx0LnRoZW4oKCkgPT4ge1xuXHRcdFx0XHRcdFx0aWYgKCF0aGlzLl9yb29tLmNhblNlbmQoJ2F1ZGlvJykpXG5cdFx0XHRcdFx0XHRcdHJldHVybjtcblxuXHRcdFx0XHRcdFx0dGhpcy5fc2V0TWljUHJvZHVjZXIodGhpcy5kZXZpY2VJZCwgdGhpcy5wcm9kdWNlclZvbHVtZSwgdGhpcy5pc1VzYilcblx0XHRcdFx0XHRcdFx0LmNhdGNoKCgpID0+IHsgfSk7XG5cdFx0XHRcdFx0fSk7XG5cdFx0XHR9KVxuXHRcdFx0LnRoZW4oKCkgPT4ge1xuXHRcdFx0XHQvLyB0aGlzLnNldFN0YXRlQ29ubmVjdGlvbignY29ubmVjdGVkJyk7XG5cdFx0XHR9KVxuXHRcdFx0LmNhdGNoKChlcnJvcikgPT4ge1xuXHRcdFx0XHRsb2dnZXIuZXJyb3IoJ19qb2luUm9vbSgpIGZhaWxlZDolbycsIGVycm9yKTtcblxuXHRcdFx0XHR0aGlzLmNsb3NlKCk7XG5cdFx0XHR9KTtcblx0fVxuXG5cdF9zZXRNaWNQcm9kdWNlcihkZXZpY2VJZCwgcHJvZHVjZXJWb2x1bWUsIGlzVXNiKSB7XG5cdFx0aWYgKCF0aGlzLl9yb29tLmNhblNlbmQoJ2F1ZGlvJykpIHtcblx0XHRcdHJldHVybiBQcm9taXNlLnJlamVjdChcblx0XHRcdFx0bmV3IEVycm9yKCdjYW5ub3Qgc2VuZCBhdWRpbycpKTtcblx0XHR9XG5cblx0XHRpZiAodGhpcy5fbWljUHJvZHVjZXIpIHtcblx0XHRcdHJldHVybiBQcm9taXNlLnJlamVjdChcblx0XHRcdFx0bmV3IEVycm9yKCdtaWMgUHJvZHVjZXIgYWxyZWFkeSBleGlzdHMnKSk7XG5cdFx0fVxuXG5cdFx0bGV0IHByb2R1Y2VyO1xuXG5cdFx0cmV0dXJuIFByb21pc2UucmVzb2x2ZSgpXG5cdFx0XHQudGhlbigoKSA9PiB7XG5cdFx0XHRcdGxvZ2dlci5kZWJ1ZygnX3NldE1pY1Byb2R1Y2VyKCkgfCBjYWxsaW5nIGdldFVzZXJNZWRpYSgpJyk7XG5cblx0XHRcdFx0Y29uc3QgY29uc3RyYWludHMgPSB7XG5cdFx0XHRcdFx0YXVkaW86IHtcblx0XHRcdFx0XHRcdGVjaG9DYW5jZWxsYXRpb246IHdpbmRvdy5pc1JhZ2VNcCA/IHRydWUgOiBpc1VzYiA/IGZhbHNlIDogbnVsbCxcblx0XHRcdFx0XHRcdG5vaXNlU3VwcHJlc3Npb246IGZhbHNlLFxuXHRcdFx0XHRcdFx0YXV0b0dhaW5Db250cm9sOiBmYWxzZSxcblx0XHRcdFx0XHRcdGRldmljZUlkOiBkZXZpY2VJZCxcblx0XHRcdFx0XHRcdHZvbHVtZTogcHJvZHVjZXJWb2x1bWVcblx0XHRcdFx0ICBcdH1cblx0XHRcdFx0fTtcblxuXHRcdFx0XHRyZXR1cm4gbmF2aWdhdG9yLm1lZGlhRGV2aWNlcy5nZXRVc2VyTWVkaWEoY29uc3RyYWludHMpO1xuXHRcdFx0fSlcblx0XHRcdC50aGVuKChzdHJlYW0pID0+IHtcblx0XHRcdFx0Y29uc3QgdHJhY2sgPSBzdHJlYW0uZ2V0QXVkaW9UcmFja3MoKVswXTtcblx0XHRcdFx0dHJhY2suZW5hYmxlZCA9IGZhbHNlO1xuXG5cdFx0XHRcdHByb2R1Y2VyID0gdGhpcy5fcm9vbS5jcmVhdGVQcm9kdWNlcih0cmFjaywgbnVsbCwgeyBzb3VyY2U6ICdtaWMnIH0pO1xuXG5cdFx0XHRcdC8vIE5vIG5lZWQgdG8ga2VlcCBvcmlnaW5hbCB0cmFjay5cblx0XHRcdFx0dHJhY2suc3RvcCgpO1xuXG5cdFx0XHRcdC8vIFNlbmQgaXQuXG5cdFx0XHRcdHJldHVybiBwcm9kdWNlci5zZW5kKHRoaXMuX3NlbmRUcmFuc3BvcnQpO1xuXHRcdFx0fSlcblx0XHRcdC50aGVuKCgpID0+IHtcblx0XHRcdFx0cHJvZHVjZXIucGF1c2UoKTtcblxuXHRcdFx0XHR0aGlzLl9taWNQcm9kdWNlciA9IHByb2R1Y2VyO1xuXG5cdFx0XHRcdERhdGFTdG9yZS5hZGRQcm9kdWNlcih7XG5cdFx0XHRcdFx0aWQ6IHByb2R1Y2VyLmlkLFxuXHRcdFx0XHRcdHNvdXJjZTogJ21pYycsXG5cdFx0XHRcdFx0bG9jYWxseVBhdXNlZDogcHJvZHVjZXIubG9jYWxseVBhdXNlZCxcblx0XHRcdFx0XHRyZW1vdGVseVBhdXNlZDogcHJvZHVjZXIucmVtb3RlbHlQYXVzZWQsXG5cdFx0XHRcdFx0dHJhY2s6IHByb2R1Y2VyLnRyYWNrLFxuXHRcdFx0XHRcdGNvZGVjOiBwcm9kdWNlci5ydHBQYXJhbWV0ZXJzLmNvZGVjc1swXS5uYW1lXG5cdFx0XHRcdH0pO1xuXG5cdFx0XHRcdHByb2R1Y2VyLm9uKCdjbG9zZScsIChvcmlnaW5hdG9yKSA9PiB7XG5cdFx0XHRcdFx0bG9nZ2VyLmRlYnVnKCdtaWMgUHJvZHVjZXIgXCJjbG9zZVwiIGV2ZW50IFtvcmlnaW5hdG9yOiVzXScsIG9yaWdpbmF0b3IpO1xuXG5cdFx0XHRcdFx0dGhpcy5fbWljUHJvZHVjZXIgPSBudWxsO1xuXHRcdFx0XHRcdERhdGFTdG9yZS5yZW1vdmVQcm9kdWNlcihwcm9kdWNlci5pZCk7XG5cdFx0XHRcdH0pO1xuXG5cdFx0XHRcdHByb2R1Y2VyLm9uKCdwYXVzZScsIChvcmlnaW5hdG9yKSA9PiB7XG5cdFx0XHRcdFx0bG9nZ2VyLmRlYnVnKCdtaWMgUHJvZHVjZXIgXCJwYXVzZVwiIGV2ZW50IFtvcmlnaW5hdG9yOiVzXScsIG9yaWdpbmF0b3IpO1xuXG5cdFx0XHRcdFx0RGF0YVN0b3JlLnNldFByb2R1Y2VyUGF1c2VkKHByb2R1Y2VyLmlkLCBvcmlnaW5hdG9yKTtcblx0XHRcdFx0fSk7XG5cblx0XHRcdFx0cHJvZHVjZXIub24oJ3Jlc3VtZScsIChvcmlnaW5hdG9yKSA9PiB7XG5cdFx0XHRcdFx0bG9nZ2VyLmRlYnVnKCdtaWMgUHJvZHVjZXIgXCJyZXN1bWVcIiBldmVudCBbb3JpZ2luYXRvcjolc10nLCBvcmlnaW5hdG9yKTtcblxuXHRcdFx0XHRcdERhdGFTdG9yZS5zZXRQcm9kdWNlclJlc3VtZWQocHJvZHVjZXIuaWQsIG9yaWdpbmF0b3IpO1xuXHRcdFx0XHR9KTtcblxuXHRcdFx0XHRwcm9kdWNlci5vbignaGFuZGxlZCcsICgpID0+IHtcblx0XHRcdFx0XHRsb2dnZXIuZGVidWcoJ21pYyBQcm9kdWNlciBcImhhbmRsZWRcIiBldmVudCcpO1xuXHRcdFx0XHR9KTtcblxuXHRcdFx0XHRwcm9kdWNlci5vbigndW5oYW5kbGVkJywgKCkgPT4ge1xuXHRcdFx0XHRcdGxvZ2dlci5kZWJ1ZygnbWljIFByb2R1Y2VyIFwidW5oYW5kbGVkXCIgZXZlbnQnKTtcblx0XHRcdFx0fSk7XG5cdFx0XHR9KVxuXHRcdFx0LnRoZW4oKCkgPT4ge1xuXHRcdFx0XHRsb2dnZXIuZGVidWcoJ19zZXRNaWNQcm9kdWNlcigpIHN1Y2NlZWRlZCcpO1xuXHRcdFx0fSlcblx0XHRcdC5jYXRjaCgoZXJyb3IpID0+IHtcblx0XHRcdFx0bG9nZ2VyLmVycm9yKCdfc2V0TWljUHJvZHVjZXIoKSBmYWlsZWQ6JW8nLCBlcnJvcik7XG5cblx0XHRcdFx0aWYgKHByb2R1Y2VyKVxuXHRcdFx0XHRcdHByb2R1Y2VyLmNsb3NlKCk7XG5cblx0XHRcdFx0LyogdGhyb3cgZXJyb3I7ICovXG5cdFx0XHR9KTtcblx0fVxuXG5cdF9oYW5kbGVQZWVyKHBlZXIsIHsgbm90aWZ5ID0gdHJ1ZSB9ID0ge30pIHtcblxuXHRcdERhdGFTdG9yZS5hZGRQZWVyKHtcblx0XHRcdG5hbWU6IHBlZXIubmFtZSxcblx0XHRcdGNvbnN1bWVyczogW11cblx0XHR9KTtcblxuXHRcdGNvbnNvbGUubG9nKCduZXdQZWVyJywgcGVlci5uYW1lKVxuXG5cdFx0Zm9yIChjb25zdCBjb25zdW1lciBvZiBwZWVyLmNvbnN1bWVycykge1xuXHRcdFx0dGhpcy5faGFuZGxlQ29uc3VtZXIoY29uc3VtZXIpO1xuXHRcdH1cblxuXHRcdHBlZXIub24oJ2Nsb3NlJywgKG9yaWdpbmF0b3IpID0+IHtcblx0XHRcdGxvZ2dlci5kZWJ1ZygncGVlciBcImNsb3NlXCIgZXZlbnQgW25hbWU6XCIlc1wiLCBvcmlnaW5hdG9yOiVzXScsIHBlZXIubmFtZSwgb3JpZ2luYXRvcik7XG5cblx0XHRcdERhdGFTdG9yZS5yZW1vdmVQZWVyKHBlZXIubmFtZSk7XG5cdFx0fSk7XG5cblx0XHRwZWVyLm9uKCduZXdjb25zdW1lcicsIChjb25zdW1lcikgPT4ge1xuXHRcdFx0bG9nZ2VyLmRlYnVnKCdwZWVyIFwibmV3Y29uc3VtZXJcIiBldmVudCBbbmFtZTpcIiVzXCIsIGlkOiVzLCBjb25zdW1lcjolb10nLCBwZWVyLm5hbWUsIGNvbnN1bWVyLmlkLCBjb25zdW1lcik7XG5cblx0XHRcdHRoaXMuX2hhbmRsZUNvbnN1bWVyKGNvbnN1bWVyKTtcblx0XHR9KTtcblx0fVxuXG5cdF9oYW5kbGVDb25zdW1lcihjb25zdW1lcikge1xuXHRcdGNvbnN0IGNvZGVjID0gY29uc3VtZXIucnRwUGFyYW1ldGVycy5jb2RlY3NbMF07XG5cblx0XHREYXRhU3RvcmUuYWRkQ29uc3VtZXIoe1xuXHRcdFx0aWQ6IGNvbnN1bWVyLmlkLFxuXHRcdFx0cGVlck5hbWU6IGNvbnN1bWVyLnBlZXIubmFtZSxcblx0XHRcdHNvdXJjZTogY29uc3VtZXIuYXBwRGF0YS5zb3VyY2UsXG5cdFx0XHRzdXBwb3J0ZWQ6IGNvbnN1bWVyLnN1cHBvcnRlZCxcblx0XHRcdGxvY2FsbHlQYXVzZWQ6IGNvbnN1bWVyLmxvY2FsbHlQYXVzZWQsXG5cdFx0XHRyZW1vdGVseVBhdXNlZDogY29uc3VtZXIucmVtb3RlbHlQYXVzZWQsXG5cdFx0XHR0cmFjazogbnVsbCxcblx0XHRcdGNvZGVjOiBjb2RlYyA/IGNvZGVjLm5hbWUgOiBudWxsXG5cdFx0fSk7XG5cblx0XHRjb25zdW1lci5vbignY2xvc2UnLCAob3JpZ2luYXRvcikgPT4ge1xuXHRcdFx0bG9nZ2VyLmRlYnVnKCdjb25zdW1lciBcImNsb3NlXCIgZXZlbnQgW2lkOiVzLCBvcmlnaW5hdG9yOiVzLCBjb25zdW1lcjolb10nLCBjb25zdW1lci5pZCwgb3JpZ2luYXRvciwgY29uc3VtZXIpO1xuXG5cdFx0XHREYXRhU3RvcmUucmVtb3ZlQ29uc3VtZXIoY29uc3VtZXIuaWQpO1xuXHRcdH0pO1xuXG5cdFx0Y29uc3VtZXIub24oJ3BhdXNlJywgKG9yaWdpbmF0b3IpID0+IHtcblx0XHRcdGxvZ2dlci5kZWJ1ZygnY29uc3VtZXIgXCJwYXVzZVwiIGV2ZW50IFtpZDolcywgb3JpZ2luYXRvcjolcywgY29uc3VtZXI6JW9dJywgY29uc3VtZXIuaWQsIG9yaWdpbmF0b3IsIGNvbnN1bWVyKTtcblxuXHRcdFx0RGF0YVN0b3JlLnNldENvbnN1bWVyUGF1c2VkKGNvbnN1bWVyLmlkLCBvcmlnaW5hdG9yKTtcblxuXHRcdFx0aWYgKHR5cGVvZiBjb25zdW1lciAhPT0gJ3VuZGVmaW5lZCcgJiYgdHlwZW9mIGNvbnN1bWVyLnBlZXIgIT09ICd1bmRlZmluZWQnKSB7XG5cdFx0XHRcdE1wRXZlbnRzLnRyaWdnZXJDbGllbnRNaWNyb3Bob25lRW5hYmxlZChjb25zdW1lci5wZWVyLm5hbWUsIGZhbHNlKTtcblx0XHRcdH1cblxuXHRcdH0pO1xuXG5cdFx0Y29uc3VtZXIub24oJ3Jlc3VtZScsIChvcmlnaW5hdG9yKSA9PiB7XG5cdFx0XHRsb2dnZXIuZGVidWcoJ2NvbnN1bWVyIFwicmVzdW1lXCIgZXZlbnQgW2lkOiVzLCBvcmlnaW5hdG9yOiVzLCBjb25zdW1lcjolb10nLCBjb25zdW1lci5pZCwgb3JpZ2luYXRvciwgY29uc3VtZXIpO1xuXG5cdFx0XHREYXRhU3RvcmUuc2V0Q29uc3VtZXJSZXN1bWVkKGNvbnN1bWVyLmlkLCBvcmlnaW5hdG9yKTtcblxuXHRcdFx0aWYgKHR5cGVvZiBjb25zdW1lciAhPT0gJ3VuZGVmaW5lZCcgJiYgdHlwZW9mIGNvbnN1bWVyLnBlZXIgIT09ICd1bmRlZmluZWQnKSB7XG5cdFx0XHRcdE1wRXZlbnRzLnRyaWdnZXJDbGllbnRNaWNyb3Bob25lRW5hYmxlZChjb25zdW1lci5wZWVyLm5hbWUsIHRydWUpO1xuXHRcdFx0fVxuXHRcdH0pO1xuXG5cdFx0Y29uc3VtZXIub24oJ2VmZmVjdGl2ZXByb2ZpbGVjaGFuZ2UnLCAocHJvZmlsZSkgPT4ge1xuXHRcdFx0bG9nZ2VyLmRlYnVnKCdjb25zdW1lciBcImVmZmVjdGl2ZXByb2ZpbGVjaGFuZ2VcIiBldmVudCBbaWQ6JXMsIGNvbnN1bWVyOiVvLCBwcm9maWxlOiVzXScsIGNvbnN1bWVyLmlkLCBjb25zdW1lciwgcHJvZmlsZSk7XG5cblx0XHRcdERhdGFTdG9yZS5zZXRDb25zdW1lckVmZmVjdGl2ZVByb2ZpbGUoY29uc3VtZXIuaWQsIHByb2ZpbGUpO1xuXHRcdH0pO1xuXG5cdFx0Ly8gUmVjZWl2ZSB0aGUgY29uc3VtZXIgKGlmIHdlIGNhbikuXG5cdFx0aWYgKGNvbnN1bWVyLnN1cHBvcnRlZCkge1xuXG5cdFx0XHRjb25zdW1lci5yZWNlaXZlKHRoaXMuX3JlY3ZUcmFuc3BvcnQpXG5cdFx0XHRcdC50aGVuKCh0cmFjaykgPT4ge1xuXHRcdFx0XHRcdERhdGFTdG9yZS5zZXRDb25zdW1lclRyYWNrKGNvbnN1bWVyLmlkLCB0cmFjayk7XG5cdFx0XHRcdH0pXG5cdFx0XHRcdC5jYXRjaCgoZXJyb3IpID0+IHtcblx0XHRcdFx0XHRsb2dnZXIuZXJyb3IoJ3VuZXhwZWN0ZWQgZXJyb3Igd2hpbGUgcmVjZWl2aW5nIGEgbmV3IENvbnN1bWVyOiVvJywgZXJyb3IpO1xuXHRcdFx0XHR9KTtcblx0XHR9XG5cdH1cblxufVxuXG5leHBvcnQgZGVmYXVsdCBOZXdDbGllbnQ7IiwiZXhwb3J0IGZ1bmN0aW9uIGdldFByb3Rvb1VybChwZWVyTmFtZSwgdG9rZW4pXG57XG5cdGNvbnN0IGhvc3RuYW1lID0gd2luZG93LmxvY2F0aW9uLmhvc3RuYW1lO1xuXHRjb25zdCB1cmwgPSBgd3NzOi8vdG9wLWd0YS5jb206MzQ0My8/cGVlck5hbWU9JHtwZWVyTmFtZX0mdG9rZW49JHt0b2tlbn1gO1xuXG5cdHJldHVybiB1cmw7XG59XG4iLCJcbmV4cG9ydCBjb25zdCBVVUlEID0gKGEpID0+IGEgPyAoYSBeIE1hdGgucmFuZG9tKCkgKiAxNiA+PiBhIC8gNCkudG9TdHJpbmcoMTYpIDogKFsxZTddICsgLTFlMyArIC00ZTMgKyAtOGUzICsgLTFlMTEpLnJlcGxhY2UoL1swMThdL2csIFVVSUQpO1xuXG5leHBvcnQgY29uc3QgbGVycCA9ICh2YWx1ZV9vbmUsIHZhbHVlX3R3bywgZGVsdGFUaW1lKSA9PiB2YWx1ZV9vbmUgKyAodmFsdWVfdHdvIC0gdmFsdWVfb25lKSAqIGRlbHRhVGltZTtcblxuZXhwb3J0IGNvbnN0IGNsYW1wID0gKG1pbiwgbWF4LCBjdXJyZW50KSA9PiBNYXRoLm1pbihNYXRoLm1heChjdXJyZW50LCBtaW4pLCBtYXgpOyIsImltcG9ydCB7IEV2ZW50RW1pdHRlciB9IGZyb20gJ2V2ZW50cyc7XG5pbXBvcnQgTG9nZ2VyIGZyb20gJy4vTG9nZ2VyJztcbmltcG9ydCB7IEludmFsaWRTdGF0ZUVycm9yIH0gZnJvbSAnLi9lcnJvcnMnO1xuXG5jb25zdCBsb2dnZXIgPSBuZXcgTG9nZ2VyKCdDb21tYW5kUXVldWUnKTtcblxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgQ29tbWFuZFF1ZXVlIGV4dGVuZHMgRXZlbnRFbWl0dGVyXG57XG5cdGNvbnN0cnVjdG9yKClcblx0e1xuXHRcdHN1cGVyKCk7XG5cdFx0dGhpcy5zZXRNYXhMaXN0ZW5lcnMoSW5maW5pdHkpO1xuXG5cdFx0Ly8gQ2xvc2VkIGZsYWcuXG5cdFx0Ly8gQHR5cGUge0Jvb2xlYW59XG5cdFx0dGhpcy5fY2xvc2VkID0gZmFsc2U7XG5cblx0XHQvLyBCdXN5IHJ1bm5pbmcgYSBjb21tYW5kLlxuXHRcdC8vIEB0eXBlIHtCb29sZWFufVxuXHRcdHRoaXMuX2J1c3kgPSBmYWxzZTtcblxuXHRcdC8vIFF1ZXVlIGZvciBwZW5kaW5nIGNvbW1hbmRzLiBFYWNoIGNvbW1hbmQgaXMgYW4gT2JqZWN0IHdpdGggbWV0aG9kLFxuXHRcdC8vIHJlc29sdmUsIHJlamVjdCwgYW5kIG90aGVyIG1lbWJlcnMgKGRlcGVuZGluZyB0aGUgY2FzZSkuXG5cdFx0Ly8gQHR5cGUge0FycmF5PE9iamVjdD59XG5cdFx0dGhpcy5fcXVldWUgPSBbXTtcblx0fVxuXG5cdGNsb3NlKClcblx0e1xuXHRcdHRoaXMuX2Nsb3NlZCA9IHRydWU7XG5cdH1cblxuXHRwdXNoKG1ldGhvZCwgZGF0YSlcblx0e1xuXHRcdGNvbnN0IGNvbW1hbmQgPSBPYmplY3QuYXNzaWduKHsgbWV0aG9kIH0sIGRhdGEpO1xuXG5cdFx0bG9nZ2VyLmRlYnVnKCdwdXNoKCkgW21ldGhvZDolc10nLCBtZXRob2QpO1xuXG5cdFx0cmV0dXJuIG5ldyBQcm9taXNlKChyZXNvbHZlLCByZWplY3QpID0+XG5cdFx0e1xuXHRcdFx0Y29uc3QgcXVldWUgPSB0aGlzLl9xdWV1ZTtcblxuXHRcdFx0Y29tbWFuZC5yZXNvbHZlID0gcmVzb2x2ZTtcblx0XHRcdGNvbW1hbmQucmVqZWN0ID0gcmVqZWN0O1xuXG5cdFx0XHQvLyBBcHBlbmQgY29tbWFuZCB0byB0aGUgcXVldWUuXG5cdFx0XHRxdWV1ZS5wdXNoKGNvbW1hbmQpO1xuXHRcdFx0dGhpcy5faGFuZGxlUGVuZGluZ0NvbW1hbmRzKCk7XG5cdFx0fSk7XG5cdH1cblxuXHRfaGFuZGxlUGVuZGluZ0NvbW1hbmRzKClcblx0e1xuXHRcdGlmICh0aGlzLl9idXN5KVxuXHRcdFx0cmV0dXJuO1xuXG5cdFx0Y29uc3QgcXVldWUgPSB0aGlzLl9xdWV1ZTtcblxuXHRcdC8vIFRha2UgdGhlIGZpcnN0IGNvbW1hbmQuXG5cdFx0Y29uc3QgY29tbWFuZCA9IHF1ZXVlWzBdO1xuXG5cdFx0aWYgKCFjb21tYW5kKVxuXHRcdFx0cmV0dXJuO1xuXG5cdFx0dGhpcy5fYnVzeSA9IHRydWU7XG5cblx0XHQvLyBFeGVjdXRlIGl0LlxuXHRcdHRoaXMuX2hhbmRsZUNvbW1hbmQoY29tbWFuZClcblx0XHRcdC50aGVuKCgpID0+XG5cdFx0XHR7XG5cdFx0XHRcdHRoaXMuX2J1c3kgPSBmYWxzZTtcblxuXHRcdFx0XHQvLyBSZW1vdmUgdGhlIGZpcnN0IGNvbW1hbmQgKHRoZSBjb21wbGV0ZWQgb25lKSBmcm9tIHRoZSBxdWV1ZS5cblx0XHRcdFx0cXVldWUuc2hpZnQoKTtcblxuXHRcdFx0XHQvLyBBbmQgY29udGludWUuXG5cdFx0XHRcdHRoaXMuX2hhbmRsZVBlbmRpbmdDb21tYW5kcygpO1xuXHRcdFx0fSk7XG5cdH1cblxuXHRfaGFuZGxlQ29tbWFuZChjb21tYW5kKVxuXHR7XG5cdFx0bG9nZ2VyLmRlYnVnKCdfaGFuZGxlQ29tbWFuZCgpIFttZXRob2Q6JXNdJywgY29tbWFuZC5tZXRob2QpO1xuXG5cdFx0aWYgKHRoaXMuX2Nsb3NlZClcblx0XHR7XG5cdFx0XHRjb21tYW5kLnJlamVjdChuZXcgSW52YWxpZFN0YXRlRXJyb3IoJ2Nsb3NlZCcpKTtcblxuXHRcdFx0cmV0dXJuIFByb21pc2UucmVzb2x2ZSgpO1xuXHRcdH1cblxuXHRcdGNvbnN0IHByb21pc2VIb2xkZXIgPSB7IHByb21pc2U6IG51bGwgfTtcblxuXHRcdHRoaXMuZW1pdCgnZXhlYycsIGNvbW1hbmQsIHByb21pc2VIb2xkZXIpO1xuXG5cdFx0cmV0dXJuIFByb21pc2UucmVzb2x2ZSgpXG5cdFx0XHQudGhlbigoKSA9PlxuXHRcdFx0e1xuXHRcdFx0XHRyZXR1cm4gcHJvbWlzZUhvbGRlci5wcm9taXNlO1xuXHRcdFx0fSlcblx0XHRcdC50aGVuKChyZXN1bHQpID0+XG5cdFx0XHR7XG5cdFx0XHRcdGxvZ2dlci5kZWJ1ZygnX2hhbmRsZUNvbW1hbmQoKSB8IGNvbW1hbmQgc3VjY2VlZGVkIFttZXRob2Q6JXNdJywgY29tbWFuZC5tZXRob2QpO1xuXG5cdFx0XHRcdGlmICh0aGlzLl9jbG9zZWQpXG5cdFx0XHRcdHtcblx0XHRcdFx0XHRjb21tYW5kLnJlamVjdChuZXcgSW52YWxpZFN0YXRlRXJyb3IoJ2Nsb3NlZCcpKTtcblxuXHRcdFx0XHRcdHJldHVybjtcblx0XHRcdFx0fVxuXG5cdFx0XHRcdC8vIFJlc29sdmUgdGhlIGNvbW1hbmQgd2l0aCB0aGUgZ2l2ZW4gcmVzdWx0IChpZiBhbnkpLlxuXHRcdFx0XHRjb21tYW5kLnJlc29sdmUocmVzdWx0KTtcblx0XHRcdH0pXG5cdFx0XHQuY2F0Y2goKGVycm9yKSA9PlxuXHRcdFx0e1xuXHRcdFx0XHRsb2dnZXIuZXJyb3IoXG5cdFx0XHRcdFx0J19oYW5kbGVDb21tYW5kKCkgfCBjb21tYW5kIGZhaWxlZCBbbWV0aG9kOiVzXTogJW8nLCBjb21tYW5kLm1ldGhvZCwgZXJyb3IpO1xuXG5cdFx0XHRcdC8vIFJlamVjdCB0aGUgY29tbWFuZCB3aXRoIHRoZSBlcnJvci5cblx0XHRcdFx0Y29tbWFuZC5yZWplY3QoZXJyb3IpO1xuXHRcdFx0fSk7XG5cdH1cbn1cbiIsImltcG9ydCBMb2dnZXIgZnJvbSAnLi9Mb2dnZXInO1xuaW1wb3J0IEVuaGFuY2VkRXZlbnRFbWl0dGVyIGZyb20gJy4vRW5oYW5jZWRFdmVudEVtaXR0ZXInO1xuaW1wb3J0IHsgSW52YWxpZFN0YXRlRXJyb3IgfSBmcm9tICcuL2Vycm9ycyc7XG5cbmNvbnN0IFBST0ZJTEVTID0gbmV3IFNldChbICdkZWZhdWx0JywgJ2xvdycsICdtZWRpdW0nLCAnaGlnaCcgXSk7XG5jb25zdCBERUZBVUxUX1NUQVRTX0lOVEVSVkFMID0gMTAwMDtcblxuY29uc3QgbG9nZ2VyID0gbmV3IExvZ2dlcignQ29uc3VtZXInKTtcblxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgQ29uc3VtZXIgZXh0ZW5kcyBFbmhhbmNlZEV2ZW50RW1pdHRlclxue1xuXHQvKipcblx0ICogQHByaXZhdGVcblx0ICpcblx0ICogQGVtaXRzIHtvcmlnaW5hdG9yOiBTdHJpbmcsIFthcHBEYXRhXTogQW55fSBwYXVzZVxuXHQgKiBAZW1pdHMge29yaWdpbmF0b3I6IFN0cmluZywgW2FwcERhdGFdOiBBbnl9IHJlc3VtZVxuXHQgKiBAZW1pdHMge3Byb2ZpbGU6IFN0cmluZ30gZWZmZWN0aXZlcHJvZmlsZWNoYW5nZVxuXHQgKiBAZW1pdHMge3N0YXRzOiBPYmplY3R9IHN0YXRzXG5cdCAqIEBlbWl0cyBoYW5kbGVkXG5cdCAqIEBlbWl0cyB1bmhhbmRsZWRcblx0ICogQGVtaXRzIHtvcmlnaW5hdG9yOiBTdHJpbmd9IGNsb3NlXG5cdCAqXG5cdCAqIEBlbWl0cyBAY2xvc2Vcblx0ICovXG5cdGNvbnN0cnVjdG9yKGlkLCBraW5kLCBydHBQYXJhbWV0ZXJzLCBwZWVyLCBhcHBEYXRhKVxuXHR7XG5cdFx0c3VwZXIobG9nZ2VyKTtcblxuXHRcdC8vIElkLlxuXHRcdC8vIEB0eXBlIHtOdW1iZXJ9XG5cdFx0dGhpcy5faWQgPSBpZDtcblxuXHRcdC8vIENsb3NlZCBmbGFnLlxuXHRcdC8vIEB0eXBlIHtCb29sZWFufVxuXHRcdHRoaXMuX2Nsb3NlZCA9IGZhbHNlO1xuXG5cdFx0Ly8gTWVkaWEga2luZC5cblx0XHQvLyBAdHlwZSB7U3RyaW5nfVxuXHRcdHRoaXMuX2tpbmQgPSBraW5kO1xuXG5cdFx0Ly8gUlRQIHBhcmFtZXRlcnMuXG5cdFx0Ly8gQHR5cGUge1JUQ1J0cFBhcmFtZXRlcnN9XG5cdFx0dGhpcy5fcnRwUGFyYW1ldGVycyA9IHJ0cFBhcmFtZXRlcnM7XG5cblx0XHQvLyBBc3NvY2lhdGVkIFBlZXIuXG5cdFx0Ly8gQHR5cGUge1BlZXJ9XG5cdFx0dGhpcy5fcGVlciA9IHBlZXI7XG5cblx0XHQvLyBBcHAgY3VzdG9tIGRhdGEuXG5cdFx0Ly8gQHR5cGUge0FueX1cblx0XHR0aGlzLl9hcHBEYXRhID0gYXBwRGF0YTtcblxuXHRcdC8vIFdoZXRoZXIgd2UgY2FuIHJlY2VpdmUgdGhpcyBDb25zdW1lciAoYmFzZWQgb24gb3VyIFJUUCBjYXBhYmlsaXRpZXMpLlxuXHRcdC8vIEB0eXBlIHtCb29sZWFufVxuXHRcdHRoaXMuX3N1cHBvcnRlZCA9IGZhbHNlO1xuXG5cdFx0Ly8gQXNzb2NpYXRlZCBUcmFuc3BvcnQuXG5cdFx0Ly8gQHR5cGUge1RyYW5zcG9ydH1cblx0XHR0aGlzLl90cmFuc3BvcnQgPSBudWxsO1xuXG5cdFx0Ly8gUmVtb3RlIHRyYWNrLlxuXHRcdC8vIEB0eXBlIHtNZWRpYVN0cmVhbVRyYWNrfVxuXHRcdHRoaXMuX3RyYWNrID0gbnVsbDtcblxuXHRcdC8vIExvY2FsbHkgcGF1c2VkIGZsYWcuXG5cdFx0Ly8gQHR5cGUge0Jvb2xlYW59XG5cdFx0dGhpcy5fbG9jYWxseVBhdXNlZCA9IGZhbHNlO1xuXG5cdFx0Ly8gUmVtb3RlbHkgcGF1c2VkIGZsYWcuXG5cdFx0Ly8gQHR5cGUge0Jvb2xlYW59XG5cdFx0dGhpcy5fcmVtb3RlbHlQYXVzZWQgPSBmYWxzZTtcblxuXHRcdC8vIFBlcmlvZGljIHN0YXRzIGZsYWcuXG5cdFx0Ly8gQHR5cGUge0Jvb2xlYW59XG5cdFx0dGhpcy5fc3RhdHNFbmFibGVkID0gZmFsc2U7XG5cblx0XHQvLyBQZXJpb2RpYyBzdGF0cyBnYXRoZXJpbmcgaW50ZXJ2YWwgKG1pbGxpc2Vjb25kcykuXG5cdFx0Ly8gQHR5cGUge051bWJlcn1cblx0XHR0aGlzLl9zdGF0c0ludGVydmFsID0gREVGQVVMVF9TVEFUU19JTlRFUlZBTDtcblxuXHRcdC8vIFByZWZlcnJlZCBwcm9maWxlLlxuXHRcdC8vIEB0eXBlIHtTdHJpbmd9XG5cdFx0dGhpcy5fcHJlZmVycmVkUHJvZmlsZSA9ICdkZWZhdWx0JztcblxuXHRcdC8vIEVmZmVjdGl2ZSBwcm9maWxlLlxuXHRcdC8vIEB0eXBlIHtTdHJpbmd9XG5cdFx0dGhpcy5fZWZmZWN0aXZlUHJvZmlsZSA9IG51bGw7XG5cdH1cblxuXHQvKipcblx0ICogQ29uc3VtZXIgaWQuXG5cdCAqXG5cdCAqIEByZXR1cm4ge051bWJlcn1cblx0ICovXG5cdGdldCBpZCgpXG5cdHtcblx0XHRyZXR1cm4gdGhpcy5faWQ7XG5cdH1cblxuXHQvKipcblx0ICogV2hldGhlciB0aGUgQ29uc3VtZXIgaXMgY2xvc2VkLlxuXHQgKlxuXHQgKiBAcmV0dXJuIHtCb29sZWFufVxuXHQgKi9cblx0Z2V0IGNsb3NlZCgpXG5cdHtcblx0XHRyZXR1cm4gdGhpcy5fY2xvc2VkO1xuXHR9XG5cblx0LyoqXG5cdCAqIE1lZGlhIGtpbmQuXG5cdCAqXG5cdCAqIEByZXR1cm4ge1N0cmluZ31cblx0ICovXG5cdGdldCBraW5kKClcblx0e1xuXHRcdHJldHVybiB0aGlzLl9raW5kO1xuXHR9XG5cblx0LyoqXG5cdCAqIFJUUCBwYXJhbWV0ZXJzLlxuXHQgKlxuXHQgKiBAcmV0dXJuIHtSVENSdHBQYXJhbWV0ZXJzfVxuXHQgKi9cblx0Z2V0IHJ0cFBhcmFtZXRlcnMoKVxuXHR7XG5cdFx0cmV0dXJuIHRoaXMuX3J0cFBhcmFtZXRlcnM7XG5cdH1cblxuXHQvKipcblx0ICogQXNzb2NpYXRlZCBQZWVyLlxuXHQgKlxuXHQgKiBAcmV0dXJuIHtQZWVyfVxuXHQgKi9cblx0Z2V0IHBlZXIoKVxuXHR7XG5cdFx0cmV0dXJuIHRoaXMuX3BlZXI7XG5cdH1cblxuXHQvKipcblx0ICogQXBwIGN1c3RvbSBkYXRhLlxuXHQgKlxuXHQgKiBAcmV0dXJuIHtBbnl9XG5cdCAqL1xuXHRnZXQgYXBwRGF0YSgpXG5cdHtcblx0XHRyZXR1cm4gdGhpcy5fYXBwRGF0YTtcblx0fVxuXG5cdC8qKlxuXHQgKiBXaGV0aGVyIHdlIGNhbiByZWNlaXZlIHRoaXMgQ29uc3VtZXIgKGJhc2VkIG9uIG91ciBSVFAgY2FwYWJpbGl0aWVzKS5cblx0ICpcblx0ICogQHJldHVybiB7Qm9vbGVhbn1cblx0ICovXG5cdGdldCBzdXBwb3J0ZWQoKVxuXHR7XG5cdFx0cmV0dXJuIHRoaXMuX3N1cHBvcnRlZDtcblx0fVxuXG5cdC8qKlxuXHQgKiBBc3NvY2lhdGVkIFRyYW5zcG9ydC5cblx0ICpcblx0ICogQHJldHVybiB7VHJhbnNwb3J0fVxuXHQgKi9cblx0Z2V0IHRyYW5zcG9ydCgpXG5cdHtcblx0XHRyZXR1cm4gdGhpcy5fdHJhbnNwb3J0O1xuXHR9XG5cblx0LyoqXG5cdCAqIFRoZSBhc3NvY2lhdGVkIHRyYWNrIChpZiBhbnkgeWV0KS5cblx0ICpcblx0ICogQHJldHVybiB7TWVkaWFTdHJlYW1UcmFja3xOdWxsfVxuXHQgKi9cblx0Z2V0IHRyYWNrKClcblx0e1xuXHRcdHJldHVybiB0aGlzLl90cmFjaztcblx0fVxuXG5cdC8qKlxuXHQgKiBXaGV0aGVyIHRoZSBDb25zdW1lciBpcyBsb2NhbGx5IHBhdXNlZC5cblx0ICpcblx0ICogQHJldHVybiB7Qm9vbGVhbn1cblx0ICovXG5cdGdldCBsb2NhbGx5UGF1c2VkKClcblx0e1xuXHRcdHJldHVybiB0aGlzLl9sb2NhbGx5UGF1c2VkO1xuXHR9XG5cblx0LyoqXG5cdCAqIFdoZXRoZXIgdGhlIENvbnN1bWVyIGlzIHJlbW90ZWx5IHBhdXNlZC5cblx0ICpcblx0ICogQHJldHVybiB7Qm9vbGVhbn1cblx0ICovXG5cdGdldCByZW1vdGVseVBhdXNlZCgpXG5cdHtcblx0XHRyZXR1cm4gdGhpcy5fcmVtb3RlbHlQYXVzZWQ7XG5cdH1cblxuXHQvKipcblx0ICogV2hldGhlciB0aGUgQ29uc3VtZXIgaXMgcGF1c2VkLlxuXHQgKlxuXHQgKiBAcmV0dXJuIHtCb29sZWFufVxuXHQgKi9cblx0Z2V0IHBhdXNlZCgpXG5cdHtcblx0XHRyZXR1cm4gdGhpcy5fbG9jYWxseVBhdXNlZCB8fCB0aGlzLl9yZW1vdGVseVBhdXNlZDtcblx0fVxuXG5cdC8qKlxuXHQgKiBUaGUgcHJlZmVycmVkIHByb2ZpbGUuXG5cdCAqXG5cdCAqIEB0eXBlIHtTdHJpbmd9XG5cdCAqL1xuXHRnZXQgcHJlZmVycmVkUHJvZmlsZSgpXG5cdHtcblx0XHRyZXR1cm4gdGhpcy5fcHJlZmVycmVkUHJvZmlsZTtcblx0fVxuXG5cdC8qKlxuXHQgKiBUaGUgZWZmZWN0aXZlIHByb2ZpbGUuXG5cdCAqXG5cdCAqIEB0eXBlIHtTdHJpbmd9XG5cdCAqL1xuXHRnZXQgZWZmZWN0aXZlUHJvZmlsZSgpXG5cdHtcblx0XHRyZXR1cm4gdGhpcy5fZWZmZWN0aXZlUHJvZmlsZTtcblx0fVxuXG5cdC8qKlxuXHQgKiBDbG9zZXMgdGhlIENvbnN1bWVyLlxuXHQgKiBUaGlzIGlzIGNhbGxlZCB3aGVuIHRoZSBsb2NhbCBSb29tIGlzIGNsb3NlZC5cblx0ICpcblx0ICogQHByaXZhdGVcblx0ICovXG5cdGNsb3NlKClcblx0e1xuXHRcdGxvZ2dlci5kZWJ1ZygnY2xvc2UoKScpO1xuXG5cdFx0aWYgKHRoaXMuX2Nsb3NlZClcblx0XHRcdHJldHVybjtcblxuXHRcdHRoaXMuX2Nsb3NlZCA9IHRydWU7XG5cblx0XHRpZiAodGhpcy5fc3RhdHNFbmFibGVkKVxuXHRcdHtcblx0XHRcdHRoaXMuX3N0YXRzRW5hYmxlZCA9IGZhbHNlO1xuXG5cdFx0XHRpZiAodGhpcy50cmFuc3BvcnQpXG5cdFx0XHRcdHRoaXMudHJhbnNwb3J0LmRpc2FibGVDb25zdW1lclN0YXRzKHRoaXMpO1xuXHRcdH1cblxuXHRcdHRoaXMuZW1pdCgnQGNsb3NlJyk7XG5cdFx0dGhpcy5zYWZlRW1pdCgnY2xvc2UnLCAnbG9jYWwnKTtcblxuXHRcdHRoaXMuX2Rlc3Ryb3koKTtcblx0fVxuXG5cdC8qKlxuXHQgKiBNeSByZW1vdGUgQ29uc3VtZXIgd2FzIGNsb3NlZC5cblx0ICogSW52b2tlZCB2aWEgcmVtb3RlIG5vdGlmaWNhdGlvbi5cblx0ICpcblx0ICogQHByaXZhdGVcblx0ICovXG5cdHJlbW90ZUNsb3NlKClcblx0e1xuXHRcdGxvZ2dlci5kZWJ1ZygncmVtb3RlQ2xvc2UoKScpO1xuXG5cdFx0aWYgKHRoaXMuX2Nsb3NlZClcblx0XHRcdHJldHVybjtcblxuXHRcdHRoaXMuX2Nsb3NlZCA9IHRydWU7XG5cblx0XHRpZiAodGhpcy5fdHJhbnNwb3J0KVxuXHRcdFx0dGhpcy5fdHJhbnNwb3J0LnJlbW92ZUNvbnN1bWVyKHRoaXMpO1xuXG5cdFx0dGhpcy5fZGVzdHJveSgpO1xuXG5cdFx0dGhpcy5lbWl0KCdAY2xvc2UnKTtcblx0XHR0aGlzLnNhZmVFbWl0KCdjbG9zZScsICdyZW1vdGUnKTtcblx0fVxuXG5cdF9kZXN0cm95KClcblx0e1xuXHRcdHRoaXMuX3RyYW5zcG9ydCA9IG51bGw7XG5cblx0XHR0cnkgeyB0aGlzLl90cmFjay5zdG9wKCk7IH1cblx0XHRjYXRjaCAoZXJyb3IpIHt9XG5cblx0XHR0aGlzLl90cmFjayA9IG51bGw7XG5cdH1cblxuXHQvKipcblx0ICogUmVjZWl2ZXMgUlRQLlxuXHQgKlxuXHQgKiBAcGFyYW0ge3RyYW5zcG9ydH0gVHJhbnNwb3J0IGluc3RhbmNlLlxuXHQgKlxuXHQgKiBAcmV0dXJuIHtQcm9taXNlfSBSZXNvbHZlcyB3aXRoIGEgcmVtb3RlIE1lZGlhU3RyZWFtVHJhY2suXG5cdCAqL1xuXHRyZWNlaXZlKHRyYW5zcG9ydClcblx0e1xuXHRcdGxvZ2dlci5kZWJ1ZygncmVjZWl2ZSgpIFt0cmFuc3BvcnQ6JW9dJywgdHJhbnNwb3J0KTtcblxuXHRcdGlmICh0aGlzLl9jbG9zZWQpXG5cdFx0XHRyZXR1cm4gUHJvbWlzZS5yZWplY3QobmV3IEludmFsaWRTdGF0ZUVycm9yKCdDb25zdW1lciBjbG9zZWQnKSk7XG5cdFx0ZWxzZSBpZiAoIXRoaXMuX3N1cHBvcnRlZClcblx0XHRcdHJldHVybiBQcm9taXNlLnJlamVjdChuZXcgRXJyb3IoJ3Vuc3VwcG9ydGVkIGNvZGVjcycpKTtcblx0XHRlbHNlIGlmICh0aGlzLl90cmFuc3BvcnQpXG5cdFx0XHRyZXR1cm4gUHJvbWlzZS5yZWplY3QobmV3IEVycm9yKCdhbHJlYWR5IGhhbmRsZWQgYnkgYSBUcmFuc3BvcnQnKSk7XG5cdFx0ZWxzZSBpZiAodHlwZW9mIHRyYW5zcG9ydCAhPT0gJ29iamVjdCcpXG5cdFx0XHRyZXR1cm4gUHJvbWlzZS5yZWplY3QobmV3IFR5cGVFcnJvcignaW52YWxpZCBUcmFuc3BvcnQnKSk7XG5cblx0XHR0aGlzLl90cmFuc3BvcnQgPSB0cmFuc3BvcnQ7XG5cblx0XHRyZXR1cm4gdHJhbnNwb3J0LmFkZENvbnN1bWVyKHRoaXMpXG5cdFx0XHQudGhlbigodHJhY2spID0+XG5cdFx0XHR7XG5cdFx0XHRcdHRoaXMuX3RyYWNrID0gdHJhY2s7XG5cblx0XHRcdFx0Ly8gSWYgd2Ugd2VyZSBwYXVzZWQsIGRpc2FibGUgdGhlIHRyYWNrLlxuXHRcdFx0XHRpZiAodGhpcy5wYXVzZWQpXG5cdFx0XHRcdFx0dHJhY2suZW5hYmxlZCA9IGZhbHNlO1xuXG5cdFx0XHRcdHRyYW5zcG9ydC5vbmNlKCdAY2xvc2UnLCAoKSA9PlxuXHRcdFx0XHR7XG5cdFx0XHRcdFx0aWYgKHRoaXMuX2Nsb3NlZCB8fCB0aGlzLl90cmFuc3BvcnQgIT09IHRyYW5zcG9ydClcblx0XHRcdFx0XHRcdHJldHVybjtcblxuXHRcdFx0XHRcdHRoaXMuX3RyYW5zcG9ydCA9IG51bGw7XG5cblx0XHRcdFx0XHR0cnkgeyB0aGlzLl90cmFjay5zdG9wKCk7IH1cblx0XHRcdFx0XHRjYXRjaCAoZXJyb3IpIHt9XG5cblx0XHRcdFx0XHR0aGlzLl90cmFjayA9IG51bGw7XG5cblx0XHRcdFx0XHR0aGlzLnNhZmVFbWl0KCd1bmhhbmRsZWQnKTtcblx0XHRcdFx0fSk7XG5cblx0XHRcdFx0dGhpcy5zYWZlRW1pdCgnaGFuZGxlZCcpO1xuXG5cdFx0XHRcdGlmICh0aGlzLl9zdGF0c0VuYWJsZWQpXG5cdFx0XHRcdFx0dHJhbnNwb3J0LmVuYWJsZUNvbnN1bWVyU3RhdHModGhpcywgdGhpcy5fc3RhdHNJbnRlcnZhbCk7XG5cblx0XHRcdFx0cmV0dXJuIHRyYWNrO1xuXHRcdFx0fSlcblx0XHRcdC5jYXRjaCgoZXJyb3IpID0+XG5cdFx0XHR7XG5cdFx0XHRcdHRoaXMuX3RyYW5zcG9ydCA9IG51bGw7XG5cblx0XHRcdFx0dGhyb3cgZXJyb3I7XG5cdFx0XHR9KTtcblx0fVxuXG5cdC8qKlxuXHQgKiBQYXVzZXMgcmVjZWl2aW5nIG1lZGlhLlxuXHQgKlxuXHQgKiBAcGFyYW0ge0FueX0gW2FwcERhdGFdIC0gQXBwIGN1c3RvbSBkYXRhLlxuXHQgKlxuXHQgKiBAcmV0dXJuIHtCb29sZWFufSB0cnVlIGlmIHBhdXNlZC5cblx0ICovXG5cdHBhdXNlKGFwcERhdGEpXG5cdHtcblx0XHRsb2dnZXIuZGVidWcoJ3BhdXNlKCknKTtcblxuXHRcdGlmICh0aGlzLl9jbG9zZWQpXG5cdFx0e1xuXHRcdFx0bG9nZ2VyLmVycm9yKCdwYXVzZSgpIHwgQ29uc3VtZXIgY2xvc2VkJyk7XG5cblx0XHRcdHJldHVybiBmYWxzZTtcblx0XHR9XG5cdFx0ZWxzZSBpZiAodGhpcy5fbG9jYWxseVBhdXNlZClcblx0XHR7XG5cdFx0XHRyZXR1cm4gdHJ1ZTtcblx0XHR9XG5cblx0XHR0aGlzLl9sb2NhbGx5UGF1c2VkID0gdHJ1ZTtcblxuXHRcdGlmICh0aGlzLl90cmFjaylcblx0XHRcdHRoaXMuX3RyYWNrLmVuYWJsZWQgPSBmYWxzZTtcblxuXHRcdGlmICh0aGlzLl90cmFuc3BvcnQpXG5cdFx0XHR0aGlzLl90cmFuc3BvcnQucGF1c2VDb25zdW1lcih0aGlzLCBhcHBEYXRhKTtcblxuXHRcdHRoaXMuc2FmZUVtaXQoJ3BhdXNlJywgJ2xvY2FsJywgYXBwRGF0YSk7XG5cblx0XHQvLyBSZXR1cm4gdHJ1ZSBpZiByZWFsbHkgcGF1c2VkLlxuXHRcdHJldHVybiB0aGlzLnBhdXNlZDtcblx0fVxuXG5cdC8qKlxuXHQgKiBNeSByZW1vdGUgQ29uc3VtZXIgd2FzIHBhdXNlZC5cblx0ICogSW52b2tlZCB2aWEgcmVtb3RlIG5vdGlmaWNhdGlvbi5cblx0ICpcblx0ICogQHByaXZhdGVcblx0ICpcblx0ICogQHBhcmFtIHtBbnl9IFthcHBEYXRhXSAtIEFwcCBjdXN0b20gZGF0YS5cblx0ICovXG5cdHJlbW90ZVBhdXNlKGFwcERhdGEpXG5cdHtcblx0XHRsb2dnZXIuZGVidWcoJ3JlbW90ZVBhdXNlKCknKTtcblxuXHRcdGlmICh0aGlzLl9jbG9zZWQgfHwgdGhpcy5fcmVtb3RlbHlQYXVzZWQpXG5cdFx0XHRyZXR1cm47XG5cblx0XHR0aGlzLl9yZW1vdGVseVBhdXNlZCA9IHRydWU7XG5cblx0XHRpZiAodGhpcy5fdHJhY2spXG5cdFx0XHR0aGlzLl90cmFjay5lbmFibGVkID0gZmFsc2U7XG5cblx0XHR0aGlzLnNhZmVFbWl0KCdwYXVzZScsICdyZW1vdGUnLCBhcHBEYXRhKTtcblx0fVxuXG5cdC8qKlxuXHQgKiBSZXN1bWVzIHJlY2VpdmluZyBtZWRpYS5cblx0ICpcblx0ICogQHBhcmFtIHtBbnl9IFthcHBEYXRhXSAtIEFwcCBjdXN0b20gZGF0YS5cblx0ICpcblx0ICogQHJldHVybiB7Qm9vbGVhbn0gdHJ1ZSBpZiBub3QgcGF1c2VkLlxuXHQgKi9cblx0cmVzdW1lKGFwcERhdGEpXG5cdHtcblx0XHRsb2dnZXIuZGVidWcoJ3Jlc3VtZSgpJyk7XG5cblx0XHRpZiAodGhpcy5fY2xvc2VkKVxuXHRcdHtcblx0XHRcdGxvZ2dlci5lcnJvcigncmVzdW1lKCkgfCBDb25zdW1lciBjbG9zZWQnKTtcblxuXHRcdFx0cmV0dXJuIGZhbHNlO1xuXHRcdH1cblx0XHRlbHNlIGlmICghdGhpcy5fbG9jYWxseVBhdXNlZClcblx0XHR7XG5cdFx0XHRyZXR1cm4gdHJ1ZTtcblx0XHR9XG5cblx0XHR0aGlzLl9sb2NhbGx5UGF1c2VkID0gZmFsc2U7XG5cblx0XHRpZiAodGhpcy5fdHJhY2sgJiYgIXRoaXMuX3JlbW90ZWx5UGF1c2VkKVxuXHRcdFx0dGhpcy5fdHJhY2suZW5hYmxlZCA9IHRydWU7XG5cblx0XHRpZiAodGhpcy5fdHJhbnNwb3J0KVxuXHRcdFx0dGhpcy5fdHJhbnNwb3J0LnJlc3VtZUNvbnN1bWVyKHRoaXMsIGFwcERhdGEpO1xuXG5cdFx0dGhpcy5zYWZlRW1pdCgncmVzdW1lJywgJ2xvY2FsJywgYXBwRGF0YSk7XG5cblx0XHQvLyBSZXR1cm4gdHJ1ZSBpZiBub3QgcGF1c2VkLlxuXHRcdHJldHVybiAhdGhpcy5wYXVzZWQ7XG5cdH1cblxuXHQvKipcblx0ICogTXkgcmVtb3RlIENvbnN1bWVyIHdhcyByZXN1bWVkLlxuXHQgKiBJbnZva2VkIHZpYSByZW1vdGUgbm90aWZpY2F0aW9uLlxuXHQgKlxuXHQgKiBAcHJpdmF0ZVxuXHQgKlxuXHQgKiBAcGFyYW0ge0FueX0gW2FwcERhdGFdIC0gQXBwIGN1c3RvbSBkYXRhLlxuXHQgKi9cblx0cmVtb3RlUmVzdW1lKGFwcERhdGEpXG5cdHtcblx0XHRsb2dnZXIuZGVidWcoJ3JlbW90ZVJlc3VtZSgpJyk7XG5cblx0XHRpZiAodGhpcy5fY2xvc2VkIHx8ICF0aGlzLl9yZW1vdGVseVBhdXNlZClcblx0XHRcdHJldHVybjtcblxuXHRcdHRoaXMuX3JlbW90ZWx5UGF1c2VkID0gZmFsc2U7XG5cblx0XHRpZiAodGhpcy5fdHJhY2sgJiYgIXRoaXMuX2xvY2FsbHlQYXVzZWQpXG5cdFx0XHR0aGlzLl90cmFjay5lbmFibGVkID0gdHJ1ZTtcblxuXHRcdHRoaXMuc2FmZUVtaXQoJ3Jlc3VtZScsICdyZW1vdGUnLCBhcHBEYXRhKTtcblx0fVxuXG5cdC8qKlxuXHQgKiBTZXQgcHJlZmVycmVkIHJlY2VpdmluZyBwcm9maWxlLlxuXHQgKlxuXHQgKiBAcGFyYW0ge1N0cmluZ30gcHJvZmlsZVxuXHQgKi9cblx0c2V0UHJlZmVycmVkUHJvZmlsZShwcm9maWxlKVxuXHR7XG5cdFx0bG9nZ2VyLmRlYnVnKCdzZXRQcmVmZXJyZWRQcm9maWxlKCkgW3Byb2ZpbGU6JXNdJywgcHJvZmlsZSk7XG5cblx0XHRpZiAodGhpcy5fY2xvc2VkKVxuXHRcdHtcblx0XHRcdGxvZ2dlci5lcnJvcignc2V0UHJlZmVycmVkUHJvZmlsZSgpIHwgQ29uc3VtZXIgY2xvc2VkJyk7XG5cblx0XHRcdHJldHVybjtcblx0XHR9XG5cdFx0ZWxzZSBpZiAocHJvZmlsZSA9PT0gdGhpcy5fcHJlZmVycmVkUHJvZmlsZSlcblx0XHR7XG5cdFx0XHRyZXR1cm47XG5cdFx0fVxuXHRcdGVsc2UgaWYgKCFQUk9GSUxFUy5oYXMocHJvZmlsZSkpXG5cdFx0e1xuXHRcdFx0bG9nZ2VyLmVycm9yKCdzZXRQcmVmZXJyZWRQcm9maWxlKCkgfCBpbnZhbGlkIHByb2ZpbGUgXCIlc1wiJywgcHJvZmlsZSk7XG5cblx0XHRcdHJldHVybjtcblx0XHR9XG5cblx0XHR0aGlzLl9wcmVmZXJyZWRQcm9maWxlID0gcHJvZmlsZTtcblxuXHRcdGlmICh0aGlzLl90cmFuc3BvcnQpXG5cdFx0XHR0aGlzLl90cmFuc3BvcnQuc2V0Q29uc3VtZXJQcmVmZXJyZWRQcm9maWxlKHRoaXMsIHRoaXMuX3ByZWZlcnJlZFByb2ZpbGUpO1xuXHR9XG5cblx0LyoqXG5cdCAqIFByZWZlcnJlZCByZWNlaXZpbmcgcHJvZmlsZSB3YXMgc2V0IG9uIG15IHJlbW90ZSBDb25zdW1lci5cblx0ICpcblx0ICogQHBhcmFtIHtTdHJpbmd9IHByb2ZpbGVcblx0ICovXG5cdHJlbW90ZVNldFByZWZlcnJlZFByb2ZpbGUocHJvZmlsZSlcblx0e1xuXHRcdGxvZ2dlci5kZWJ1ZygncmVtb3RlU2V0UHJlZmVycmVkUHJvZmlsZSgpIFtwcm9maWxlOiVzXScsIHByb2ZpbGUpO1xuXG5cdFx0aWYgKHRoaXMuX2Nsb3NlZCB8fCBwcm9maWxlID09PSB0aGlzLl9wcmVmZXJyZWRQcm9maWxlKVxuXHRcdFx0cmV0dXJuO1xuXG5cdFx0dGhpcy5fcHJlZmVycmVkUHJvZmlsZSA9IHByb2ZpbGU7XG5cdH1cblxuXHQvKipcblx0ICogRWZmZWN0aXZlIHJlY2VpdmluZyBwcm9maWxlIGNoYW5nZWQgb24gbXkgcmVtb3RlIENvbnN1bWVyLlxuXHQgKlxuXHQgKiBAcGFyYW0ge1N0cmluZ30gcHJvZmlsZVxuXHQgKi9cblx0cmVtb3RlRWZmZWN0aXZlUHJvZmlsZUNoYW5nZWQocHJvZmlsZSlcblx0e1xuXHRcdGxvZ2dlci5kZWJ1ZygncmVtb3RlRWZmZWN0aXZlUHJvZmlsZUNoYW5nZWQoKSBbcHJvZmlsZTolc10nLCBwcm9maWxlKTtcblxuXHRcdGlmICh0aGlzLl9jbG9zZWQgfHwgcHJvZmlsZSA9PT0gdGhpcy5fZWZmZWN0aXZlUHJvZmlsZSlcblx0XHRcdHJldHVybjtcblxuXHRcdHRoaXMuX2VmZmVjdGl2ZVByb2ZpbGUgPSBwcm9maWxlO1xuXG5cdFx0dGhpcy5zYWZlRW1pdCgnZWZmZWN0aXZlcHJvZmlsZWNoYW5nZScsIHRoaXMuX2VmZmVjdGl2ZVByb2ZpbGUpO1xuXHR9XG5cblx0LyoqXG5cdCAqIEVuYWJsZXMgcGVyaW9kaWMgc3RhdHMgcmV0cmlldmFsLlxuXHQgKi9cblx0ZW5hYmxlU3RhdHMoaW50ZXJ2YWwgPSBERUZBVUxUX1NUQVRTX0lOVEVSVkFMKVxuXHR7XG5cdFx0bG9nZ2VyLmRlYnVnKCdlbmFibGVTdGF0cygpIFtpbnRlcnZhbDolc10nLCBpbnRlcnZhbCk7XG5cblx0XHRpZiAodGhpcy5fY2xvc2VkKVxuXHRcdHtcblx0XHRcdGxvZ2dlci5lcnJvcignZW5hYmxlU3RhdHMoKSB8IENvbnN1bWVyIGNsb3NlZCcpO1xuXG5cdFx0XHRyZXR1cm47XG5cdFx0fVxuXG5cdFx0aWYgKHRoaXMuX3N0YXRzRW5hYmxlZClcblx0XHRcdHJldHVybjtcblxuXHRcdGlmICh0eXBlb2YgaW50ZXJ2YWwgIT09ICdudW1iZXInIHx8IGludGVydmFsIDwgMTAwMClcblx0XHRcdHRoaXMuX3N0YXRzSW50ZXJ2YWwgPSBERUZBVUxUX1NUQVRTX0lOVEVSVkFMO1xuXHRcdGVsc2Vcblx0XHRcdHRoaXMuX3N0YXRzSW50ZXJ2YWwgPSBpbnRlcnZhbDtcblxuXHRcdHRoaXMuX3N0YXRzRW5hYmxlZCA9IHRydWU7XG5cblx0XHRpZiAodGhpcy5fdHJhbnNwb3J0KVxuXHRcdFx0dGhpcy5fdHJhbnNwb3J0LmVuYWJsZUNvbnN1bWVyU3RhdHModGhpcywgdGhpcy5fc3RhdHNJbnRlcnZhbCk7XG5cdH1cblxuXHQvKipcblx0ICogRGlzYWJsZXMgcGVyaW9kaWMgc3RhdHMgcmV0cmlldmFsLlxuXHQgKi9cblx0ZGlzYWJsZVN0YXRzKClcblx0e1xuXHRcdGxvZ2dlci5kZWJ1ZygnZGlzYWJsZVN0YXRzKCknKTtcblxuXHRcdGlmICh0aGlzLl9jbG9zZWQpXG5cdFx0e1xuXHRcdFx0bG9nZ2VyLmVycm9yKCdkaXNhYmxlU3RhdHMoKSB8IENvbnN1bWVyIGNsb3NlZCcpO1xuXG5cdFx0XHRyZXR1cm47XG5cdFx0fVxuXG5cdFx0aWYgKCF0aGlzLl9zdGF0c0VuYWJsZWQpXG5cdFx0XHRyZXR1cm47XG5cblx0XHR0aGlzLl9zdGF0c0VuYWJsZWQgPSBmYWxzZTtcblxuXHRcdGlmICh0aGlzLl90cmFuc3BvcnQpXG5cdFx0XHR0aGlzLl90cmFuc3BvcnQuZGlzYWJsZUNvbnN1bWVyU3RhdHModGhpcyk7XG5cdH1cblxuXHQvKipcblx0ICogTWFyayB0aGlzIENvbnN1bWVyIGFzIHN1aXRhYmxlIGZvciByZWNlcHRpb24gb3Igbm90LlxuXHQgKlxuXHQgKiBAcHJpdmF0ZVxuXHQgKlxuXHQgKiBAcGFyYW0ge0Jvb2xlYW59IGZsYWdcblx0ICovXG5cdHNldFN1cHBvcnRlZChmbGFnKVxuXHR7XG5cdFx0dGhpcy5fc3VwcG9ydGVkID0gZmxhZztcblx0fVxuXG5cdC8qKlxuXHQgKiBSZWNlaXZlIHJlbW90ZSBzdGF0cy5cblx0ICpcblx0ICogQHByaXZhdGVcblx0ICpcblx0ICogQHBhcmFtIHtPYmplY3R9IHN0YXRzXG5cdCAqL1xuXHRyZW1vdGVTdGF0cyhzdGF0cylcblx0e1xuXHRcdHRoaXMuc2FmZUVtaXQoJ3N0YXRzJywgc3RhdHMpO1xuXHR9XG59XG4iLCJpbXBvcnQgYm93c2VyIGZyb20gJ2Jvd3Nlcic7XG5pbXBvcnQgTG9nZ2VyIGZyb20gJy4vTG9nZ2VyJztcbmltcG9ydCBDaHJvbWU1NSBmcm9tICcuL2hhbmRsZXJzL0Nocm9tZTU1JztcbmltcG9ydCBDaHJvbWU2NyBmcm9tICcuL2hhbmRsZXJzL0Nocm9tZTY3JztcbmltcG9ydCBTYWZhcmkxMSBmcm9tICcuL2hhbmRsZXJzL1NhZmFyaTExJztcbmltcG9ydCBGaXJlZm94NTAgZnJvbSAnLi9oYW5kbGVycy9GaXJlZm94NTAnO1xuaW1wb3J0IEZpcmVmb3g1OSBmcm9tICcuL2hhbmRsZXJzL0ZpcmVmb3g1OSc7XG5pbXBvcnQgRWRnZTExIGZyb20gJy4vaGFuZGxlcnMvRWRnZTExJztcbmltcG9ydCBSZWFjdE5hdGl2ZSBmcm9tICcuL2hhbmRsZXJzL1JlYWN0TmF0aXZlJztcblxuY29uc3QgbG9nZ2VyID0gbmV3IExvZ2dlcignRGV2aWNlJyk7XG5cbi8qKlxuICogQ2xhc3Mgd2l0aCBzdGF0aWMgbWVtYmVycyByZXByZXNlbnRpbmcgdGhlIHVuZGVybHlpbmcgZGV2aWNlIG9yIGJyb3dzZXIuXG4gKi9cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIERldmljZVxue1xuXHQvKipcblx0ICogR2V0IHRoZSBkZXZpY2UgZmxhZy5cblx0ICpcblx0ICogQHJldHVybiB7U3RyaW5nfVxuXHQgKi9cblx0c3RhdGljIGdldEZsYWcoKVxuXHR7XG5cdFx0aWYgKCFEZXZpY2UuX2RldGVjdGVkKVxuXHRcdFx0RGV2aWNlLl9kZXRlY3QoKTtcblxuXHRcdHJldHVybiBEZXZpY2UuX2ZsYWc7XG5cdH1cblxuXHQvKipcblx0ICogR2V0IHRoZSBkZXZpY2UgbmFtZS5cblx0ICpcblx0ICogQHJldHVybiB7U3RyaW5nfVxuXHQgKi9cblx0c3RhdGljIGdldE5hbWUoKVxuXHR7XG5cdFx0aWYgKCFEZXZpY2UuX2RldGVjdGVkKVxuXHRcdFx0RGV2aWNlLl9kZXRlY3QoKTtcblxuXHRcdHJldHVybiBEZXZpY2UuX25hbWU7XG5cdH1cblxuXHQvKipcblx0ICogR2V0IHRoZSBkZXZpY2UgdmVyc2lvbi5cblx0ICpcblx0ICogQHJldHVybiB7U3RyaW5nfVxuXHQgKi9cblx0c3RhdGljIGdldFZlcnNpb24oKVxuXHR7XG5cdFx0aWYgKCFEZXZpY2UuX2RldGVjdGVkKVxuXHRcdFx0RGV2aWNlLl9kZXRlY3QoKTtcblxuXHRcdHJldHVybiBEZXZpY2UuX3ZlcnNpb247XG5cdH1cblxuXHQvKipcblx0ICogR2V0IHRoZSBib3dzZXIgbW9kdWxlIE9iamVjdC5cblx0ICpcblx0ICogQHJldHVybiB7T2JqZWN0fVxuXHQgKi9cblx0c3RhdGljIGdldEJvd3NlcigpXG5cdHtcblx0XHRpZiAoIURldmljZS5fZGV0ZWN0ZWQpXG5cdFx0XHREZXZpY2UuX2RldGVjdCgpO1xuXG5cdFx0cmV0dXJuIERldmljZS5fYm93c2VyO1xuXHR9XG5cblx0LyoqXG5cdCAqIFdoZXRoZXIgdGhpcyBkZXZpY2UgaXMgc3VwcG9ydGVkLlxuXHQgKlxuXHQgKiBAcmV0dXJuIHtCb29sZWFufVxuXHQgKi9cblx0c3RhdGljIGlzU3VwcG9ydGVkKClcblx0e1xuXHRcdGlmICghRGV2aWNlLl9kZXRlY3RlZClcblx0XHRcdERldmljZS5fZGV0ZWN0KCk7XG5cblx0XHRyZXR1cm4gQm9vbGVhbihEZXZpY2UuX2hhbmRsZXJDbGFzcyk7XG5cdH1cblxuXHQvKipcblx0ICogUmV0dXJucyBhIHN1aXRhYmxlIFdlYlJUQyBoYW5kbGVyIGNsYXNzLlxuXHQgKlxuXHQgKiBAdHlwZSB7Q2xhc3N9XG5cdCAqL1xuXHRzdGF0aWMgZ2V0IEhhbmRsZXIoKVxuXHR7XG5cdFx0aWYgKCFEZXZpY2UuX2RldGVjdGVkKVxuXHRcdFx0RGV2aWNlLl9kZXRlY3QoKTtcblxuXHRcdHJldHVybiBEZXZpY2UuX2hhbmRsZXJDbGFzcztcblx0fVxuXG5cdC8qKlxuXHQgKiBEZXRlY3RzIHRoZSBjdXJyZW50IGRldmljZS9icm93c2VyLlxuXHQgKlxuXHQgKiBAcHJpdmF0ZVxuXHQgKi9cblx0c3RhdGljIF9kZXRlY3QoKVxuXHR7XG5cdFx0RGV2aWNlLl9kZXRlY3RlZCA9IHRydWU7XG5cblx0XHQvLyBJZiB0aGlzIGlzIFJlYWN0LU5hdGl2ZSBtYW51YWxseSBmaWxsIGRhdGEuXG5cdFx0aWYgKGdsb2JhbC5uYXZpZ2F0b3IgJiYgZ2xvYmFsLm5hdmlnYXRvci5wcm9kdWN0ID09PSAnUmVhY3ROYXRpdmUnKVxuXHRcdHtcblx0XHRcdERldmljZS5fZmxhZyA9ICdyZWFjdC1uYXRpdmUnO1xuXHRcdFx0RGV2aWNlLl9uYW1lID0gJ1JlYWN0TmF0aXZlJztcblx0XHRcdERldmljZS5fdmVyc2lvbiA9IHVuZGVmaW5lZDsgLy8gTk9URTogTm8gaWRlYSBob3cgdG8ga25vdyBpdC5cblx0XHRcdERldmljZS5fYm93c2VyID0ge307XG5cdFx0XHREZXZpY2UuX2hhbmRsZXJDbGFzcyA9IFJlYWN0TmF0aXZlO1xuXHRcdH1cblx0XHQvLyBJZiB0aGlzIGlzIGEgYnJvd3NlciB1c2UgYm93c2VyIG1vZHVsZSBkZXRlY3Rpb24uXG5cdFx0ZWxzZSBpZiAoZ2xvYmFsLm5hdmlnYXRvciAmJiB0eXBlb2YgZ2xvYmFsLm5hdmlnYXRvci51c2VyQWdlbnQgPT09ICdzdHJpbmcnKVxuXHRcdHtcblx0XHRcdGNvbnN0IHVhID0gZ2xvYmFsLm5hdmlnYXRvci51c2VyQWdlbnQ7XG5cdFx0XHRjb25zdCBicm93c2VyID0gYm93c2VyLmRldGVjdCh1YSk7XG5cblx0XHRcdERldmljZS5fZmxhZyA9IHVuZGVmaW5lZDtcblx0XHRcdERldmljZS5fbmFtZSA9IGJyb3dzZXIubmFtZSB8fCB1bmRlZmluZWQ7XG5cdFx0XHREZXZpY2UuX3ZlcnNpb24gPSBicm93c2VyLnZlcnNpb24gfHwgdW5kZWZpbmVkO1xuXHRcdFx0RGV2aWNlLl9ib3dzZXIgPSBicm93c2VyO1xuXHRcdFx0RGV2aWNlLl9oYW5kbGVyQ2xhc3MgPSBudWxsO1xuXG5cdFx0XHQvLyBDaHJvbWUsIENocm9taXVtIChkZXNrdG9wIGFuZCBtb2JpbGUpLlxuXHRcdFx0aWYgKGJvd3Nlci5jaGVjayh7IGNocm9tZTogJzY3JywgY2hyb21pdW06ICc2NycgfSwgdHJ1ZSwgdWEpKVxuXHRcdFx0e1xuXHRcdFx0XHREZXZpY2UuX2ZsYWcgPSAnY2hyb21lJztcblx0XHRcdFx0RGV2aWNlLl9oYW5kbGVyQ2xhc3MgPSBDaHJvbWU2Nztcblx0XHRcdH1cblx0XHRcdGVsc2UgaWYgKGJvd3Nlci5jaGVjayh7IGNocm9tZTogJzU1JywgY2hyb21pdW06ICc1NScgfSwgdHJ1ZSwgdWEpKVxuXHRcdFx0e1xuXHRcdFx0XHREZXZpY2UuX2ZsYWcgPSAnY2hyb21lJztcblx0XHRcdFx0RGV2aWNlLl9oYW5kbGVyQ2xhc3MgPSBDaHJvbWU1NTtcblx0XHRcdH1cblx0XHRcdC8vIEZpcmVmb3ggKGRlc2t0b3AgYW5kIG1vYmlsZSkuXG5cdFx0XHRlbHNlIGlmIChib3dzZXIuY2hlY2soeyBmaXJlZm94OiAnNTknIH0sIHRydWUsIHVhKSlcblx0XHRcdHtcblx0XHRcdFx0RGV2aWNlLl9mbGFnID0gJ2ZpcmVmb3gnO1xuXHRcdFx0XHREZXZpY2UuX2hhbmRsZXJDbGFzcyA9IEZpcmVmb3g1OTtcblx0XHRcdH1cblx0XHRcdGVsc2UgaWYgKGJvd3Nlci5jaGVjayh7IGZpcmVmb3g6ICc1MCcgfSwgdHJ1ZSwgdWEpKVxuXHRcdFx0e1xuXHRcdFx0XHREZXZpY2UuX2ZsYWcgPSAnZmlyZWZveCc7XG5cdFx0XHRcdERldmljZS5faGFuZGxlckNsYXNzID0gRmlyZWZveDUwO1xuXHRcdFx0fVxuXHRcdFx0Ly8gU2FmYXJpIChkZXNrdG9wIGFuZCBtb2JpbGUpLlxuXHRcdFx0ZWxzZSBpZiAoYm93c2VyLmNoZWNrKHsgc2FmYXJpOiAnMTEnIH0sIHRydWUsIHVhKSlcblx0XHRcdHtcblx0XHRcdFx0RGV2aWNlLl9mbGFnID0gJ3NhZmFyaSc7XG5cdFx0XHRcdERldmljZS5faGFuZGxlckNsYXNzID0gU2FmYXJpMTE7XG5cdFx0XHR9XG5cdFx0XHQvLyBFZGdlIChkZXNrdG9wKS5cblx0XHRcdGVsc2UgaWYgKGJvd3Nlci5jaGVjayh7IG1zZWRnZTogJzExJyB9LCB0cnVlLCB1YSkpXG5cdFx0XHR7XG5cdFx0XHRcdERldmljZS5fZmxhZyA9ICdtc2VkZ2UnO1xuXHRcdFx0XHREZXZpY2UuX2hhbmRsZXJDbGFzcyA9IEVkZ2UxMTtcblx0XHRcdH1cblx0XHRcdC8vIE9wZXJhIChkZXNrdG9wIGFuZCBtb2JpbGUpLlxuXHRcdFx0aWYgKGJvd3Nlci5jaGVjayh7IG9wZXJhOiAnNDQnIH0sIHRydWUsIHVhKSlcblx0XHRcdHtcblx0XHRcdFx0RGV2aWNlLl9mbGFnID0gJ29wZXJhJztcblx0XHRcdFx0RGV2aWNlLl9oYW5kbGVyQ2xhc3MgPSBDaHJvbWU1NTtcblx0XHRcdH1cblxuXHRcdFx0aWYgKERldmljZS5pc1N1cHBvcnRlZCgpKVxuXHRcdFx0e1xuXHRcdFx0XHRsb2dnZXIuZGVidWcoXG5cdFx0XHRcdFx0J2Jyb3dzZXIgc3VwcG9ydGVkIFtmbGFnOiVzLCBuYW1lOlwiJXNcIiwgdmVyc2lvbjolcywgaGFuZGxlcjolc10nLFxuXHRcdFx0XHRcdERldmljZS5fZmxhZywgRGV2aWNlLl9uYW1lLCBEZXZpY2UuX3ZlcnNpb24sIERldmljZS5faGFuZGxlckNsYXNzLnRhZyk7XG5cdFx0XHR9XG5cdFx0XHRlbHNlXG5cdFx0XHR7XG5cdFx0XHRcdGxvZ2dlci53YXJuKFxuXHRcdFx0XHRcdCdicm93c2VyIG5vdCBzdXBwb3J0ZWQgW25hbWU6JXMsIHZlcnNpb246JXNdJyxcblx0XHRcdFx0XHREZXZpY2UuX25hbWUsIERldmljZS5fdmVyc2lvbik7XG5cdFx0XHR9XG5cdFx0fVxuXHRcdC8vIE90aGVyd2lzZSBmYWlsLlxuXHRcdGVsc2Vcblx0XHR7XG5cdFx0XHRsb2dnZXIud2FybignZGV2aWNlIG5vdCBzdXBwb3J0ZWQnKTtcblx0XHR9XG5cdH1cbn1cblxuLy8gSW5pdGlhbGl6ZWQgZmxhZy5cbi8vIEB0eXBlIHtCb29sZWFufVxuRGV2aWNlLl9kZXRlY3RlZCA9IGZhbHNlO1xuXG4vLyBEZXZpY2UgZmxhZy5cbi8vIEB0eXBlIHtTdHJpbmd9XG5EZXZpY2UuX2ZsYWcgPSB1bmRlZmluZWQ7XG5cbi8vIERldmljZSBuYW1lLlxuLy8gQHR5cGUge1N0cmluZ31cbkRldmljZS5fbmFtZSA9IHVuZGVmaW5lZDtcblxuLy8gRGV2aWNlIHZlcnNpb24uXG4vLyBAdHlwZSB7U3RyaW5nfVxuRGV2aWNlLl92ZXJzaW9uID0gdW5kZWZpbmVkO1xuXG4vLyBib3dzZXIgbW9kdWxlIE9iamVjdC5cbi8vIEB0eXBlIHtPYmplY3R9XG5EZXZpY2UuX2Jvd3NlciA9IHVuZGVmaW5lZDtcblxuLy8gV2ViUlRDIGhhbmRlciBmb3IgdGhpcyBkZXZpY2UuXG4vLyBAdHlwZSB7Q2xhc3N9XG5EZXZpY2UuX2hhbmRsZXJDbGFzcyA9IG51bGw7XG4iLCJpbXBvcnQgeyBFdmVudEVtaXR0ZXIgfSBmcm9tICdldmVudHMnO1xuaW1wb3J0IExvZ2dlciBmcm9tICcuL0xvZ2dlcic7XG5cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIEVuaGFuY2VkRXZlbnRFbWl0dGVyIGV4dGVuZHMgRXZlbnRFbWl0dGVyXG57XG5cdGNvbnN0cnVjdG9yKGxvZ2dlcilcblx0e1xuXHRcdHN1cGVyKCk7XG5cdFx0dGhpcy5zZXRNYXhMaXN0ZW5lcnMoSW5maW5pdHkpO1xuXG5cdFx0dGhpcy5fbG9nZ2VyID0gbG9nZ2VyIHx8IG5ldyBMb2dnZXIoJ0VuaGFuY2VkRXZlbnRFbWl0dGVyJyk7XG5cdH1cblxuXHRzYWZlRW1pdChldmVudCwgLi4uYXJncylcblx0e1xuXHRcdHRyeVxuXHRcdHtcblx0XHRcdHRoaXMuZW1pdChldmVudCwgLi4uYXJncyk7XG5cdFx0fVxuXHRcdGNhdGNoIChlcnJvcilcblx0XHR7XG5cdFx0XHR0aGlzLl9sb2dnZXIuZXJyb3IoXG5cdFx0XHRcdCdzYWZlRW1pdCgpIHwgZXZlbnQgbGlzdGVuZXIgdGhyZXcgYW4gZXJyb3IgW2V2ZW50OiVzXTolbycsXG5cdFx0XHRcdGV2ZW50LCBlcnJvcik7XG5cdFx0fVxuXHR9XG5cblx0c2FmZUVtaXRBc1Byb21pc2UoZXZlbnQsIC4uLmFyZ3MpXG5cdHtcblx0XHRyZXR1cm4gbmV3IFByb21pc2UoKHJlc29sdmUsIHJlamVjdCkgPT5cblx0XHR7XG5cdFx0XHRjb25zdCBjYWxsYmFjayA9IChyZXN1bHQpID0+XG5cdFx0XHR7XG5cdFx0XHRcdHJlc29sdmUocmVzdWx0KTtcblx0XHRcdH07XG5cblx0XHRcdGNvbnN0IGVycmJhY2sgPSAoZXJyb3IpID0+XG5cdFx0XHR7XG5cdFx0XHRcdHRoaXMuX2xvZ2dlci5lcnJvcihcblx0XHRcdFx0XHQnc2FmZUVtaXRBc1Byb21pc2UoKSB8IGVycmJhY2sgY2FsbGVkIFtldmVudDolc106JW8nLFxuXHRcdFx0XHRcdGV2ZW50LCBlcnJvcik7XG5cblx0XHRcdFx0cmVqZWN0KGVycm9yKTtcblx0XHRcdH07XG5cblx0XHRcdHRoaXMuc2FmZUVtaXQoZXZlbnQsIC4uLmFyZ3MsIGNhbGxiYWNrLCBlcnJiYWNrKTtcblx0XHR9KTtcblx0fVxufVxuIiwiaW1wb3J0IGRlYnVnIGZyb20gJ2RlYnVnJztcblxuY29uc3QgQVBQX05BTUUgPSAnbWVkaWFzb3VwLWNsaWVudCc7XG5cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIExvZ2dlclxue1xuXHRjb25zdHJ1Y3RvcihwcmVmaXgpXG5cdHtcblx0XHRpZiAocHJlZml4KVxuXHRcdHtcblx0XHRcdHRoaXMuX2RlYnVnID0gZGVidWcoYCR7QVBQX05BTUV9OiR7cHJlZml4fWApO1xuXHRcdFx0dGhpcy5fd2FybiA9IGRlYnVnKGAke0FQUF9OQU1FfTpXQVJOOiR7cHJlZml4fWApO1xuXHRcdFx0dGhpcy5fZXJyb3IgPSBkZWJ1ZyhgJHtBUFBfTkFNRX06RVJST1I6JHtwcmVmaXh9YCk7XG5cdFx0fVxuXHRcdGVsc2Vcblx0XHR7XG5cdFx0XHR0aGlzLl9kZWJ1ZyA9IGRlYnVnKEFQUF9OQU1FKTtcblx0XHRcdHRoaXMuX3dhcm4gPSBkZWJ1ZyhgJHtBUFBfTkFNRX06V0FSTmApO1xuXHRcdFx0dGhpcy5fZXJyb3IgPSBkZWJ1ZyhgJHtBUFBfTkFNRX06RVJST1JgKTtcblx0XHR9XG5cblx0XHQvKiBlc2xpbnQtZGlzYWJsZSBuby1jb25zb2xlICovXG5cdFx0dGhpcy5fZGVidWcubG9nID0gY29uc29sZS5pbmZvLmJpbmQoY29uc29sZSk7XG5cdFx0dGhpcy5fd2Fybi5sb2cgPSBjb25zb2xlLndhcm4uYmluZChjb25zb2xlKTtcblx0XHR0aGlzLl9lcnJvci5sb2cgPSBjb25zb2xlLmVycm9yLmJpbmQoY29uc29sZSk7XG5cdFx0LyogZXNsaW50LWVuYWJsZSBuby1jb25zb2xlICovXG5cdH1cblxuXHRnZXQgZGVidWcoKVxuXHR7XG5cdFx0cmV0dXJuIHRoaXMuX2RlYnVnO1xuXHR9XG5cblx0Z2V0IHdhcm4oKVxuXHR7XG5cdFx0cmV0dXJuIHRoaXMuX3dhcm47XG5cdH1cblxuXHRnZXQgZXJyb3IoKVxuXHR7XG5cdFx0cmV0dXJuIHRoaXMuX2Vycm9yO1xuXHR9XG59XG4iLCJpbXBvcnQgTG9nZ2VyIGZyb20gJy4vTG9nZ2VyJztcbmltcG9ydCBFbmhhbmNlZEV2ZW50RW1pdHRlciBmcm9tICcuL0VuaGFuY2VkRXZlbnRFbWl0dGVyJztcblxuY29uc3QgbG9nZ2VyID0gbmV3IExvZ2dlcignUGVlcicpO1xuXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBQZWVyIGV4dGVuZHMgRW5oYW5jZWRFdmVudEVtaXR0ZXJcbntcblx0LyoqXG5cdCAqIEBwcml2YXRlXG5cdCAqXG5cdCAqIEBlbWl0cyB7Y29uc3VtZXI6IENvbnN1bWVyfSBuZXdjb25zdW1lclxuXHQgKiBAZW1pdHMge29yaWdpbmF0b3I6IFN0cmluZywgW2FwcERhdGFdOiBBbnl9IGNsb3NlXG5cdCAqXG5cdCAqIEBlbWl0cyBAY2xvc2Vcblx0ICovXG5cdGNvbnN0cnVjdG9yKG5hbWUsIGFwcERhdGEpXG5cdHtcblx0XHRzdXBlcihsb2dnZXIpO1xuXG5cdFx0Ly8gTmFtZS5cblx0XHQvLyBAdHlwZSB7U3RyaW5nfVxuXHRcdHRoaXMuX25hbWUgPSBuYW1lO1xuXG5cdFx0Ly8gQ2xvc2VkIGZsYWcuXG5cdFx0Ly8gQHR5cGUge0Jvb2xlYW59XG5cdFx0dGhpcy5fY2xvc2VkID0gZmFsc2U7XG5cblx0XHQvLyBBcHAgY3VzdG9tIGRhdGEuXG5cdFx0Ly8gQHR5cGUge0FueX1cblx0XHR0aGlzLl9hcHBEYXRhID0gYXBwRGF0YTtcblxuXHRcdC8vIE1hcCBvZiBDb25zdW1lcnMgaW5kZXhlZCBieSBpZC5cblx0XHQvLyBAdHlwZSB7bWFwPE51bWJlciwgQ29uc3VtZXI+fVxuXHRcdHRoaXMuX2NvbnN1bWVycyA9IG5ldyBNYXAoKTtcblx0fVxuXG5cdC8qKlxuXHQgKiBQZWVyIG5hbWUuXG5cdCAqXG5cdCAqIEByZXR1cm4ge1N0cmluZ31cblx0ICovXG5cdGdldCBuYW1lKClcblx0e1xuXHRcdHJldHVybiB0aGlzLl9uYW1lO1xuXHR9XG5cblx0LyoqXG5cdCAqIFdoZXRoZXIgdGhlIFBlZXIgaXMgY2xvc2VkLlxuXHQgKlxuXHQgKiBAcmV0dXJuIHtCb29sZWFufVxuXHQgKi9cblx0Z2V0IGNsb3NlZCgpXG5cdHtcblx0XHRyZXR1cm4gdGhpcy5fY2xvc2VkO1xuXHR9XG5cblx0LyoqXG5cdCAqIEFwcCBjdXN0b20gZGF0YS5cblx0ICpcblx0ICogQHJldHVybiB7QW55fVxuXHQgKi9cblx0Z2V0IGFwcERhdGEoKVxuXHR7XG5cdFx0cmV0dXJuIHRoaXMuX2FwcERhdGE7XG5cdH1cblxuXHQvKipcblx0ICogVGhlIGxpc3Qgb2YgQ29uc3VtZXJzLlxuXHQgKlxuXHQgKiBAcmV0dXJuIHtBcnJheTxDb25zdW1lcj59XG5cdCAqL1xuXHRnZXQgY29uc3VtZXJzKClcblx0e1xuXHRcdHJldHVybiBBcnJheS5mcm9tKHRoaXMuX2NvbnN1bWVycy52YWx1ZXMoKSk7XG5cdH1cblxuXHQvKipcblx0ICogQ2xvc2VzIHRoZSBQZWVyLlxuXHQgKiBUaGlzIGlzIGNhbGxlZCB3aGVuIHRoZSBsb2NhbCBSb29tIGlzIGNsb3NlZC5cblx0ICpcblx0ICogQHByaXZhdGVcblx0ICovXG5cdGNsb3NlKClcblx0e1xuXHRcdGxvZ2dlci5kZWJ1ZygnY2xvc2UoKScpO1xuXG5cdFx0aWYgKHRoaXMuX2Nsb3NlZClcblx0XHRcdHJldHVybjtcblxuXHRcdHRoaXMuX2Nsb3NlZCA9IHRydWU7XG5cblx0XHR0aGlzLmVtaXQoJ0BjbG9zZScpO1xuXHRcdHRoaXMuc2FmZUVtaXQoJ2Nsb3NlJywgJ2xvY2FsJyk7XG5cblx0XHQvLyBDbG9zZSBhbGwgdGhlIENvbnN1bWVycy5cblx0XHRmb3IgKGNvbnN0IGNvbnN1bWVyIG9mIHRoaXMuX2NvbnN1bWVycy52YWx1ZXMoKSlcblx0XHR7XG5cdFx0XHRjb25zdW1lci5jbG9zZSgpO1xuXHRcdH1cblx0fVxuXG5cdC8qKlxuXHQgKiBUaGUgcmVtb3RlIFBlZXIgb3IgUm9vbSB3YXMgY2xvc2VkLlxuXHQgKiBJbnZva2VkIHZpYSByZW1vdGUgbm90aWZpY2F0aW9uLlxuXHQgKlxuXHQgKiBAcHJpdmF0ZVxuXHQgKlxuXHQgKiBAcGFyYW0ge0FueX0gW2FwcERhdGFdIC0gQXBwIGN1c3RvbSBkYXRhLlxuXHQgKi9cblx0cmVtb3RlQ2xvc2UoYXBwRGF0YSlcblx0e1xuXHRcdGxvZ2dlci5kZWJ1ZygncmVtb3RlQ2xvc2UoKScpO1xuXG5cdFx0aWYgKHRoaXMuX2Nsb3NlZClcblx0XHRcdHJldHVybjtcblxuXHRcdHRoaXMuX2Nsb3NlZCA9IHRydWU7XG5cblx0XHR0aGlzLmVtaXQoJ0BjbG9zZScpO1xuXHRcdHRoaXMuc2FmZUVtaXQoJ2Nsb3NlJywgJ3JlbW90ZScsIGFwcERhdGEpO1xuXG5cdFx0Ly8gQ2xvc2UgYWxsIHRoZSBDb25zdW1lcnMuXG5cdFx0Zm9yIChjb25zdCBjb25zdW1lciBvZiB0aGlzLl9jb25zdW1lcnMudmFsdWVzKCkpXG5cdFx0e1xuXHRcdFx0Y29uc3VtZXIucmVtb3RlQ2xvc2UoKTtcblx0XHR9XG5cdH1cblxuXHQvKipcblx0ICogR2V0IHRoZSBDb25zdW1lciB3aXRoIHRoZSBnaXZlbiBpZC5cblx0ICpcblx0ICogQHBhcmFtIHtOdW1iZXJ9IGlkXG5cdCAqXG5cdCAqIEByZXR1cm4ge0NvbnN1bWVyfVxuXHQgKi9cblx0Z2V0Q29uc3VtZXJCeUlkKGlkKVxuXHR7XG5cdFx0cmV0dXJuIHRoaXMuX2NvbnN1bWVycy5nZXQoaWQpO1xuXHR9XG5cblx0LyoqXG5cdCAqIEFkZCBhbiBhc3NvY2lhdGVkIENvbnN1bWVyLlxuXHQgKlxuXHQgKiBAcHJpdmF0ZVxuXHQgKlxuXHQgKiBAcGFyYW0ge0NvbnN1bWVyfSBjb25zdW1lclxuXHQgKi9cblx0YWRkQ29uc3VtZXIoY29uc3VtZXIpXG5cdHtcblx0XHRpZiAodGhpcy5fY29uc3VtZXJzLmhhcyhjb25zdW1lci5pZCkpXG5cdFx0XHR0aHJvdyBuZXcgRXJyb3IoYENvbnN1bWVyIGFscmVhZHkgZXhpc3RzIFtpZDoke2NvbnN1bWVyLmlkfV1gKTtcblxuXHRcdC8vIFN0b3JlIGl0LlxuXHRcdHRoaXMuX2NvbnN1bWVycy5zZXQoY29uc3VtZXIuaWQsIGNvbnN1bWVyKTtcblxuXHRcdC8vIEhhbmRsZSBpdC5cblx0XHRjb25zdW1lci5vbignQGNsb3NlJywgKCkgPT5cblx0XHR7XG5cdFx0XHR0aGlzLl9jb25zdW1lcnMuZGVsZXRlKGNvbnN1bWVyLmlkKTtcblx0XHR9KTtcblxuXHRcdC8vIEVtaXQgZXZlbnQuXG5cdFx0dGhpcy5zYWZlRW1pdCgnbmV3Y29uc3VtZXInLCBjb25zdW1lcik7XG5cdH1cbn1cbiIsImltcG9ydCBMb2dnZXIgZnJvbSAnLi9Mb2dnZXInO1xuaW1wb3J0IEVuaGFuY2VkRXZlbnRFbWl0dGVyIGZyb20gJy4vRW5oYW5jZWRFdmVudEVtaXR0ZXInO1xuaW1wb3J0IHsgSW52YWxpZFN0YXRlRXJyb3IgfSBmcm9tICcuL2Vycm9ycyc7XG5pbXBvcnQgKiBhcyB1dGlscyBmcm9tICcuL3V0aWxzJztcblxuY29uc3QgREVGQVVMVF9TVEFUU19JTlRFUlZBTCA9IDEwMDA7XG5jb25zdCBTSU1VTENBU1RfREVGQVVMVCA9XG57XG5cdGxvdyAgICA6IDEwMDAwMCxcblx0bWVkaXVtIDogMzAwMDAwLFxuXHRoaWdoICAgOiAxNTAwMDAwXG59O1xuXG5jb25zdCBsb2dnZXIgPSBuZXcgTG9nZ2VyKCdQcm9kdWNlcicpO1xuXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBQcm9kdWNlciBleHRlbmRzIEVuaGFuY2VkRXZlbnRFbWl0dGVyXG57XG5cdC8qKlxuXHQgKiBAcHJpdmF0ZVxuXHQgKlxuXHQgKiBAZW1pdHMge29yaWdpbmF0b3I6IFN0cmluZywgW2FwcERhdGFdOiBBbnl9IHBhdXNlXG5cdCAqIEBlbWl0cyB7b3JpZ2luYXRvcjogU3RyaW5nLCBbYXBwRGF0YV06IEFueX0gcmVzdW1lXG5cdCAqIEBlbWl0cyB7c3RhdHM6IE9iamVjdH0gc3RhdHNcblx0ICogQGVtaXRzIGhhbmRsZWRcblx0ICogQGVtaXRzIHVuaGFuZGxlZFxuXHQgKiBAZW1pdHMgdHJhY2tlbmRlZFxuXHQgKiBAZW1pdHMge29yaWdpbmF0b3I6IFN0cmluZywgW2FwcERhdGFdOiBBbnl9IGNsb3NlXG5cdCAqXG5cdCAqIEBlbWl0cyB7b3JpZ2luYXRvcjogU3RyaW5nLCBbYXBwRGF0YV06IEFueX0gQGNsb3NlXG5cdCAqL1xuXHRjb25zdHJ1Y3Rvcih0cmFjaywgb3B0aW9ucywgYXBwRGF0YSlcblx0e1xuXHRcdHN1cGVyKGxvZ2dlcik7XG5cblx0XHQvLyBJZC5cblx0XHQvLyBAdHlwZSB7TnVtYmVyfVxuXHRcdHRoaXMuX2lkID0gdXRpbHMucmFuZG9tTnVtYmVyKCk7XG5cblx0XHQvLyBDbG9zZWQgZmxhZy5cblx0XHQvLyBAdHlwZSB7Qm9vbGVhbn1cblx0XHR0aGlzLl9jbG9zZWQgPSBmYWxzZTtcblxuXHRcdC8vIE9yaWdpbmFsIHRyYWNrLlxuXHRcdC8vIEB0eXBlIHtNZWRpYVN0cmVhbVRyYWNrfVxuXHRcdHRoaXMuX29yaWdpbmFsVHJhY2sgPSB0cmFjaztcblxuXHRcdC8vIFRyYWNrIGNsb25lZCBmcm9tIHRoZSBvcmlnaW5hbCBvbmUgKGlmIHN1cHBvcnRlZCkuXG5cdFx0Ly8gQHR5cGUge01lZGlhU3RyZWFtVHJhY2t9XG5cdFx0dHJ5XG5cdFx0e1xuXHRcdFx0dGhpcy5fdHJhY2sgPSB0cmFjay5jbG9uZSgpO1xuXHRcdH1cblx0XHRjYXRjaCAoZXJyb3IpXG5cdFx0e1xuXHRcdFx0dGhpcy5fdHJhY2sgPSB0cmFjaztcblx0XHR9XG5cblx0XHQvLyBBcHAgY3VzdG9tIGRhdGEuXG5cdFx0Ly8gQHR5cGUge0FueX1cblx0XHR0aGlzLl9hcHBEYXRhID0gYXBwRGF0YTtcblxuXHRcdC8vIFNpbXVsY2FzdC5cblx0XHQvLyBAdHlwZSB7T2JqZWN0fGZhbHNlfVxuXHRcdHRoaXMuX3NpbXVsY2FzdCA9IGZhbHNlO1xuXG5cdFx0aWYgKHR5cGVvZiBvcHRpb25zLnNpbXVsY2FzdCA9PT0gJ29iamVjdCcpXG5cdFx0XHR0aGlzLl9zaW11bGNhc3QgPSBPYmplY3QuYXNzaWduKHt9LCBTSU1VTENBU1RfREVGQVVMVCwgb3B0aW9ucy5zaW11bGNhc3QpO1xuXHRcdGVsc2UgaWYgKG9wdGlvbnMuc2ltdWxjYXN0ID09PSB0cnVlKVxuXHRcdFx0dGhpcy5fc2ltdWxjYXN0ID0gT2JqZWN0LmFzc2lnbih7fSwgU0lNVUxDQVNUX0RFRkFVTFQpO1xuXG5cdFx0Ly8gQXNzb2NpYXRlZCBUcmFuc3BvcnQuXG5cdFx0Ly8gQHR5cGUge1RyYW5zcG9ydH1cblx0XHR0aGlzLl90cmFuc3BvcnQgPSBudWxsO1xuXG5cdFx0Ly8gUlRQIHBhcmFtZXRlcnMuXG5cdFx0Ly8gQHR5cGUge1JUQ1J0cFBhcmFtZXRlcnN9XG5cdFx0dGhpcy5fcnRwUGFyYW1ldGVycyA9IG51bGw7XG5cblx0XHQvLyBMb2NhbGx5IHBhdXNlZCBmbGFnLlxuXHRcdC8vIEB0eXBlIHtCb29sZWFufVxuXHRcdHRoaXMuX2xvY2FsbHlQYXVzZWQgPSAhdGhpcy5fdHJhY2suZW5hYmxlZDtcblxuXHRcdC8vIFJlbW90ZWx5IHBhdXNlZCBmbGFnLlxuXHRcdC8vIEB0eXBlIHtCb29sZWFufVxuXHRcdHRoaXMuX3JlbW90ZWx5UGF1c2VkID0gZmFsc2U7XG5cblx0XHQvLyBQZXJpb2RpYyBzdGF0cyBmbGFnLlxuXHRcdC8vIEB0eXBlIHtCb29sZWFufVxuXHRcdHRoaXMuX3N0YXRzRW5hYmxlZCA9IGZhbHNlO1xuXG5cdFx0Ly8gUGVyaW9kaWMgc3RhdHMgZ2F0aGVyaW5nIGludGVydmFsIChtaWxsaXNlY29uZHMpLlxuXHRcdC8vIEB0eXBlIHtOdW1iZXJ9XG5cdFx0dGhpcy5fc3RhdHNJbnRlcnZhbCA9IERFRkFVTFRfU1RBVFNfSU5URVJWQUw7XG5cblx0XHQvLyBIYW5kbGUgdGhlIGVmZmVjdGl2ZSB0cmFjay5cblx0XHR0aGlzLl9oYW5kbGVUcmFjaygpO1xuXHR9XG5cblx0LyoqXG5cdCAqIFByb2R1Y2VyIGlkLlxuXHQgKlxuXHQgKiBAcmV0dXJuIHtOdW1iZXJ9XG5cdCAqL1xuXHRnZXQgaWQoKVxuXHR7XG5cdFx0cmV0dXJuIHRoaXMuX2lkO1xuXHR9XG5cblx0LyoqXG5cdCAqIFdoZXRoZXIgdGhlIFByb2R1Y2VyIGlzIGNsb3NlZC5cblx0ICpcblx0ICogQHJldHVybiB7Qm9vbGVhbn1cblx0ICovXG5cdGdldCBjbG9zZWQoKVxuXHR7XG5cdFx0cmV0dXJuIHRoaXMuX2Nsb3NlZDtcblx0fVxuXG5cdC8qKlxuXHQgKiBNZWRpYSBraW5kLlxuXHQgKlxuXHQgKiBAcmV0dXJuIHtTdHJpbmd9XG5cdCAqL1xuXHRnZXQga2luZCgpXG5cdHtcblx0XHRyZXR1cm4gdGhpcy5fdHJhY2sua2luZDtcblx0fVxuXG5cdC8qKlxuXHQgKiBUaGUgYXNzb2NpYXRlZCB0cmFjay5cblx0ICpcblx0ICogQHJldHVybiB7TWVkaWFTdHJlYW1UcmFja31cblx0ICovXG5cdGdldCB0cmFjaygpXG5cdHtcblx0XHRyZXR1cm4gdGhpcy5fdHJhY2s7XG5cdH1cblxuXHQvKipcblx0ICogVGhlIGFzc29jaWF0ZWQgb3JpZ2luYWwgdHJhY2suXG5cdCAqXG5cdCAqIEByZXR1cm4ge01lZGlhU3RyZWFtVHJhY2t9XG5cdCAqL1xuXHRnZXQgb3JpZ2luYWxUcmFjaygpXG5cdHtcblx0XHRyZXR1cm4gdGhpcy5fb3JpZ2luYWxUcmFjaztcblx0fVxuXG5cdC8qKlxuXHQgKiBTaW11bGNhc3Qgc2V0dGluZ3MuXG5cdCAqXG5cdCAqIEByZXR1cm4ge09iamVjdHxmYWxzZX1cblx0ICovXG5cdGdldCBzaW11bGNhc3QoKVxuXHR7XG5cdFx0cmV0dXJuIHRoaXMuX3NpbXVsY2FzdDtcblx0fVxuXG5cdC8qKlxuXHQgKiBBcHAgY3VzdG9tIGRhdGEuXG5cdCAqXG5cdCAqIEByZXR1cm4ge0FueX1cblx0ICovXG5cdGdldCBhcHBEYXRhKClcblx0e1xuXHRcdHJldHVybiB0aGlzLl9hcHBEYXRhO1xuXHR9XG5cblx0LyoqXG5cdCAqIEFzc29jaWF0ZWQgVHJhbnNwb3J0LlxuXHQgKlxuXHQgKiBAcmV0dXJuIHtUcmFuc3BvcnR9XG5cdCAqL1xuXHRnZXQgdHJhbnNwb3J0KClcblx0e1xuXHRcdHJldHVybiB0aGlzLl90cmFuc3BvcnQ7XG5cdH1cblxuXHQvKipcblx0ICogUlRQIHBhcmFtZXRlcnMuXG5cdCAqXG5cdCAqIEByZXR1cm4ge1JUQ1J0cFBhcmFtZXRlcnN9XG5cdCAqL1xuXHRnZXQgcnRwUGFyYW1ldGVycygpXG5cdHtcblx0XHRyZXR1cm4gdGhpcy5fcnRwUGFyYW1ldGVycztcblx0fVxuXG5cdC8qKlxuXHQgKiBXaGV0aGVyIHRoZSBQcm9kdWNlciBpcyBsb2NhbGx5IHBhdXNlZC5cblx0ICpcblx0ICogQHJldHVybiB7Qm9vbGVhbn1cblx0ICovXG5cdGdldCBsb2NhbGx5UGF1c2VkKClcblx0e1xuXHRcdHJldHVybiB0aGlzLl9sb2NhbGx5UGF1c2VkO1xuXHR9XG5cblx0LyoqXG5cdCAqIFdoZXRoZXIgdGhlIFByb2R1Y2VyIGlzIHJlbW90ZWx5IHBhdXNlZC5cblx0ICpcblx0ICogQHJldHVybiB7Qm9vbGVhbn1cblx0ICovXG5cdGdldCByZW1vdGVseVBhdXNlZCgpXG5cdHtcblx0XHRyZXR1cm4gdGhpcy5fcmVtb3RlbHlQYXVzZWQ7XG5cdH1cblxuXHQvKipcblx0ICogV2hldGhlciB0aGUgUHJvZHVjZXIgaXMgcGF1c2VkLlxuXHQgKlxuXHQgKiBAcmV0dXJuIHtCb29sZWFufVxuXHQgKi9cblx0Z2V0IHBhdXNlZCgpXG5cdHtcblx0XHRyZXR1cm4gdGhpcy5fbG9jYWxseVBhdXNlZCB8fCB0aGlzLl9yZW1vdGVseVBhdXNlZDtcblx0fVxuXG5cdC8qKlxuXHQgKiBDbG9zZXMgdGhlIFByb2R1Y2VyLlxuXHQgKlxuXHQgKiBAcGFyYW0ge0FueX0gW2FwcERhdGFdIC0gQXBwIGN1c3RvbSBkYXRhLlxuXHQgKi9cblx0Y2xvc2UoYXBwRGF0YSlcblx0e1xuXHRcdGxvZ2dlci5kZWJ1ZygnY2xvc2UoKScpO1xuXG5cdFx0aWYgKHRoaXMuX2Nsb3NlZClcblx0XHRcdHJldHVybjtcblxuXHRcdHRoaXMuX2Nsb3NlZCA9IHRydWU7XG5cblx0XHRpZiAodGhpcy5fc3RhdHNFbmFibGVkKVxuXHRcdHtcblx0XHRcdHRoaXMuX3N0YXRzRW5hYmxlZCA9IGZhbHNlO1xuXG5cdFx0XHRpZiAodGhpcy50cmFuc3BvcnQpXG5cdFx0XHR7XG5cdFx0XHRcdHRoaXMudHJhbnNwb3J0LmRpc2FibGVQcm9kdWNlclN0YXRzKHRoaXMpO1xuXHRcdFx0fVxuXHRcdH1cblxuXHRcdGlmICh0aGlzLl90cmFuc3BvcnQpXG5cdFx0XHR0aGlzLl90cmFuc3BvcnQucmVtb3ZlUHJvZHVjZXIodGhpcywgJ2xvY2FsJywgYXBwRGF0YSk7XG5cblx0XHR0aGlzLl9kZXN0cm95KCk7XG5cblx0XHR0aGlzLmVtaXQoJ0BjbG9zZScsICdsb2NhbCcsIGFwcERhdGEpO1xuXHRcdHRoaXMuc2FmZUVtaXQoJ2Nsb3NlJywgJ2xvY2FsJywgYXBwRGF0YSk7XG5cdH1cblxuXHQvKipcblx0ICogTXkgcmVtb3RlIFByb2R1Y2VyIHdhcyBjbG9zZWQuXG5cdCAqIEludm9rZWQgdmlhIHJlbW90ZSBub3RpZmljYXRpb24uXG5cdCAqXG5cdCAqIEBwcml2YXRlXG5cdCAqXG5cdCAqIEBwYXJhbSB7QW55fSBbYXBwRGF0YV0gLSBBcHAgY3VzdG9tIGRhdGEuXG5cdCAqL1xuXHRyZW1vdGVDbG9zZShhcHBEYXRhKVxuXHR7XG5cdFx0bG9nZ2VyLmRlYnVnKCdyZW1vdGVDbG9zZSgpJyk7XG5cblx0XHRpZiAodGhpcy5fY2xvc2VkKVxuXHRcdFx0cmV0dXJuO1xuXG5cdFx0dGhpcy5fY2xvc2VkID0gdHJ1ZTtcblxuXHRcdGlmICh0aGlzLl90cmFuc3BvcnQpXG5cdFx0XHR0aGlzLl90cmFuc3BvcnQucmVtb3ZlUHJvZHVjZXIodGhpcywgJ3JlbW90ZScsIGFwcERhdGEpO1xuXG5cdFx0dGhpcy5fZGVzdHJveSgpO1xuXG5cdFx0dGhpcy5lbWl0KCdAY2xvc2UnLCAncmVtb3RlJywgYXBwRGF0YSk7XG5cdFx0dGhpcy5zYWZlRW1pdCgnY2xvc2UnLCAncmVtb3RlJywgYXBwRGF0YSk7XG5cdH1cblxuXHRfZGVzdHJveSgpXG5cdHtcblx0XHR0aGlzLl90cmFuc3BvcnQgPSBmYWxzZTtcblx0XHR0aGlzLl9ydHBQYXJhbWV0ZXJzID0gbnVsbDtcblxuXHRcdHRyeSB7IHRoaXMuX3RyYWNrLnN0b3AoKTsgfVxuXHRcdGNhdGNoIChlcnJvcikge31cblx0fVxuXG5cdC8qKlxuXHQgKiBTZW5kcyBSVFAuXG5cdCAqXG5cdCAqIEBwYXJhbSB7VHJhbnNwb3J0fSB0cmFuc3BvcnQgaW5zdGFuY2UuXG5cdCAqXG5cdCAqIEByZXR1cm4ge1Byb21pc2V9XG5cdCAqL1xuXHRzZW5kKHRyYW5zcG9ydClcblx0e1xuXHRcdGxvZ2dlci5kZWJ1Zygnc2VuZCgpIFt0cmFuc3BvcnQ6JW9dJywgdHJhbnNwb3J0KTtcblxuXHRcdGlmICh0aGlzLl9jbG9zZWQpXG5cdFx0XHRyZXR1cm4gUHJvbWlzZS5yZWplY3QobmV3IEludmFsaWRTdGF0ZUVycm9yKCdQcm9kdWNlciBjbG9zZWQnKSk7XG5cdFx0ZWxzZSBpZiAodGhpcy5fdHJhbnNwb3J0KVxuXHRcdFx0cmV0dXJuIFByb21pc2UucmVqZWN0KG5ldyBFcnJvcignYWxyZWFkeSBoYW5kbGVkIGJ5IGEgVHJhbnNwb3J0JykpO1xuXHRcdGVsc2UgaWYgKHR5cGVvZiB0cmFuc3BvcnQgIT09ICdvYmplY3QnKVxuXHRcdFx0cmV0dXJuIFByb21pc2UucmVqZWN0KG5ldyBUeXBlRXJyb3IoJ2ludmFsaWQgVHJhbnNwb3J0JykpO1xuXG5cdFx0dGhpcy5fdHJhbnNwb3J0ID0gdHJhbnNwb3J0O1xuXG5cdFx0cmV0dXJuIHRyYW5zcG9ydC5hZGRQcm9kdWNlcih0aGlzKVxuXHRcdFx0LnRoZW4oKCkgPT5cblx0XHRcdHtcblx0XHRcdFx0dHJhbnNwb3J0Lm9uY2UoJ0BjbG9zZScsICgpID0+XG5cdFx0XHRcdHtcblx0XHRcdFx0XHRpZiAodGhpcy5fY2xvc2VkIHx8IHRoaXMuX3RyYW5zcG9ydCAhPT0gdHJhbnNwb3J0KVxuXHRcdFx0XHRcdFx0cmV0dXJuO1xuXG5cdFx0XHRcdFx0dGhpcy5fdHJhbnNwb3J0LnJlbW92ZVByb2R1Y2VyKHRoaXMsICdsb2NhbCcpO1xuXG5cdFx0XHRcdFx0dGhpcy5fdHJhbnNwb3J0ID0gbnVsbDtcblx0XHRcdFx0XHR0aGlzLl9ydHBQYXJhbWV0ZXJzID0gbnVsbDtcblxuXHRcdFx0XHRcdHRoaXMuc2FmZUVtaXQoJ3VuaGFuZGxlZCcpO1xuXHRcdFx0XHR9KTtcblxuXHRcdFx0XHR0aGlzLnNhZmVFbWl0KCdoYW5kbGVkJyk7XG5cblx0XHRcdFx0aWYgKHRoaXMuX3N0YXRzRW5hYmxlZClcblx0XHRcdFx0XHR0cmFuc3BvcnQuZW5hYmxlUHJvZHVjZXJTdGF0cyh0aGlzLCB0aGlzLl9zdGF0c0ludGVydmFsKTtcblx0XHRcdH0pXG5cdFx0XHQuY2F0Y2goKGVycm9yKSA9PlxuXHRcdFx0e1xuXHRcdFx0XHR0aGlzLl90cmFuc3BvcnQgPSBudWxsO1xuXG5cdFx0XHRcdHRocm93IGVycm9yO1xuXHRcdFx0fSk7XG5cdH1cblxuXHQvKipcblx0ICogUGF1c2VzIHNlbmRpbmcgbWVkaWEuXG5cdCAqXG5cdCAqIEBwYXJhbSB7QW55fSBbYXBwRGF0YV0gLSBBcHAgY3VzdG9tIGRhdGEuXG5cdCAqXG5cdCAqIEByZXR1cm4ge0Jvb2xlYW59IHRydWUgaWYgcGF1c2VkLlxuXHQgKi9cblx0cGF1c2UoYXBwRGF0YSlcblx0e1xuXHRcdGxvZ2dlci5kZWJ1ZygncGF1c2UoKScpO1xuXG5cdFx0aWYgKHRoaXMuX2Nsb3NlZClcblx0XHR7XG5cdFx0XHRsb2dnZXIuZXJyb3IoJ3BhdXNlKCkgfCBQcm9kdWNlciBjbG9zZWQnKTtcblxuXHRcdFx0cmV0dXJuIGZhbHNlO1xuXHRcdH1cblx0XHRlbHNlIGlmICh0aGlzLl9sb2NhbGx5UGF1c2VkKVxuXHRcdHtcblx0XHRcdHJldHVybiB0cnVlO1xuXHRcdH1cblxuXHRcdHRoaXMuX2xvY2FsbHlQYXVzZWQgPSB0cnVlO1xuXHRcdHRoaXMuX3RyYWNrLmVuYWJsZWQgPSBmYWxzZTtcblxuXHRcdGlmICh0aGlzLl90cmFuc3BvcnQpXG5cdFx0XHR0aGlzLl90cmFuc3BvcnQucGF1c2VQcm9kdWNlcih0aGlzLCBhcHBEYXRhKTtcblxuXHRcdHRoaXMuc2FmZUVtaXQoJ3BhdXNlJywgJ2xvY2FsJywgYXBwRGF0YSk7XG5cblx0XHQvLyBSZXR1cm4gdHJ1ZSBpZiByZWFsbHkgcGF1c2VkLlxuXHRcdHJldHVybiB0aGlzLnBhdXNlZDtcblx0fVxuXG5cdC8qKlxuXHQgKiBNeSByZW1vdGUgUHJvZHVjZXIgd2FzIHBhdXNlZC5cblx0ICogSW52b2tlZCB2aWEgcmVtb3RlIG5vdGlmaWNhdGlvbi5cblx0ICpcblx0ICogQHByaXZhdGVcblx0ICpcblx0ICogQHBhcmFtIHtBbnl9IFthcHBEYXRhXSAtIEFwcCBjdXN0b20gZGF0YS5cblx0ICovXG5cdHJlbW90ZVBhdXNlKGFwcERhdGEpXG5cdHtcblx0XHRsb2dnZXIuZGVidWcoJ3JlbW90ZVBhdXNlKCknKTtcblxuXHRcdGlmICh0aGlzLl9jbG9zZWQgfHwgdGhpcy5fcmVtb3RlbHlQYXVzZWQpXG5cdFx0XHRyZXR1cm47XG5cblx0XHR0aGlzLl9yZW1vdGVseVBhdXNlZCA9IHRydWU7XG5cdFx0dGhpcy5fdHJhY2suZW5hYmxlZCA9IGZhbHNlO1xuXG5cdFx0dGhpcy5zYWZlRW1pdCgncGF1c2UnLCAncmVtb3RlJywgYXBwRGF0YSk7XG5cdH1cblxuXHQvKipcblx0ICogUmVzdW1lcyBzZW5kaW5nIG1lZGlhLlxuXHQgKlxuXHQgKiBAcGFyYW0ge0FueX0gW2FwcERhdGFdIC0gQXBwIGN1c3RvbSBkYXRhLlxuXHQgKlxuXHQgKiBAcmV0dXJuIHtCb29sZWFufSB0cnVlIGlmIG5vdCBwYXVzZWQuXG5cdCAqL1xuXHRyZXN1bWUoYXBwRGF0YSlcblx0e1xuXHRcdGxvZ2dlci5kZWJ1ZygncmVzdW1lKCknKTtcblxuXHRcdGlmICh0aGlzLl9jbG9zZWQpXG5cdFx0e1xuXHRcdFx0bG9nZ2VyLmVycm9yKCdyZXN1bWUoKSB8IFByb2R1Y2VyIGNsb3NlZCcpO1xuXG5cdFx0XHRyZXR1cm4gZmFsc2U7XG5cdFx0fVxuXHRcdGVsc2UgaWYgKCF0aGlzLl9sb2NhbGx5UGF1c2VkKVxuXHRcdHtcblx0XHRcdHJldHVybiB0cnVlO1xuXHRcdH1cblxuXHRcdHRoaXMuX2xvY2FsbHlQYXVzZWQgPSBmYWxzZTtcblxuXHRcdGlmICghdGhpcy5fcmVtb3RlbHlQYXVzZWQpXG5cdFx0XHR0aGlzLl90cmFjay5lbmFibGVkID0gdHJ1ZTtcblxuXHRcdGlmICh0aGlzLl90cmFuc3BvcnQpXG5cdFx0XHR0aGlzLl90cmFuc3BvcnQucmVzdW1lUHJvZHVjZXIodGhpcywgYXBwRGF0YSk7XG5cblx0XHR0aGlzLnNhZmVFbWl0KCdyZXN1bWUnLCAnbG9jYWwnLCBhcHBEYXRhKTtcblxuXHRcdC8vIFJldHVybiB0cnVlIGlmIG5vdCBwYXVzZWQuXG5cdFx0cmV0dXJuICF0aGlzLnBhdXNlZDtcblx0fVxuXG5cdC8qKlxuXHQgKiBNeSByZW1vdGUgUHJvZHVjZXIgd2FzIHJlc3VtZWQuXG5cdCAqIEludm9rZWQgdmlhIHJlbW90ZSBub3RpZmljYXRpb24uXG5cdCAqXG5cdCAqIEBwcml2YXRlXG5cdCAqXG5cdCAqIEBwYXJhbSB7QW55fSBbYXBwRGF0YV0gLSBBcHAgY3VzdG9tIGRhdGEuXG5cdCAqL1xuXHRyZW1vdGVSZXN1bWUoYXBwRGF0YSlcblx0e1xuXHRcdGxvZ2dlci5kZWJ1ZygncmVtb3RlUmVzdW1lKCknKTtcblxuXHRcdGlmICh0aGlzLl9jbG9zZWQgfHwgIXRoaXMuX3JlbW90ZWx5UGF1c2VkKVxuXHRcdFx0cmV0dXJuO1xuXG5cdFx0dGhpcy5fcmVtb3RlbHlQYXVzZWQgPSBmYWxzZTtcblxuXHRcdGlmICghdGhpcy5fbG9jYWxseVBhdXNlZClcblx0XHRcdHRoaXMuX3RyYWNrLmVuYWJsZWQgPSB0cnVlO1xuXG5cdFx0dGhpcy5zYWZlRW1pdCgncmVzdW1lJywgJ3JlbW90ZScsIGFwcERhdGEpO1xuXHR9XG5cblx0LyoqXG5cdCAqIFJlcGxhY2VzIHRoZSBjdXJyZW50IHRyYWNrIHdpdGggYSBuZXcgb25lLlxuXHQgKlxuXHQgKiBAcGFyYW0ge01lZGlhU3RyZWFtVHJhY2t9IHRyYWNrIC0gTmV3IHRyYWNrLlxuXHQgKlxuXHQgKiBAcmV0dXJuIHtQcm9taXNlfSBSZXNvbHZlcyB3aXRoIHRoZSBuZXcgdHJhY2sgaXRzZWxmLlxuXHQgKi9cblx0cmVwbGFjZVRyYWNrKHRyYWNrKVxuXHR7XG5cdFx0bG9nZ2VyLmRlYnVnKCdyZXBsYWNlVHJhY2soKSBbdHJhY2s6JW9dJywgdHJhY2spO1xuXG5cdFx0aWYgKHRoaXMuX2Nsb3NlZClcblx0XHRcdHJldHVybiBQcm9taXNlLnJlamVjdChuZXcgSW52YWxpZFN0YXRlRXJyb3IoJ1Byb2R1Y2VyIGNsb3NlZCcpKTtcblx0XHRlbHNlIGlmICghKHRyYWNrIGluc3RhbmNlb2YgTWVkaWFTdHJlYW1UcmFjaykpXG5cdFx0XHRyZXR1cm4gUHJvbWlzZS5yZWplY3QobmV3IFR5cGVFcnJvcigndHJhY2sgaXMgbm90IGEgTWVkaWFTdHJlYW1UcmFjaycpKTtcblx0XHRlbHNlIGlmICh0cmFjay5yZWFkeVN0YXRlID09PSAnZW5kZWQnKVxuXHRcdFx0cmV0dXJuIFByb21pc2UucmVqZWN0KG5ldyBFcnJvcigndHJhY2sucmVhZHlTdGF0ZSBpcyBcImVuZGVkXCInKSk7XG5cblx0XHRsZXQgY2xvbmVkVHJhY2s7XG5cblx0XHR0cnlcblx0XHR7XG5cdFx0XHRjbG9uZWRUcmFjayA9IHRyYWNrLmNsb25lKCk7XG5cdFx0fVxuXHRcdGNhdGNoIChlcnJvcilcblx0XHR7XG5cdFx0XHRjbG9uZWRUcmFjayA9IHRyYWNrO1xuXHRcdH1cblxuXHRcdHJldHVybiBQcm9taXNlLnJlc29sdmUoKVxuXHRcdFx0LnRoZW4oKCkgPT5cblx0XHRcdHtcblx0XHRcdFx0Ly8gSWYgdGhpcyBQcm9kdWNlciBpcyBoYW5kbGVkIGJ5IGEgVHJhbnNwb3J0LCB3ZSBuZWVkIHRvIHRlbGwgaXQgYWJvdXRcblx0XHRcdFx0Ly8gdGhlIG5ldyB0cmFjay5cblx0XHRcdFx0aWYgKHRoaXMuX3RyYW5zcG9ydClcblx0XHRcdFx0XHRyZXR1cm4gdGhpcy5fdHJhbnNwb3J0LnJlcGxhY2VQcm9kdWNlclRyYWNrKHRoaXMsIGNsb25lZFRyYWNrKTtcblx0XHRcdH0pXG5cdFx0XHQudGhlbigoKSA9PlxuXHRcdFx0e1xuXHRcdFx0XHQvLyBTdG9wIHRoZSBwcmV2aW91cyB0cmFjay5cblx0XHRcdFx0dHJ5IHsgdGhpcy5fdHJhY2sub25lbmRlZCA9IG51bGw7IHRoaXMuX3RyYWNrLnN0b3AoKTsgfVxuXHRcdFx0XHRjYXRjaCAoZXJyb3IpIHt9XG5cblx0XHRcdFx0Ly8gSWYgdGhpcyBQcm9kdWNlciB3YXMgbG9jYWxseSBwYXVzZWQvcmVzdW1lZCBhbmQgdGhlIHN0YXRlIG9mIHRoZSBuZXdcblx0XHRcdFx0Ly8gdHJhY2sgZG9lcyBub3QgbWF0Y2gsIGZpeCBpdC5cblx0XHRcdFx0aWYgKCF0aGlzLnBhdXNlZClcblx0XHRcdFx0XHRjbG9uZWRUcmFjay5lbmFibGVkID0gdHJ1ZTtcblx0XHRcdFx0ZWxzZVxuXHRcdFx0XHRcdGNsb25lZFRyYWNrLmVuYWJsZWQgPSBmYWxzZTtcblxuXHRcdFx0XHQvLyBTZXQgdGhlIG5ldyB0cmFja3MuXG5cdFx0XHRcdHRoaXMuX29yaWdpbmFsVHJhY2sgPSB0cmFjaztcblx0XHRcdFx0dGhpcy5fdHJhY2sgPSBjbG9uZWRUcmFjaztcblxuXHRcdFx0XHQvLyBIYW5kbGUgdGhlIGVmZmVjdGl2ZSB0cmFjay5cblx0XHRcdFx0dGhpcy5faGFuZGxlVHJhY2soKTtcblxuXHRcdFx0XHQvLyBSZXR1cm4gdGhlIG5ldyB0cmFjay5cblx0XHRcdFx0cmV0dXJuIHRoaXMuX3RyYWNrO1xuXHRcdFx0fSk7XG5cdH1cblxuXHQvKipcblx0ICogU2V0L3VwZGF0ZSBSVFAgcGFyYW1ldGVycy5cblx0ICpcblx0ICogQHByaXZhdGVcblx0ICpcblx0ICogQHBhcmFtIHtSVENSdHBQYXJhbWV0ZXJzfSBydHBQYXJhbWV0ZXJzXG5cdCAqL1xuXHRzZXRSdHBQYXJhbWV0ZXJzKHJ0cFBhcmFtZXRlcnMpXG5cdHtcblx0XHR0aGlzLl9ydHBQYXJhbWV0ZXJzID0gcnRwUGFyYW1ldGVycztcblx0fVxuXG5cdC8qKlxuXHQgKiBFbmFibGVzIHBlcmlvZGljIHN0YXRzIHJldHJpZXZhbC5cblx0ICovXG5cdGVuYWJsZVN0YXRzKGludGVydmFsID0gREVGQVVMVF9TVEFUU19JTlRFUlZBTClcblx0e1xuXHRcdGxvZ2dlci5kZWJ1ZygnZW5hYmxlU3RhdHMoKSBbaW50ZXJ2YWw6JXNdJywgaW50ZXJ2YWwpO1xuXG5cdFx0aWYgKHRoaXMuX2Nsb3NlZClcblx0XHR7XG5cdFx0XHRsb2dnZXIuZXJyb3IoJ2VuYWJsZVN0YXRzKCkgfCBQcm9kdWNlciBjbG9zZWQnKTtcblxuXHRcdFx0cmV0dXJuO1xuXHRcdH1cblxuXHRcdGlmICh0aGlzLl9zdGF0c0VuYWJsZWQpXG5cdFx0XHRyZXR1cm47XG5cblx0XHRpZiAodHlwZW9mIGludGVydmFsICE9PSAnbnVtYmVyJyB8fCBpbnRlcnZhbCA8IDEwMDApXG5cdFx0XHR0aGlzLl9zdGF0c0ludGVydmFsID0gREVGQVVMVF9TVEFUU19JTlRFUlZBTDtcblx0XHRlbHNlXG5cdFx0XHR0aGlzLl9zdGF0c0ludGVydmFsID0gaW50ZXJ2YWw7XG5cblx0XHR0aGlzLl9zdGF0c0VuYWJsZWQgPSB0cnVlO1xuXG5cdFx0aWYgKHRoaXMuX3RyYW5zcG9ydClcblx0XHRcdHRoaXMuX3RyYW5zcG9ydC5lbmFibGVQcm9kdWNlclN0YXRzKHRoaXMsIHRoaXMuX3N0YXRzSW50ZXJ2YWwpO1xuXHR9XG5cblx0LyoqXG5cdCAqIERpc2FibGVzIHBlcmlvZGljIHN0YXRzIHJldHJpZXZhbC5cblx0ICovXG5cdGRpc2FibGVTdGF0cygpXG5cdHtcblx0XHRsb2dnZXIuZGVidWcoJ2Rpc2FibGVTdGF0cygpJyk7XG5cblx0XHRpZiAodGhpcy5fY2xvc2VkKVxuXHRcdHtcblx0XHRcdGxvZ2dlci5lcnJvcignZGlzYWJsZVN0YXRzKCkgfCBQcm9kdWNlciBjbG9zZWQnKTtcblxuXHRcdFx0cmV0dXJuO1xuXHRcdH1cblxuXHRcdGlmICghdGhpcy5fc3RhdHNFbmFibGVkKVxuXHRcdFx0cmV0dXJuO1xuXG5cdFx0dGhpcy5fc3RhdHNFbmFibGVkID0gZmFsc2U7XG5cblx0XHRpZiAodGhpcy5fdHJhbnNwb3J0KVxuXHRcdFx0dGhpcy5fdHJhbnNwb3J0LmRpc2FibGVQcm9kdWNlclN0YXRzKHRoaXMpO1xuXHR9XG5cblx0LyoqXG5cdCAqIFJlY2VpdmUgcmVtb3RlIHN0YXRzLlxuXHQgKlxuXHQgKiBAcHJpdmF0ZVxuXHQgKlxuXHQgKiBAcGFyYW0ge09iamVjdH0gc3RhdHNcblx0ICovXG5cdHJlbW90ZVN0YXRzKHN0YXRzKVxuXHR7XG5cdFx0dGhpcy5zYWZlRW1pdCgnc3RhdHMnLCBzdGF0cyk7XG5cdH1cblxuXHQvKipcblx0ICogQHByaXZhdGVcblx0ICovXG5cdF9oYW5kbGVUcmFjaygpXG5cdHtcblx0XHQvLyBJZiB0aGUgY2xvbmVkIHRyYWNrIGlzIGNsb3NlZCAoZm9yIGV4YW1wbGUgaWYgdGhlIGRlc2t0b3Agc2hhcmluZyBpcyBjbG9zZWRcblx0XHQvLyB2aWEgY2hyb21lIFVJKSBub3RpZnkgdGhlIGFwcCBhbmQgbGV0IGl0IGRlY2lkZSB3aGV0ZXIgdG8gY2xvc2UgdGhlIFByb2R1Y2VyXG5cdFx0Ly8gb3Igbm90LlxuXHRcdHRoaXMuX3RyYWNrLm9uZW5kZWQgPSAoKSA9PlxuXHRcdHtcblx0XHRcdGlmICh0aGlzLl9jbG9zZWQpXG5cdFx0XHRcdHJldHVybjtcblxuXHRcdFx0bG9nZ2VyLndhcm4oJ3RyYWNrIFwiZW5kZWRcIiBldmVudCcpO1xuXG5cdFx0XHR0aGlzLnNhZmVFbWl0KCd0cmFja2VuZGVkJyk7XG5cdFx0fTtcblx0fVxufVxuIiwiaW1wb3J0IExvZ2dlciBmcm9tICcuL0xvZ2dlcic7XG5pbXBvcnQgRW5oYW5jZWRFdmVudEVtaXR0ZXIgZnJvbSAnLi9FbmhhbmNlZEV2ZW50RW1pdHRlcic7XG5pbXBvcnQgeyBJbnZhbGlkU3RhdGVFcnJvciwgVGltZW91dEVycm9yLCBVbnN1cHBvcnRlZEVycm9yIH0gZnJvbSAnLi9lcnJvcnMnO1xuaW1wb3J0ICogYXMgb3J0YyBmcm9tICcuL29ydGMnO1xuaW1wb3J0IERldmljZSBmcm9tICcuL0RldmljZSc7XG5pbXBvcnQgVHJhbnNwb3J0IGZyb20gJy4vVHJhbnNwb3J0JztcbmltcG9ydCBQcm9kdWNlciBmcm9tICcuL1Byb2R1Y2VyJztcbmltcG9ydCBQZWVyIGZyb20gJy4vUGVlcic7XG5pbXBvcnQgQ29uc3VtZXIgZnJvbSAnLi9Db25zdW1lcic7XG5cbmNvbnN0IGxvZ2dlciA9IG5ldyBMb2dnZXIoJ1Jvb20nKTtcblxuY29uc3QgUm9vbVN0YXRlID1cbntcblx0bmV3ICAgICA6ICduZXcnLFxuXHRqb2luaW5nIDogJ2pvaW5pbmcnLFxuXHRqb2luZWQgIDogJ2pvaW5lZCcsXG5cdGNsb3NlZCAgOiAnY2xvc2VkJ1xufTtcblxuLyoqXG4gKiBBbiBpbnN0YW5jZSBvZiBSb29tIHJlcHJlc2VudHMgYSByZW1vdGUgbXVsdGkgY29uZmVyZW5jZSBhbmQgYSBsb2NhbFxuICogcGVlciB0aGF0IGpvaW5zIGl0LlxuICovXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBSb29tIGV4dGVuZHMgRW5oYW5jZWRFdmVudEVtaXR0ZXJcbntcblx0LyoqXG5cdCAqIFJvb20gY2xhc3MuXG5cdCAqXG5cdCAqIEBwYXJhbSB7T2JqZWN0fSBbb3B0aW9uc11cblx0ICogQHBhcmFtIHtPYmplY3R9IFtyb29tU2V0dGluZ3NdIFJlbW90ZSByb29tIHNldHRpbmdzLCBpbmNsdWRpbmcgaXRzIFJUUFxuXHQgKiBjYXBhYmlsaXRpZXMsIG1hbmRhdG9yeSBjb2RlY3MsIGV0Yy4gSWYgZ2l2ZW4sIG5vICdxdWVyeVJvb20nIHJlcXVlc3QgaXMgc2VudFxuXHQgKiB0byB0aGUgc2VydmVyIHRvIGRpc2NvdmVyIHRoZW0uXG5cdCAqIEBwYXJhbSB7TnVtYmVyfSBbb3B0aW9ucy5yZXF1ZXN0VGltZW91dD0xMDAwMF0gLSBUaW1lb3V0IGZvciBzZW50IHJlcXVlc3RzXG5cdCAqIChpbiBtaWxsaXNlY29uZHMpLiBEZWZhdWx0cyB0byAxMDAwMCAoMTAgc2Vjb25kcykuXG5cdCAqIEBwYXJhbSB7T2JqZWN0fSBbb3B0aW9ucy50cmFuc3BvcnRPcHRpb25zXSAtIE9wdGlvbnMgZm9yIFRyYW5zcG9ydCBjcmVhdGVkIGluIG1lZGlhc291cC5cblx0ICogQHBhcmFtIHtBcnJheTxSVENJY2VTZXJ2ZXI+fSBbb3B0aW9ucy50dXJuU2VydmVyc10gLSBBcnJheSBvZiBUVVJOIHNlcnZlcnMuXG5cdCAqXG5cdCAqIEB0aHJvd3Mge0Vycm9yfSBpZiBkZXZpY2UgaXMgbm90IHN1cHBvcnRlZC5cblx0ICpcblx0ICogQGVtaXRzIHtyZXF1ZXN0OiBPYmplY3QsIGNhbGxiYWNrOiBGdW5jdGlvbiwgZXJyYmFjazogRnVuY3Rpb259IHJlcXVlc3Rcblx0ICogQGVtaXRzIHtub3RpZmljYXRpb246IE9iamVjdH0gbm90aWZ5XG5cdCAqIEBlbWl0cyB7cGVlcjogUGVlcn0gbmV3cGVlclxuXHQgKiBAZW1pdHMge29yaWdpbmF0b3I6IFN0cmluZywgW2FwcERhdGFdOiBBbnl9IGNsb3NlXG5cdCAqL1xuXHRjb25zdHJ1Y3RvcihvcHRpb25zKVxuXHR7XG5cdFx0c3VwZXIobG9nZ2VyKTtcblxuXHRcdGxvZ2dlci5kZWJ1ZygnY29uc3RydWN0b3IoKSBbb3B0aW9uczolb10nLCBvcHRpb25zKTtcblxuXHRcdGlmICghRGV2aWNlLmlzU3VwcG9ydGVkKCkpXG5cdFx0XHR0aHJvdyBuZXcgRXJyb3IoJ2N1cnJlbnQgYnJvd3Nlci9kZXZpY2Ugbm90IHN1cHBvcnRlZCcpO1xuXG5cdFx0b3B0aW9ucyA9IG9wdGlvbnMgfHwge307XG5cblx0XHQvLyBDb21wdXRlZCBzZXR0aW5ncy5cblx0XHQvLyBAdHlwZSB7T2JqZWN0fVxuXHRcdHRoaXMuX3NldHRpbmdzID1cblx0XHR7XG5cdFx0XHRyb29tU2V0dGluZ3MgICAgIDogb3B0aW9ucy5yb29tU2V0dGluZ3MsXG5cdFx0XHRyZXF1ZXN0VGltZW91dCAgIDogb3B0aW9ucy5yZXF1ZXN0VGltZW91dCB8fCAxMDAwMCxcblx0XHRcdHRyYW5zcG9ydE9wdGlvbnMgOiBvcHRpb25zLnRyYW5zcG9ydE9wdGlvbnMgfHwge30sXG5cdFx0XHR0dXJuU2VydmVycyAgICAgIDogb3B0aW9ucy50dXJuU2VydmVycyB8fCBbXVxuXHRcdH07XG5cblx0XHQvLyBSb29tIHN0YXRlLlxuXHRcdC8vIEB0eXBlIHtCb29sZWFufVxuXHRcdHRoaXMuX3N0YXRlID0gUm9vbVN0YXRlLm5ldztcblxuXHRcdC8vIE15IG1lZGlhc291cCBQZWVyIG5hbWUuXG5cdFx0Ly8gQHR5cGUge1N0cmluZ31cblx0XHR0aGlzLl9wZWVyTmFtZSA9IG51bGw7XG5cblx0XHQvLyBNYXAgb2YgVHJhbnNwb3J0cyBpbmRleGVkIGJ5IGlkLlxuXHRcdC8vIEB0eXBlIHttYXA8TnVtYmVyLCBUcmFuc3BvcnQ+fVxuXHRcdHRoaXMuX3RyYW5zcG9ydHMgPSBuZXcgTWFwKCk7XG5cblx0XHQvLyBNYXAgb2YgUHJvZHVjZXJzIGluZGV4ZWQgYnkgaWQuXG5cdFx0Ly8gQHR5cGUge21hcDxOdW1iZXIsIFByb2R1Y2VyPn1cblx0XHR0aGlzLl9wcm9kdWNlcnMgPSBuZXcgTWFwKCk7XG5cblx0XHQvLyBNYXAgb2YgUGVlcnMgaW5kZXhlZCBieSBuYW1lLlxuXHRcdC8vIEB0eXBlIHttYXA8U3RyaW5nLCBQZWVyPn1cblx0XHR0aGlzLl9wZWVycyA9IG5ldyBNYXAoKTtcblxuXHRcdC8vIEV4dGVuZGVkIFJUUCBjYXBhYmlsaXRpZXMuXG5cdFx0Ly8gQHR5cGUge09iamVjdH1cblx0XHR0aGlzLl9leHRlbmRlZFJ0cENhcGFiaWxpdGllcyA9IG51bGw7XG5cblx0XHQvLyBXaGV0aGVyIHdlIGNhbiBzZW5kIGF1ZGlvL3ZpZGVvIGJhc2VkIG9uIGNvbXB1dGVkIGV4dGVuZGVkIFJUUFxuXHRcdC8vIGNhcGFiaWxpdGllcy5cblx0XHQvLyBAdHlwZSB7T2JqZWN0fVxuXHRcdHRoaXMuX2NhblNlbmRCeUtpbmQgPVxuXHRcdHtcblx0XHRcdGF1ZGlvIDogZmFsc2UsXG5cdFx0XHR2aWRlbyA6IGZhbHNlXG5cdFx0fTtcblxuXHRcdHRoaXMucGVlcnNDb25uZWN0aW5nUXVldWUgPSBuZXcgU2V0KCk7XG5cdH1cblxuXHQvKipcblx0ICogV2hldGhlciB0aGUgUm9vbSBpcyBqb2luZWQuXG5cdCAqXG5cdCAqIEByZXR1cm4ge0Jvb2xlYW59XG5cdCAqL1xuXHRnZXQgam9pbmVkKClcblx0e1xuXHRcdHJldHVybiB0aGlzLl9zdGF0ZSA9PT0gUm9vbVN0YXRlLmpvaW5lZDtcblx0fVxuXG5cdC8qKlxuXHQgKiBXaGV0aGVyIHRoZSBSb29tIGlzIGNsb3NlZC5cblx0ICpcblx0ICogQHJldHVybiB7Qm9vbGVhbn1cblx0ICovXG5cdGdldCBjbG9zZWQoKVxuXHR7XG5cdFx0cmV0dXJuIHRoaXMuX3N0YXRlID09PSBSb29tU3RhdGUuY2xvc2VkO1xuXHR9XG5cblx0LyoqXG5cdCAqIE15IG1lZGlhc291cCBQZWVyIG5hbWUuXG5cdCAqXG5cdCAqIEByZXR1cm4ge1N0cmluZ31cblx0ICovXG5cdGdldCBwZWVyTmFtZSgpXG5cdHtcblx0XHRyZXR1cm4gdGhpcy5fcGVlck5hbWU7XG5cdH1cblxuXHQvKipcblx0ICogVGhlIGxpc3Qgb2YgVHJhbnNwb3J0cy5cblx0ICpcblx0ICogQHJldHVybiB7QXJyYXk8VHJhbnNwb3J0Pn1cblx0ICovXG5cdGdldCB0cmFuc3BvcnRzKClcblx0e1xuXHRcdHJldHVybiBBcnJheS5mcm9tKHRoaXMuX3RyYW5zcG9ydHMudmFsdWVzKCkpO1xuXHR9XG5cblx0LyoqXG5cdCAqIFRoZSBsaXN0IG9mIFByb2R1Y2Vycy5cblx0ICpcblx0ICogQHJldHVybiB7QXJyYXk8UHJvZHVjZXI+fVxuXHQgKi9cblx0Z2V0IHByb2R1Y2VycygpXG5cdHtcblx0XHRyZXR1cm4gQXJyYXkuZnJvbSh0aGlzLl9wcm9kdWNlcnMudmFsdWVzKCkpO1xuXHR9XG5cblx0LyoqXG5cdCAqIFRoZSBsaXN0IG9mIFBlZXJzLlxuXHQgKlxuXHQgKiBAcmV0dXJuIHtBcnJheTxQZWVyPn1cblx0ICovXG5cdGdldCBwZWVycygpXG5cdHtcblx0XHRyZXR1cm4gQXJyYXkuZnJvbSh0aGlzLl9wZWVycy52YWx1ZXMoKSk7XG5cdH1cblxuXHQvKipcblx0ICogR2V0IHRoZSBUcmFuc3BvcnQgd2l0aCB0aGUgZ2l2ZW4gaWQuXG5cdCAqXG5cdCAqIEBwYXJhbSB7TnVtYmVyfSBpZFxuXHQgKlxuXHQgKiBAcmV0dXJuIHtUcmFuc3BvcnR9XG5cdCAqL1xuXHRnZXRUcmFuc3BvcnRCeUlkKGlkKVxuXHR7XG5cdFx0cmV0dXJuIHRoaXMuX3RyYW5zcG9ydHMuZ2V0KGlkKTtcblx0fVxuXG5cdC8qKlxuXHQgKiBHZXQgdGhlIFByb2R1Y2VyIHdpdGggdGhlIGdpdmVuIGlkLlxuXHQgKlxuXHQgKiBAcGFyYW0ge051bWJlcn0gaWRcblx0ICpcblx0ICogQHJldHVybiB7UHJvZHVjZXJ9XG5cdCAqL1xuXHRnZXRQcm9kdWNlckJ5SWQoaWQpXG5cdHtcblx0XHRyZXR1cm4gdGhpcy5fcHJvZHVjZXJzLmdldChpZCk7XG5cdH1cblxuXHQvKipcblx0ICogR2V0IHRoZSBQZWVyIHdpdGggdGhlIGdpdmVuIG5hbWUuXG5cdCAqXG5cdCAqIEBwYXJhbSB7U3RyaW5nfSBuYW1lXG5cdCAqXG5cdCAqIEByZXR1cm4ge1BlZXJ9XG5cdCAqL1xuXHRnZXRQZWVyQnlOYW1lKG5hbWUpXG5cdHtcblx0XHRyZXR1cm4gdGhpcy5fcGVlcnMuZ2V0KG5hbWUpO1xuXHR9XG5cblx0LyoqXG5cdCAqIFN0YXJ0IHRoZSBwcm9jZWR1cmVzIHRvIGpvaW4gYSByZW1vdGUgcm9vbS5cblx0ICogQHBhcmFtIHtTdHJpbmd9IHBlZXJOYW1lIC0gTXkgbWVkaWFzb3VwIFBlZXIgbmFtZS5cblx0ICogQHBhcmFtIHtBbnl9IFthcHBEYXRhXSAtIEFwcCBjdXN0b20gZGF0YS5cblx0ICogQHJldHVybiB7UHJvbWlzZX1cblx0ICovXG5cdGpvaW4ocGVlck5hbWUsIGFwcERhdGEpXG5cdHtcblx0XHRsb2dnZXIuZGVidWcoJ2pvaW4oKSBbcGVlck5hbWU6XCIlc1wiXScsIHBlZXJOYW1lKTtcblxuXHRcdGlmICh0eXBlb2YgcGVlck5hbWUgIT09ICdzdHJpbmcnKVxuXHRcdFx0cmV0dXJuIFByb21pc2UucmVqZWN0KG5ldyBUeXBlRXJyb3IoJ2ludmFsaWQgcGVlck5hbWUnKSk7XG5cblx0XHRpZiAodGhpcy5fc3RhdGUgIT09IFJvb21TdGF0ZS5uZXcgJiYgdGhpcy5fc3RhdGUgIT09IFJvb21TdGF0ZS5jbG9zZWQpXG5cdFx0e1xuXHRcdFx0cmV0dXJuIFByb21pc2UucmVqZWN0KFxuXHRcdFx0XHRuZXcgSW52YWxpZFN0YXRlRXJyb3IoYGludmFsaWQgc3RhdGUgXCIke3RoaXMuX3N0YXRlfVwiYCkpO1xuXHRcdH1cblxuXHRcdHRoaXMuX3BlZXJOYW1lID0gcGVlck5hbWU7XG5cdFx0dGhpcy5fc3RhdGUgPSBSb29tU3RhdGUuam9pbmluZztcblxuXHRcdGxldCByb29tU2V0dGluZ3M7XG5cblx0XHRyZXR1cm4gUHJvbWlzZS5yZXNvbHZlKClcblx0XHRcdC50aGVuKCgpID0+XG5cdFx0XHR7XG5cdFx0XHRcdC8vIElmIFJvb20gc2V0dGluZ3MgYXJlIHByb3ZpZGVkIGRvbid0IHF1ZXJ5IHRoZW0uXG5cdFx0XHRcdGlmICh0aGlzLl9zZXR0aW5ncy5yb29tU2V0dGluZ3MpXG5cdFx0XHRcdHtcblx0XHRcdFx0XHRyb29tU2V0dGluZ3MgPSB0aGlzLl9zZXR0aW5ncy5yb29tU2V0dGluZ3M7XG5cblx0XHRcdFx0XHRyZXR1cm47XG5cdFx0XHRcdH1cblx0XHRcdFx0ZWxzZVxuXHRcdFx0XHR7XG5cdFx0XHRcdFx0cmV0dXJuIHRoaXMuX3NlbmRSZXF1ZXN0KCdxdWVyeVJvb20nLCB7IHRhcmdldDogJ3Jvb20nIH0pXG5cdFx0XHRcdFx0XHQudGhlbigocmVzcG9uc2UpID0+XG5cdFx0XHRcdFx0XHR7XG5cdFx0XHRcdFx0XHRcdHJvb21TZXR0aW5ncyA9IHJlc3BvbnNlO1xuXG5cdFx0XHRcdFx0XHRcdGxvZ2dlci5kZWJ1Zyhcblx0XHRcdFx0XHRcdFx0XHQnam9pbigpIHwgZ290IFJvb20gc2V0dGluZ3M6JW8nLCByb29tU2V0dGluZ3MpO1xuXHRcdFx0XHRcdFx0fSk7XG5cdFx0XHRcdH1cblx0XHRcdH0pXG5cdFx0XHQudGhlbigoKSA9PlxuXHRcdFx0e1xuXHRcdFx0XHRyZXR1cm4gRGV2aWNlLkhhbmRsZXIuZ2V0TmF0aXZlUnRwQ2FwYWJpbGl0aWVzKCk7XG5cdFx0XHR9KVxuXHRcdFx0LnRoZW4oKG5hdGl2ZVJ0cENhcGFiaWxpdGllcykgPT5cblx0XHRcdHtcblx0XHRcdFx0bG9nZ2VyLmRlYnVnKFxuXHRcdFx0XHRcdCdqb2luKCkgfCBuYXRpdmUgUlRQIGNhcGFiaWxpdGllczolbycsIG5hdGl2ZVJ0cENhcGFiaWxpdGllcyk7XG5cblx0XHRcdFx0Ly8gR2V0IGV4dGVuZGVkIFJUUCBjYXBhYmlsaXRpZXMuXG5cdFx0XHRcdHRoaXMuX2V4dGVuZGVkUnRwQ2FwYWJpbGl0aWVzID0gb3J0Yy5nZXRFeHRlbmRlZFJ0cENhcGFiaWxpdGllcyhcblx0XHRcdFx0XHRuYXRpdmVSdHBDYXBhYmlsaXRpZXMsIHJvb21TZXR0aW5ncy5ydHBDYXBhYmlsaXRpZXMpO1xuXG5cdFx0XHRcdGxvZ2dlci5kZWJ1Zyhcblx0XHRcdFx0XHQnam9pbigpIHwgZXh0ZW5kZWQgUlRQIGNhcGFiaWxpdGllczolbycsIHRoaXMuX2V4dGVuZGVkUnRwQ2FwYWJpbGl0aWVzKTtcblxuXHRcdFx0XHQvLyBDaGVjayB1bnN1cHBvcnRlZCBjb2RlY3MuXG5cdFx0XHRcdGNvbnN0IHVuc3VwcG9ydGVkUm9vbUNvZGVjcyA9IG9ydGMuZ2V0VW5zdXBwb3J0ZWRDb2RlY3MoXG5cdFx0XHRcdFx0cm9vbVNldHRpbmdzLnJ0cENhcGFiaWxpdGllcyxcblx0XHRcdFx0XHRyb29tU2V0dGluZ3MubWFuZGF0b3J5Q29kZWNQYXlsb2FkVHlwZXMsXG5cdFx0XHRcdFx0dGhpcy5fZXh0ZW5kZWRSdHBDYXBhYmlsaXRpZXMpO1xuXG5cdFx0XHRcdGlmICh1bnN1cHBvcnRlZFJvb21Db2RlY3MubGVuZ3RoID4gMClcblx0XHRcdFx0e1xuXHRcdFx0XHRcdGxvZ2dlci5lcnJvcihcblx0XHRcdFx0XHRcdCclcyBtYW5kYXRvcnkgcm9vbSBjb2RlY3Mgbm90IHN1cHBvcnRlZDolbycsXG5cdFx0XHRcdFx0XHR1bnN1cHBvcnRlZFJvb21Db2RlY3MubGVuZ3RoLFxuXHRcdFx0XHRcdFx0dW5zdXBwb3J0ZWRSb29tQ29kZWNzKTtcblxuXHRcdFx0XHRcdHRocm93IG5ldyBVbnN1cHBvcnRlZEVycm9yKFxuXHRcdFx0XHRcdFx0J21hbmRhdG9yeSByb29tIGNvZGVjcyBub3Qgc3VwcG9ydGVkJywgdW5zdXBwb3J0ZWRSb29tQ29kZWNzKTtcblx0XHRcdFx0fVxuXG5cdFx0XHRcdC8vIENoZWNrIHdoZXRoZXIgd2UgY2FuIHNlbmQgYXVkaW8vdmlkZW8uXG5cdFx0XHRcdHRoaXMuX2NhblNlbmRCeUtpbmQuYXVkaW8gPVxuXHRcdFx0XHRcdG9ydGMuY2FuU2VuZCgnYXVkaW8nLCB0aGlzLl9leHRlbmRlZFJ0cENhcGFiaWxpdGllcyk7XG5cdFx0XHRcdHRoaXMuX2NhblNlbmRCeUtpbmQudmlkZW8gPVxuXHRcdFx0XHRcdG9ydGMuY2FuU2VuZCgndmlkZW8nLCB0aGlzLl9leHRlbmRlZFJ0cENhcGFiaWxpdGllcyk7XG5cblx0XHRcdFx0Ly8gR2VuZXJhdGUgb3VyIGVmZmVjdGl2ZSBSVFAgY2FwYWJpbGl0aWVzIGZvciByZWNlaXZpbmcgbWVkaWEuXG5cdFx0XHRcdGNvbnN0IGVmZmVjdGl2ZUxvY2FsUnRwQ2FwYWJpbGl0aWVzID1cblx0XHRcdFx0XHRvcnRjLmdldFJ0cENhcGFiaWxpdGllcyh0aGlzLl9leHRlbmRlZFJ0cENhcGFiaWxpdGllcyk7XG5cblx0XHRcdFx0bG9nZ2VyLmRlYnVnKFxuXHRcdFx0XHRcdCdqb2luKCkgfCBlZmZlY3RpdmUgbG9jYWwgUlRQIGNhcGFiaWxpdGllcyBmb3IgcmVjZWl2aW5nOiVvJyxcblx0XHRcdFx0XHRlZmZlY3RpdmVMb2NhbFJ0cENhcGFiaWxpdGllcyk7XG5cblx0XHRcdFx0Y29uc3QgZGF0YSA9XG5cdFx0XHRcdHtcblx0XHRcdFx0XHR0YXJnZXQgICAgICAgICAgOiAncm9vbScsXG5cdFx0XHRcdFx0cGVlck5hbWUgICAgICAgIDogdGhpcy5fcGVlck5hbWUsXG5cdFx0XHRcdFx0cnRwQ2FwYWJpbGl0aWVzIDogZWZmZWN0aXZlTG9jYWxSdHBDYXBhYmlsaXRpZXMsXG5cdFx0XHRcdFx0YXBwRGF0YSAgICAgICAgIDogYXBwRGF0YVxuXHRcdFx0XHR9O1xuXG5cdFx0XHRcdHJldHVybiB0aGlzLl9zZW5kUmVxdWVzdCgnam9pbicsIGRhdGEpXG5cdFx0XHRcdFx0LnRoZW4oKHJlc3BvbnNlKSA9PiByZXNwb25zZS5wZWVycyk7XG5cdFx0XHR9KVxuXHRcdFx0LnRoZW4oKHBlZXJzKSA9PlxuXHRcdFx0e1xuXHRcdFx0XHQvLyBIYW5kbGUgUGVlcnMgYWxyZWFkeSBleGlzdGluZyBpbiB0aGUgcm9vbS5cblx0XHRcdFx0LyogZm9yIChjb25zdCBwZWVyRGF0YSBvZiBwZWVycyB8fCBbXSlcblx0XHRcdFx0e1xuXHRcdFx0XHRcdHRyeVxuXHRcdFx0XHRcdHtcblx0XHRcdFx0XHRcdHRoaXMuX2hhbmRsZVBlZXJEYXRhKHBlZXJEYXRhKTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0Y2F0Y2ggKGVycm9yKVxuXHRcdFx0XHRcdHtcblx0XHRcdFx0XHRcdGxvZ2dlci5lcnJvcignam9pbigpIHwgZXJyb3IgaGFuZGxpbmcgUGVlcjolbycsIGVycm9yKTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH0gKi9cblxuXHRcdFx0XHR0aGlzLl9zdGF0ZSA9IFJvb21TdGF0ZS5qb2luZWQ7XG5cblx0XHRcdFx0bG9nZ2VyLmRlYnVnKCdqb2luKCkgfCBqb2luZWQgdGhlIFJvb20nKTtcblxuXHRcdFx0XHQvLyBSZXR1cm4gdGhlIGxpc3Qgb2YgYWxyZWFkeSBleGlzdGluZyBQZWVycy5cblx0XHRcdFx0cmV0dXJuIHRoaXMucGVlcnM7XG5cdFx0XHR9KVxuXHRcdFx0LmNhdGNoKChlcnJvcikgPT5cblx0XHRcdHtcblx0XHRcdFx0dGhpcy5fc3RhdGUgPSBSb29tU3RhdGUubmV3O1xuXG5cdFx0XHRcdHRocm93IGVycm9yO1xuXHRcdFx0fSk7XG5cdH1cblxuXHRyZXF1ZXN0TWVkaWFQZWVyKHBlZXJOYW1lKSB7XG5cblx0XHRpZiAodGhpcy5fcGVlcnMuaGFzKHBlZXJOYW1lKSkge1xuXHRcdFx0cmV0dXJuIFByb21pc2UucmVzb2x2ZSgpXG5cdFx0XHRcdC50aGVuKCgpID0+IHtcblx0XHRcdFx0XHRyZXR1cm4geyBzdGF0dXM6IGZhbHNlIH1cblx0XHRcdFx0fSk7XG5cdFx0fVxuXG5cdFx0aWYgKHRoaXMucGVlcnNDb25uZWN0aW5nUXVldWUuaGFzKHBlZXJOYW1lKSkge1xuXHRcdFx0cmV0dXJuIFByb21pc2UucmVzb2x2ZSgpXG5cdFx0XHRcdC50aGVuKCgpID0+IHtcblx0XHRcdFx0XHRyZXR1cm4geyBzdGF0dXM6IGZhbHNlIH1cblx0XHRcdFx0fSk7XG5cdFx0fVxuXG5cdFx0dGhpcy5wZWVyc0Nvbm5lY3RpbmdRdWV1ZS5hZGQocGVlck5hbWUpO1xuXG5cdFx0bG9nZ2VyLmRlYnVnKCdyZXF1ZXN0TWVkaWFQZWVyKCkgW3BlZXJOYW1lOlwiJXNcIl0nLCBwZWVyTmFtZSk7XG5cblx0XHRyZXR1cm4gUHJvbWlzZS5yZXNvbHZlKClcblx0XHRcdC50aGVuKCgpID0+IHtcblx0XHRcdFx0cmV0dXJuIHRoaXMuX3NlbmRSZXF1ZXN0KCdyZXF1ZXN0TWVkaWFQZWVyJywgeyBwZWVyTmFtZSwgbXlQZWVyTmFtZTogdGhpcy5fcGVlck5hbWUgfSk7XG5cdFx0XHR9KVxuXHRcdFx0LnRoZW4ocmVzcG9uc2UgPT4ge1xuXG5cdFx0XHRcdGlmIChyZXNwb25zZS5zdGF0dXMpIHtcblx0XHRcdFx0XHR0aGlzLl9oYW5kbGVQZWVyRGF0YShyZXNwb25zZS5wZWVyKTtcblx0XHRcdFx0fVxuXG5cdFx0XHRcdHRoaXMucGVlcnNDb25uZWN0aW5nUXVldWUuZGVsZXRlKHBlZXJOYW1lKTtcblxuXHRcdFx0XHRsb2dnZXIuZGVidWcoJ3JlcXVlc3RNZWRpYVBlZXIoKTpzdGF0dXMgW3BlZXJOYW1lOlwiJXNcIiwgc3RhdHVzOlwiJXNcIl0nLCBwZWVyTmFtZSwgcmVzcG9uc2Uuc3RhdHVzKTtcblxuXHRcdFx0XHRyZXR1cm4gcmVzcG9uc2U7XG5cdFx0XHR9KVxuXHRcdFx0LmNhdGNoKChlcnIpID0+IHtcblx0XHRcdFx0dGhpcy5wZWVyc0Nvbm5lY3RpbmdRdWV1ZS5kZWxldGUocGVlck5hbWUpO1xuXHRcdFx0XHRyZXR1cm4gZXJyO1xuXHRcdFx0fSlcblx0fVxuXG5cdHJlcXVlc3RDbG9zZU1lZGlhUGVlcihwZWVyTmFtZSkge1xuXG5cdFx0bG9nZ2VyLmRlYnVnKCdyZXF1ZXN0Q2xvc2VNZWRpYVBlZXIoKSBbcGVlck5hbWU6XCIlc1wiXScsIHBlZXJOYW1lKTtcblxuXHRcdHJldHVybiBQcm9taXNlLnJlc29sdmUoKVxuXHRcdFx0LnRoZW4oKCkgPT4ge1xuXHRcdFx0XHRyZXR1cm4gdGhpcy5fc2VuZFJlcXVlc3QoJ3JlcXVlc3RDbG9zZU1lZGlhUGVlcicsIHsgcGVlck5hbWUsIG15UGVlck5hbWU6IHRoaXMuX3BlZXJOYW1lIH0pO1xuXHRcdFx0fSlcblx0XHRcdC50aGVuKHJlc3BvbnNlID0+IHtcblx0XHRcdFx0bG9nZ2VyLmRlYnVnKCdyZXF1ZXN0Q2xvc2VNZWRpYVBlZXIoKTpzdGF0dXMgW3BlZXJOYW1lOlwiJXNcIiwgc3RhdHVzOlwiJXNcIl0nLCBwZWVyTmFtZSwgcmVzcG9uc2Uuc3RhdHVzKTtcblx0XHRcdFx0cmV0dXJuIHJlc3BvbnNlO1xuXHRcdFx0fSlcblx0fVxuXG5cdC8qKlxuXHQgKiBMZWF2ZSB0aGUgUm9vbS5cblx0ICpcblx0ICogQHBhcmFtIHtBbnl9IFthcHBEYXRhXSAtIEFwcCBjdXN0b20gZGF0YS5cblx0ICovXG5cdGxlYXZlKGFwcERhdGEpXG5cdHtcblx0XHRsb2dnZXIuZGVidWcoJ2xlYXZlKCknKTtcblxuXHRcdGlmICh0aGlzLmNsb3NlZClcblx0XHRcdHJldHVybjtcblxuXHRcdC8vIFNlbmQgYSBub3RpZmljYXRpb24uXG5cdFx0dGhpcy5fc2VuZE5vdGlmaWNhdGlvbignbGVhdmUnLCB7IGFwcERhdGEgfSk7XG5cblx0XHQvLyBTZXQgY2xvc2VkIHN0YXRlIGFmdGVyIHNlbmRpbmcgdGhlIG5vdGlmaWNhdGlvbiAob3RoZXJ3aXNlIHRoZVxuXHRcdC8vIG5vdGlmaWNhdGlvbiB3b24ndCBiZSBzZW50KS5cblx0XHR0aGlzLl9zdGF0ZSA9IFJvb21TdGF0ZS5jbG9zZWQ7XG5cblx0XHR0aGlzLnNhZmVFbWl0KCdjbG9zZScsICdsb2NhbCcsIGFwcERhdGEpO1xuXG5cdFx0Ly8gQ2xvc2UgYWxsIHRoZSBUcmFuc3BvcnRzLlxuXHRcdGZvciAoY29uc3QgdHJhbnNwb3J0IG9mIHRoaXMuX3RyYW5zcG9ydHMudmFsdWVzKCkpXG5cdFx0e1xuXHRcdFx0dHJhbnNwb3J0LmNsb3NlKCk7XG5cdFx0fVxuXG5cdFx0Ly8gQ2xvc2UgYWxsIHRoZSBQcm9kdWNlcnMuXG5cdFx0Zm9yIChjb25zdCBwcm9kdWNlciBvZiB0aGlzLl9wcm9kdWNlcnMudmFsdWVzKCkpXG5cdFx0e1xuXHRcdFx0cHJvZHVjZXIuY2xvc2UoKTtcblx0XHR9XG5cblx0XHQvLyBDbG9zZSBhbGwgdGhlIFBlZXJzLlxuXHRcdGZvciAoY29uc3QgcGVlciBvZiB0aGlzLl9wZWVycy52YWx1ZXMoKSlcblx0XHR7XG5cdFx0XHRwZWVyLmNsb3NlKCk7XG5cdFx0fVxuXHR9XG5cblx0LyoqXG5cdCAqIFRoZSByZW1vdGUgUm9vbSB3YXMgY2xvc2VkIG9yIG91ciByZW1vdGUgUGVlciBoYXMgYmVlbiBjbG9zZWQuXG5cdCAqIEludm9rZWQgdmlhIHJlbW90ZSBub3RpZmljYXRpb24gb3IgdmlhIEFQSS5cblx0ICpcblx0ICogQHBhcmFtIHtBbnl9IFthcHBEYXRhXSAtIEFwcCBjdXN0b20gZGF0YS5cblx0ICovXG5cdHJlbW90ZUNsb3NlKGFwcERhdGEpXG5cdHtcblx0XHRsb2dnZXIuZGVidWcoJ3JlbW90ZUNsb3NlKCknKTtcblxuXHRcdGlmICh0aGlzLmNsb3NlZClcblx0XHRcdHJldHVybjtcblxuXHRcdHRoaXMuX3N0YXRlID0gUm9vbVN0YXRlLmNsb3NlZDtcblxuXHRcdHRoaXMuc2FmZUVtaXQoJ2Nsb3NlJywgJ3JlbW90ZScsIGFwcERhdGEpO1xuXG5cdFx0Ly8gQ2xvc2UgYWxsIHRoZSBUcmFuc3BvcnRzLlxuXHRcdGZvciAoY29uc3QgdHJhbnNwb3J0IG9mIHRoaXMuX3RyYW5zcG9ydHMudmFsdWVzKCkpXG5cdFx0e1xuXHRcdFx0dHJhbnNwb3J0LnJlbW90ZUNsb3NlKCk7XG5cdFx0fVxuXG5cdFx0Ly8gQ2xvc2UgYWxsIHRoZSBQcm9kdWNlcnMuXG5cdFx0Zm9yIChjb25zdCBwcm9kdWNlciBvZiB0aGlzLl9wcm9kdWNlcnMudmFsdWVzKCkpXG5cdFx0e1xuXHRcdFx0cHJvZHVjZXIucmVtb3RlQ2xvc2UoKTtcblx0XHR9XG5cblx0XHQvLyBDbG9zZSBhbGwgdGhlIFBlZXJzLlxuXHRcdGZvciAoY29uc3QgcGVlciBvZiB0aGlzLl9wZWVycy52YWx1ZXMoKSlcblx0XHR7XG5cdFx0XHRwZWVyLnJlbW90ZUNsb3NlKCk7XG5cdFx0fVxuXHR9XG5cblx0LyoqXG5cdCAqIFdoZXRoZXIgd2UgY2FuIHNlbmQgYXVkaW8vdmlkZW8uXG5cdCAqXG5cdCAqIEBwYXJhbSB7U3RyaW5nfSBraW5kIC0gJ2F1ZGlvJyBvciAndmlkZW8nLlxuXHQgKlxuXHQgKiBAcmV0dXJuIHtCb29sZWFufVxuXHQgKi9cblx0Y2FuU2VuZChraW5kKVxuXHR7XG5cdFx0aWYgKCF0aGlzLmpvaW5lZClcblx0XHRcdHRocm93IG5ldyBJbnZhbGlkU3RhdGVFcnJvcihgaW52YWxpZCBzdGF0ZSBcIiR7dGhpcy5fc3RhdGV9XCJgKTtcblx0XHRlbHNlIGlmIChraW5kICE9PSAnYXVkaW8nICYmIGtpbmQgIT09ICd2aWRlbycpXG5cdFx0XHR0aHJvdyBuZXcgVHlwZUVycm9yKGBpbnZhbGlkIGtpbmQgXCIke2tpbmR9XCJgKTtcblxuXHRcdHJldHVybiB0aGlzLl9jYW5TZW5kQnlLaW5kW2tpbmRdO1xuXHR9XG5cblx0LyoqXG5cdCAqIENyZWF0ZXMgYSBUcmFuc3BvcnQuXG5cdCAqXG5cdCAqIEBwYXJhbSB7U3RyaW5nfSBkaXJlY3Rpb24gLSBNdXN0IGJlICdzZW5kJyBvciAncmVjdicuXG5cdCAqIEBwYXJhbSB7QW55fSBbYXBwRGF0YV0gLSBBcHAgY3VzdG9tIGRhdGEuXG5cdCAqXG5cdCAqIEByZXR1cm4ge1RyYW5zcG9ydH1cblx0ICpcblx0ICogQHRocm93cyB7SW52YWxpZFN0YXRlRXJyb3J9IGlmIG5vdCBqb2luZWQuXG5cdCAqIEB0aHJvd3Mge1R5cGVFcnJvcn0gaWYgd3JvbmcgYXJndW1lbnRzLlxuXHQgKi9cblx0Y3JlYXRlVHJhbnNwb3J0KGRpcmVjdGlvbiwgYXBwRGF0YSlcblx0e1xuXHRcdGxvZ2dlci5kZWJ1ZygnY3JlYXRlVHJhbnNwb3J0KCkgW2RpcmVjdGlvbjolc10nLCBkaXJlY3Rpb24pO1xuXG5cdFx0aWYgKCF0aGlzLmpvaW5lZClcblx0XHRcdHRocm93IG5ldyBJbnZhbGlkU3RhdGVFcnJvcihgaW52YWxpZCBzdGF0ZSBcIiR7dGhpcy5fc3RhdGV9XCJgKTtcblx0XHRlbHNlIGlmIChkaXJlY3Rpb24gIT09ICdzZW5kJyAmJiBkaXJlY3Rpb24gIT09ICdyZWN2Jylcblx0XHRcdHRocm93IG5ldyBUeXBlRXJyb3IoYGludmFsaWQgZGlyZWN0aW9uIFwiJHtkaXJlY3Rpb259XCJgKTtcblxuXHRcdC8vIENyZWF0ZSBhIG5ldyBUcmFuc3BvcnQuXG5cdFx0Y29uc3QgdHJhbnNwb3J0ID0gbmV3IFRyYW5zcG9ydChcblx0XHRcdGRpcmVjdGlvbiwgdGhpcy5fZXh0ZW5kZWRSdHBDYXBhYmlsaXRpZXMsIHRoaXMuX3NldHRpbmdzLCBhcHBEYXRhKTtcblxuXHRcdC8vIFN0b3JlIGl0LlxuXHRcdHRoaXMuX3RyYW5zcG9ydHMuc2V0KHRyYW5zcG9ydC5pZCwgdHJhbnNwb3J0KTtcblxuXHRcdHRyYW5zcG9ydC5vbignQHJlcXVlc3QnLCAobWV0aG9kLCBkYXRhLCBjYWxsYmFjaywgZXJyYmFjaykgPT5cblx0XHR7XG5cdFx0XHR0aGlzLl9zZW5kUmVxdWVzdChtZXRob2QsIGRhdGEpXG5cdFx0XHRcdC50aGVuKGNhbGxiYWNrKVxuXHRcdFx0XHQuY2F0Y2goZXJyYmFjayk7XG5cdFx0fSk7XG5cblx0XHR0cmFuc3BvcnQub24oJ0Bub3RpZnknLCAobWV0aG9kLCBkYXRhKSA9PlxuXHRcdHtcblx0XHRcdHRoaXMuX3NlbmROb3RpZmljYXRpb24obWV0aG9kLCBkYXRhKTtcblx0XHR9KTtcblxuXHRcdHRyYW5zcG9ydC5vbignQGNsb3NlJywgKCkgPT5cblx0XHR7XG5cdFx0XHR0aGlzLl90cmFuc3BvcnRzLmRlbGV0ZSh0cmFuc3BvcnQuaWQpO1xuXHRcdH0pO1xuXG5cdFx0cmV0dXJuIHRyYW5zcG9ydDtcblx0fVxuXG5cdC8qKlxuXHQgKiBDcmVhdGVzIGEgUHJvZHVjZXIuXG5cdCAqXG5cdCAqIEBwYXJhbSB7TWVkaWFTdHJlYW1UcmFja30gdHJhY2tcblx0ICogQHBhcmFtIHtPYmplY3R9IFtvcHRpb25zXVxuXHQgKiBAcGFyYW0ge09iamVjdH0gW29wdGlvbnMuc2ltdWxjYXN0XVxuXHQgKiBAcGFyYW0ge0FueX0gW2FwcERhdGFdIC0gQXBwIGN1c3RvbSBkYXRhLlxuXHQgKlxuXHQgKiBAcmV0dXJuIHtQcm9kdWNlcn1cblx0ICpcblx0ICogQHRocm93cyB7SW52YWxpZFN0YXRlRXJyb3J9IGlmIG5vdCBqb2luZWQuXG5cdCAqIEB0aHJvd3Mge1R5cGVFcnJvcn0gaWYgd3JvbmcgYXJndW1lbnRzLlxuXHQgKiBAdGhyb3dzIHtFcnJvcn0gaWYgY2Fubm90IHNlbmQgdGhlIGdpdmVuIGtpbmQuXG5cdCAqL1xuXHRjcmVhdGVQcm9kdWNlcih0cmFjaywgb3B0aW9ucywgYXBwRGF0YSlcblx0e1xuXHRcdGxvZ2dlci5kZWJ1ZygnY3JlYXRlUHJvZHVjZXIoKSBbdHJhY2s6JW8sIG9wdGlvbnM6JW9dJywgdHJhY2ssIG9wdGlvbnMpO1xuXG5cdFx0aWYgKCF0aGlzLmpvaW5lZClcblx0XHRcdHRocm93IG5ldyBJbnZhbGlkU3RhdGVFcnJvcihgaW52YWxpZCBzdGF0ZSBcIiR7dGhpcy5fc3RhdGV9XCJgKTtcblx0XHRlbHNlIGlmICghKHRyYWNrIGluc3RhbmNlb2YgTWVkaWFTdHJlYW1UcmFjaykpXG5cdFx0XHR0aHJvdyBuZXcgVHlwZUVycm9yKCd0cmFjayBpcyBub3QgYSBNZWRpYVN0cmVhbVRyYWNrJyk7XG5cdFx0ZWxzZSBpZiAoIXRoaXMuX2NhblNlbmRCeUtpbmRbdHJhY2sua2luZF0pXG5cdFx0XHR0aHJvdyBuZXcgRXJyb3IoYGNhbm5vdCBzZW5kICR7dHJhY2sua2luZH1gKTtcblx0XHRlbHNlIGlmICh0cmFjay5yZWFkeVN0YXRlID09PSAnZW5kZWQnKVxuXHRcdFx0dGhyb3cgbmV3IEVycm9yKCd0cmFjay5yZWFkeVN0YXRlIGlzIFwiZW5kZWRcIicpO1xuXG5cdFx0b3B0aW9ucyA9IG9wdGlvbnMgfHwge307XG5cblx0XHQvLyBDcmVhdGUgYSBuZXcgUHJvZHVjZXIuXG5cdFx0Y29uc3QgcHJvZHVjZXIgPSBuZXcgUHJvZHVjZXIodHJhY2ssIG9wdGlvbnMsIGFwcERhdGEpO1xuXG5cdFx0Ly8gU3RvcmUgaXQuXG5cdFx0dGhpcy5fcHJvZHVjZXJzLnNldChwcm9kdWNlci5pZCwgcHJvZHVjZXIpO1xuXG5cdFx0cHJvZHVjZXIub24oJ0BjbG9zZScsICgpID0+XG5cdFx0e1xuXHRcdFx0dGhpcy5fcHJvZHVjZXJzLmRlbGV0ZShwcm9kdWNlci5pZCk7XG5cdFx0fSk7XG5cblx0XHRyZXR1cm4gcHJvZHVjZXI7XG5cdH1cblxuXHQvKipcblx0ICogUHJvZHVjZSBhIElDRSByZXN0YXJ0IGluIGFsbCB0aGUgVHJhbnNwb3J0cy5cblx0ICovXG5cdHJlc3RhcnRJY2UoKVxuXHR7XG5cdFx0aWYgKCF0aGlzLmpvaW5lZClcblx0XHRcdHRocm93IG5ldyBJbnZhbGlkU3RhdGVFcnJvcihgaW52YWxpZCBzdGF0ZSBcIiR7dGhpcy5fc3RhdGV9XCJgKTtcblxuXHRcdGZvciAoY29uc3QgdHJhbnNwb3J0IG9mIHRoaXMuX3RyYW5zcG9ydHMudmFsdWVzKCkpXG5cdFx0e1xuXHRcdFx0dHJhbnNwb3J0LnJlc3RhcnRJY2UoKTtcblx0XHR9XG5cdH1cblxuXHQvKipcblx0ICogUHJvdmlkZSB0aGUgbG9jYWwgUm9vbSB3aXRoIGEgbm90aWZpY2F0aW9uIGdlbmVyYXRlZCBieSBtZWRpYXNvdXAgc2VydmVyLlxuXHQgKlxuXHQgKiBAcGFyYW0ge09iamVjdH0gbm90aWZpY2F0aW9uXG5cdCAqL1xuXHRyZWNlaXZlTm90aWZpY2F0aW9uKG5vdGlmaWNhdGlvbilcblx0e1xuXHRcdGlmICh0aGlzLmNsb3NlZClcblx0XHRcdHJldHVybiBQcm9taXNlLnJlamVjdChuZXcgSW52YWxpZFN0YXRlRXJyb3IoJ1Jvb20gY2xvc2VkJykpO1xuXHRcdGVsc2UgaWYgKHR5cGVvZiBub3RpZmljYXRpb24gIT09ICdvYmplY3QnKVxuXHRcdFx0cmV0dXJuIFByb21pc2UucmVqZWN0KG5ldyBUeXBlRXJyb3IoJ3dyb25nIG5vdGlmaWNhdGlvbiBPYmplY3QnKSk7XG5cdFx0ZWxzZSBpZiAobm90aWZpY2F0aW9uLm5vdGlmaWNhdGlvbiAhPT0gdHJ1ZSlcblx0XHRcdHJldHVybiBQcm9taXNlLnJlamVjdChuZXcgVHlwZUVycm9yKCdub3QgYSBub3RpZmljYXRpb24nKSk7XG5cdFx0ZWxzZSBpZiAodHlwZW9mIG5vdGlmaWNhdGlvbi5tZXRob2QgIT09ICdzdHJpbmcnKVxuXHRcdFx0cmV0dXJuIFByb21pc2UucmVqZWN0KG5ldyBUeXBlRXJyb3IoJ3dyb25nL21pc3Npbmcgbm90aWZpY2F0aW9uIG1ldGhvZCcpKTtcblxuXHRcdGNvbnN0IHsgbWV0aG9kIH0gPSBub3RpZmljYXRpb247XG5cblx0XHRsb2dnZXIuZGVidWcoXG5cdFx0XHQncmVjZWl2ZU5vdGlmaWNhdGlvbigpIFttZXRob2Q6JXMsIG5vdGlmaWNhdGlvbjolb10nLFxuXHRcdFx0bWV0aG9kLCBub3RpZmljYXRpb24pO1xuXG5cdFx0cmV0dXJuIFByb21pc2UucmVzb2x2ZSgpXG5cdFx0XHQudGhlbigoKSA9PlxuXHRcdFx0e1xuXHRcdFx0XHRzd2l0Y2ggKG1ldGhvZClcblx0XHRcdFx0e1xuXHRcdFx0XHRcdGNhc2UgJ2Nsb3NlZCc6XG5cdFx0XHRcdFx0e1xuXHRcdFx0XHRcdFx0Y29uc3QgeyBhcHBEYXRhIH0gPSBub3RpZmljYXRpb247XG5cblx0XHRcdFx0XHRcdHRoaXMucmVtb3RlQ2xvc2UoYXBwRGF0YSk7XG5cblx0XHRcdFx0XHRcdGJyZWFrO1xuXHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdGNhc2UgJ3RyYW5zcG9ydENsb3NlZCc6XG5cdFx0XHRcdFx0e1xuXHRcdFx0XHRcdFx0Y29uc3QgeyBpZCwgYXBwRGF0YSB9ID0gbm90aWZpY2F0aW9uO1xuXHRcdFx0XHRcdFx0Y29uc3QgdHJhbnNwb3J0ID0gdGhpcy5fdHJhbnNwb3J0cy5nZXQoaWQpO1xuXG5cdFx0XHRcdFx0XHRpZiAoIXRyYW5zcG9ydClcblx0XHRcdFx0XHRcdFx0dGhyb3cgbmV3IEVycm9yKGBUcmFuc3BvcnQgbm90IGZvdW5kIFtpZDpcIiR7aWR9XCJdYCk7XG5cblx0XHRcdFx0XHRcdHRyYW5zcG9ydC5yZW1vdGVDbG9zZShhcHBEYXRhKTtcblxuXHRcdFx0XHRcdFx0YnJlYWs7XG5cdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0Y2FzZSAndHJhbnNwb3J0U3RhdHMnOlxuXHRcdFx0XHRcdHtcblx0XHRcdFx0XHRcdGNvbnN0IHsgaWQsIHN0YXRzIH0gPSBub3RpZmljYXRpb247XG5cdFx0XHRcdFx0XHRjb25zdCB0cmFuc3BvcnQgPSB0aGlzLl90cmFuc3BvcnRzLmdldChpZCk7XG5cblx0XHRcdFx0XHRcdGlmICghdHJhbnNwb3J0KVxuXHRcdFx0XHRcdFx0XHR0aHJvdyBuZXcgRXJyb3IoYHRyYW5zcG9ydCBub3QgZm91bmQgW2lkOiR7aWR9XWApO1xuXG5cdFx0XHRcdFx0XHR0cmFuc3BvcnQucmVtb3RlU3RhdHMoc3RhdHMpO1xuXG5cdFx0XHRcdFx0XHRicmVhaztcblx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHRjYXNlICduZXdQZWVyJzpcblx0XHRcdFx0XHR7XG5cdFx0XHRcdFx0XHRjb25zdCB7IG5hbWUgfSA9IG5vdGlmaWNhdGlvbjtcblxuXHRcdFx0XHRcdFx0aWYgKHRoaXMuX3BlZXJzLmhhcyhuYW1lKSlcblx0XHRcdFx0XHRcdFx0dGhyb3cgbmV3IEVycm9yKGBQZWVyIGFscmVhZHkgZXhpc3RzIFtuYW1lOlwiJHtuYW1lfVwiXWApO1xuXG5cdFx0XHRcdFx0XHRjb25zdCBwZWVyRGF0YSA9IG5vdGlmaWNhdGlvbjtcblxuXHRcdFx0XHRcdFx0dGhpcy5faGFuZGxlUGVlckRhdGEocGVlckRhdGEpO1xuXG5cdFx0XHRcdFx0XHRicmVhaztcblx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHRjYXNlICdwZWVyQ2xvc2VkJzpcblx0XHRcdFx0XHR7XG5cblx0XHRcdFx0XHRcdGlmICghdGhpcy5jbG9zZWQpIHtcblx0XHRcdFx0XHRcdFx0Y29uc3QgcGVlck5hbWUgPSBub3RpZmljYXRpb24ubmFtZTtcblx0XHRcdFx0XHRcdFx0Y29uc3QgeyBhcHBEYXRhIH0gPSBub3RpZmljYXRpb247XG5cdFx0XHRcdFx0XHRcdGNvbnN0IHBlZXIgPSB0aGlzLl9wZWVycy5nZXQocGVlck5hbWUpO1xuXG5cdFx0XHRcdFx0XHRcdGlmICghcGVlcilcblx0XHRcdFx0XHRcdFx0XHRyZXR1cm47Ly8gdGhyb3cgbmV3IEVycm9yKGBubyBQZWVyIGZvdW5kIFtuYW1lOlwiJHtwZWVyTmFtZX1cIl1gKTtcblxuXHRcdFx0XHRcdFx0XHRwZWVyLnJlbW90ZUNsb3NlKGFwcERhdGEpO1xuXHRcdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0XHRicmVhaztcblx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHRjYXNlICdwcm9kdWNlclBhdXNlZCc6XG5cdFx0XHRcdFx0e1xuXHRcdFx0XHRcdFx0Y29uc3QgeyBpZCwgYXBwRGF0YSB9ID0gbm90aWZpY2F0aW9uO1xuXHRcdFx0XHRcdFx0Y29uc3QgcHJvZHVjZXIgPSB0aGlzLl9wcm9kdWNlcnMuZ2V0KGlkKTtcblxuXHRcdFx0XHRcdFx0aWYgKCFwcm9kdWNlcilcblx0XHRcdFx0XHRcdFx0dGhyb3cgbmV3IEVycm9yKGBQcm9kdWNlciBub3QgZm91bmQgW2lkOiR7aWR9XWApO1xuXG5cdFx0XHRcdFx0XHRwcm9kdWNlci5yZW1vdGVQYXVzZShhcHBEYXRhKTtcblxuXHRcdFx0XHRcdFx0YnJlYWs7XG5cdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0Y2FzZSAncHJvZHVjZXJSZXN1bWVkJzpcblx0XHRcdFx0XHR7XG5cdFx0XHRcdFx0XHRjb25zdCB7IGlkLCBhcHBEYXRhIH0gPSBub3RpZmljYXRpb247XG5cdFx0XHRcdFx0XHRjb25zdCBwcm9kdWNlciA9IHRoaXMuX3Byb2R1Y2Vycy5nZXQoaWQpO1xuXG5cdFx0XHRcdFx0XHRpZiAoIXByb2R1Y2VyKVxuXHRcdFx0XHRcdFx0XHR0aHJvdyBuZXcgRXJyb3IoYFByb2R1Y2VyIG5vdCBmb3VuZCBbaWQ6JHtpZH1dYCk7XG5cblx0XHRcdFx0XHRcdHByb2R1Y2VyLnJlbW90ZVJlc3VtZShhcHBEYXRhKTtcblxuXHRcdFx0XHRcdFx0YnJlYWs7XG5cdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0Y2FzZSAncHJvZHVjZXJDbG9zZWQnOlxuXHRcdFx0XHRcdHtcblx0XHRcdFx0XHRcdGNvbnN0IHsgaWQsIGFwcERhdGEgfSA9IG5vdGlmaWNhdGlvbjtcblx0XHRcdFx0XHRcdGNvbnN0IHByb2R1Y2VyID0gdGhpcy5fcHJvZHVjZXJzLmdldChpZCk7XG5cblx0XHRcdFx0XHRcdGlmICghcHJvZHVjZXIpXG5cdFx0XHRcdFx0XHRcdHRocm93IG5ldyBFcnJvcihgUHJvZHVjZXIgbm90IGZvdW5kIFtpZDoke2lkfV1gKTtcblxuXHRcdFx0XHRcdFx0cHJvZHVjZXIucmVtb3RlQ2xvc2UoYXBwRGF0YSk7XG5cblx0XHRcdFx0XHRcdGJyZWFrO1xuXHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdGNhc2UgJ3Byb2R1Y2VyU3RhdHMnOlxuXHRcdFx0XHRcdHtcblx0XHRcdFx0XHRcdGNvbnN0IHsgaWQsIHN0YXRzIH0gPSBub3RpZmljYXRpb247XG5cdFx0XHRcdFx0XHRjb25zdCBwcm9kdWNlciA9IHRoaXMuX3Byb2R1Y2Vycy5nZXQoaWQpO1xuXG5cdFx0XHRcdFx0XHRpZiAoIXByb2R1Y2VyKVxuXHRcdFx0XHRcdFx0XHR0aHJvdyBuZXcgRXJyb3IoYFByb2R1Y2VyIG5vdCBmb3VuZCBbaWQ6JHtpZH1dYCk7XG5cblx0XHRcdFx0XHRcdHByb2R1Y2VyLnJlbW90ZVN0YXRzKHN0YXRzKTtcblxuXHRcdFx0XHRcdFx0YnJlYWs7XG5cdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0Y2FzZSAnbmV3Q29uc3VtZXInOlxuXHRcdFx0XHRcdHtcblx0XHRcdFx0XHRcdGNvbnN0IHsgcGVlck5hbWUgfSA9IG5vdGlmaWNhdGlvbjtcblx0XHRcdFx0XHRcdGNvbnN0IHBlZXIgPSB0aGlzLl9wZWVycy5nZXQocGVlck5hbWUpO1xuXG5cdFx0XHRcdFx0XHRpZiAoIXBlZXIpXG5cdFx0XHRcdFx0XHRcdHRocm93IG5ldyBFcnJvcihgbm8gUGVlciBmb3VuZCBbbmFtZTpcIiR7cGVlck5hbWV9XCJdYCk7XG5cblx0XHRcdFx0XHRcdGNvbnN0IGNvbnN1bWVyRGF0YSA9IG5vdGlmaWNhdGlvbjtcblxuXHRcdFx0XHRcdFx0dGhpcy5faGFuZGxlQ29uc3VtZXJEYXRhKGNvbnN1bWVyRGF0YSwgcGVlcik7XG5cblx0XHRcdFx0XHRcdGJyZWFrO1xuXHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdGNhc2UgJ2NvbnN1bWVyQ2xvc2VkJzpcblx0XHRcdFx0XHR7XG5cdFx0XHRcdFx0XHRjb25zdCB7IGlkLCBwZWVyTmFtZSwgYXBwRGF0YSB9ID0gbm90aWZpY2F0aW9uO1xuXHRcdFx0XHRcdFx0Y29uc3QgcGVlciA9IHRoaXMuX3BlZXJzLmdldChwZWVyTmFtZSk7XG5cblx0XHRcdFx0XHRcdGlmICghcGVlcilcblx0XHRcdFx0XHRcdFx0dGhyb3cgbmV3IEVycm9yKGBubyBQZWVyIGZvdW5kIFtuYW1lOlwiJHtwZWVyTmFtZX1cIl1gKTtcblxuXHRcdFx0XHRcdFx0Y29uc3QgY29uc3VtZXIgPSBwZWVyLmdldENvbnN1bWVyQnlJZChpZCk7XG5cblx0XHRcdFx0XHRcdGlmICghY29uc3VtZXIpXG5cdFx0XHRcdFx0XHRcdHRocm93IG5ldyBFcnJvcihgQ29uc3VtZXIgbm90IGZvdW5kIFtpZDoke2lkfV1gKTtcblxuXHRcdFx0XHRcdFx0Y29uc3VtZXIucmVtb3RlQ2xvc2UoYXBwRGF0YSk7XG5cblx0XHRcdFx0XHRcdGJyZWFrO1xuXHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdGNhc2UgJ2NvbnN1bWVyUGF1c2VkJzpcblx0XHRcdFx0XHR7XG5cdFx0XHRcdFx0XHRjb25zdCB7IGlkLCBwZWVyTmFtZSwgYXBwRGF0YSB9ID0gbm90aWZpY2F0aW9uO1xuXHRcdFx0XHRcdFx0Y29uc3QgcGVlciA9IHRoaXMuX3BlZXJzLmdldChwZWVyTmFtZSk7XG5cblx0XHRcdFx0XHRcdGlmICghcGVlcilcblx0XHRcdFx0XHRcdFx0dGhyb3cgbmV3IEVycm9yKGBubyBQZWVyIGZvdW5kIFtuYW1lOlwiJHtwZWVyTmFtZX1cIl1gKTtcblxuXHRcdFx0XHRcdFx0Y29uc3QgY29uc3VtZXIgPSBwZWVyLmdldENvbnN1bWVyQnlJZChpZCk7XG5cblx0XHRcdFx0XHRcdGlmICghY29uc3VtZXIpXG5cdFx0XHRcdFx0XHRcdHRocm93IG5ldyBFcnJvcihgQ29uc3VtZXIgbm90IGZvdW5kIFtpZDoke2lkfV1gKTtcblxuXHRcdFx0XHRcdFx0Y29uc3VtZXIucmVtb3RlUGF1c2UoYXBwRGF0YSk7XG5cblx0XHRcdFx0XHRcdGJyZWFrO1xuXHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdGNhc2UgJ2NvbnN1bWVyUmVzdW1lZCc6XG5cdFx0XHRcdFx0e1xuXHRcdFx0XHRcdFx0Y29uc3QgeyBpZCwgcGVlck5hbWUsIGFwcERhdGEgfSA9IG5vdGlmaWNhdGlvbjtcblx0XHRcdFx0XHRcdGNvbnN0IHBlZXIgPSB0aGlzLl9wZWVycy5nZXQocGVlck5hbWUpO1xuXG5cdFx0XHRcdFx0XHRpZiAoIXBlZXIpXG5cdFx0XHRcdFx0XHRcdHRocm93IG5ldyBFcnJvcihgbm8gUGVlciBmb3VuZCBbbmFtZTpcIiR7cGVlck5hbWV9XCJdYCk7XG5cblx0XHRcdFx0XHRcdGNvbnN0IGNvbnN1bWVyID0gcGVlci5nZXRDb25zdW1lckJ5SWQoaWQpO1xuXG5cdFx0XHRcdFx0XHRpZiAoIWNvbnN1bWVyKVxuXHRcdFx0XHRcdFx0XHR0aHJvdyBuZXcgRXJyb3IoYENvbnN1bWVyIG5vdCBmb3VuZCBbaWQ6JHtpZH1dYCk7XG5cblx0XHRcdFx0XHRcdGNvbnN1bWVyLnJlbW90ZVJlc3VtZShhcHBEYXRhKTtcblxuXHRcdFx0XHRcdFx0YnJlYWs7XG5cdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0Y2FzZSAnY29uc3VtZXJQcmVmZXJyZWRQcm9maWxlU2V0Jzpcblx0XHRcdFx0XHR7XG5cdFx0XHRcdFx0XHRjb25zdCB7IGlkLCBwZWVyTmFtZSwgcHJvZmlsZSB9ID0gbm90aWZpY2F0aW9uO1xuXHRcdFx0XHRcdFx0Y29uc3QgcGVlciA9IHRoaXMuX3BlZXJzLmdldChwZWVyTmFtZSk7XG5cblx0XHRcdFx0XHRcdGlmICghcGVlcilcblx0XHRcdFx0XHRcdFx0dGhyb3cgbmV3IEVycm9yKGBubyBQZWVyIGZvdW5kIFtuYW1lOlwiJHtwZWVyTmFtZX1cIl1gKTtcblxuXHRcdFx0XHRcdFx0Y29uc3QgY29uc3VtZXIgPSBwZWVyLmdldENvbnN1bWVyQnlJZChpZCk7XG5cblx0XHRcdFx0XHRcdGlmICghY29uc3VtZXIpXG5cdFx0XHRcdFx0XHRcdHRocm93IG5ldyBFcnJvcihgQ29uc3VtZXIgbm90IGZvdW5kIFtpZDoke2lkfV1gKTtcblxuXHRcdFx0XHRcdFx0Y29uc3VtZXIucmVtb3RlU2V0UHJlZmVycmVkUHJvZmlsZShwcm9maWxlKTtcblxuXHRcdFx0XHRcdFx0YnJlYWs7XG5cdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0Y2FzZSAnY29uc3VtZXJFZmZlY3RpdmVQcm9maWxlQ2hhbmdlZCc6XG5cdFx0XHRcdFx0e1xuXHRcdFx0XHRcdFx0Y29uc3QgeyBpZCwgcGVlck5hbWUsIHByb2ZpbGUgfSA9IG5vdGlmaWNhdGlvbjtcblx0XHRcdFx0XHRcdGNvbnN0IHBlZXIgPSB0aGlzLl9wZWVycy5nZXQocGVlck5hbWUpO1xuXG5cdFx0XHRcdFx0XHRpZiAoIXBlZXIpXG5cdFx0XHRcdFx0XHRcdHRocm93IG5ldyBFcnJvcihgbm8gUGVlciBmb3VuZCBbbmFtZTpcIiR7cGVlck5hbWV9XCJdYCk7XG5cblx0XHRcdFx0XHRcdGNvbnN0IGNvbnN1bWVyID0gcGVlci5nZXRDb25zdW1lckJ5SWQoaWQpO1xuXG5cdFx0XHRcdFx0XHRpZiAoIWNvbnN1bWVyKVxuXHRcdFx0XHRcdFx0XHR0aHJvdyBuZXcgRXJyb3IoYENvbnN1bWVyIG5vdCBmb3VuZCBbaWQ6JHtpZH1dYCk7XG5cblx0XHRcdFx0XHRcdGNvbnN1bWVyLnJlbW90ZUVmZmVjdGl2ZVByb2ZpbGVDaGFuZ2VkKHByb2ZpbGUpO1xuXG5cdFx0XHRcdFx0XHRicmVhaztcblx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHRjYXNlICdjb25zdW1lclN0YXRzJzpcblx0XHRcdFx0XHR7XG5cdFx0XHRcdFx0XHRjb25zdCB7IGlkLCBwZWVyTmFtZSwgc3RhdHMgfSA9IG5vdGlmaWNhdGlvbjtcblx0XHRcdFx0XHRcdGNvbnN0IHBlZXIgPSB0aGlzLl9wZWVycy5nZXQocGVlck5hbWUpO1xuXG5cdFx0XHRcdFx0XHRpZiAoIXBlZXIpXG5cdFx0XHRcdFx0XHRcdHRocm93IG5ldyBFcnJvcihgbm8gUGVlciBmb3VuZCBbbmFtZTpcIiR7cGVlck5hbWV9XCJdYCk7XG5cblx0XHRcdFx0XHRcdGNvbnN0IGNvbnN1bWVyID0gcGVlci5nZXRDb25zdW1lckJ5SWQoaWQpO1xuXG5cdFx0XHRcdFx0XHRpZiAoIWNvbnN1bWVyKVxuXHRcdFx0XHRcdFx0XHR0aHJvdyBuZXcgRXJyb3IoYENvbnN1bWVyIG5vdCBmb3VuZCBbaWQ6JHtpZH1dYCk7XG5cblx0XHRcdFx0XHRcdGNvbnN1bWVyLnJlbW90ZVN0YXRzKHN0YXRzKTtcblxuXHRcdFx0XHRcdFx0YnJlYWs7XG5cdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0ZGVmYXVsdDpcblx0XHRcdFx0XHRcdHRocm93IG5ldyBFcnJvcihgdW5rbm93biBub3RpZmljYXRpb24gbWV0aG9kIFwiJHttZXRob2R9XCJgKTtcblx0XHRcdFx0fVxuXHRcdFx0fSlcblx0XHRcdC5jYXRjaCgoZXJyb3IpID0+XG5cdFx0XHR7XG5cdFx0XHRcdGxvZ2dlci5lcnJvcihcblx0XHRcdFx0XHQncmVjZWl2ZU5vdGlmaWNhdGlvbigpIGZhaWxlZCBbbm90aWZpY2F0aW9uOiVvXTogJXMnLCBub3RpZmljYXRpb24sIGVycm9yKTtcblx0XHRcdH0pO1xuXHR9XG5cblx0X3NlbmRSZXF1ZXN0KG1ldGhvZCwgZGF0YSlcblx0e1xuXHRcdGNvbnN0IHJlcXVlc3QgPSBPYmplY3QuYXNzaWduKHsgbWV0aG9kLCB0YXJnZXQ6ICdwZWVyJyB9LCBkYXRhKTtcblxuXHRcdC8vIFNob3VsZCBuZXZlciBoYXBwZW4uXG5cdFx0Ly8gSWdub3JlIGlmIGNsb3NlZC5cblx0XHRpZiAodGhpcy5jbG9zZWQpXG5cdFx0e1xuXHRcdFx0bG9nZ2VyLmVycm9yKFxuXHRcdFx0XHQnX3NlbmRSZXF1ZXN0KCkgfCBSb29tIGNsb3NlZCBbbWV0aG9kOiVzLCByZXF1ZXN0OiVvXScsXG5cdFx0XHRcdG1ldGhvZCwgcmVxdWVzdCk7XG5cblx0XHRcdHJldHVybiBQcm9taXNlLnJlamVjdChuZXcgSW52YWxpZFN0YXRlRXJyb3IoJ1Jvb20gY2xvc2VkJykpO1xuXHRcdH1cblxuXHRcdGxvZ2dlci5kZWJ1ZygnX3NlbmRSZXF1ZXN0KCkgW21ldGhvZDolcywgcmVxdWVzdDolb10nLCBtZXRob2QsIHJlcXVlc3QpO1xuXG5cdFx0cmV0dXJuIG5ldyBQcm9taXNlKChyZXNvbHZlLCByZWplY3QpID0+XG5cdFx0e1xuXHRcdFx0bGV0IGRvbmUgPSBmYWxzZTtcblxuXHRcdFx0Y29uc3QgdGltZXIgPSBzZXRUaW1lb3V0KCgpID0+XG5cdFx0XHR7XG5cdFx0XHRcdGxvZ2dlci5lcnJvcihcblx0XHRcdFx0XHQncmVxdWVzdCBmYWlsZWQgW21ldGhvZDolc106IHRpbWVvdXQnLCBtZXRob2QpO1xuXG5cdFx0XHRcdGRvbmUgPSB0cnVlO1xuXHRcdFx0XHRyZWplY3QobmV3IFRpbWVvdXRFcnJvcigndGltZW91dCcpKTtcblx0XHRcdH0sIHRoaXMuX3NldHRpbmdzLnJlcXVlc3RUaW1lb3V0KTtcblxuXHRcdFx0Y29uc3QgY2FsbGJhY2sgPSAocmVzcG9uc2UpID0+XG5cdFx0XHR7XG5cdFx0XHRcdGlmIChkb25lKVxuXHRcdFx0XHRcdHJldHVybjtcblxuXHRcdFx0XHRkb25lID0gdHJ1ZTtcblx0XHRcdFx0Y2xlYXJUaW1lb3V0KHRpbWVyKTtcblxuXHRcdFx0XHRpZiAodGhpcy5jbG9zZWQpXG5cdFx0XHRcdHtcblx0XHRcdFx0XHRsb2dnZXIuZXJyb3IoXG5cdFx0XHRcdFx0XHQncmVxdWVzdCBmYWlsZWQgW21ldGhvZDolc106IFJvb20gY2xvc2VkJywgbWV0aG9kKTtcblxuXHRcdFx0XHRcdHJlamVjdChuZXcgRXJyb3IoJ1Jvb20gY2xvc2VkJykpO1xuXG5cdFx0XHRcdFx0cmV0dXJuO1xuXHRcdFx0XHR9XG5cblx0XHRcdFx0bG9nZ2VyLmRlYnVnKFxuXHRcdFx0XHRcdCdyZXF1ZXN0IHN1Y2NlZWRlZCBbbWV0aG9kOiVzLCByZXNwb25zZTolb10nLCBtZXRob2QsIHJlc3BvbnNlKTtcblxuXHRcdFx0XHRyZXNvbHZlKHJlc3BvbnNlKTtcblx0XHRcdH07XG5cblx0XHRcdGNvbnN0IGVycmJhY2sgPSAoZXJyb3IpID0+XG5cdFx0XHR7XG5cdFx0XHRcdGlmIChkb25lKVxuXHRcdFx0XHRcdHJldHVybjtcblxuXHRcdFx0XHRkb25lID0gdHJ1ZTtcblx0XHRcdFx0Y2xlYXJUaW1lb3V0KHRpbWVyKTtcblxuXHRcdFx0XHRpZiAodGhpcy5jbG9zZWQpXG5cdFx0XHRcdHtcblx0XHRcdFx0XHRsb2dnZXIuZXJyb3IoXG5cdFx0XHRcdFx0XHQncmVxdWVzdCBmYWlsZWQgW21ldGhvZDolc106IFJvb20gY2xvc2VkJywgbWV0aG9kKTtcblxuXHRcdFx0XHRcdHJlamVjdChuZXcgRXJyb3IoJ1Jvb20gY2xvc2VkJykpO1xuXG5cdFx0XHRcdFx0cmV0dXJuO1xuXHRcdFx0XHR9XG5cblx0XHRcdFx0Ly8gTWFrZSBzdXJlIG1lc3NhZ2UgaXMgYW4gRXJyb3IuXG5cdFx0XHRcdGlmICghKGVycm9yIGluc3RhbmNlb2YgRXJyb3IpKVxuXHRcdFx0XHRcdGVycm9yID0gbmV3IEVycm9yKFN0cmluZyhlcnJvcikpO1xuXG5cdFx0XHRcdGxvZ2dlci5lcnJvcigncmVxdWVzdCBmYWlsZWQgW21ldGhvZDolc106JW8nLCBtZXRob2QsIGVycm9yKTtcblxuXHRcdFx0XHRyZWplY3QoZXJyb3IpO1xuXHRcdFx0fTtcblxuXHRcdFx0dGhpcy5zYWZlRW1pdCgncmVxdWVzdCcsIHJlcXVlc3QsIGNhbGxiYWNrLCBlcnJiYWNrKTtcblx0XHR9KTtcblx0fVxuXG5cdF9zZW5kTm90aWZpY2F0aW9uKG1ldGhvZCwgZGF0YSlcblx0e1xuXHRcdC8vIElnbm9yZSBpZiBjbG9zZWQuXG5cdFx0aWYgKHRoaXMuY2xvc2VkKVxuXHRcdFx0cmV0dXJuO1xuXG5cdFx0Y29uc3Qgbm90aWZpY2F0aW9uID1cblx0XHRcdE9iamVjdC5hc3NpZ24oeyBtZXRob2QsIHRhcmdldDogJ3BlZXInLCBub3RpZmljYXRpb246IHRydWUgfSwgZGF0YSk7XG5cblx0XHRsb2dnZXIuZGVidWcoXG5cdFx0XHQnX3NlbmROb3RpZmljYXRpb24oKSBbbWV0aG9kOiVzLCBub3RpZmljYXRpb246JW9dJywgbWV0aG9kLCBub3RpZmljYXRpb24pO1xuXG5cdFx0dGhpcy5zYWZlRW1pdCgnbm90aWZ5Jywgbm90aWZpY2F0aW9uKTtcblx0fVxuXG5cdF9oYW5kbGVQZWVyRGF0YShwZWVyRGF0YSlcblx0e1xuXHRcdGNvbnN0IHsgbmFtZSwgY29uc3VtZXJzLCBhcHBEYXRhIH0gPSBwZWVyRGF0YTtcblx0XHRjb25zdCBwZWVyID0gbmV3IFBlZXIobmFtZSwgYXBwRGF0YSk7XG5cblx0XHQvLyBTdG9yZSBpdC5cblx0XHR0aGlzLl9wZWVycy5zZXQocGVlci5uYW1lLCBwZWVyKTtcblxuXHRcdHBlZXIub24oJ0BjbG9zZScsICgpID0+XG5cdFx0e1xuXHRcdFx0dGhpcy5fcGVlcnMuZGVsZXRlKHBlZXIubmFtZSk7XG5cdFx0fSk7XG5cblx0XHQvLyBBZGQgY29uc3VtZXJzLlxuXG5cdFx0aWYgKHR5cGVvZiBjb25zdW1lcnMgPT09ICdvYmplY3QnKSB7XG5cdFx0XHRmb3IgKGNvbnN0IGNvbnN1bWVyRGF0YSBvZiBjb25zdW1lcnMpXG5cdFx0XHR7XG5cdFx0XHRcdHRyeVxuXHRcdFx0XHR7XG5cdFx0XHRcdFx0dGhpcy5faGFuZGxlQ29uc3VtZXJEYXRhKGNvbnN1bWVyRGF0YSwgcGVlcik7XG5cdFx0XHRcdH1cblx0XHRcdFx0Y2F0Y2ggKGVycm9yKVxuXHRcdFx0XHR7XG5cdFx0XHRcdFx0bG9nZ2VyLmVycm9yKCdlcnJvciBoYW5kbGluZyBleGlzdGluZyBDb25zdW1lciBpbiBQZWVyOiVvJywgZXJyb3IpO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0Ly8gSWYgYWxyZWFkeSBqb2luZWQgZW1pdCBldmVudC5cblx0XHRpZiAodGhpcy5qb2luZWQpXG5cdFx0XHR0aGlzLnNhZmVFbWl0KCduZXdwZWVyJywgcGVlcik7XG5cdH1cblxuXHRfaGFuZGxlQ29uc3VtZXJEYXRhKHByb2R1Y2VyRGF0YSwgcGVlcilcblx0e1xuXHRcdGNvbnN0IHsgaWQsIGtpbmQsIHJ0cFBhcmFtZXRlcnMsIHBhdXNlZCwgYXBwRGF0YSB9ID0gcHJvZHVjZXJEYXRhO1xuXHRcdGNvbnN0IGNvbnN1bWVyID0gbmV3IENvbnN1bWVyKGlkLCBraW5kLCBydHBQYXJhbWV0ZXJzLCBwZWVyLCBhcHBEYXRhKTtcblx0XHRjb25zdCBzdXBwb3J0ZWQgPSBvcnRjLmNhblJlY2VpdmUoY29uc3VtZXIucnRwUGFyYW1ldGVycywgdGhpcy5fZXh0ZW5kZWRSdHBDYXBhYmlsaXRpZXMpO1xuXG5cdFx0aWYgKHN1cHBvcnRlZClcblx0XHRcdGNvbnN1bWVyLnNldFN1cHBvcnRlZCh0cnVlKTtcblxuXHRcdGlmIChwYXVzZWQpXG5cdFx0XHRjb25zdW1lci5yZW1vdGVQYXVzZSgpO1xuXG5cdFx0cGVlci5hZGRDb25zdW1lcihjb25zdW1lcik7XG5cdH1cbn1cbiIsImltcG9ydCBMb2dnZXIgZnJvbSAnLi9Mb2dnZXInO1xuaW1wb3J0IEVuaGFuY2VkRXZlbnRFbWl0dGVyIGZyb20gJy4vRW5oYW5jZWRFdmVudEVtaXR0ZXInO1xuaW1wb3J0IHsgSW52YWxpZFN0YXRlRXJyb3IgfSBmcm9tICcuL2Vycm9ycyc7XG5pbXBvcnQgKiBhcyB1dGlscyBmcm9tICcuL3V0aWxzJztcbmltcG9ydCBEZXZpY2UgZnJvbSAnLi9EZXZpY2UnO1xuaW1wb3J0IENvbW1hbmRRdWV1ZSBmcm9tICcuL0NvbW1hbmRRdWV1ZSc7XG5cbmNvbnN0IERFRkFVTFRfU1RBVFNfSU5URVJWQUwgPSAxMDAwO1xuXG5jb25zdCBsb2dnZXIgPSBuZXcgTG9nZ2VyKCdUcmFuc3BvcnQnKTtcblxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgVHJhbnNwb3J0IGV4dGVuZHMgRW5oYW5jZWRFdmVudEVtaXR0ZXJcbntcblx0LyoqXG5cdCAqIEBwcml2YXRlXG5cdCAqXG5cdCAqIEBlbWl0cyB7c3RhdGU6IFN0cmluZ30gY29ubmVjdGlvbnN0YXRlY2hhbmdlXG5cdCAqIEBlbWl0cyB7c3RhdHM6IE9iamVjdH0gc3RhdHNcblx0ICogQGVtaXRzIHtvcmlnaW5hdG9yOiBTdHJpbmcsIFthcHBEYXRhXTogQW55fSBjbG9zZVxuXHQgKlxuXHQgKiBAZW1pdHMge21ldGhvZDogU3RyaW5nLCBbZGF0YV06IE9iamVjdCwgY2FsbGJhY2s6IEZ1bmN0aW9uLCBlcnJiYWNrOiBGdW5jdGlvbn0gQHJlcXVlc3Rcblx0ICogQGVtaXRzIHttZXRob2Q6IFN0cmluZywgW2RhdGFdOiBPYmplY3R9IEBub3RpZnlcblx0ICogQGVtaXRzIEBjbG9zZVxuXHQgKi9cblx0Y29uc3RydWN0b3IoZGlyZWN0aW9uLCBleHRlbmRlZFJ0cENhcGFiaWxpdGllcywgc2V0dGluZ3MsIGFwcERhdGEpXG5cdHtcblx0XHRzdXBlcihsb2dnZXIpO1xuXG5cdFx0bG9nZ2VyLmRlYnVnKCdjb25zdHJ1Y3RvcigpIFtkaXJlY3Rpb246JXMsIGV4dGVuZGVkUnRwQ2FwYWJpbGl0aWVzOiVvXScsXG5cdFx0XHRkaXJlY3Rpb24sIGV4dGVuZGVkUnRwQ2FwYWJpbGl0aWVzKTtcblxuXHRcdC8vIElkLlxuXHRcdC8vIEB0eXBlIHtOdW1iZXJ9XG5cdFx0dGhpcy5faWQgPSB1dGlscy5yYW5kb21OdW1iZXIoKTtcblxuXHRcdC8vIENsb3NlZCBmbGFnLlxuXHRcdC8vIEB0eXBlIHtCb29sZWFufVxuXHRcdHRoaXMuX2Nsb3NlZCA9IGZhbHNlO1xuXG5cdFx0Ly8gRGlyZWN0aW9uLlxuXHRcdC8vIEB0eXBlIHtTdHJpbmd9XG5cdFx0dGhpcy5fZGlyZWN0aW9uID0gZGlyZWN0aW9uO1xuXG5cdFx0Ly8gUm9vbSBzZXR0aW5ncy5cblx0XHQvLyBAdHlwZSB7T2JqZWN0fVxuXHRcdHRoaXMuX3NldHRpbmdzID0gc2V0dGluZ3M7XG5cblx0XHQvLyBBcHAgY3VzdG9tIGRhdGEuXG5cdFx0Ly8gQHR5cGUge0FueX1cblx0XHR0aGlzLl9hcHBEYXRhID0gYXBwRGF0YTtcblxuXHRcdC8vIFBlcmlvZGljIHN0YXRzIGZsYWcuXG5cdFx0Ly8gQHR5cGUge0Jvb2xlYW59XG5cdFx0dGhpcy5fc3RhdHNFbmFibGVkID0gZmFsc2U7XG5cblx0XHQvLyBDb21tYW5kcyBoYW5kbGVyLlxuXHRcdC8vIEB0eXBlIHtDb21tYW5kUXVldWV9XG5cdFx0dGhpcy5fY29tbWFuZFF1ZXVlID0gbmV3IENvbW1hbmRRdWV1ZSgpO1xuXG5cdFx0Ly8gRGV2aWNlIHNwZWNpZmljIGhhbmRsZXIuXG5cdFx0dGhpcy5faGFuZGxlciA9IG5ldyBEZXZpY2UuSGFuZGxlcihkaXJlY3Rpb24sIGV4dGVuZGVkUnRwQ2FwYWJpbGl0aWVzLCBzZXR0aW5ncyk7XG5cblx0XHQvLyBUcmFuc3BvcnQgc3RhdGUuIFZhbHVlcyBjYW4gYmU6XG5cdFx0Ly8gJ25ldycvJ2Nvbm5lY3RpbmcnLydjb25uZWN0ZWQnLydmYWlsZWQnLydkaXNjb25uZWN0ZWQnLydjbG9zZWQnXG5cdFx0Ly8gQHR5cGUge1N0cmluZ31cblx0XHR0aGlzLl9jb25uZWN0aW9uU3RhdGUgPSAnbmV3JztcblxuXHRcdHRoaXMuX2NvbW1hbmRRdWV1ZS5vbignZXhlYycsIHRoaXMuX2V4ZWNDb21tYW5kLmJpbmQodGhpcykpO1xuXG5cdFx0dGhpcy5faGFuZGxlSGFuZGxlcigpO1xuXHR9XG5cblx0LyoqXG5cdCAqIFRyYW5zcG9ydCBpZC5cblx0ICpcblx0ICogQHJldHVybiB7TnVtYmVyfVxuXHQgKi9cblx0Z2V0IGlkKClcblx0e1xuXHRcdHJldHVybiB0aGlzLl9pZDtcblx0fVxuXG5cdC8qKlxuXHQgKiBXaGV0aGVyIHRoZSBUcmFuc3BvcnQgaXMgY2xvc2VkLlxuXHQgKlxuXHQgKiBAcmV0dXJuIHtCb29sZWFufVxuXHQgKi9cblx0Z2V0IGNsb3NlZCgpXG5cdHtcblx0XHRyZXR1cm4gdGhpcy5fY2xvc2VkO1xuXHR9XG5cblx0LyoqXG5cdCAqIFRyYW5zcG9ydCBkaXJlY3Rpb24uXG5cdCAqXG5cdCAqIEByZXR1cm4ge1N0cmluZ31cblx0ICovXG5cdGdldCBkaXJlY3Rpb24oKVxuXHR7XG5cdFx0cmV0dXJuIHRoaXMuX2RpcmVjdGlvbjtcblx0fVxuXG5cdC8qKlxuXHQgKiBBcHAgY3VzdG9tIGRhdGEuXG5cdCAqXG5cdCAqIEByZXR1cm4ge0FueX1cblx0ICovXG5cdGdldCBhcHBEYXRhKClcblx0e1xuXHRcdHJldHVybiB0aGlzLl9hcHBEYXRhO1xuXHR9XG5cblx0LyoqXG5cdCAqIENvbm5lY3Rpb24gc3RhdGUuXG5cdCAqXG5cdCAqIEByZXR1cm4ge1N0cmluZ31cblx0ICovXG5cdGdldCBjb25uZWN0aW9uU3RhdGUoKVxuXHR7XG5cdFx0cmV0dXJuIHRoaXMuX2Nvbm5lY3Rpb25TdGF0ZTtcblx0fVxuXG5cdC8qKlxuXHQgKiBDbG9zZSB0aGUgVHJhbnNwb3J0LlxuXHQgKlxuXHQgKiBAcGFyYW0ge0FueX0gW2FwcERhdGFdIC0gQXBwIGN1c3RvbSBkYXRhLlxuXHQgKi9cblx0Y2xvc2UoYXBwRGF0YSlcblx0e1xuXHRcdGxvZ2dlci5kZWJ1ZygnY2xvc2UoKScpO1xuXG5cdFx0aWYgKHRoaXMuX2Nsb3NlZClcblx0XHRcdHJldHVybjtcblxuXHRcdHRoaXMuX2Nsb3NlZCA9IHRydWU7XG5cblx0XHRpZiAodGhpcy5fc3RhdHNFbmFibGVkKVxuXHRcdHtcblx0XHRcdHRoaXMuX3N0YXRzRW5hYmxlZCA9IGZhbHNlO1xuXHRcdFx0dGhpcy5kaXNhYmxlU3RhdHMoKTtcblx0XHR9XG5cblx0XHR0aGlzLnNhZmVFbWl0KFxuXHRcdFx0J0Bub3RpZnknLCAnY2xvc2VUcmFuc3BvcnQnLCB7IGlkOiB0aGlzLl9pZCwgYXBwRGF0YSB9KTtcblxuXHRcdHRoaXMuZW1pdCgnQGNsb3NlJyk7XG5cdFx0dGhpcy5zYWZlRW1pdCgnY2xvc2UnLCAnbG9jYWwnLCBhcHBEYXRhKTtcblxuXHRcdHRoaXMuX2Rlc3Ryb3koKTtcblx0fVxuXG5cdC8qKlxuXHQgKiBNeSByZW1vdGUgVHJhbnNwb3J0IHdhcyBjbG9zZWQuXG5cdCAqIEludm9rZWQgdmlhIHJlbW90ZSBub3RpZmljYXRpb24uXG5cdCAqXG5cdCAqIEBwcml2YXRlXG5cdCAqXG5cdCAqIEBwYXJhbSB7QW55fSBbYXBwRGF0YV0gLSBBcHAgY3VzdG9tIGRhdGEuXG5cdCAqL1xuXHRyZW1vdGVDbG9zZShhcHBEYXRhKVxuXHR7XG5cdFx0bG9nZ2VyLmRlYnVnKCdyZW1vdGVDbG9zZSgpJyk7XG5cblx0XHRpZiAodGhpcy5fY2xvc2VkKVxuXHRcdFx0cmV0dXJuO1xuXG5cdFx0dGhpcy5fY2xvc2VkID0gdHJ1ZTtcblxuXHRcdHRoaXMuZW1pdCgnQGNsb3NlJyk7XG5cdFx0dGhpcy5zYWZlRW1pdCgnY2xvc2UnLCAncmVtb3RlJywgYXBwRGF0YSk7XG5cblx0XHR0aGlzLl9kZXN0cm95KCk7XG5cdH1cblxuXHRfZGVzdHJveSgpXG5cdHtcblx0XHQvLyBDbG9zZSB0aGUgQ29tbWFuZFF1ZXVlLlxuXHRcdHRoaXMuX2NvbW1hbmRRdWV1ZS5jbG9zZSgpO1xuXG5cdFx0Ly8gQ2xvc2UgdGhlIGhhbmRsZXIuXG5cdFx0dGhpcy5faGFuZGxlci5jbG9zZSgpO1xuXHR9XG5cblx0cmVzdGFydEljZSgpXG5cdHtcblx0XHRsb2dnZXIuZGVidWcoJ3Jlc3RhcnRJY2UoKScpO1xuXG5cdFx0aWYgKHRoaXMuX2Nsb3NlZClcblx0XHRcdHJldHVybjtcblx0XHRlbHNlIGlmICh0aGlzLl9jb25uZWN0aW9uU3RhdGUgPT09ICduZXcnKVxuXHRcdFx0cmV0dXJuO1xuXG5cdFx0UHJvbWlzZS5yZXNvbHZlKClcblx0XHRcdC50aGVuKCgpID0+XG5cdFx0XHR7XG5cdFx0XHRcdGNvbnN0IGRhdGEgPVxuXHRcdFx0XHR7XG5cdFx0XHRcdFx0aWQgOiB0aGlzLl9pZFxuXHRcdFx0XHR9O1xuXG5cdFx0XHRcdHJldHVybiB0aGlzLnNhZmVFbWl0QXNQcm9taXNlKCdAcmVxdWVzdCcsICdyZXN0YXJ0VHJhbnNwb3J0JywgZGF0YSk7XG5cdFx0XHR9KVxuXHRcdFx0LnRoZW4oKHJlc3BvbnNlKSA9PlxuXHRcdFx0e1xuXHRcdFx0XHRjb25zdCByZW1vdGVJY2VQYXJhbWV0ZXJzID0gcmVzcG9uc2UuaWNlUGFyYW1ldGVycztcblxuXHRcdFx0XHQvLyBFbnF1ZXVlIGNvbW1hbmQuXG5cdFx0XHRcdHJldHVybiB0aGlzLl9jb21tYW5kUXVldWUucHVzaCgncmVzdGFydEljZScsIHsgcmVtb3RlSWNlUGFyYW1ldGVycyB9KTtcblx0XHRcdH0pXG5cdFx0XHQuY2F0Y2goKGVycm9yKSA9PlxuXHRcdFx0e1xuXHRcdFx0XHRsb2dnZXIuZXJyb3IoJ3Jlc3RhcnRJY2UoKSB8IGZhaWxlZDogJW8nLCBlcnJvcik7XG5cdFx0XHR9KTtcblx0fVxuXG5cdGVuYWJsZVN0YXRzKGludGVydmFsID0gREVGQVVMVF9TVEFUU19JTlRFUlZBTClcblx0e1xuXHRcdGxvZ2dlci5kZWJ1ZygnZW5hYmxlU3RhdHMoKSBbaW50ZXJ2YWw6JXNdJywgaW50ZXJ2YWwpO1xuXG5cdFx0aWYgKHR5cGVvZiBpbnRlcnZhbCAhPT0gJ251bWJlcicgfHwgaW50ZXJ2YWwgPCAxMDAwKVxuXHRcdFx0aW50ZXJ2YWwgPSBERUZBVUxUX1NUQVRTX0lOVEVSVkFMO1xuXG5cdFx0dGhpcy5fc3RhdHNFbmFibGVkID0gdHJ1ZTtcblxuXHRcdGNvbnN0IGRhdGEgPVxuXHRcdHtcblx0XHRcdGlkICAgICAgIDogdGhpcy5faWQsXG5cdFx0XHRpbnRlcnZhbCA6IGludGVydmFsXG5cdFx0fTtcblxuXHRcdHRoaXMuc2FmZUVtaXQoJ0Bub3RpZnknLCAnZW5hYmxlVHJhbnNwb3J0U3RhdHMnLCBkYXRhKTtcblx0fVxuXG5cdGRpc2FibGVTdGF0cygpXG5cdHtcblx0XHRsb2dnZXIuZGVidWcoJ2Rpc2FibGVTdGF0cygpJyk7XG5cblx0XHR0aGlzLl9zdGF0c0VuYWJsZWQgPSBmYWxzZTtcblxuXHRcdGNvbnN0IGRhdGEgPVxuXHRcdHtcblx0XHRcdGlkIDogdGhpcy5faWRcblx0XHR9O1xuXG5cdFx0dGhpcy5zYWZlRW1pdCgnQG5vdGlmeScsICdkaXNhYmxlVHJhbnNwb3J0U3RhdHMnLCBkYXRhKTtcblx0fVxuXG5cdF9oYW5kbGVIYW5kbGVyKClcblx0e1xuXHRcdGNvbnN0IGhhbmRsZXIgPSB0aGlzLl9oYW5kbGVyO1xuXG5cdFx0aGFuZGxlci5vbignQGNvbm5lY3Rpb25zdGF0ZWNoYW5nZScsIChzdGF0ZSkgPT5cblx0XHR7XG5cdFx0XHRpZiAodGhpcy5fY29ubmVjdGlvblN0YXRlID09PSBzdGF0ZSlcblx0XHRcdFx0cmV0dXJuO1xuXG5cdFx0XHRsb2dnZXIuZGVidWcoJ1RyYW5zcG9ydCBjb25uZWN0aW9uIHN0YXRlIGNoYW5nZWQgdG8gJXMnLCBzdGF0ZSk7XG5cblx0XHRcdHRoaXMuX2Nvbm5lY3Rpb25TdGF0ZSA9IHN0YXRlO1xuXG5cdFx0XHRpZiAoIXRoaXMuX2Nsb3NlZClcblx0XHRcdFx0dGhpcy5zYWZlRW1pdCgnY29ubmVjdGlvbnN0YXRlY2hhbmdlJywgc3RhdGUpO1xuXHRcdH0pO1xuXG5cdFx0aGFuZGxlci5vbihcblx0XHRcdCdAbmVlZGNyZWF0ZXRyYW5zcG9ydCcsXG5cdFx0XHQodHJhbnNwb3J0TG9jYWxQYXJhbWV0ZXJzLCBjYWxsYmFjaywgZXJyYmFjaykgPT5cblx0XHRcdHtcblx0XHRcdFx0Y29uc3QgZGF0YSA9XG5cdFx0XHRcdHtcblx0XHRcdFx0XHRpZCAgICAgICAgOiB0aGlzLl9pZCxcblx0XHRcdFx0XHRkaXJlY3Rpb24gOiB0aGlzLl9kaXJlY3Rpb24sXG5cdFx0XHRcdFx0b3B0aW9ucyAgIDogdGhpcy5fc2V0dGluZ3MudHJhbnNwb3J0T3B0aW9ucyxcblx0XHRcdFx0XHRhcHBEYXRhICAgOiB0aGlzLl9hcHBEYXRhXG5cdFx0XHRcdH07XG5cblx0XHRcdFx0aWYgKHRyYW5zcG9ydExvY2FsUGFyYW1ldGVycylcblx0XHRcdFx0XHRkYXRhLmR0bHNQYXJhbWV0ZXJzID0gdHJhbnNwb3J0TG9jYWxQYXJhbWV0ZXJzLmR0bHNQYXJhbWV0ZXJzO1xuXG5cdFx0XHRcdHRoaXMuc2FmZUVtaXQoJ0ByZXF1ZXN0JywgJ2NyZWF0ZVRyYW5zcG9ydCcsIGRhdGEsIGNhbGxiYWNrLCBlcnJiYWNrKTtcblx0XHRcdH0pO1xuXG5cdFx0aGFuZGxlci5vbignQG5lZWR1cGRhdGV0cmFuc3BvcnQnLCAodHJhbnNwb3J0TG9jYWxQYXJhbWV0ZXJzKSA9PlxuXHRcdHtcblx0XHRcdGNvbnN0IGRhdGEgPVxuXHRcdFx0e1xuXHRcdFx0XHRpZCAgICAgICAgICAgICA6IHRoaXMuX2lkLFxuXHRcdFx0XHRkdGxzUGFyYW1ldGVycyA6IHRyYW5zcG9ydExvY2FsUGFyYW1ldGVycy5kdGxzUGFyYW1ldGVyc1xuXHRcdFx0fTtcblxuXHRcdFx0dGhpcy5zYWZlRW1pdCgnQG5vdGlmeScsICd1cGRhdGVUcmFuc3BvcnQnLCBkYXRhKTtcblx0XHR9KTtcblxuXHRcdGhhbmRsZXIub24oJ0BuZWVkdXBkYXRlcHJvZHVjZXInLCAocHJvZHVjZXIsIHJ0cFBhcmFtZXRlcnMpID0+XG5cdFx0e1xuXHRcdFx0Y29uc3QgZGF0YSA9XG5cdFx0XHR7XG5cdFx0XHRcdGlkICAgICAgICAgICAgOiBwcm9kdWNlci5pZCxcblx0XHRcdFx0cnRwUGFyYW1ldGVycyA6IHJ0cFBhcmFtZXRlcnNcblx0XHRcdH07XG5cblx0XHRcdC8vIFVwZGF0ZSBQcm9kdWNlciBSVFAgcGFyYW1ldGVycy5cblx0XHRcdHByb2R1Y2VyLnNldFJ0cFBhcmFtZXRlcnMocnRwUGFyYW1ldGVycyk7XG5cblx0XHRcdC8vIE5vdGlmeSB0aGUgc2VydmVyLlxuXHRcdFx0dGhpcy5zYWZlRW1pdCgnQG5vdGlmeScsICd1cGRhdGVQcm9kdWNlcicsIGRhdGEpO1xuXHRcdH0pO1xuXHR9XG5cblx0LyoqXG5cdCAqIFNlbmQgdGhlIGdpdmVuIFByb2R1Y2VyIG92ZXIgdGhpcyBUcmFuc3BvcnQuXG5cdCAqXG5cdCAqIEBwcml2YXRlXG5cdCAqXG5cdCAqIEBwYXJhbSB7UHJvZHVjZXJ9IHByb2R1Y2VyXG5cdCAqXG5cdCAqIEByZXR1cm4ge1Byb21pc2V9XG5cdCAqL1xuXHRhZGRQcm9kdWNlcihwcm9kdWNlcilcblx0e1xuXHRcdGxvZ2dlci5kZWJ1ZygnYWRkUHJvZHVjZXIoKSBbcHJvZHVjZXI6JW9dJywgcHJvZHVjZXIpO1xuXG5cdFx0aWYgKHRoaXMuX2Nsb3NlZClcblx0XHRcdHJldHVybiBQcm9taXNlLnJlamVjdChuZXcgSW52YWxpZFN0YXRlRXJyb3IoJ1RyYW5zcG9ydCBjbG9zZWQnKSk7XG5cdFx0aWYgKHRoaXMuX2RpcmVjdGlvbiAhPT0gJ3NlbmQnKVxuXHRcdFx0cmV0dXJuIFByb21pc2UucmVqZWN0KG5ldyBFcnJvcignbm90IGEgc2VuZGluZyBUcmFuc3BvcnQnKSk7XG5cblx0XHQvLyBFbnF1ZXVlIGNvbW1hbmQuXG5cdFx0cmV0dXJuIHRoaXMuX2NvbW1hbmRRdWV1ZS5wdXNoKCdhZGRQcm9kdWNlcicsIHsgcHJvZHVjZXIgfSk7XG5cdH1cblxuXHQvKipcblx0ICogQHByaXZhdGVcblx0ICovXG5cdHJlbW92ZVByb2R1Y2VyKHByb2R1Y2VyLCBvcmlnaW5hdG9yLCBhcHBEYXRhKVxuXHR7XG5cdFx0bG9nZ2VyLmRlYnVnKCdyZW1vdmVQcm9kdWNlcigpIFtwcm9kdWNlcjolb10nLCBwcm9kdWNlcik7XG5cblx0XHQvLyBFbnF1ZXVlIGNvbW1hbmQuXG5cdFx0aWYgKCF0aGlzLl9jbG9zZWQpXG5cdFx0e1xuXHRcdFx0dGhpcy5fY29tbWFuZFF1ZXVlLnB1c2goJ3JlbW92ZVByb2R1Y2VyJywgeyBwcm9kdWNlciB9KVxuXHRcdFx0XHQuY2F0Y2goKCkgPT4ge30pO1xuXHRcdH1cblxuXHRcdGlmIChvcmlnaW5hdG9yID09PSAnbG9jYWwnKVxuXHRcdFx0dGhpcy5zYWZlRW1pdCgnQG5vdGlmeScsICdjbG9zZVByb2R1Y2VyJywgeyBpZDogcHJvZHVjZXIuaWQsIGFwcERhdGEgfSk7XG5cdH1cblxuXHQvKipcblx0ICogQHByaXZhdGVcblx0ICovXG5cdHBhdXNlUHJvZHVjZXIocHJvZHVjZXIsIGFwcERhdGEpXG5cdHtcblx0XHRsb2dnZXIuZGVidWcoJ3BhdXNlUHJvZHVjZXIoKSBbcHJvZHVjZXI6JW9dJywgcHJvZHVjZXIpO1xuXG5cdFx0Y29uc3QgZGF0YSA9XG5cdFx0e1xuXHRcdFx0aWQgICAgICA6IHByb2R1Y2VyLmlkLFxuXHRcdFx0YXBwRGF0YSA6IGFwcERhdGFcblx0XHR9O1xuXG5cdFx0dGhpcy5zYWZlRW1pdCgnQG5vdGlmeScsICdwYXVzZVByb2R1Y2VyJywgZGF0YSk7XG5cdH1cblxuXHQvKipcblx0ICogQHByaXZhdGVcblx0ICovXG5cdHJlc3VtZVByb2R1Y2VyKHByb2R1Y2VyLCBhcHBEYXRhKVxuXHR7XG5cdFx0bG9nZ2VyLmRlYnVnKCdyZXN1bWVQcm9kdWNlcigpIFtwcm9kdWNlcjolb10nLCBwcm9kdWNlcik7XG5cblx0XHRjb25zdCBkYXRhID1cblx0XHR7XG5cdFx0XHRpZCAgICAgIDogcHJvZHVjZXIuaWQsXG5cdFx0XHRhcHBEYXRhIDogYXBwRGF0YVxuXHRcdH07XG5cblx0XHR0aGlzLnNhZmVFbWl0KCdAbm90aWZ5JywgJ3Jlc3VtZVByb2R1Y2VyJywgZGF0YSk7XG5cdH1cblxuXHQvKipcblx0ICogQHByaXZhdGVcblx0ICpcblx0ICogQHJldHVybiB7UHJvbWlzZX1cblx0ICovXG5cdHJlcGxhY2VQcm9kdWNlclRyYWNrKHByb2R1Y2VyLCB0cmFjaylcblx0e1xuXHRcdGxvZ2dlci5kZWJ1ZygncmVwbGFjZVByb2R1Y2VyVHJhY2soKSBbcHJvZHVjZXI6JW9dJywgcHJvZHVjZXIpO1xuXG5cdFx0cmV0dXJuIHRoaXMuX2NvbW1hbmRRdWV1ZS5wdXNoKFxuXHRcdFx0J3JlcGxhY2VQcm9kdWNlclRyYWNrJywgeyBwcm9kdWNlciwgdHJhY2sgfSk7XG5cdH1cblxuXHQvKipcblx0ICogQHByaXZhdGVcblx0ICovXG5cdGVuYWJsZVByb2R1Y2VyU3RhdHMocHJvZHVjZXIsIGludGVydmFsKVxuXHR7XG5cdFx0bG9nZ2VyLmRlYnVnKCdlbmFibGVQcm9kdWNlclN0YXRzKCkgW3Byb2R1Y2VyOiVvXScsIHByb2R1Y2VyKTtcblxuXHRcdGNvbnN0IGRhdGEgPVxuXHRcdHtcblx0XHRcdGlkICAgICAgIDogcHJvZHVjZXIuaWQsXG5cdFx0XHRpbnRlcnZhbCA6IGludGVydmFsXG5cdFx0fTtcblxuXHRcdHRoaXMuc2FmZUVtaXQoJ0Bub3RpZnknLCAnZW5hYmxlUHJvZHVjZXJTdGF0cycsIGRhdGEpO1xuXHR9XG5cblx0LyoqXG5cdCAqIEBwcml2YXRlXG5cdCAqL1xuXHRkaXNhYmxlUHJvZHVjZXJTdGF0cyhwcm9kdWNlcilcblx0e1xuXHRcdGxvZ2dlci5kZWJ1ZygnZGlzYWJsZVByb2R1Y2VyU3RhdHMoKSBbcHJvZHVjZXI6JW9dJywgcHJvZHVjZXIpO1xuXG5cdFx0Y29uc3QgZGF0YSA9XG5cdFx0e1xuXHRcdFx0aWQgOiBwcm9kdWNlci5pZFxuXHRcdH07XG5cblx0XHR0aGlzLnNhZmVFbWl0KCdAbm90aWZ5JywgJ2Rpc2FibGVQcm9kdWNlclN0YXRzJywgZGF0YSk7XG5cdH1cblxuXHQvKipcblx0ICogUmVjZWl2ZSB0aGUgZ2l2ZW4gQ29uc3VtZXIgb3ZlciB0aGlzIFRyYW5zcG9ydC5cblx0ICpcblx0ICogQHByaXZhdGVcblx0ICpcblx0ICogQHBhcmFtIHtDb25zdW1lcn0gY29uc3VtZXJcblx0ICpcblx0ICogQHJldHVybiB7UHJvbWlzZX0gUmVzb2x2ZXMgdG8gYSByZW1vdGUgTWVkaWFTdHJlYW1UcmFjay5cblx0ICovXG5cdGFkZENvbnN1bWVyKGNvbnN1bWVyKVxuXHR7XG5cdFx0bG9nZ2VyLmRlYnVnKCdhZGRDb25zdW1lcigpIFtjb25zdW1lcjolb10nLCBjb25zdW1lcik7XG5cblx0XHRpZiAodGhpcy5fY2xvc2VkKVxuXHRcdFx0cmV0dXJuIFByb21pc2UucmVqZWN0KG5ldyBJbnZhbGlkU3RhdGVFcnJvcignVHJhbnNwb3J0IGNsb3NlZCcpKTtcblx0XHRpZiAodGhpcy5fZGlyZWN0aW9uICE9PSAncmVjdicpXG5cdFx0XHRyZXR1cm4gUHJvbWlzZS5yZWplY3QobmV3IEVycm9yKCdub3QgYSByZWNlaXZpbmcgVHJhbnNwb3J0JykpO1xuXG5cdFx0Ly8gRW5xdWV1ZSBjb21tYW5kLlxuXHRcdHJldHVybiB0aGlzLl9jb21tYW5kUXVldWUucHVzaCgnYWRkQ29uc3VtZXInLCB7IGNvbnN1bWVyIH0pO1xuXHR9XG5cblx0LyoqXG5cdCAqIEBwcml2YXRlXG5cdCAqL1xuXHRyZW1vdmVDb25zdW1lcihjb25zdW1lcilcblx0e1xuXHRcdGxvZ2dlci5kZWJ1ZygncmVtb3ZlQ29uc3VtZXIoKSBbY29uc3VtZXI6JW9dJywgY29uc3VtZXIpO1xuXG5cdFx0Ly8gRW5xdWV1ZSBjb21tYW5kLlxuXHRcdHRoaXMuX2NvbW1hbmRRdWV1ZS5wdXNoKCdyZW1vdmVDb25zdW1lcicsIHsgY29uc3VtZXIgfSlcblx0XHRcdC5jYXRjaCgoKSA9PiB7fSk7XG5cdH1cblxuXHQvKipcblx0ICogQHByaXZhdGVcblx0ICovXG5cdHBhdXNlQ29uc3VtZXIoY29uc3VtZXIsIGFwcERhdGEpXG5cdHtcblx0XHRsb2dnZXIuZGVidWcoJ3BhdXNlQ29uc3VtZXIoKSBbY29uc3VtZXI6JW9dJywgY29uc3VtZXIpO1xuXG5cdFx0Y29uc3QgZGF0YSA9XG5cdFx0e1xuXHRcdFx0aWQgICAgICA6IGNvbnN1bWVyLmlkLFxuXHRcdFx0YXBwRGF0YSA6IGFwcERhdGFcblx0XHR9O1xuXG5cdFx0dGhpcy5zYWZlRW1pdCgnQG5vdGlmeScsICdwYXVzZUNvbnN1bWVyJywgZGF0YSk7XG5cdH1cblxuXHQvKipcblx0ICogQHByaXZhdGVcblx0ICovXG5cdHJlc3VtZUNvbnN1bWVyKGNvbnN1bWVyLCBhcHBEYXRhKVxuXHR7XG5cdFx0bG9nZ2VyLmRlYnVnKCdyZXN1bWVDb25zdW1lcigpIFtjb25zdW1lcjolb10nLCBjb25zdW1lcik7XG5cblx0XHRjb25zdCBkYXRhID1cblx0XHR7XG5cdFx0XHRpZCAgICAgIDogY29uc3VtZXIuaWQsXG5cdFx0XHRhcHBEYXRhIDogYXBwRGF0YVxuXHRcdH07XG5cblx0XHR0aGlzLnNhZmVFbWl0KCdAbm90aWZ5JywgJ3Jlc3VtZUNvbnN1bWVyJywgZGF0YSk7XG5cdH1cblxuXHQvKipcblx0ICogQHByaXZhdGVcblx0ICovXG5cdHNldENvbnN1bWVyUHJlZmVycmVkUHJvZmlsZShjb25zdW1lciwgcHJvZmlsZSlcblx0e1xuXHRcdGxvZ2dlci5kZWJ1Zygnc2V0Q29uc3VtZXJQcmVmZXJyZWRQcm9maWxlKCkgW2NvbnN1bWVyOiVvXScsIGNvbnN1bWVyKTtcblxuXHRcdGNvbnN0IGRhdGEgPVxuXHRcdHtcblx0XHRcdGlkICAgICAgOiBjb25zdW1lci5pZCxcblx0XHRcdHByb2ZpbGUgOiBwcm9maWxlXG5cdFx0fTtcblxuXHRcdHRoaXMuc2FmZUVtaXQoJ0Bub3RpZnknLCAnc2V0Q29uc3VtZXJQcmVmZXJyZWRQcm9maWxlJywgZGF0YSk7XG5cdH1cblxuXHQvKipcblx0ICogQHByaXZhdGVcblx0ICovXG5cdGVuYWJsZUNvbnN1bWVyU3RhdHMoY29uc3VtZXIsIGludGVydmFsKVxuXHR7XG5cdFx0bG9nZ2VyLmRlYnVnKCdlbmFibGVDb25zdW1lclN0YXRzKCkgW2NvbnN1bWVyOiVvXScsIGNvbnN1bWVyKTtcblxuXHRcdGNvbnN0IGRhdGEgPVxuXHRcdHtcblx0XHRcdGlkICAgICAgIDogY29uc3VtZXIuaWQsXG5cdFx0XHRpbnRlcnZhbCA6IGludGVydmFsXG5cdFx0fTtcblxuXHRcdHRoaXMuc2FmZUVtaXQoJ0Bub3RpZnknLCAnZW5hYmxlQ29uc3VtZXJTdGF0cycsIGRhdGEpO1xuXHR9XG5cblx0LyoqXG5cdCAqIEBwcml2YXRlXG5cdCAqL1xuXHRkaXNhYmxlQ29uc3VtZXJTdGF0cyhjb25zdW1lcilcblx0e1xuXHRcdGxvZ2dlci5kZWJ1ZygnZGlzYWJsZUNvbnN1bWVyU3RhdHMoKSBbY29uc3VtZXI6JW9dJywgY29uc3VtZXIpO1xuXG5cdFx0Y29uc3QgZGF0YSA9XG5cdFx0e1xuXHRcdFx0aWQgOiBjb25zdW1lci5pZFxuXHRcdH07XG5cblx0XHR0aGlzLnNhZmVFbWl0KCdAbm90aWZ5JywgJ2Rpc2FibGVDb25zdW1lclN0YXRzJywgZGF0YSk7XG5cdH1cblxuXHQvKipcblx0ICogUmVjZWl2ZSByZW1vdGUgc3RhdHMuXG5cdCAqXG5cdCAqIEBwcml2YXRlXG5cdCAqXG5cdCAqIEBwYXJhbSB7T2JqZWN0fSBzdGF0c1xuXHQgKi9cblx0cmVtb3RlU3RhdHMoc3RhdHMpXG5cdHtcblx0XHR0aGlzLnNhZmVFbWl0KCdzdGF0cycsIHN0YXRzKTtcblx0fVxuXG5cdF9leGVjQ29tbWFuZChjb21tYW5kLCBwcm9taXNlSG9sZGVyKVxuXHR7XG5cdFx0bGV0IHByb21pc2U7XG5cblx0XHR0cnlcblx0XHR7XG5cdFx0XHRzd2l0Y2ggKGNvbW1hbmQubWV0aG9kKVxuXHRcdFx0e1xuXHRcdFx0XHRjYXNlICdhZGRQcm9kdWNlcic6XG5cdFx0XHRcdHtcblx0XHRcdFx0XHRjb25zdCB7IHByb2R1Y2VyIH0gPSBjb21tYW5kO1xuXG5cdFx0XHRcdFx0cHJvbWlzZSA9IHRoaXMuX2V4ZWNBZGRQcm9kdWNlcihwcm9kdWNlcik7XG5cdFx0XHRcdFx0YnJlYWs7XG5cdFx0XHRcdH1cblxuXHRcdFx0XHRjYXNlICdyZW1vdmVQcm9kdWNlcic6XG5cdFx0XHRcdHtcblx0XHRcdFx0XHRjb25zdCB7IHByb2R1Y2VyIH0gPSBjb21tYW5kO1xuXG5cdFx0XHRcdFx0cHJvbWlzZSA9IHRoaXMuX2V4ZWNSZW1vdmVQcm9kdWNlcihwcm9kdWNlcik7XG5cdFx0XHRcdFx0YnJlYWs7XG5cdFx0XHRcdH1cblxuXHRcdFx0XHRjYXNlICdyZXBsYWNlUHJvZHVjZXJUcmFjayc6XG5cdFx0XHRcdHtcblx0XHRcdFx0XHRjb25zdCB7IHByb2R1Y2VyLCB0cmFjayB9ID0gY29tbWFuZDtcblxuXHRcdFx0XHRcdHByb21pc2UgPSB0aGlzLl9leGVjUmVwbGFjZVByb2R1Y2VyVHJhY2socHJvZHVjZXIsIHRyYWNrKTtcblx0XHRcdFx0XHRicmVhaztcblx0XHRcdFx0fVxuXG5cdFx0XHRcdGNhc2UgJ2FkZENvbnN1bWVyJzpcblx0XHRcdFx0e1xuXHRcdFx0XHRcdGNvbnN0IHsgY29uc3VtZXIgfSA9IGNvbW1hbmQ7XG5cblx0XHRcdFx0XHRwcm9taXNlID0gdGhpcy5fZXhlY0FkZENvbnN1bWVyKGNvbnN1bWVyKTtcblx0XHRcdFx0XHRicmVhaztcblx0XHRcdFx0fVxuXG5cdFx0XHRcdGNhc2UgJ3JlbW92ZUNvbnN1bWVyJzpcblx0XHRcdFx0e1xuXHRcdFx0XHRcdGNvbnN0IHsgY29uc3VtZXIgfSA9IGNvbW1hbmQ7XG5cblx0XHRcdFx0XHRwcm9taXNlID0gdGhpcy5fZXhlY1JlbW92ZUNvbnN1bWVyKGNvbnN1bWVyKTtcblx0XHRcdFx0XHRicmVhaztcblx0XHRcdFx0fVxuXG5cdFx0XHRcdGNhc2UgJ3Jlc3RhcnRJY2UnOlxuXHRcdFx0XHR7XG5cdFx0XHRcdFx0Y29uc3QgeyByZW1vdGVJY2VQYXJhbWV0ZXJzIH0gPSBjb21tYW5kO1xuXG5cdFx0XHRcdFx0cHJvbWlzZSA9IHRoaXMuX2V4ZWNSZXN0YXJ0SWNlKHJlbW90ZUljZVBhcmFtZXRlcnMpO1xuXHRcdFx0XHRcdGJyZWFrO1xuXHRcdFx0XHR9XG5cblx0XHRcdFx0ZGVmYXVsdDpcblx0XHRcdFx0e1xuXHRcdFx0XHRcdHByb21pc2UgPSBQcm9taXNlLnJlamVjdChcblx0XHRcdFx0XHRcdG5ldyBFcnJvcihgdW5rbm93biBjb21tYW5kIG1ldGhvZCBcIiR7Y29tbWFuZC5tZXRob2R9XCJgKSk7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9XG5cdFx0Y2F0Y2ggKGVycm9yKVxuXHRcdHtcblx0XHRcdHByb21pc2UgPSBQcm9taXNlLnJlamVjdChlcnJvcik7XG5cdFx0fVxuXG5cdFx0Ly8gRmlsbCB0aGUgZ2l2ZW4gUHJvbWlzZSBob2xkZXIuXG5cdFx0cHJvbWlzZUhvbGRlci5wcm9taXNlID0gcHJvbWlzZTtcblx0fVxuXG5cdF9leGVjQWRkUHJvZHVjZXIocHJvZHVjZXIpXG5cdHtcblx0XHRsb2dnZXIuZGVidWcoJ19leGVjQWRkUHJvZHVjZXIoKScpO1xuXG5cdFx0bGV0IHByb2R1Y2VyUnRwUGFyYW1ldGVycztcblxuXHRcdC8vIENhbGwgdGhlIGhhbmRsZXIuXG5cdFx0cmV0dXJuIFByb21pc2UucmVzb2x2ZSgpXG5cdFx0XHQudGhlbigoKSA9PlxuXHRcdFx0e1xuXHRcdFx0XHRyZXR1cm4gdGhpcy5faGFuZGxlci5hZGRQcm9kdWNlcihwcm9kdWNlcik7XG5cdFx0XHR9KVxuXHRcdFx0LnRoZW4oKHJ0cFBhcmFtZXRlcnMpID0+XG5cdFx0XHR7XG5cdFx0XHRcdHByb2R1Y2VyUnRwUGFyYW1ldGVycyA9IHJ0cFBhcmFtZXRlcnM7XG5cblx0XHRcdFx0Y29uc3QgZGF0YSA9XG5cdFx0XHRcdHtcblx0XHRcdFx0XHRpZCAgICAgICAgICAgIDogcHJvZHVjZXIuaWQsXG5cdFx0XHRcdFx0a2luZCAgICAgICAgICA6IHByb2R1Y2VyLmtpbmQsXG5cdFx0XHRcdFx0dHJhbnNwb3J0SWQgICA6IHRoaXMuX2lkLFxuXHRcdFx0XHRcdHJ0cFBhcmFtZXRlcnMgOiBydHBQYXJhbWV0ZXJzLFxuXHRcdFx0XHRcdHBhdXNlZCAgICAgICAgOiBwcm9kdWNlci5sb2NhbGx5UGF1c2VkLFxuXHRcdFx0XHRcdGFwcERhdGEgICAgICAgOiBwcm9kdWNlci5hcHBEYXRhXG5cdFx0XHRcdH07XG5cblx0XHRcdFx0cmV0dXJuIHRoaXMuc2FmZUVtaXRBc1Byb21pc2UoJ0ByZXF1ZXN0JywgJ2NyZWF0ZVByb2R1Y2VyJywgZGF0YSk7XG5cdFx0XHR9KVxuXHRcdFx0LnRoZW4oKCkgPT5cblx0XHRcdHtcblx0XHRcdFx0cHJvZHVjZXIuc2V0UnRwUGFyYW1ldGVycyhwcm9kdWNlclJ0cFBhcmFtZXRlcnMpO1xuXHRcdFx0fSk7XG5cdH1cblxuXHRfZXhlY1JlbW92ZVByb2R1Y2VyKHByb2R1Y2VyKVxuXHR7XG5cdFx0bG9nZ2VyLmRlYnVnKCdfZXhlY1JlbW92ZVByb2R1Y2VyKCknKTtcblxuXHRcdC8vIENhbGwgdGhlIGhhbmRsZXIuXG5cdFx0cmV0dXJuIHRoaXMuX2hhbmRsZXIucmVtb3ZlUHJvZHVjZXIocHJvZHVjZXIpO1xuXHR9XG5cblx0X2V4ZWNSZXBsYWNlUHJvZHVjZXJUcmFjayhwcm9kdWNlciwgdHJhY2spXG5cdHtcblx0XHRsb2dnZXIuZGVidWcoJ19leGVjUmVwbGFjZVByb2R1Y2VyVHJhY2soKScpO1xuXG5cdFx0Ly8gQ2FsbCB0aGUgaGFuZGxlci5cblx0XHRyZXR1cm4gdGhpcy5faGFuZGxlci5yZXBsYWNlUHJvZHVjZXJUcmFjayhwcm9kdWNlciwgdHJhY2spO1xuXHR9XG5cblx0X2V4ZWNBZGRDb25zdW1lcihjb25zdW1lcilcblx0e1xuXHRcdGxvZ2dlci5kZWJ1ZygnX2V4ZWNBZGRDb25zdW1lcigpJyk7XG5cblx0XHRsZXQgY29uc3VtZXJUcmFjaztcblxuXHRcdC8vIENhbGwgdGhlIGhhbmRsZXIuXG5cdFx0cmV0dXJuIFByb21pc2UucmVzb2x2ZSgpXG5cdFx0XHQudGhlbigoKSA9PlxuXHRcdFx0e1xuXHRcdFx0XHRyZXR1cm4gdGhpcy5faGFuZGxlci5hZGRDb25zdW1lcihjb25zdW1lcik7XG5cdFx0XHR9KVxuXHRcdFx0LnRoZW4oKHRyYWNrKSA9PlxuXHRcdFx0e1xuXHRcdFx0XHRjb25zdW1lclRyYWNrID0gdHJhY2s7XG5cblx0XHRcdFx0Y29uc3QgZGF0YSA9XG5cdFx0XHRcdHtcblx0XHRcdFx0XHRpZCAgICAgICAgICAgICAgIDogY29uc3VtZXIuaWQsXG5cdFx0XHRcdFx0dHJhbnNwb3J0SWQgICAgICA6IHRoaXMuaWQsXG5cdFx0XHRcdFx0cGF1c2VkICAgICAgICAgICA6IGNvbnN1bWVyLmxvY2FsbHlQYXVzZWQsXG5cdFx0XHRcdFx0cHJlZmVycmVkUHJvZmlsZSA6IGNvbnN1bWVyLnByZWZlcnJlZFByb2ZpbGVcblx0XHRcdFx0fTtcblxuXHRcdFx0XHRyZXR1cm4gdGhpcy5zYWZlRW1pdEFzUHJvbWlzZSgnQHJlcXVlc3QnLCAnZW5hYmxlQ29uc3VtZXInLCBkYXRhKTtcblx0XHRcdH0pXG5cdFx0XHQudGhlbigocmVzcG9uc2UpID0+XG5cdFx0XHR7XG5cdFx0XHRcdGNvbnN0IHsgcGF1c2VkLCBwcmVmZXJyZWRQcm9maWxlLCBlZmZlY3RpdmVQcm9maWxlIH0gPSByZXNwb25zZTtcblxuXHRcdFx0XHRpZiAocGF1c2VkKVxuXHRcdFx0XHRcdGNvbnN1bWVyLnJlbW90ZVBhdXNlKCk7XG5cblx0XHRcdFx0aWYgKHByZWZlcnJlZFByb2ZpbGUpXG5cdFx0XHRcdFx0Y29uc3VtZXIucmVtb3RlU2V0UHJlZmVycmVkUHJvZmlsZShwcmVmZXJyZWRQcm9maWxlKTtcblxuXHRcdFx0XHRpZiAoZWZmZWN0aXZlUHJvZmlsZSlcblx0XHRcdFx0XHRjb25zdW1lci5yZW1vdGVFZmZlY3RpdmVQcm9maWxlQ2hhbmdlZChlZmZlY3RpdmVQcm9maWxlKTtcblxuXHRcdFx0XHRyZXR1cm4gY29uc3VtZXJUcmFjaztcblx0XHRcdH0pO1xuXHR9XG5cblx0X2V4ZWNSZW1vdmVDb25zdW1lcihjb25zdW1lcilcblx0e1xuXHRcdGxvZ2dlci5kZWJ1ZygnX2V4ZWNSZW1vdmVDb25zdW1lcigpJyk7XG5cblx0XHQvLyBDYWxsIHRoZSBoYW5kbGVyLlxuXHRcdHJldHVybiB0aGlzLl9oYW5kbGVyLnJlbW92ZUNvbnN1bWVyKGNvbnN1bWVyKTtcblx0fVxuXG5cdF9leGVjUmVzdGFydEljZShyZW1vdGVJY2VQYXJhbWV0ZXJzKVxuXHR7XG5cdFx0bG9nZ2VyLmRlYnVnKCdfZXhlY1Jlc3RhcnRJY2UoKScpO1xuXG5cdFx0Ly8gQ2FsbCB0aGUgaGFuZGxlci5cblx0XHRyZXR1cm4gdGhpcy5faGFuZGxlci5yZXN0YXJ0SWNlKHJlbW90ZUljZVBhcmFtZXRlcnMpO1xuXHR9XG59XG4iLCIvKipcbiAqIEVycm9yIHByb2R1Y2VkIHdoZW4gY2FsbGluZyBhIG1ldGhvZCBpbiBhbiBpbnZhbGlkIHN0YXRlLlxuICovXG5leHBvcnQgY2xhc3MgSW52YWxpZFN0YXRlRXJyb3IgZXh0ZW5kcyBFcnJvclxue1xuXHRjb25zdHJ1Y3RvcihtZXNzYWdlKVxuXHR7XG5cdFx0c3VwZXIobWVzc2FnZSk7XG5cblx0XHR0aGlzLm5hbWUgPSAnSW52YWxpZFN0YXRlRXJyb3InO1xuXG5cdFx0aWYgKEVycm9yLmhhc093blByb3BlcnR5KCdjYXB0dXJlU3RhY2tUcmFjZScpKSAvLyBKdXN0IGluIFY4LlxuXHRcdFx0RXJyb3IuY2FwdHVyZVN0YWNrVHJhY2UodGhpcywgSW52YWxpZFN0YXRlRXJyb3IpO1xuXHRcdGVsc2Vcblx0XHRcdHRoaXMuc3RhY2sgPSAobmV3IEVycm9yKG1lc3NhZ2UpKS5zdGFjaztcblx0fVxufVxuXG4vKipcbiAqIEVycm9yIHByb2R1Y2VkIHdoZW4gYSBQcm9taXNlIGlzIHJlamVjdGVkIGR1ZSB0byBhIHRpbWVvdXQuXG4gKi9cbmV4cG9ydCBjbGFzcyBUaW1lb3V0RXJyb3IgZXh0ZW5kcyBFcnJvclxue1xuXHRjb25zdHJ1Y3RvcihtZXNzYWdlKVxuXHR7XG5cdFx0c3VwZXIobWVzc2FnZSk7XG5cblx0XHR0aGlzLm5hbWUgPSAnVGltZW91dEVycm9yJztcblxuXHRcdGlmIChFcnJvci5oYXNPd25Qcm9wZXJ0eSgnY2FwdHVyZVN0YWNrVHJhY2UnKSkgLy8gSnVzdCBpbiBWOC5cblx0XHRcdEVycm9yLmNhcHR1cmVTdGFja1RyYWNlKHRoaXMsIEludmFsaWRTdGF0ZUVycm9yKTtcblx0XHRlbHNlXG5cdFx0XHR0aGlzLnN0YWNrID0gKG5ldyBFcnJvcihtZXNzYWdlKSkuc3RhY2s7XG5cdH1cbn1cblxuLyoqXG4gKiBFcnJvciBpbmRpY2F0aW5nIG5vdCBzdXBwb3J0IGZvciBzb21ldGhpbmcuXG4gKi9cbmV4cG9ydCBjbGFzcyBVbnN1cHBvcnRlZEVycm9yIGV4dGVuZHMgRXJyb3Jcbntcblx0Y29uc3RydWN0b3IobWVzc2FnZSwgZGF0YSlcblx0e1xuXHRcdHN1cGVyKG1lc3NhZ2UpO1xuXG5cdFx0dGhpcy5uYW1lID0gJ1Vuc3VwcG9ydGVkRXJyb3InO1xuXG5cdFx0aWYgKEVycm9yLmhhc093blByb3BlcnR5KCdjYXB0dXJlU3RhY2tUcmFjZScpKSAvLyBKdXN0IGluIFY4LlxuXHRcdFx0RXJyb3IuY2FwdHVyZVN0YWNrVHJhY2UodGhpcywgSW52YWxpZFN0YXRlRXJyb3IpO1xuXHRcdGVsc2Vcblx0XHRcdHRoaXMuc3RhY2sgPSAobmV3IEVycm9yKG1lc3NhZ2UpKS5zdGFjaztcblxuXHRcdHRoaXMuZGF0YSA9IGRhdGE7XG5cdH1cbn1cbiIsImltcG9ydCBzZHBUcmFuc2Zvcm0gZnJvbSAnc2RwLXRyYW5zZm9ybSc7XG5pbXBvcnQgTG9nZ2VyIGZyb20gJy4uL0xvZ2dlcic7XG5pbXBvcnQgRW5oYW5jZWRFdmVudEVtaXR0ZXIgZnJvbSAnLi4vRW5oYW5jZWRFdmVudEVtaXR0ZXInO1xuaW1wb3J0ICogYXMgdXRpbHMgZnJvbSAnLi4vdXRpbHMnO1xuaW1wb3J0ICogYXMgb3J0YyBmcm9tICcuLi9vcnRjJztcbmltcG9ydCAqIGFzIHNkcENvbW1vblV0aWxzIGZyb20gJy4vc2RwL2NvbW1vblV0aWxzJztcbmltcG9ydCAqIGFzIHNkcFBsYW5CVXRpbHMgZnJvbSAnLi9zZHAvcGxhbkJVdGlscyc7XG5pbXBvcnQgUmVtb3RlUGxhbkJTZHAgZnJvbSAnLi9zZHAvUmVtb3RlUGxhbkJTZHAnO1xuXG5jb25zdCBsb2dnZXIgPSBuZXcgTG9nZ2VyKCdDaHJvbWU1NScpO1xuXG5jbGFzcyBIYW5kbGVyIGV4dGVuZHMgRW5oYW5jZWRFdmVudEVtaXR0ZXJcbntcblx0Y29uc3RydWN0b3IoZGlyZWN0aW9uLCBydHBQYXJhbWV0ZXJzQnlLaW5kLCBzZXR0aW5ncylcblx0e1xuXHRcdHN1cGVyKGxvZ2dlcik7XG5cblx0XHQvLyBSVENQZWVyQ29ubmVjdGlvbiBpbnN0YW5jZS5cblx0XHQvLyBAdHlwZSB7UlRDUGVlckNvbm5lY3Rpb259XG5cdFx0dGhpcy5fcGMgPSBuZXcgUlRDUGVlckNvbm5lY3Rpb24oXG5cdFx0XHR7XG5cdFx0XHRcdGljZVNlcnZlcnMgICAgICAgICA6IHNldHRpbmdzLnR1cm5TZXJ2ZXJzIHx8IFtdLFxuXHRcdFx0XHRpY2VUcmFuc3BvcnRQb2xpY3kgOiAnYWxsJyxcblx0XHRcdFx0YnVuZGxlUG9saWN5ICAgICAgIDogJ21heC1idW5kbGUnLFxuXHRcdFx0XHRydGNwTXV4UG9saWN5ICAgICAgOiAncmVxdWlyZSdcblx0XHRcdH0pO1xuXG5cdFx0Ly8gR2VuZXJpYyBzZW5kaW5nIFJUUCBwYXJhbWV0ZXJzIGZvciBhdWRpbyBhbmQgdmlkZW8uXG5cdFx0Ly8gQHR5cGUge09iamVjdH1cblx0XHR0aGlzLl9ydHBQYXJhbWV0ZXJzQnlLaW5kID0gcnRwUGFyYW1ldGVyc0J5S2luZDtcblxuXHRcdC8vIFJlbW90ZSBTRFAgaGFuZGxlci5cblx0XHQvLyBAdHlwZSB7UmVtb3RlUGxhbkJTZHB9XG5cdFx0dGhpcy5fcmVtb3RlU2RwID0gbmV3IFJlbW90ZVBsYW5CU2RwKGRpcmVjdGlvbiwgcnRwUGFyYW1ldGVyc0J5S2luZCk7XG5cblx0XHQvLyBIYW5kbGUgUlRDUGVlckNvbm5lY3Rpb24gY29ubmVjdGlvbiBzdGF0dXMuXG5cdFx0dGhpcy5fcGMuYWRkRXZlbnRMaXN0ZW5lcignaWNlY29ubmVjdGlvbnN0YXRlY2hhbmdlJywgKCkgPT5cblx0XHR7XG5cdFx0XHRzd2l0Y2ggKHRoaXMuX3BjLmljZUNvbm5lY3Rpb25TdGF0ZSlcblx0XHRcdHtcblx0XHRcdFx0Y2FzZSAnY2hlY2tpbmcnOlxuXHRcdFx0XHRcdHRoaXMuZW1pdCgnQGNvbm5lY3Rpb25zdGF0ZWNoYW5nZScsICdjb25uZWN0aW5nJyk7XG5cdFx0XHRcdFx0YnJlYWs7XG5cdFx0XHRcdGNhc2UgJ2Nvbm5lY3RlZCc6XG5cdFx0XHRcdGNhc2UgJ2NvbXBsZXRlZCc6XG5cdFx0XHRcdFx0dGhpcy5lbWl0KCdAY29ubmVjdGlvbnN0YXRlY2hhbmdlJywgJ2Nvbm5lY3RlZCcpO1xuXHRcdFx0XHRcdGJyZWFrO1xuXHRcdFx0XHRjYXNlICdmYWlsZWQnOlxuXHRcdFx0XHRcdHRoaXMuZW1pdCgnQGNvbm5lY3Rpb25zdGF0ZWNoYW5nZScsICdmYWlsZWQnKTtcblx0XHRcdFx0XHRicmVhaztcblx0XHRcdFx0Y2FzZSAnZGlzY29ubmVjdGVkJzpcblx0XHRcdFx0XHR0aGlzLmVtaXQoJ0Bjb25uZWN0aW9uc3RhdGVjaGFuZ2UnLCAnZGlzY29ubmVjdGVkJyk7XG5cdFx0XHRcdFx0YnJlYWs7XG5cdFx0XHRcdGNhc2UgJ2Nsb3NlZCc6XG5cdFx0XHRcdFx0dGhpcy5lbWl0KCdAY29ubmVjdGlvbnN0YXRlY2hhbmdlJywgJ2Nsb3NlZCcpO1xuXHRcdFx0XHRcdGJyZWFrO1xuXHRcdFx0fVxuXHRcdH0pO1xuXHR9XG5cblx0Y2xvc2UoKVxuXHR7XG5cdFx0bG9nZ2VyLmRlYnVnKCdjbG9zZSgpJyk7XG5cblx0XHQvLyBDbG9zZSBSVENQZWVyQ29ubmVjdGlvbi5cblx0XHR0cnkgeyB0aGlzLl9wYy5jbG9zZSgpOyB9XG5cdFx0Y2F0Y2ggKGVycm9yKSB7fVxuXHR9XG59XG5cbmNsYXNzIFNlbmRIYW5kbGVyIGV4dGVuZHMgSGFuZGxlclxue1xuXHRjb25zdHJ1Y3RvcihydHBQYXJhbWV0ZXJzQnlLaW5kLCBzZXR0aW5ncylcblx0e1xuXHRcdHN1cGVyKCdzZW5kJywgcnRwUGFyYW1ldGVyc0J5S2luZCwgc2V0dGluZ3MpO1xuXG5cdFx0Ly8gR290IHRyYW5zcG9ydCBsb2NhbCBhbmQgcmVtb3RlIHBhcmFtZXRlcnMuXG5cdFx0Ly8gQHR5cGUge0Jvb2xlYW59XG5cdFx0dGhpcy5fdHJhbnNwb3J0UmVhZHkgPSBmYWxzZTtcblxuXHRcdC8vIExvY2FsIHN0cmVhbS5cblx0XHQvLyBAdHlwZSB7TWVkaWFTdHJlYW19XG5cdFx0dGhpcy5fc3RyZWFtID0gbmV3IE1lZGlhU3RyZWFtKCk7XG5cdH1cblxuXHRhZGRQcm9kdWNlcihwcm9kdWNlcilcblx0e1xuXHRcdGNvbnN0IHsgdHJhY2sgfSA9IHByb2R1Y2VyO1xuXG5cdFx0bG9nZ2VyLmRlYnVnKFxuXHRcdFx0J2FkZFByb2R1Y2VyKCkgW2lkOiVzLCBraW5kOiVzLCB0cmFja0lkOiVzXScsXG5cdFx0XHRwcm9kdWNlci5pZCwgcHJvZHVjZXIua2luZCwgdHJhY2suaWQpO1xuXG5cdFx0aWYgKHRoaXMuX3N0cmVhbS5nZXRUcmFja0J5SWQodHJhY2suaWQpKVxuXHRcdFx0cmV0dXJuIFByb21pc2UucmVqZWN0KG5ldyBFcnJvcigndHJhY2sgYWxyZWFkeSBhZGRlZCcpKTtcblxuXHRcdGxldCBsb2NhbFNkcE9iajtcblxuXHRcdHJldHVybiBQcm9taXNlLnJlc29sdmUoKVxuXHRcdFx0LnRoZW4oKCkgPT5cblx0XHRcdHtcblx0XHRcdFx0Ly8gQWRkIHRoZSB0cmFjayB0byB0aGUgbG9jYWwgc3RyZWFtLlxuXHRcdFx0XHR0aGlzLl9zdHJlYW0uYWRkVHJhY2sodHJhY2spO1xuXG5cdFx0XHRcdC8vIEFkZCB0aGUgc3RyZWFtIHRvIHRoZSBQZWVyQ29ubmVjdGlvbi5cblx0XHRcdFx0dGhpcy5fcGMuYWRkU3RyZWFtKHRoaXMuX3N0cmVhbSk7XG5cblx0XHRcdFx0cmV0dXJuIHRoaXMuX3BjLmNyZWF0ZU9mZmVyKCk7XG5cdFx0XHR9KVxuXHRcdFx0LnRoZW4oKG9mZmVyKSA9PlxuXHRcdFx0e1xuXHRcdFx0XHQvLyBJZiBzaW11bGNhc3QgaXMgc2V0LCBtYW5nbGUgdGhlIG9mZmVyLlxuXHRcdFx0XHRpZiAocHJvZHVjZXIuc2ltdWxjYXN0KVxuXHRcdFx0XHR7XG5cdFx0XHRcdFx0bG9nZ2VyLmRlYnVnKCdhZGRQcm9kdWNlcigpIHwgZW5hYmxpbmcgc2ltdWxjYXN0Jyk7XG5cblx0XHRcdFx0XHRjb25zdCBzZHBPYmplY3QgPSBzZHBUcmFuc2Zvcm0ucGFyc2Uob2ZmZXIuc2RwKTtcblxuXHRcdFx0XHRcdHNkcFBsYW5CVXRpbHMuYWRkU2ltdWxjYXN0Rm9yVHJhY2soc2RwT2JqZWN0LCB0cmFjayk7XG5cblx0XHRcdFx0XHRjb25zdCBvZmZlclNkcCA9IHNkcFRyYW5zZm9ybS53cml0ZShzZHBPYmplY3QpO1xuXG5cdFx0XHRcdFx0b2ZmZXIgPSB7IHR5cGU6ICdvZmZlcicsIHNkcDogb2ZmZXJTZHAgfTtcblx0XHRcdFx0fVxuXG5cdFx0XHRcdGxvZ2dlci5kZWJ1Zyhcblx0XHRcdFx0XHQnYWRkUHJvZHVjZXIoKSB8IGNhbGxpbmcgcGMuc2V0TG9jYWxEZXNjcmlwdGlvbigpIFtvZmZlcjolb10nLFxuXHRcdFx0XHRcdG9mZmVyKTtcblxuXHRcdFx0XHRyZXR1cm4gdGhpcy5fcGMuc2V0TG9jYWxEZXNjcmlwdGlvbihvZmZlcik7XG5cdFx0XHR9KVxuXHRcdFx0LnRoZW4oKCkgPT5cblx0XHRcdHtcblx0XHRcdFx0aWYgKCF0aGlzLl90cmFuc3BvcnRSZWFkeSlcblx0XHRcdFx0XHRyZXR1cm4gdGhpcy5fc2V0dXBUcmFuc3BvcnQoKTtcblx0XHRcdH0pXG5cdFx0XHQudGhlbigoKSA9PlxuXHRcdFx0e1xuXHRcdFx0XHRsb2NhbFNkcE9iaiA9IHNkcFRyYW5zZm9ybS5wYXJzZSh0aGlzLl9wYy5sb2NhbERlc2NyaXB0aW9uLnNkcCk7XG5cblx0XHRcdFx0Y29uc3QgcmVtb3RlU2RwID0gdGhpcy5fcmVtb3RlU2RwLmNyZWF0ZUFuc3dlclNkcChsb2NhbFNkcE9iaik7XG5cdFx0XHRcdGNvbnN0IGFuc3dlciA9IHsgdHlwZTogJ2Fuc3dlcicsIHNkcDogcmVtb3RlU2RwIH07XG5cblx0XHRcdFx0bG9nZ2VyLmRlYnVnKFxuXHRcdFx0XHRcdCdhZGRQcm9kdWNlcigpIHwgY2FsbGluZyBwYy5zZXRSZW1vdGVEZXNjcmlwdGlvbigpIFthbnN3ZXI6JW9dJyxcblx0XHRcdFx0XHRhbnN3ZXIpO1xuXG5cdFx0XHRcdHJldHVybiB0aGlzLl9wYy5zZXRSZW1vdGVEZXNjcmlwdGlvbihhbnN3ZXIpO1xuXHRcdFx0fSlcblx0XHRcdC50aGVuKCgpID0+XG5cdFx0XHR7XG5cdFx0XHRcdGNvbnN0IHJ0cFBhcmFtZXRlcnMgPSB1dGlscy5jbG9uZSh0aGlzLl9ydHBQYXJhbWV0ZXJzQnlLaW5kW3Byb2R1Y2VyLmtpbmRdKTtcblxuXHRcdFx0XHQvLyBGaWxsIHRoZSBSVFAgcGFyYW1ldGVycyBmb3IgdGhpcyB0cmFjay5cblx0XHRcdFx0c2RwUGxhbkJVdGlscy5maWxsUnRwUGFyYW1ldGVyc0ZvclRyYWNrKFxuXHRcdFx0XHRcdHJ0cFBhcmFtZXRlcnMsIGxvY2FsU2RwT2JqLCB0cmFjayk7XG5cblx0XHRcdFx0cmV0dXJuIHJ0cFBhcmFtZXRlcnM7XG5cdFx0XHR9KVxuXHRcdFx0LmNhdGNoKChlcnJvcikgPT5cblx0XHRcdHtcblx0XHRcdFx0Ly8gUGFuaWMgaGVyZS4gVHJ5IHRvIHVuZG8gdGhpbmdzLlxuXG5cdFx0XHRcdHRoaXMuX3N0cmVhbS5yZW1vdmVUcmFjayh0cmFjayk7XG5cdFx0XHRcdHRoaXMuX3BjLmFkZFN0cmVhbSh0aGlzLl9zdHJlYW0pO1xuXG5cdFx0XHRcdHRocm93IGVycm9yO1xuXHRcdFx0fSk7XG5cdH1cblxuXHRyZW1vdmVQcm9kdWNlcihwcm9kdWNlcilcblx0e1xuXHRcdGNvbnN0IHsgdHJhY2sgfSA9IHByb2R1Y2VyO1xuXG5cdFx0bG9nZ2VyLmRlYnVnKFxuXHRcdFx0J3JlbW92ZVByb2R1Y2VyKCkgW2lkOiVzLCBraW5kOiVzLCB0cmFja0lkOiVzXScsXG5cdFx0XHRwcm9kdWNlci5pZCwgcHJvZHVjZXIua2luZCwgdHJhY2suaWQpO1xuXG5cdFx0cmV0dXJuIFByb21pc2UucmVzb2x2ZSgpXG5cdFx0XHQudGhlbigoKSA9PlxuXHRcdFx0e1xuXHRcdFx0XHQvLyBSZW1vdmUgdGhlIHRyYWNrIGZyb20gdGhlIGxvY2FsIHN0cmVhbS5cblx0XHRcdFx0dGhpcy5fc3RyZWFtLnJlbW92ZVRyYWNrKHRyYWNrKTtcblxuXHRcdFx0XHQvLyBBZGQgdGhlIHN0cmVhbSB0byB0aGUgUGVlckNvbm5lY3Rpb24uXG5cdFx0XHRcdHRoaXMuX3BjLmFkZFN0cmVhbSh0aGlzLl9zdHJlYW0pO1xuXG5cdFx0XHRcdHJldHVybiB0aGlzLl9wYy5jcmVhdGVPZmZlcigpO1xuXHRcdFx0fSlcblx0XHRcdC50aGVuKChvZmZlcikgPT5cblx0XHRcdHtcblx0XHRcdFx0bG9nZ2VyLmRlYnVnKFxuXHRcdFx0XHRcdCdyZW1vdmVQcm9kdWNlcigpIHwgY2FsbGluZyBwYy5zZXRMb2NhbERlc2NyaXB0aW9uKCkgW29mZmVyOiVvXScsXG5cdFx0XHRcdFx0b2ZmZXIpO1xuXG5cdFx0XHRcdHJldHVybiB0aGlzLl9wYy5zZXRMb2NhbERlc2NyaXB0aW9uKG9mZmVyKTtcblx0XHRcdH0pXG5cdFx0XHQuY2F0Y2goKGVycm9yKSA9PlxuXHRcdFx0e1xuXHRcdFx0XHQvLyBOT1RFOiBJZiB0aGVyZSBhcmUgbm8gc2VuZGluZyB0cmFja3MsIHNldExvY2FsRGVzY3JpcHRpb24oKSB3aWxsIGZhaWwgd2l0aFxuXHRcdFx0XHQvLyBcIkZhaWxlZCB0byBjcmVhdGUgY2hhbm5lbHNcIi4gSWYgc28sIGlnbm9yZSBpdC5cblx0XHRcdFx0aWYgKHRoaXMuX3N0cmVhbS5nZXRUcmFja3MoKS5sZW5ndGggPT09IDApXG5cdFx0XHRcdHtcblx0XHRcdFx0XHRsb2dnZXIud2Fybihcblx0XHRcdFx0XHRcdCdyZW1vdmVQcm9kdWNlcigpIHwgaWdub3JpbmcgZXhwZWN0ZWQgZXJyb3IgZHVlIG5vIHNlbmRpbmcgdHJhY2tzOiAlcycsXG5cdFx0XHRcdFx0XHRlcnJvci50b1N0cmluZygpKTtcblxuXHRcdFx0XHRcdHJldHVybjtcblx0XHRcdFx0fVxuXG5cdFx0XHRcdHRocm93IGVycm9yO1xuXHRcdFx0fSlcblx0XHRcdC50aGVuKCgpID0+XG5cdFx0XHR7XG5cdFx0XHRcdGlmICh0aGlzLl9wYy5zaWduYWxpbmdTdGF0ZSA9PT0gJ3N0YWJsZScpXG5cdFx0XHRcdFx0cmV0dXJuO1xuXG5cdFx0XHRcdGNvbnN0IGxvY2FsU2RwT2JqID0gc2RwVHJhbnNmb3JtLnBhcnNlKHRoaXMuX3BjLmxvY2FsRGVzY3JpcHRpb24uc2RwKTtcblx0XHRcdFx0Y29uc3QgcmVtb3RlU2RwID0gdGhpcy5fcmVtb3RlU2RwLmNyZWF0ZUFuc3dlclNkcChsb2NhbFNkcE9iaik7XG5cdFx0XHRcdGNvbnN0IGFuc3dlciA9IHsgdHlwZTogJ2Fuc3dlcicsIHNkcDogcmVtb3RlU2RwIH07XG5cblx0XHRcdFx0bG9nZ2VyLmRlYnVnKFxuXHRcdFx0XHRcdCdyZW1vdmVQcm9kdWNlcigpIHwgY2FsbGluZyBwYy5zZXRSZW1vdGVEZXNjcmlwdGlvbigpIFthbnN3ZXI6JW9dJyxcblx0XHRcdFx0XHRhbnN3ZXIpO1xuXG5cdFx0XHRcdHJldHVybiB0aGlzLl9wYy5zZXRSZW1vdGVEZXNjcmlwdGlvbihhbnN3ZXIpO1xuXHRcdFx0fSk7XG5cdH1cblxuXHRyZXBsYWNlUHJvZHVjZXJUcmFjayhwcm9kdWNlciwgdHJhY2spXG5cdHtcblx0XHRsb2dnZXIuZGVidWcoXG5cdFx0XHQncmVwbGFjZVByb2R1Y2VyVHJhY2soKSBbaWQ6JXMsIGtpbmQ6JXMsIHRyYWNrSWQ6JXNdJyxcblx0XHRcdHByb2R1Y2VyLmlkLCBwcm9kdWNlci5raW5kLCB0cmFjay5pZCk7XG5cblx0XHRjb25zdCBvbGRUcmFjayA9IHByb2R1Y2VyLnRyYWNrO1xuXHRcdGxldCBsb2NhbFNkcE9iajtcblxuXHRcdHJldHVybiBQcm9taXNlLnJlc29sdmUoKVxuXHRcdFx0LnRoZW4oKCkgPT5cblx0XHRcdHtcblx0XHRcdFx0Ly8gUmVtb3ZlIHRoZSBvbGQgdHJhY2sgZnJvbSB0aGUgbG9jYWwgc3RyZWFtLlxuXHRcdFx0XHR0aGlzLl9zdHJlYW0ucmVtb3ZlVHJhY2sob2xkVHJhY2spO1xuXG5cdFx0XHRcdC8vIEFkZCB0aGUgbmV3IHRyYWNrIHRvIHRoZSBsb2NhbCBzdHJlYW0uXG5cdFx0XHRcdHRoaXMuX3N0cmVhbS5hZGRUcmFjayh0cmFjayk7XG5cblx0XHRcdFx0Ly8gQWRkIHRoZSBzdHJlYW0gdG8gdGhlIFBlZXJDb25uZWN0aW9uLlxuXHRcdFx0XHR0aGlzLl9wYy5hZGRTdHJlYW0odGhpcy5fc3RyZWFtKTtcblxuXHRcdFx0XHRyZXR1cm4gdGhpcy5fcGMuY3JlYXRlT2ZmZXIoKTtcblx0XHRcdH0pXG5cdFx0XHQudGhlbigob2ZmZXIpID0+XG5cdFx0XHR7XG5cdFx0XHRcdC8vIElmIHNpbXVsY2FzdCBpcyBzZXQsIG1hbmdsZSB0aGUgb2ZmZXIuXG5cdFx0XHRcdGlmIChwcm9kdWNlci5zaW11bGNhc3QpXG5cdFx0XHRcdHtcblx0XHRcdFx0XHRsb2dnZXIuZGVidWcoJ2FkZFByb2R1Y2VyKCkgfCBlbmFibGluZyBzaW11bGNhc3QnKTtcblxuXHRcdFx0XHRcdGNvbnN0IHNkcE9iamVjdCA9IHNkcFRyYW5zZm9ybS5wYXJzZShvZmZlci5zZHApO1xuXG5cdFx0XHRcdFx0c2RwUGxhbkJVdGlscy5hZGRTaW11bGNhc3RGb3JUcmFjayhzZHBPYmplY3QsIHRyYWNrKTtcblxuXHRcdFx0XHRcdGNvbnN0IG9mZmVyU2RwID0gc2RwVHJhbnNmb3JtLndyaXRlKHNkcE9iamVjdCk7XG5cblx0XHRcdFx0XHRvZmZlciA9IHsgdHlwZTogJ29mZmVyJywgc2RwOiBvZmZlclNkcCB9O1xuXHRcdFx0XHR9XG5cblx0XHRcdFx0bG9nZ2VyLmRlYnVnKFxuXHRcdFx0XHRcdCdyZXBsYWNlUHJvZHVjZXJUcmFjaygpIHwgY2FsbGluZyBwYy5zZXRMb2NhbERlc2NyaXB0aW9uKCkgW29mZmVyOiVvXScsXG5cdFx0XHRcdFx0b2ZmZXIpO1xuXG5cdFx0XHRcdHJldHVybiB0aGlzLl9wYy5zZXRMb2NhbERlc2NyaXB0aW9uKG9mZmVyKTtcblx0XHRcdH0pXG5cdFx0XHQudGhlbigoKSA9PlxuXHRcdFx0e1xuXHRcdFx0XHRsb2NhbFNkcE9iaiA9IHNkcFRyYW5zZm9ybS5wYXJzZSh0aGlzLl9wYy5sb2NhbERlc2NyaXB0aW9uLnNkcCk7XG5cblx0XHRcdFx0Y29uc3QgcmVtb3RlU2RwID0gdGhpcy5fcmVtb3RlU2RwLmNyZWF0ZUFuc3dlclNkcChsb2NhbFNkcE9iaik7XG5cdFx0XHRcdGNvbnN0IGFuc3dlciA9IHsgdHlwZTogJ2Fuc3dlcicsIHNkcDogcmVtb3RlU2RwIH07XG5cblx0XHRcdFx0bG9nZ2VyLmRlYnVnKFxuXHRcdFx0XHRcdCdyZXBsYWNlUHJvZHVjZXJUcmFjaygpIHwgY2FsbGluZyBwYy5zZXRSZW1vdGVEZXNjcmlwdGlvbigpIFthbnN3ZXI6JW9dJyxcblx0XHRcdFx0XHRhbnN3ZXIpO1xuXG5cdFx0XHRcdHJldHVybiB0aGlzLl9wYy5zZXRSZW1vdGVEZXNjcmlwdGlvbihhbnN3ZXIpO1xuXHRcdFx0fSlcblx0XHRcdC50aGVuKCgpID0+XG5cdFx0XHR7XG5cdFx0XHRcdGNvbnN0IHJ0cFBhcmFtZXRlcnMgPSB1dGlscy5jbG9uZSh0aGlzLl9ydHBQYXJhbWV0ZXJzQnlLaW5kW3Byb2R1Y2VyLmtpbmRdKTtcblxuXHRcdFx0XHQvLyBGaWxsIHRoZSBSVFAgcGFyYW1ldGVycyBmb3IgdGhlIG5ldyB0cmFjay5cblx0XHRcdFx0c2RwUGxhbkJVdGlscy5maWxsUnRwUGFyYW1ldGVyc0ZvclRyYWNrKFxuXHRcdFx0XHRcdHJ0cFBhcmFtZXRlcnMsIGxvY2FsU2RwT2JqLCB0cmFjayk7XG5cblx0XHRcdFx0Ly8gV2UgbmVlZCB0byBwcm92aWRlIG5ldyBSVFAgcGFyYW1ldGVycy5cblx0XHRcdFx0dGhpcy5zYWZlRW1pdCgnQG5lZWR1cGRhdGVwcm9kdWNlcicsIHByb2R1Y2VyLCBydHBQYXJhbWV0ZXJzKTtcblx0XHRcdH0pXG5cdFx0XHQuY2F0Y2goKGVycm9yKSA9PlxuXHRcdFx0e1xuXHRcdFx0XHQvLyBQYW5pYyBoZXJlLiBUcnkgdG8gdW5kbyB0aGluZ3MuXG5cblx0XHRcdFx0dGhpcy5fc3RyZWFtLnJlbW92ZVRyYWNrKHRyYWNrKTtcblx0XHRcdFx0dGhpcy5fc3RyZWFtLmFkZFRyYWNrKG9sZFRyYWNrKTtcblx0XHRcdFx0dGhpcy5fcGMuYWRkU3RyZWFtKHRoaXMuX3N0cmVhbSk7XG5cblx0XHRcdFx0dGhyb3cgZXJyb3I7XG5cdFx0XHR9KTtcblx0fVxuXG5cdHJlc3RhcnRJY2UocmVtb3RlSWNlUGFyYW1ldGVycylcblx0e1xuXHRcdGxvZ2dlci5kZWJ1ZygncmVzdGFydEljZSgpJyk7XG5cblx0XHQvLyBQcm92aWRlIHRoZSByZW1vdGUgU0RQIGhhbmRsZXIgd2l0aCBuZXcgcmVtb3RlIElDRSBwYXJhbWV0ZXJzLlxuXHRcdHRoaXMuX3JlbW90ZVNkcC51cGRhdGVUcmFuc3BvcnRSZW1vdGVJY2VQYXJhbWV0ZXJzKHJlbW90ZUljZVBhcmFtZXRlcnMpO1xuXG5cdFx0cmV0dXJuIFByb21pc2UucmVzb2x2ZSgpXG5cdFx0XHQudGhlbigoKSA9PlxuXHRcdFx0e1xuXHRcdFx0XHRyZXR1cm4gdGhpcy5fcGMuY3JlYXRlT2ZmZXIoeyBpY2VSZXN0YXJ0OiB0cnVlIH0pO1xuXHRcdFx0fSlcblx0XHRcdC50aGVuKChvZmZlcikgPT5cblx0XHRcdHtcblx0XHRcdFx0bG9nZ2VyLmRlYnVnKFxuXHRcdFx0XHRcdCdyZXN0YXJ0SWNlKCkgfCBjYWxsaW5nIHBjLnNldExvY2FsRGVzY3JpcHRpb24oKSBbb2ZmZXI6JW9dJyxcblx0XHRcdFx0XHRvZmZlcik7XG5cblx0XHRcdFx0cmV0dXJuIHRoaXMuX3BjLnNldExvY2FsRGVzY3JpcHRpb24ob2ZmZXIpO1xuXHRcdFx0fSlcblx0XHRcdC50aGVuKCgpID0+XG5cdFx0XHR7XG5cdFx0XHRcdGNvbnN0IGxvY2FsU2RwT2JqID0gc2RwVHJhbnNmb3JtLnBhcnNlKHRoaXMuX3BjLmxvY2FsRGVzY3JpcHRpb24uc2RwKTtcblx0XHRcdFx0Y29uc3QgcmVtb3RlU2RwID0gdGhpcy5fcmVtb3RlU2RwLmNyZWF0ZUFuc3dlclNkcChsb2NhbFNkcE9iaik7XG5cdFx0XHRcdGNvbnN0IGFuc3dlciA9IHsgdHlwZTogJ2Fuc3dlcicsIHNkcDogcmVtb3RlU2RwIH07XG5cblx0XHRcdFx0bG9nZ2VyLmRlYnVnKFxuXHRcdFx0XHRcdCdyZXN0YXJ0SWNlKCkgfCBjYWxsaW5nIHBjLnNldFJlbW90ZURlc2NyaXB0aW9uKCkgW2Fuc3dlcjolb10nLFxuXHRcdFx0XHRcdGFuc3dlcik7XG5cblx0XHRcdFx0cmV0dXJuIHRoaXMuX3BjLnNldFJlbW90ZURlc2NyaXB0aW9uKGFuc3dlcik7XG5cdFx0XHR9KTtcblx0fVxuXG5cdF9zZXR1cFRyYW5zcG9ydCgpXG5cdHtcblx0XHRsb2dnZXIuZGVidWcoJ19zZXR1cFRyYW5zcG9ydCgpJyk7XG5cblx0XHRyZXR1cm4gUHJvbWlzZS5yZXNvbHZlKClcblx0XHRcdC50aGVuKCgpID0+XG5cdFx0XHR7XG5cdFx0XHRcdC8vIEdldCBvdXIgbG9jYWwgRFRMUyBwYXJhbWV0ZXJzLlxuXHRcdFx0XHRjb25zdCB0cmFuc3BvcnRMb2NhbFBhcmFtZXRlcnMgPSB7fTtcblx0XHRcdFx0Y29uc3Qgc2RwID0gdGhpcy5fcGMubG9jYWxEZXNjcmlwdGlvbi5zZHA7XG5cdFx0XHRcdGNvbnN0IHNkcE9iaiA9IHNkcFRyYW5zZm9ybS5wYXJzZShzZHApO1xuXHRcdFx0XHRjb25zdCBkdGxzUGFyYW1ldGVycyA9IHNkcENvbW1vblV0aWxzLmV4dHJhY3REdGxzUGFyYW1ldGVycyhzZHBPYmopO1xuXG5cdFx0XHRcdC8vIExldCdzIGRlY2lkZSB0aGF0IHdlJ2xsIGJlIERUTFMgc2VydmVyIChiZWNhdXNlIHdlIGNhbikuXG5cdFx0XHRcdGR0bHNQYXJhbWV0ZXJzLnJvbGUgPSAnc2VydmVyJztcblxuXHRcdFx0XHR0cmFuc3BvcnRMb2NhbFBhcmFtZXRlcnMuZHRsc1BhcmFtZXRlcnMgPSBkdGxzUGFyYW1ldGVycztcblxuXHRcdFx0XHQvLyBQcm92aWRlIHRoZSByZW1vdGUgU0RQIGhhbmRsZXIgd2l0aCB0cmFuc3BvcnQgbG9jYWwgcGFyYW1ldGVycy5cblx0XHRcdFx0dGhpcy5fcmVtb3RlU2RwLnNldFRyYW5zcG9ydExvY2FsUGFyYW1ldGVycyh0cmFuc3BvcnRMb2NhbFBhcmFtZXRlcnMpO1xuXG5cdFx0XHRcdC8vIFdlIG5lZWQgdHJhbnNwb3J0IHJlbW90ZSBwYXJhbWV0ZXJzLlxuXHRcdFx0XHRyZXR1cm4gdGhpcy5zYWZlRW1pdEFzUHJvbWlzZShcblx0XHRcdFx0XHQnQG5lZWRjcmVhdGV0cmFuc3BvcnQnLCB0cmFuc3BvcnRMb2NhbFBhcmFtZXRlcnMpO1xuXHRcdFx0fSlcblx0XHRcdC50aGVuKCh0cmFuc3BvcnRSZW1vdGVQYXJhbWV0ZXJzKSA9PlxuXHRcdFx0e1xuXHRcdFx0XHQvLyBQcm92aWRlIHRoZSByZW1vdGUgU0RQIGhhbmRsZXIgd2l0aCB0cmFuc3BvcnQgcmVtb3RlIHBhcmFtZXRlcnMuXG5cdFx0XHRcdHRoaXMuX3JlbW90ZVNkcC5zZXRUcmFuc3BvcnRSZW1vdGVQYXJhbWV0ZXJzKHRyYW5zcG9ydFJlbW90ZVBhcmFtZXRlcnMpO1xuXG5cdFx0XHRcdHRoaXMuX3RyYW5zcG9ydFJlYWR5ID0gdHJ1ZTtcblx0XHRcdH0pO1xuXHR9XG59XG5cbmNsYXNzIFJlY3ZIYW5kbGVyIGV4dGVuZHMgSGFuZGxlclxue1xuXHRjb25zdHJ1Y3RvcihydHBQYXJhbWV0ZXJzQnlLaW5kLCBzZXR0aW5ncylcblx0e1xuXHRcdHN1cGVyKCdyZWN2JywgcnRwUGFyYW1ldGVyc0J5S2luZCwgc2V0dGluZ3MpO1xuXG5cdFx0Ly8gR290IHRyYW5zcG9ydCByZW1vdGUgcGFyYW1ldGVycy5cblx0XHQvLyBAdHlwZSB7Qm9vbGVhbn1cblx0XHR0aGlzLl90cmFuc3BvcnRDcmVhdGVkID0gZmFsc2U7XG5cblx0XHQvLyBHb3QgdHJhbnNwb3J0IGxvY2FsIHBhcmFtZXRlcnMuXG5cdFx0Ly8gQHR5cGUge0Jvb2xlYW59XG5cdFx0dGhpcy5fdHJhbnNwb3J0VXBkYXRlZCA9IGZhbHNlO1xuXG5cdFx0Ly8gU2VlbiBtZWRpYSBraW5kcy5cblx0XHQvLyBAdHlwZSB7U2V0PFN0cmluZz59XG5cdFx0dGhpcy5fa2luZHMgPSBuZXcgU2V0KCk7XG5cblx0XHQvLyBNYXAgb2YgQ29uc3VtZXJzIGluZm9ybWF0aW9uIGluZGV4ZWQgYnkgY29uc3VtZXIuaWQuXG5cdFx0Ly8gLSBraW5kIHtTdHJpbmd9XG5cdFx0Ly8gLSB0cmFja0lkIHtTdHJpbmd9XG5cdFx0Ly8gLSBzc3JjIHtOdW1iZXJ9XG5cdFx0Ly8gLSBydHhTc3JjIHtOdW1iZXJ9XG5cdFx0Ly8gLSBjbmFtZSB7U3RyaW5nfVxuXHRcdC8vIEB0eXBlIHtNYXA8TnVtYmVyLCBPYmplY3Q+fVxuXHRcdHRoaXMuX2NvbnN1bWVySW5mb3MgPSBuZXcgTWFwKCk7XG5cdH1cblxuXHRhZGRDb25zdW1lcihjb25zdW1lcilcblx0e1xuXHRcdGxvZ2dlci5kZWJ1Zyhcblx0XHRcdCdhZGRDb25zdW1lcigpIFtpZDolcywga2luZDolc10nLCBjb25zdW1lci5pZCwgY29uc3VtZXIua2luZCk7XG5cblx0XHRpZiAodGhpcy5fY29uc3VtZXJJbmZvcy5oYXMoY29uc3VtZXIuaWQpKVxuXHRcdFx0cmV0dXJuIFByb21pc2UucmVqZWN0KG5ldyBFcnJvcignQ29uc3VtZXIgYWxyZWFkeSBhZGRlZCcpKTtcblxuXHRcdGNvbnN0IGVuY29kaW5nID0gY29uc3VtZXIucnRwUGFyYW1ldGVycy5lbmNvZGluZ3NbMF07XG5cdFx0Y29uc3QgY25hbWUgPSBjb25zdW1lci5ydHBQYXJhbWV0ZXJzLnJ0Y3AuY25hbWU7XG5cdFx0Y29uc3QgY29uc3VtZXJJbmZvID1cblx0XHR7XG5cdFx0XHRraW5kICAgICA6IGNvbnN1bWVyLmtpbmQsXG5cdFx0XHRzdHJlYW1JZCA6IGByZWN2LXN0cmVhbS0ke2NvbnN1bWVyLmlkfWAsXG5cdFx0XHR0cmFja0lkICA6IGBjb25zdW1lci0ke2NvbnN1bWVyLmtpbmR9LSR7Y29uc3VtZXIuaWR9YCxcblx0XHRcdHNzcmMgICAgIDogZW5jb2Rpbmcuc3NyYyxcblx0XHRcdGNuYW1lICAgIDogY25hbWVcblx0XHR9O1xuXG5cdFx0aWYgKGVuY29kaW5nLnJ0eCAmJiBlbmNvZGluZy5ydHguc3NyYylcblx0XHRcdGNvbnN1bWVySW5mby5ydHhTc3JjID0gZW5jb2RpbmcucnR4LnNzcmM7XG5cblx0XHR0aGlzLl9jb25zdW1lckluZm9zLnNldChjb25zdW1lci5pZCwgY29uc3VtZXJJbmZvKTtcblx0XHR0aGlzLl9raW5kcy5hZGQoY29uc3VtZXIua2luZCk7XG5cblx0XHRyZXR1cm4gUHJvbWlzZS5yZXNvbHZlKClcblx0XHRcdC50aGVuKCgpID0+XG5cdFx0XHR7XG5cdFx0XHRcdGlmICghdGhpcy5fdHJhbnNwb3J0Q3JlYXRlZClcblx0XHRcdFx0XHRyZXR1cm4gdGhpcy5fc2V0dXBUcmFuc3BvcnQoKTtcblx0XHRcdH0pXG5cdFx0XHQudGhlbigoKSA9PlxuXHRcdFx0e1xuXHRcdFx0XHRjb25zdCByZW1vdGVTZHAgPSB0aGlzLl9yZW1vdGVTZHAuY3JlYXRlT2ZmZXJTZHAoXG5cdFx0XHRcdFx0QXJyYXkuZnJvbSh0aGlzLl9raW5kcyksIEFycmF5LmZyb20odGhpcy5fY29uc3VtZXJJbmZvcy52YWx1ZXMoKSkpO1xuXHRcdFx0XHRjb25zdCBvZmZlciA9IHsgdHlwZTogJ29mZmVyJywgc2RwOiByZW1vdGVTZHAgfTtcblxuXHRcdFx0XHRsb2dnZXIuZGVidWcoXG5cdFx0XHRcdFx0J2FkZENvbnN1bWVyKCkgfCBjYWxsaW5nIHBjLnNldFJlbW90ZURlc2NyaXB0aW9uKCkgW29mZmVyOiVvXScsXG5cdFx0XHRcdFx0b2ZmZXIpO1xuXG5cdFx0XHRcdHJldHVybiB0aGlzLl9wYy5zZXRSZW1vdGVEZXNjcmlwdGlvbihvZmZlcik7XG5cdFx0XHR9KVxuXHRcdFx0LnRoZW4oKCkgPT5cblx0XHRcdHtcblx0XHRcdFx0cmV0dXJuIHRoaXMuX3BjLmNyZWF0ZUFuc3dlcigpO1xuXHRcdFx0fSlcblx0XHRcdC50aGVuKChhbnN3ZXIpID0+XG5cdFx0XHR7XG5cdFx0XHRcdGxvZ2dlci5kZWJ1Zyhcblx0XHRcdFx0XHQnYWRkQ29uc3VtZXIoKSB8IGNhbGxpbmcgcGMuc2V0TG9jYWxEZXNjcmlwdGlvbigpIFthbnN3ZXI6JW9dJyxcblx0XHRcdFx0XHRhbnN3ZXIpO1xuXG5cdFx0XHRcdHJldHVybiB0aGlzLl9wYy5zZXRMb2NhbERlc2NyaXB0aW9uKGFuc3dlcik7XG5cdFx0XHR9KVxuXHRcdFx0LnRoZW4oKCkgPT5cblx0XHRcdHtcblx0XHRcdFx0aWYgKCF0aGlzLl90cmFuc3BvcnRVcGRhdGVkKVxuXHRcdFx0XHRcdHJldHVybiB0aGlzLl91cGRhdGVUcmFuc3BvcnQoKTtcblx0XHRcdH0pXG5cdFx0XHQudGhlbigoKSA9PlxuXHRcdFx0e1xuXHRcdFx0XHRjb25zdCBzdHJlYW0gPSB0aGlzLl9wYy5nZXRSZW1vdGVTdHJlYW1zKClcblx0XHRcdFx0XHQuZmluZCgocykgPT4gcy5pZCA9PT0gY29uc3VtZXJJbmZvLnN0cmVhbUlkKTtcblx0XHRcdFx0Y29uc3QgdHJhY2sgPSBzdHJlYW0uZ2V0VHJhY2tCeUlkKGNvbnN1bWVySW5mby50cmFja0lkKTtcblxuXHRcdFx0XHRpZiAoIXRyYWNrKVxuXHRcdFx0XHRcdHRocm93IG5ldyBFcnJvcigncmVtb3RlIHRyYWNrIG5vdCBmb3VuZCcpO1xuXG5cdFx0XHRcdHJldHVybiB0cmFjaztcblx0XHRcdH0pO1xuXHR9XG5cblx0cmVtb3ZlQ29uc3VtZXIoY29uc3VtZXIpXG5cdHtcblx0XHRsb2dnZXIuZGVidWcoXG5cdFx0XHQncmVtb3ZlQ29uc3VtZXIoKSBbaWQ6JXMsIGtpbmQ6JXNdJywgY29uc3VtZXIuaWQsIGNvbnN1bWVyLmtpbmQpO1xuXG5cdFx0aWYgKCF0aGlzLl9jb25zdW1lckluZm9zLmhhcyhjb25zdW1lci5pZCkpXG5cdFx0XHRyZXR1cm4gUHJvbWlzZS5yZWplY3QobmV3IEVycm9yKCdDb25zdW1lciBub3QgZm91bmQnKSk7XG5cblx0XHR0aGlzLl9jb25zdW1lckluZm9zLmRlbGV0ZShjb25zdW1lci5pZCk7XG5cblx0XHRyZXR1cm4gUHJvbWlzZS5yZXNvbHZlKClcblx0XHRcdC50aGVuKCgpID0+XG5cdFx0XHR7XG5cdFx0XHRcdGNvbnN0IHJlbW90ZVNkcCA9IHRoaXMuX3JlbW90ZVNkcC5jcmVhdGVPZmZlclNkcChcblx0XHRcdFx0XHRBcnJheS5mcm9tKHRoaXMuX2tpbmRzKSwgQXJyYXkuZnJvbSh0aGlzLl9jb25zdW1lckluZm9zLnZhbHVlcygpKSk7XG5cdFx0XHRcdGNvbnN0IG9mZmVyID0geyB0eXBlOiAnb2ZmZXInLCBzZHA6IHJlbW90ZVNkcCB9O1xuXG5cdFx0XHRcdGxvZ2dlci5kZWJ1Zyhcblx0XHRcdFx0XHQncmVtb3ZlQ29uc3VtZXIoKSB8IGNhbGxpbmcgcGMuc2V0UmVtb3RlRGVzY3JpcHRpb24oKSBbb2ZmZXI6JW9dJyxcblx0XHRcdFx0XHRvZmZlcik7XG5cblx0XHRcdFx0cmV0dXJuIHRoaXMuX3BjLnNldFJlbW90ZURlc2NyaXB0aW9uKG9mZmVyKTtcblx0XHRcdH0pXG5cdFx0XHQudGhlbigoKSA9PlxuXHRcdFx0e1xuXHRcdFx0XHRyZXR1cm4gdGhpcy5fcGMuY3JlYXRlQW5zd2VyKCk7XG5cdFx0XHR9KVxuXHRcdFx0LnRoZW4oKGFuc3dlcikgPT5cblx0XHRcdHtcblx0XHRcdFx0bG9nZ2VyLmRlYnVnKFxuXHRcdFx0XHRcdCdyZW1vdmVDb25zdW1lcigpIHwgY2FsbGluZyBwYy5zZXRMb2NhbERlc2NyaXB0aW9uKCkgW2Fuc3dlcjolb10nLFxuXHRcdFx0XHRcdGFuc3dlcik7XG5cblx0XHRcdFx0cmV0dXJuIHRoaXMuX3BjLnNldExvY2FsRGVzY3JpcHRpb24oYW5zd2VyKTtcblx0XHRcdH0pO1xuXHR9XG5cblx0cmVzdGFydEljZShyZW1vdGVJY2VQYXJhbWV0ZXJzKVxuXHR7XG5cdFx0bG9nZ2VyLmRlYnVnKCdyZXN0YXJ0SWNlKCknKTtcblxuXHRcdC8vIFByb3ZpZGUgdGhlIHJlbW90ZSBTRFAgaGFuZGxlciB3aXRoIG5ldyByZW1vdGUgSUNFIHBhcmFtZXRlcnMuXG5cdFx0dGhpcy5fcmVtb3RlU2RwLnVwZGF0ZVRyYW5zcG9ydFJlbW90ZUljZVBhcmFtZXRlcnMocmVtb3RlSWNlUGFyYW1ldGVycyk7XG5cblx0XHRyZXR1cm4gUHJvbWlzZS5yZXNvbHZlKClcblx0XHRcdC50aGVuKCgpID0+XG5cdFx0XHR7XG5cdFx0XHRcdGNvbnN0IHJlbW90ZVNkcCA9IHRoaXMuX3JlbW90ZVNkcC5jcmVhdGVPZmZlclNkcChcblx0XHRcdFx0XHRBcnJheS5mcm9tKHRoaXMuX2tpbmRzKSwgQXJyYXkuZnJvbSh0aGlzLl9jb25zdW1lckluZm9zLnZhbHVlcygpKSk7XG5cdFx0XHRcdGNvbnN0IG9mZmVyID0geyB0eXBlOiAnb2ZmZXInLCBzZHA6IHJlbW90ZVNkcCB9O1xuXG5cdFx0XHRcdGxvZ2dlci5kZWJ1Zyhcblx0XHRcdFx0XHQncmVzdGFydEljZSgpIHwgY2FsbGluZyBwYy5zZXRSZW1vdGVEZXNjcmlwdGlvbigpIFtvZmZlcjolb10nLFxuXHRcdFx0XHRcdG9mZmVyKTtcblxuXHRcdFx0XHRyZXR1cm4gdGhpcy5fcGMuc2V0UmVtb3RlRGVzY3JpcHRpb24ob2ZmZXIpO1xuXHRcdFx0fSlcblx0XHRcdC50aGVuKCgpID0+XG5cdFx0XHR7XG5cdFx0XHRcdHJldHVybiB0aGlzLl9wYy5jcmVhdGVBbnN3ZXIoKTtcblx0XHRcdH0pXG5cdFx0XHQudGhlbigoYW5zd2VyKSA9PlxuXHRcdFx0e1xuXHRcdFx0XHRsb2dnZXIuZGVidWcoXG5cdFx0XHRcdFx0J3Jlc3RhcnRJY2UoKSB8IGNhbGxpbmcgcGMuc2V0TG9jYWxEZXNjcmlwdGlvbigpIFthbnN3ZXI6JW9dJyxcblx0XHRcdFx0XHRhbnN3ZXIpO1xuXG5cdFx0XHRcdHJldHVybiB0aGlzLl9wYy5zZXRMb2NhbERlc2NyaXB0aW9uKGFuc3dlcik7XG5cdFx0XHR9KTtcblx0fVxuXG5cdF9zZXR1cFRyYW5zcG9ydCgpXG5cdHtcblx0XHRsb2dnZXIuZGVidWcoJ19zZXR1cFRyYW5zcG9ydCgpJyk7XG5cblx0XHRyZXR1cm4gUHJvbWlzZS5yZXNvbHZlKClcblx0XHRcdC50aGVuKCgpID0+XG5cdFx0XHR7XG5cdFx0XHRcdC8vIFdlIG5lZWQgdHJhbnNwb3J0IHJlbW90ZSBwYXJhbWV0ZXJzLlxuXHRcdFx0XHRyZXR1cm4gdGhpcy5zYWZlRW1pdEFzUHJvbWlzZSgnQG5lZWRjcmVhdGV0cmFuc3BvcnQnLCBudWxsKTtcblx0XHRcdH0pXG5cdFx0XHQudGhlbigodHJhbnNwb3J0UmVtb3RlUGFyYW1ldGVycykgPT5cblx0XHRcdHtcblx0XHRcdFx0Ly8gUHJvdmlkZSB0aGUgcmVtb3RlIFNEUCBoYW5kbGVyIHdpdGggdHJhbnNwb3J0IHJlbW90ZSBwYXJhbWV0ZXJzLlxuXHRcdFx0XHR0aGlzLl9yZW1vdGVTZHAuc2V0VHJhbnNwb3J0UmVtb3RlUGFyYW1ldGVycyh0cmFuc3BvcnRSZW1vdGVQYXJhbWV0ZXJzKTtcblxuXHRcdFx0XHR0aGlzLl90cmFuc3BvcnRDcmVhdGVkID0gdHJ1ZTtcblx0XHRcdH0pO1xuXHR9XG5cblx0X3VwZGF0ZVRyYW5zcG9ydCgpXG5cdHtcblx0XHRsb2dnZXIuZGVidWcoJ191cGRhdGVUcmFuc3BvcnQoKScpO1xuXG5cdFx0Ly8gR2V0IG91ciBsb2NhbCBEVExTIHBhcmFtZXRlcnMuXG5cdFx0Ly8gY29uc3QgdHJhbnNwb3J0TG9jYWxQYXJhbWV0ZXJzID0ge307XG5cdFx0Y29uc3Qgc2RwID0gdGhpcy5fcGMubG9jYWxEZXNjcmlwdGlvbi5zZHA7XG5cdFx0Y29uc3Qgc2RwT2JqID0gc2RwVHJhbnNmb3JtLnBhcnNlKHNkcCk7XG5cdFx0Y29uc3QgZHRsc1BhcmFtZXRlcnMgPSBzZHBDb21tb25VdGlscy5leHRyYWN0RHRsc1BhcmFtZXRlcnMoc2RwT2JqKTtcblx0XHRjb25zdCB0cmFuc3BvcnRMb2NhbFBhcmFtZXRlcnMgPSB7IGR0bHNQYXJhbWV0ZXJzIH07XG5cblx0XHQvLyBXZSBuZWVkIHRvIHByb3ZpZGUgdHJhbnNwb3J0IGxvY2FsIHBhcmFtZXRlcnMuXG5cdFx0dGhpcy5zYWZlRW1pdCgnQG5lZWR1cGRhdGV0cmFuc3BvcnQnLCB0cmFuc3BvcnRMb2NhbFBhcmFtZXRlcnMpO1xuXG5cdFx0dGhpcy5fdHJhbnNwb3J0VXBkYXRlZCA9IHRydWU7XG5cdH1cbn1cblxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgQ2hyb21lNTVcbntcblx0c3RhdGljIGdldCB0YWcoKVxuXHR7XG5cdFx0cmV0dXJuICdDaHJvbWU1NSc7XG5cdH1cblxuXHRzdGF0aWMgZ2V0TmF0aXZlUnRwQ2FwYWJpbGl0aWVzKClcblx0e1xuXHRcdGxvZ2dlci5kZWJ1ZygnZ2V0TmF0aXZlUnRwQ2FwYWJpbGl0aWVzKCknKTtcblxuXHRcdGNvbnN0IHBjID0gbmV3IFJUQ1BlZXJDb25uZWN0aW9uKFxuXHRcdFx0e1xuXHRcdFx0XHRpY2VTZXJ2ZXJzICAgICAgICAgOiBbXSxcblx0XHRcdFx0aWNlVHJhbnNwb3J0UG9saWN5IDogJ2FsbCcsXG5cdFx0XHRcdGJ1bmRsZVBvbGljeSAgICAgICA6ICdtYXgtYnVuZGxlJyxcblx0XHRcdFx0cnRjcE11eFBvbGljeSAgICAgIDogJ3JlcXVpcmUnXG5cdFx0XHR9KTtcblxuXHRcdHJldHVybiBwYy5jcmVhdGVPZmZlcihcblx0XHRcdHtcblx0XHRcdFx0b2ZmZXJUb1JlY2VpdmVBdWRpbyA6IHRydWUsXG5cdFx0XHRcdG9mZmVyVG9SZWNlaXZlVmlkZW8gOiB0cnVlXG5cdFx0XHR9KVxuXHRcdFx0LnRoZW4oKG9mZmVyKSA9PlxuXHRcdFx0e1xuXHRcdFx0XHR0cnkgeyBwYy5jbG9zZSgpOyB9XG5cdFx0XHRcdGNhdGNoIChlcnJvcikge31cblxuXHRcdFx0XHRjb25zdCBzZHBPYmogPSBzZHBUcmFuc2Zvcm0ucGFyc2Uob2ZmZXIuc2RwKTtcblx0XHRcdFx0Y29uc3QgbmF0aXZlUnRwQ2FwYWJpbGl0aWVzID0gc2RwQ29tbW9uVXRpbHMuZXh0cmFjdFJ0cENhcGFiaWxpdGllcyhzZHBPYmopO1xuXG5cdFx0XHRcdHJldHVybiBuYXRpdmVSdHBDYXBhYmlsaXRpZXM7XG5cdFx0XHR9KVxuXHRcdFx0LmNhdGNoKChlcnJvcikgPT5cblx0XHRcdHtcblx0XHRcdFx0dHJ5IHsgcGMuY2xvc2UoKTsgfVxuXHRcdFx0XHRjYXRjaCAoZXJyb3IyKSB7fVxuXG5cdFx0XHRcdHRocm93IGVycm9yO1xuXHRcdFx0fSk7XG5cdH1cblxuXHRjb25zdHJ1Y3RvcihkaXJlY3Rpb24sIGV4dGVuZGVkUnRwQ2FwYWJpbGl0aWVzLCBzZXR0aW5ncylcblx0e1xuXHRcdGxvZ2dlci5kZWJ1Zyhcblx0XHRcdCdjb25zdHJ1Y3RvcigpIFtkaXJlY3Rpb246JXMsIGV4dGVuZGVkUnRwQ2FwYWJpbGl0aWVzOiVvXScsXG5cdFx0XHRkaXJlY3Rpb24sIGV4dGVuZGVkUnRwQ2FwYWJpbGl0aWVzKTtcblxuXHRcdGxldCBydHBQYXJhbWV0ZXJzQnlLaW5kO1xuXG5cdFx0c3dpdGNoIChkaXJlY3Rpb24pXG5cdFx0e1xuXHRcdFx0Y2FzZSAnc2VuZCc6XG5cdFx0XHR7XG5cdFx0XHRcdHJ0cFBhcmFtZXRlcnNCeUtpbmQgPVxuXHRcdFx0XHR7XG5cdFx0XHRcdFx0YXVkaW8gOiBvcnRjLmdldFNlbmRpbmdSdHBQYXJhbWV0ZXJzKCdhdWRpbycsIGV4dGVuZGVkUnRwQ2FwYWJpbGl0aWVzKSxcblx0XHRcdFx0XHR2aWRlbyA6IG9ydGMuZ2V0U2VuZGluZ1J0cFBhcmFtZXRlcnMoJ3ZpZGVvJywgZXh0ZW5kZWRSdHBDYXBhYmlsaXRpZXMpXG5cdFx0XHRcdH07XG5cblx0XHRcdFx0cmV0dXJuIG5ldyBTZW5kSGFuZGxlcihydHBQYXJhbWV0ZXJzQnlLaW5kLCBzZXR0aW5ncyk7XG5cdFx0XHR9XG5cdFx0XHRjYXNlICdyZWN2Jzpcblx0XHRcdHtcblx0XHRcdFx0cnRwUGFyYW1ldGVyc0J5S2luZCA9XG5cdFx0XHRcdHtcblx0XHRcdFx0XHRhdWRpbyA6IG9ydGMuZ2V0UmVjZWl2aW5nRnVsbFJ0cFBhcmFtZXRlcnMoJ2F1ZGlvJywgZXh0ZW5kZWRSdHBDYXBhYmlsaXRpZXMpLFxuXHRcdFx0XHRcdHZpZGVvIDogb3J0Yy5nZXRSZWNlaXZpbmdGdWxsUnRwUGFyYW1ldGVycygndmlkZW8nLCBleHRlbmRlZFJ0cENhcGFiaWxpdGllcylcblx0XHRcdFx0fTtcblxuXHRcdFx0XHRyZXR1cm4gbmV3IFJlY3ZIYW5kbGVyKHJ0cFBhcmFtZXRlcnNCeUtpbmQsIHNldHRpbmdzKTtcblx0XHRcdH1cblx0XHR9XG5cdH1cbn1cbiIsImltcG9ydCBzZHBUcmFuc2Zvcm0gZnJvbSAnc2RwLXRyYW5zZm9ybSc7XG5pbXBvcnQgTG9nZ2VyIGZyb20gJy4uL0xvZ2dlcic7XG5pbXBvcnQgRW5oYW5jZWRFdmVudEVtaXR0ZXIgZnJvbSAnLi4vRW5oYW5jZWRFdmVudEVtaXR0ZXInO1xuaW1wb3J0ICogYXMgdXRpbHMgZnJvbSAnLi4vdXRpbHMnO1xuaW1wb3J0ICogYXMgb3J0YyBmcm9tICcuLi9vcnRjJztcbmltcG9ydCAqIGFzIHNkcENvbW1vblV0aWxzIGZyb20gJy4vc2RwL2NvbW1vblV0aWxzJztcbmltcG9ydCAqIGFzIHNkcFBsYW5CVXRpbHMgZnJvbSAnLi9zZHAvcGxhbkJVdGlscyc7XG5pbXBvcnQgUmVtb3RlUGxhbkJTZHAgZnJvbSAnLi9zZHAvUmVtb3RlUGxhbkJTZHAnO1xuXG5jb25zdCBsb2dnZXIgPSBuZXcgTG9nZ2VyKCdDaHJvbWU2NycpO1xuXG5jbGFzcyBIYW5kbGVyIGV4dGVuZHMgRW5oYW5jZWRFdmVudEVtaXR0ZXJcbntcblx0Y29uc3RydWN0b3IoZGlyZWN0aW9uLCBydHBQYXJhbWV0ZXJzQnlLaW5kLCBzZXR0aW5ncylcblx0e1xuXHRcdHN1cGVyKGxvZ2dlcik7XG5cblx0XHQvLyBSVENQZWVyQ29ubmVjdGlvbiBpbnN0YW5jZS5cblx0XHQvLyBAdHlwZSB7UlRDUGVlckNvbm5lY3Rpb259XG5cdFx0dGhpcy5fcGMgPSBuZXcgUlRDUGVlckNvbm5lY3Rpb24oXG5cdFx0XHR7XG5cdFx0XHRcdGljZVNlcnZlcnMgICAgICAgICA6IHNldHRpbmdzLnR1cm5TZXJ2ZXJzIHx8IFtdLFxuXHRcdFx0XHRpY2VUcmFuc3BvcnRQb2xpY3kgOiAnYWxsJyxcblx0XHRcdFx0YnVuZGxlUG9saWN5ICAgICAgIDogJ21heC1idW5kbGUnLFxuXHRcdFx0XHRydGNwTXV4UG9saWN5ICAgICAgOiAncmVxdWlyZSdcblx0XHRcdH0pO1xuXG5cdFx0Ly8gR2VuZXJpYyBzZW5kaW5nIFJUUCBwYXJhbWV0ZXJzIGZvciBhdWRpbyBhbmQgdmlkZW8uXG5cdFx0Ly8gQHR5cGUge09iamVjdH1cblx0XHR0aGlzLl9ydHBQYXJhbWV0ZXJzQnlLaW5kID0gcnRwUGFyYW1ldGVyc0J5S2luZDtcblxuXHRcdC8vIFJlbW90ZSBTRFAgaGFuZGxlci5cblx0XHQvLyBAdHlwZSB7UmVtb3RlUGxhbkJTZHB9XG5cdFx0dGhpcy5fcmVtb3RlU2RwID0gbmV3IFJlbW90ZVBsYW5CU2RwKGRpcmVjdGlvbiwgcnRwUGFyYW1ldGVyc0J5S2luZCk7XG5cblx0XHQvLyBIYW5kbGUgUlRDUGVlckNvbm5lY3Rpb24gY29ubmVjdGlvbiBzdGF0dXMuXG5cdFx0dGhpcy5fcGMuYWRkRXZlbnRMaXN0ZW5lcignaWNlY29ubmVjdGlvbnN0YXRlY2hhbmdlJywgKCkgPT5cblx0XHR7XG5cdFx0XHRzd2l0Y2ggKHRoaXMuX3BjLmljZUNvbm5lY3Rpb25TdGF0ZSlcblx0XHRcdHtcblx0XHRcdFx0Y2FzZSAnY2hlY2tpbmcnOlxuXHRcdFx0XHRcdHRoaXMuZW1pdCgnQGNvbm5lY3Rpb25zdGF0ZWNoYW5nZScsICdjb25uZWN0aW5nJyk7XG5cdFx0XHRcdFx0YnJlYWs7XG5cdFx0XHRcdGNhc2UgJ2Nvbm5lY3RlZCc6XG5cdFx0XHRcdGNhc2UgJ2NvbXBsZXRlZCc6XG5cdFx0XHRcdFx0dGhpcy5lbWl0KCdAY29ubmVjdGlvbnN0YXRlY2hhbmdlJywgJ2Nvbm5lY3RlZCcpO1xuXHRcdFx0XHRcdGJyZWFrO1xuXHRcdFx0XHRjYXNlICdmYWlsZWQnOlxuXHRcdFx0XHRcdHRoaXMuZW1pdCgnQGNvbm5lY3Rpb25zdGF0ZWNoYW5nZScsICdmYWlsZWQnKTtcblx0XHRcdFx0XHRicmVhaztcblx0XHRcdFx0Y2FzZSAnZGlzY29ubmVjdGVkJzpcblx0XHRcdFx0XHR0aGlzLmVtaXQoJ0Bjb25uZWN0aW9uc3RhdGVjaGFuZ2UnLCAnZGlzY29ubmVjdGVkJyk7XG5cdFx0XHRcdFx0YnJlYWs7XG5cdFx0XHRcdGNhc2UgJ2Nsb3NlZCc6XG5cdFx0XHRcdFx0dGhpcy5lbWl0KCdAY29ubmVjdGlvbnN0YXRlY2hhbmdlJywgJ2Nsb3NlZCcpO1xuXHRcdFx0XHRcdGJyZWFrO1xuXHRcdFx0fVxuXHRcdH0pO1xuXHR9XG5cblx0Y2xvc2UoKVxuXHR7XG5cdFx0bG9nZ2VyLmRlYnVnKCdjbG9zZSgpJyk7XG5cblx0XHQvLyBDbG9zZSBSVENQZWVyQ29ubmVjdGlvbi5cblx0XHR0cnkgeyB0aGlzLl9wYy5jbG9zZSgpOyB9XG5cdFx0Y2F0Y2ggKGVycm9yKSB7fVxuXHR9XG59XG5cbmNsYXNzIFNlbmRIYW5kbGVyIGV4dGVuZHMgSGFuZGxlclxue1xuXHRjb25zdHJ1Y3RvcihydHBQYXJhbWV0ZXJzQnlLaW5kLCBzZXR0aW5ncylcblx0e1xuXHRcdHN1cGVyKCdzZW5kJywgcnRwUGFyYW1ldGVyc0J5S2luZCwgc2V0dGluZ3MpO1xuXG5cdFx0Ly8gR290IHRyYW5zcG9ydCBsb2NhbCBhbmQgcmVtb3RlIHBhcmFtZXRlcnMuXG5cdFx0Ly8gQHR5cGUge0Jvb2xlYW59XG5cdFx0dGhpcy5fdHJhbnNwb3J0UmVhZHkgPSBmYWxzZTtcblxuXHRcdC8vIExvY2FsIHN0cmVhbS5cblx0XHQvLyBAdHlwZSB7TWVkaWFTdHJlYW19XG5cdFx0dGhpcy5fc3RyZWFtID0gbmV3IE1lZGlhU3RyZWFtKCk7XG5cdH1cblxuXHRhZGRQcm9kdWNlcihwcm9kdWNlcilcblx0e1xuXHRcdGNvbnN0IHsgdHJhY2sgfSA9IHByb2R1Y2VyO1xuXG5cdFx0bG9nZ2VyLmRlYnVnKFxuXHRcdFx0J2FkZFByb2R1Y2VyKCkgW2lkOiVzLCBraW5kOiVzLCB0cmFja0lkOiVzXScsXG5cdFx0XHRwcm9kdWNlci5pZCwgcHJvZHVjZXIua2luZCwgdHJhY2suaWQpO1xuXG5cdFx0aWYgKHRoaXMuX3N0cmVhbS5nZXRUcmFja0J5SWQodHJhY2suaWQpKVxuXHRcdFx0cmV0dXJuIFByb21pc2UucmVqZWN0KG5ldyBFcnJvcigndHJhY2sgYWxyZWFkeSBhZGRlZCcpKTtcblxuXHRcdGxldCBsb2NhbFNkcE9iajtcblxuXHRcdHJldHVybiBQcm9taXNlLnJlc29sdmUoKVxuXHRcdFx0LnRoZW4oKCkgPT5cblx0XHRcdHtcblx0XHRcdFx0Ly8gQWRkIHRoZSB0cmFjayB0byB0aGUgbG9jYWwgc3RyZWFtLlxuXHRcdFx0XHR0aGlzLl9zdHJlYW0uYWRkVHJhY2sodHJhY2spO1xuXG5cdFx0XHRcdC8vIEFkZCB0aGUgc3RyZWFtIHRvIHRoZSBQZWVyQ29ubmVjdGlvbi5cblx0XHRcdFx0dGhpcy5fcGMuYWRkU3RyZWFtKHRoaXMuX3N0cmVhbSk7XG5cblx0XHRcdFx0cmV0dXJuIHRoaXMuX3BjLmNyZWF0ZU9mZmVyKCk7XG5cdFx0XHR9KVxuXHRcdFx0LnRoZW4oKG9mZmVyKSA9PlxuXHRcdFx0e1xuXHRcdFx0XHQvLyBJZiBzaW11bGNhc3QgaXMgc2V0LCBtYW5nbGUgdGhlIG9mZmVyLlxuXHRcdFx0XHRpZiAocHJvZHVjZXIuc2ltdWxjYXN0KVxuXHRcdFx0XHR7XG5cdFx0XHRcdFx0bG9nZ2VyLmRlYnVnKCdhZGRQcm9kdWNlcigpIHwgZW5hYmxpbmcgc2ltdWxjYXN0Jyk7XG5cblx0XHRcdFx0XHRjb25zdCBzZHBPYmplY3QgPSBzZHBUcmFuc2Zvcm0ucGFyc2Uob2ZmZXIuc2RwKTtcblxuXHRcdFx0XHRcdHNkcFBsYW5CVXRpbHMuYWRkU2ltdWxjYXN0Rm9yVHJhY2soc2RwT2JqZWN0LCB0cmFjayk7XG5cblx0XHRcdFx0XHRjb25zdCBvZmZlclNkcCA9IHNkcFRyYW5zZm9ybS53cml0ZShzZHBPYmplY3QpO1xuXG5cdFx0XHRcdFx0b2ZmZXIgPSB7IHR5cGU6ICdvZmZlcicsIHNkcDogb2ZmZXJTZHAgfTtcblx0XHRcdFx0fVxuXG5cdFx0XHRcdGxvZ2dlci5kZWJ1Zyhcblx0XHRcdFx0XHQnYWRkUHJvZHVjZXIoKSB8IGNhbGxpbmcgcGMuc2V0TG9jYWxEZXNjcmlwdGlvbigpIFtvZmZlcjolb10nLFxuXHRcdFx0XHRcdG9mZmVyKTtcblxuXHRcdFx0XHRyZXR1cm4gdGhpcy5fcGMuc2V0TG9jYWxEZXNjcmlwdGlvbihvZmZlcik7XG5cdFx0XHR9KVxuXHRcdFx0LnRoZW4oKCkgPT5cblx0XHRcdHtcblx0XHRcdFx0aWYgKCF0aGlzLl90cmFuc3BvcnRSZWFkeSlcblx0XHRcdFx0XHRyZXR1cm4gdGhpcy5fc2V0dXBUcmFuc3BvcnQoKTtcblx0XHRcdH0pXG5cdFx0XHQudGhlbigoKSA9PlxuXHRcdFx0e1xuXHRcdFx0XHRsb2NhbFNkcE9iaiA9IHNkcFRyYW5zZm9ybS5wYXJzZSh0aGlzLl9wYy5sb2NhbERlc2NyaXB0aW9uLnNkcCk7XG5cblx0XHRcdFx0Y29uc3QgcmVtb3RlU2RwID0gdGhpcy5fcmVtb3RlU2RwLmNyZWF0ZUFuc3dlclNkcChsb2NhbFNkcE9iaik7XG5cdFx0XHRcdGNvbnN0IGFuc3dlciA9IHsgdHlwZTogJ2Fuc3dlcicsIHNkcDogcmVtb3RlU2RwIH07XG5cblx0XHRcdFx0bG9nZ2VyLmRlYnVnKFxuXHRcdFx0XHRcdCdhZGRQcm9kdWNlcigpIHwgY2FsbGluZyBwYy5zZXRSZW1vdGVEZXNjcmlwdGlvbigpIFthbnN3ZXI6JW9dJyxcblx0XHRcdFx0XHRhbnN3ZXIpO1xuXG5cdFx0XHRcdHJldHVybiB0aGlzLl9wYy5zZXRSZW1vdGVEZXNjcmlwdGlvbihhbnN3ZXIpO1xuXHRcdFx0fSlcblx0XHRcdC50aGVuKCgpID0+XG5cdFx0XHR7XG5cdFx0XHRcdGNvbnN0IHJ0cFBhcmFtZXRlcnMgPSB1dGlscy5jbG9uZSh0aGlzLl9ydHBQYXJhbWV0ZXJzQnlLaW5kW3Byb2R1Y2VyLmtpbmRdKTtcblxuXHRcdFx0XHQvLyBGaWxsIHRoZSBSVFAgcGFyYW1ldGVycyBmb3IgdGhpcyB0cmFjay5cblx0XHRcdFx0c2RwUGxhbkJVdGlscy5maWxsUnRwUGFyYW1ldGVyc0ZvclRyYWNrKFxuXHRcdFx0XHRcdHJ0cFBhcmFtZXRlcnMsIGxvY2FsU2RwT2JqLCB0cmFjayk7XG5cblx0XHRcdFx0cmV0dXJuIHJ0cFBhcmFtZXRlcnM7XG5cdFx0XHR9KVxuXHRcdFx0LmNhdGNoKChlcnJvcikgPT5cblx0XHRcdHtcblx0XHRcdFx0Ly8gUGFuaWMgaGVyZS4gVHJ5IHRvIHVuZG8gdGhpbmdzLlxuXG5cdFx0XHRcdHRoaXMuX3N0cmVhbS5yZW1vdmVUcmFjayh0cmFjayk7XG5cdFx0XHRcdHRoaXMuX3BjLmFkZFN0cmVhbSh0aGlzLl9zdHJlYW0pO1xuXG5cdFx0XHRcdHRocm93IGVycm9yO1xuXHRcdFx0fSk7XG5cdH1cblxuXHRyZW1vdmVQcm9kdWNlcihwcm9kdWNlcilcblx0e1xuXHRcdGNvbnN0IHsgdHJhY2sgfSA9IHByb2R1Y2VyO1xuXG5cdFx0bG9nZ2VyLmRlYnVnKFxuXHRcdFx0J3JlbW92ZVByb2R1Y2VyKCkgW2lkOiVzLCBraW5kOiVzLCB0cmFja0lkOiVzXScsXG5cdFx0XHRwcm9kdWNlci5pZCwgcHJvZHVjZXIua2luZCwgdHJhY2suaWQpO1xuXG5cdFx0cmV0dXJuIFByb21pc2UucmVzb2x2ZSgpXG5cdFx0XHQudGhlbigoKSA9PlxuXHRcdFx0e1xuXHRcdFx0XHQvLyBSZW1vdmUgdGhlIHRyYWNrIGZyb20gdGhlIGxvY2FsIHN0cmVhbS5cblx0XHRcdFx0dGhpcy5fc3RyZWFtLnJlbW92ZVRyYWNrKHRyYWNrKTtcblxuXHRcdFx0XHQvLyBBZGQgdGhlIHN0cmVhbSB0byB0aGUgUGVlckNvbm5lY3Rpb24uXG5cdFx0XHRcdHRoaXMuX3BjLmFkZFN0cmVhbSh0aGlzLl9zdHJlYW0pO1xuXG5cdFx0XHRcdHJldHVybiB0aGlzLl9wYy5jcmVhdGVPZmZlcigpO1xuXHRcdFx0fSlcblx0XHRcdC50aGVuKChvZmZlcikgPT5cblx0XHRcdHtcblx0XHRcdFx0bG9nZ2VyLmRlYnVnKFxuXHRcdFx0XHRcdCdyZW1vdmVQcm9kdWNlcigpIHwgY2FsbGluZyBwYy5zZXRMb2NhbERlc2NyaXB0aW9uKCkgW29mZmVyOiVvXScsXG5cdFx0XHRcdFx0b2ZmZXIpO1xuXG5cdFx0XHRcdHJldHVybiB0aGlzLl9wYy5zZXRMb2NhbERlc2NyaXB0aW9uKG9mZmVyKTtcblx0XHRcdH0pXG5cdFx0XHQuY2F0Y2goKGVycm9yKSA9PlxuXHRcdFx0e1xuXHRcdFx0XHQvLyBOT1RFOiBJZiB0aGVyZSBhcmUgbm8gc2VuZGluZyB0cmFja3MsIHNldExvY2FsRGVzY3JpcHRpb24oKSB3aWxsIGZhaWwgd2l0aFxuXHRcdFx0XHQvLyBcIkZhaWxlZCB0byBjcmVhdGUgY2hhbm5lbHNcIi4gSWYgc28sIGlnbm9yZSBpdC5cblx0XHRcdFx0aWYgKHRoaXMuX3N0cmVhbS5nZXRUcmFja3MoKS5sZW5ndGggPT09IDApXG5cdFx0XHRcdHtcblx0XHRcdFx0XHRsb2dnZXIud2Fybihcblx0XHRcdFx0XHRcdCdyZW1vdmVQcm9kdWNlcigpIHwgaWdub3JpbmcgZXhwZWN0ZWQgZXJyb3IgZHVlIG5vIHNlbmRpbmcgdHJhY2tzOiAlcycsXG5cdFx0XHRcdFx0XHRlcnJvci50b1N0cmluZygpKTtcblxuXHRcdFx0XHRcdHJldHVybjtcblx0XHRcdFx0fVxuXG5cdFx0XHRcdHRocm93IGVycm9yO1xuXHRcdFx0fSlcblx0XHRcdC50aGVuKCgpID0+XG5cdFx0XHR7XG5cdFx0XHRcdGlmICh0aGlzLl9wYy5zaWduYWxpbmdTdGF0ZSA9PT0gJ3N0YWJsZScpXG5cdFx0XHRcdFx0cmV0dXJuO1xuXG5cdFx0XHRcdGNvbnN0IGxvY2FsU2RwT2JqID0gc2RwVHJhbnNmb3JtLnBhcnNlKHRoaXMuX3BjLmxvY2FsRGVzY3JpcHRpb24uc2RwKTtcblx0XHRcdFx0Y29uc3QgcmVtb3RlU2RwID0gdGhpcy5fcmVtb3RlU2RwLmNyZWF0ZUFuc3dlclNkcChsb2NhbFNkcE9iaik7XG5cdFx0XHRcdGNvbnN0IGFuc3dlciA9IHsgdHlwZTogJ2Fuc3dlcicsIHNkcDogcmVtb3RlU2RwIH07XG5cblx0XHRcdFx0bG9nZ2VyLmRlYnVnKFxuXHRcdFx0XHRcdCdyZW1vdmVQcm9kdWNlcigpIHwgY2FsbGluZyBwYy5zZXRSZW1vdGVEZXNjcmlwdGlvbigpIFthbnN3ZXI6JW9dJyxcblx0XHRcdFx0XHRhbnN3ZXIpO1xuXG5cdFx0XHRcdHJldHVybiB0aGlzLl9wYy5zZXRSZW1vdGVEZXNjcmlwdGlvbihhbnN3ZXIpO1xuXHRcdFx0fSk7XG5cdH1cblxuXHRyZXBsYWNlUHJvZHVjZXJUcmFjayhwcm9kdWNlciwgdHJhY2spXG5cdHtcblx0XHRsb2dnZXIuZGVidWcoXG5cdFx0XHQncmVwbGFjZVByb2R1Y2VyVHJhY2soKSBbaWQ6JXMsIGtpbmQ6JXMsIHRyYWNrSWQ6JXNdJyxcblx0XHRcdHByb2R1Y2VyLmlkLCBwcm9kdWNlci5raW5kLCB0cmFjay5pZCk7XG5cblx0XHRjb25zdCBvbGRUcmFjayA9IHByb2R1Y2VyLnRyYWNrO1xuXG5cdFx0cmV0dXJuIFByb21pc2UucmVzb2x2ZSgpXG5cdFx0XHQudGhlbigoKSA9PlxuXHRcdFx0e1xuXHRcdFx0XHQvLyBHZXQgdGhlIGFzc29jaWF0ZWQgUlRDUnRwU2VuZGVyLlxuXHRcdFx0XHRjb25zdCBydHBTZW5kZXIgPSB0aGlzLl9wYy5nZXRTZW5kZXJzKClcblx0XHRcdFx0XHQuZmluZCgocykgPT4gcy50cmFjayA9PT0gb2xkVHJhY2spO1xuXG5cdFx0XHRcdGlmICghcnRwU2VuZGVyKVxuXHRcdFx0XHRcdHRocm93IG5ldyBFcnJvcignbG9jYWwgdHJhY2sgbm90IGZvdW5kJyk7XG5cblx0XHRcdFx0cmV0dXJuIHJ0cFNlbmRlci5yZXBsYWNlVHJhY2sodHJhY2spO1xuXHRcdFx0fSlcblx0XHRcdC50aGVuKCgpID0+XG5cdFx0XHR7XG5cdFx0XHRcdC8vIFJlbW92ZSB0aGUgb2xkIHRyYWNrIGZyb20gdGhlIGxvY2FsIHN0cmVhbS5cblx0XHRcdFx0dGhpcy5fc3RyZWFtLnJlbW92ZVRyYWNrKG9sZFRyYWNrKTtcblxuXHRcdFx0XHQvLyBBZGQgdGhlIG5ldyB0cmFjayB0byB0aGUgbG9jYWwgc3RyZWFtLlxuXHRcdFx0XHR0aGlzLl9zdHJlYW0uYWRkVHJhY2sodHJhY2spO1xuXHRcdFx0fSk7XG5cdH1cblxuXHRyZXN0YXJ0SWNlKHJlbW90ZUljZVBhcmFtZXRlcnMpXG5cdHtcblx0XHRsb2dnZXIuZGVidWcoJ3Jlc3RhcnRJY2UoKScpO1xuXG5cdFx0Ly8gUHJvdmlkZSB0aGUgcmVtb3RlIFNEUCBoYW5kbGVyIHdpdGggbmV3IHJlbW90ZSBJQ0UgcGFyYW1ldGVycy5cblx0XHR0aGlzLl9yZW1vdGVTZHAudXBkYXRlVHJhbnNwb3J0UmVtb3RlSWNlUGFyYW1ldGVycyhyZW1vdGVJY2VQYXJhbWV0ZXJzKTtcblxuXHRcdHJldHVybiBQcm9taXNlLnJlc29sdmUoKVxuXHRcdFx0LnRoZW4oKCkgPT5cblx0XHRcdHtcblx0XHRcdFx0cmV0dXJuIHRoaXMuX3BjLmNyZWF0ZU9mZmVyKHsgaWNlUmVzdGFydDogdHJ1ZSB9KTtcblx0XHRcdH0pXG5cdFx0XHQudGhlbigob2ZmZXIpID0+XG5cdFx0XHR7XG5cdFx0XHRcdGxvZ2dlci5kZWJ1Zyhcblx0XHRcdFx0XHQncmVzdGFydEljZSgpIHwgY2FsbGluZyBwYy5zZXRMb2NhbERlc2NyaXB0aW9uKCkgW29mZmVyOiVvXScsXG5cdFx0XHRcdFx0b2ZmZXIpO1xuXG5cdFx0XHRcdHJldHVybiB0aGlzLl9wYy5zZXRMb2NhbERlc2NyaXB0aW9uKG9mZmVyKTtcblx0XHRcdH0pXG5cdFx0XHQudGhlbigoKSA9PlxuXHRcdFx0e1xuXHRcdFx0XHRjb25zdCBsb2NhbFNkcE9iaiA9IHNkcFRyYW5zZm9ybS5wYXJzZSh0aGlzLl9wYy5sb2NhbERlc2NyaXB0aW9uLnNkcCk7XG5cdFx0XHRcdGNvbnN0IHJlbW90ZVNkcCA9IHRoaXMuX3JlbW90ZVNkcC5jcmVhdGVBbnN3ZXJTZHAobG9jYWxTZHBPYmopO1xuXHRcdFx0XHRjb25zdCBhbnN3ZXIgPSB7IHR5cGU6ICdhbnN3ZXInLCBzZHA6IHJlbW90ZVNkcCB9O1xuXG5cdFx0XHRcdGxvZ2dlci5kZWJ1Zyhcblx0XHRcdFx0XHQncmVzdGFydEljZSgpIHwgY2FsbGluZyBwYy5zZXRSZW1vdGVEZXNjcmlwdGlvbigpIFthbnN3ZXI6JW9dJyxcblx0XHRcdFx0XHRhbnN3ZXIpO1xuXG5cdFx0XHRcdHJldHVybiB0aGlzLl9wYy5zZXRSZW1vdGVEZXNjcmlwdGlvbihhbnN3ZXIpO1xuXHRcdFx0fSk7XG5cdH1cblxuXHRfc2V0dXBUcmFuc3BvcnQoKVxuXHR7XG5cdFx0bG9nZ2VyLmRlYnVnKCdfc2V0dXBUcmFuc3BvcnQoKScpO1xuXG5cdFx0cmV0dXJuIFByb21pc2UucmVzb2x2ZSgpXG5cdFx0XHQudGhlbigoKSA9PlxuXHRcdFx0e1xuXHRcdFx0XHQvLyBHZXQgb3VyIGxvY2FsIERUTFMgcGFyYW1ldGVycy5cblx0XHRcdFx0Y29uc3QgdHJhbnNwb3J0TG9jYWxQYXJhbWV0ZXJzID0ge307XG5cdFx0XHRcdGNvbnN0IHNkcCA9IHRoaXMuX3BjLmxvY2FsRGVzY3JpcHRpb24uc2RwO1xuXHRcdFx0XHRjb25zdCBzZHBPYmogPSBzZHBUcmFuc2Zvcm0ucGFyc2Uoc2RwKTtcblx0XHRcdFx0Y29uc3QgZHRsc1BhcmFtZXRlcnMgPSBzZHBDb21tb25VdGlscy5leHRyYWN0RHRsc1BhcmFtZXRlcnMoc2RwT2JqKTtcblxuXHRcdFx0XHQvLyBMZXQncyBkZWNpZGUgdGhhdCB3ZSdsbCBiZSBEVExTIHNlcnZlciAoYmVjYXVzZSB3ZSBjYW4pLlxuXHRcdFx0XHRkdGxzUGFyYW1ldGVycy5yb2xlID0gJ3NlcnZlcic7XG5cblx0XHRcdFx0dHJhbnNwb3J0TG9jYWxQYXJhbWV0ZXJzLmR0bHNQYXJhbWV0ZXJzID0gZHRsc1BhcmFtZXRlcnM7XG5cblx0XHRcdFx0Ly8gUHJvdmlkZSB0aGUgcmVtb3RlIFNEUCBoYW5kbGVyIHdpdGggdHJhbnNwb3J0IGxvY2FsIHBhcmFtZXRlcnMuXG5cdFx0XHRcdHRoaXMuX3JlbW90ZVNkcC5zZXRUcmFuc3BvcnRMb2NhbFBhcmFtZXRlcnModHJhbnNwb3J0TG9jYWxQYXJhbWV0ZXJzKTtcblxuXHRcdFx0XHQvLyBXZSBuZWVkIHRyYW5zcG9ydCByZW1vdGUgcGFyYW1ldGVycy5cblx0XHRcdFx0cmV0dXJuIHRoaXMuc2FmZUVtaXRBc1Byb21pc2UoXG5cdFx0XHRcdFx0J0BuZWVkY3JlYXRldHJhbnNwb3J0JywgdHJhbnNwb3J0TG9jYWxQYXJhbWV0ZXJzKTtcblx0XHRcdH0pXG5cdFx0XHQudGhlbigodHJhbnNwb3J0UmVtb3RlUGFyYW1ldGVycykgPT5cblx0XHRcdHtcblx0XHRcdFx0Ly8gUHJvdmlkZSB0aGUgcmVtb3RlIFNEUCBoYW5kbGVyIHdpdGggdHJhbnNwb3J0IHJlbW90ZSBwYXJhbWV0ZXJzLlxuXHRcdFx0XHR0aGlzLl9yZW1vdGVTZHAuc2V0VHJhbnNwb3J0UmVtb3RlUGFyYW1ldGVycyh0cmFuc3BvcnRSZW1vdGVQYXJhbWV0ZXJzKTtcblxuXHRcdFx0XHR0aGlzLl90cmFuc3BvcnRSZWFkeSA9IHRydWU7XG5cdFx0XHR9KTtcblx0fVxufVxuXG5jbGFzcyBSZWN2SGFuZGxlciBleHRlbmRzIEhhbmRsZXJcbntcblx0Y29uc3RydWN0b3IocnRwUGFyYW1ldGVyc0J5S2luZCwgc2V0dGluZ3MpXG5cdHtcblx0XHRzdXBlcigncmVjdicsIHJ0cFBhcmFtZXRlcnNCeUtpbmQsIHNldHRpbmdzKTtcblxuXHRcdC8vIEdvdCB0cmFuc3BvcnQgcmVtb3RlIHBhcmFtZXRlcnMuXG5cdFx0Ly8gQHR5cGUge0Jvb2xlYW59XG5cdFx0dGhpcy5fdHJhbnNwb3J0Q3JlYXRlZCA9IGZhbHNlO1xuXG5cdFx0Ly8gR290IHRyYW5zcG9ydCBsb2NhbCBwYXJhbWV0ZXJzLlxuXHRcdC8vIEB0eXBlIHtCb29sZWFufVxuXHRcdHRoaXMuX3RyYW5zcG9ydFVwZGF0ZWQgPSBmYWxzZTtcblxuXHRcdC8vIFNlZW4gbWVkaWEga2luZHMuXG5cdFx0Ly8gQHR5cGUge1NldDxTdHJpbmc+fVxuXHRcdHRoaXMuX2tpbmRzID0gbmV3IFNldCgpO1xuXG5cdFx0Ly8gTWFwIG9mIENvbnN1bWVycyBpbmZvcm1hdGlvbiBpbmRleGVkIGJ5IGNvbnN1bWVyLmlkLlxuXHRcdC8vIC0ga2luZCB7U3RyaW5nfVxuXHRcdC8vIC0gdHJhY2tJZCB7U3RyaW5nfVxuXHRcdC8vIC0gc3NyYyB7TnVtYmVyfVxuXHRcdC8vIC0gcnR4U3NyYyB7TnVtYmVyfVxuXHRcdC8vIC0gY25hbWUge1N0cmluZ31cblx0XHQvLyBAdHlwZSB7TWFwPE51bWJlciwgT2JqZWN0Pn1cblx0XHR0aGlzLl9jb25zdW1lckluZm9zID0gbmV3IE1hcCgpO1xuXHR9XG5cblx0YWRkQ29uc3VtZXIoY29uc3VtZXIpXG5cdHtcblx0XHRsb2dnZXIuZGVidWcoXG5cdFx0XHQnYWRkQ29uc3VtZXIoKSBbaWQ6JXMsIGtpbmQ6JXNdJywgY29uc3VtZXIuaWQsIGNvbnN1bWVyLmtpbmQpO1xuXG5cdFx0aWYgKHRoaXMuX2NvbnN1bWVySW5mb3MuaGFzKGNvbnN1bWVyLmlkKSlcblx0XHRcdHJldHVybiBQcm9taXNlLnJlamVjdChuZXcgRXJyb3IoJ0NvbnN1bWVyIGFscmVhZHkgYWRkZWQnKSk7XG5cblx0XHRjb25zdCBlbmNvZGluZyA9IGNvbnN1bWVyLnJ0cFBhcmFtZXRlcnMuZW5jb2RpbmdzWzBdO1xuXHRcdGNvbnN0IGNuYW1lID0gY29uc3VtZXIucnRwUGFyYW1ldGVycy5ydGNwLmNuYW1lO1xuXHRcdGNvbnN0IGNvbnN1bWVySW5mbyA9XG5cdFx0e1xuXHRcdFx0a2luZCAgICAgOiBjb25zdW1lci5raW5kLFxuXHRcdFx0c3RyZWFtSWQgOiBgcmVjdi1zdHJlYW0tJHtjb25zdW1lci5pZH1gLFxuXHRcdFx0dHJhY2tJZCAgOiBgY29uc3VtZXItJHtjb25zdW1lci5raW5kfS0ke2NvbnN1bWVyLmlkfWAsXG5cdFx0XHRzc3JjICAgICA6IGVuY29kaW5nLnNzcmMsXG5cdFx0XHRjbmFtZSAgICA6IGNuYW1lXG5cdFx0fTtcblxuXHRcdGlmIChlbmNvZGluZy5ydHggJiYgZW5jb2RpbmcucnR4LnNzcmMpXG5cdFx0XHRjb25zdW1lckluZm8ucnR4U3NyYyA9IGVuY29kaW5nLnJ0eC5zc3JjO1xuXG5cdFx0dGhpcy5fY29uc3VtZXJJbmZvcy5zZXQoY29uc3VtZXIuaWQsIGNvbnN1bWVySW5mbyk7XG5cdFx0dGhpcy5fa2luZHMuYWRkKGNvbnN1bWVyLmtpbmQpO1xuXG5cdFx0cmV0dXJuIFByb21pc2UucmVzb2x2ZSgpXG5cdFx0XHQudGhlbigoKSA9PlxuXHRcdFx0e1xuXHRcdFx0XHRpZiAoIXRoaXMuX3RyYW5zcG9ydENyZWF0ZWQpXG5cdFx0XHRcdFx0cmV0dXJuIHRoaXMuX3NldHVwVHJhbnNwb3J0KCk7XG5cdFx0XHR9KVxuXHRcdFx0LnRoZW4oKCkgPT5cblx0XHRcdHtcblx0XHRcdFx0Y29uc3QgcmVtb3RlU2RwID0gdGhpcy5fcmVtb3RlU2RwLmNyZWF0ZU9mZmVyU2RwKFxuXHRcdFx0XHRcdEFycmF5LmZyb20odGhpcy5fa2luZHMpLCBBcnJheS5mcm9tKHRoaXMuX2NvbnN1bWVySW5mb3MudmFsdWVzKCkpKTtcblx0XHRcdFx0Y29uc3Qgb2ZmZXIgPSB7IHR5cGU6ICdvZmZlcicsIHNkcDogcmVtb3RlU2RwIH07XG5cblx0XHRcdFx0bG9nZ2VyLmRlYnVnKFxuXHRcdFx0XHRcdCdhZGRDb25zdW1lcigpIHwgY2FsbGluZyBwYy5zZXRSZW1vdGVEZXNjcmlwdGlvbigpIFtvZmZlcjolb10nLFxuXHRcdFx0XHRcdG9mZmVyKTtcblxuXHRcdFx0XHRyZXR1cm4gdGhpcy5fcGMuc2V0UmVtb3RlRGVzY3JpcHRpb24ob2ZmZXIpO1xuXHRcdFx0fSlcblx0XHRcdC50aGVuKCgpID0+XG5cdFx0XHR7XG5cdFx0XHRcdHJldHVybiB0aGlzLl9wYy5jcmVhdGVBbnN3ZXIoKTtcblx0XHRcdH0pXG5cdFx0XHQudGhlbigoYW5zd2VyKSA9PlxuXHRcdFx0e1xuXHRcdFx0XHRsb2dnZXIuZGVidWcoXG5cdFx0XHRcdFx0J2FkZENvbnN1bWVyKCkgfCBjYWxsaW5nIHBjLnNldExvY2FsRGVzY3JpcHRpb24oKSBbYW5zd2VyOiVvXScsXG5cdFx0XHRcdFx0YW5zd2VyKTtcblxuXHRcdFx0XHRyZXR1cm4gdGhpcy5fcGMuc2V0TG9jYWxEZXNjcmlwdGlvbihhbnN3ZXIpO1xuXHRcdFx0fSlcblx0XHRcdC50aGVuKCgpID0+XG5cdFx0XHR7XG5cdFx0XHRcdGlmICghdGhpcy5fdHJhbnNwb3J0VXBkYXRlZClcblx0XHRcdFx0XHRyZXR1cm4gdGhpcy5fdXBkYXRlVHJhbnNwb3J0KCk7XG5cdFx0XHR9KVxuXHRcdFx0LnRoZW4oKCkgPT5cblx0XHRcdHtcblx0XHRcdFx0Y29uc3Qgc3RyZWFtID0gdGhpcy5fcGMuZ2V0UmVtb3RlU3RyZWFtcygpXG5cdFx0XHRcdFx0LmZpbmQoKHMpID0+IHMuaWQgPT09IGNvbnN1bWVySW5mby5zdHJlYW1JZCk7XG5cdFx0XHRcdGNvbnN0IHRyYWNrID0gc3RyZWFtLmdldFRyYWNrQnlJZChjb25zdW1lckluZm8udHJhY2tJZCk7XG5cblx0XHRcdFx0aWYgKCF0cmFjaylcblx0XHRcdFx0XHR0aHJvdyBuZXcgRXJyb3IoJ3JlbW90ZSB0cmFjayBub3QgZm91bmQnKTtcblxuXHRcdFx0XHRyZXR1cm4gdHJhY2s7XG5cdFx0XHR9KTtcblx0fVxuXG5cdHJlbW92ZUNvbnN1bWVyKGNvbnN1bWVyKVxuXHR7XG5cdFx0bG9nZ2VyLmRlYnVnKFxuXHRcdFx0J3JlbW92ZUNvbnN1bWVyKCkgW2lkOiVzLCBraW5kOiVzXScsIGNvbnN1bWVyLmlkLCBjb25zdW1lci5raW5kKTtcblxuXHRcdGlmICghdGhpcy5fY29uc3VtZXJJbmZvcy5oYXMoY29uc3VtZXIuaWQpKVxuXHRcdFx0cmV0dXJuIFByb21pc2UucmVqZWN0KG5ldyBFcnJvcignQ29uc3VtZXIgbm90IGZvdW5kJykpO1xuXG5cdFx0dGhpcy5fY29uc3VtZXJJbmZvcy5kZWxldGUoY29uc3VtZXIuaWQpO1xuXG5cdFx0cmV0dXJuIFByb21pc2UucmVzb2x2ZSgpXG5cdFx0XHQudGhlbigoKSA9PlxuXHRcdFx0e1xuXHRcdFx0XHRjb25zdCByZW1vdGVTZHAgPSB0aGlzLl9yZW1vdGVTZHAuY3JlYXRlT2ZmZXJTZHAoXG5cdFx0XHRcdFx0QXJyYXkuZnJvbSh0aGlzLl9raW5kcyksIEFycmF5LmZyb20odGhpcy5fY29uc3VtZXJJbmZvcy52YWx1ZXMoKSkpO1xuXHRcdFx0XHRjb25zdCBvZmZlciA9IHsgdHlwZTogJ29mZmVyJywgc2RwOiByZW1vdGVTZHAgfTtcblxuXHRcdFx0XHRsb2dnZXIuZGVidWcoXG5cdFx0XHRcdFx0J3JlbW92ZUNvbnN1bWVyKCkgfCBjYWxsaW5nIHBjLnNldFJlbW90ZURlc2NyaXB0aW9uKCkgW29mZmVyOiVvXScsXG5cdFx0XHRcdFx0b2ZmZXIpO1xuXG5cdFx0XHRcdHJldHVybiB0aGlzLl9wYy5zZXRSZW1vdGVEZXNjcmlwdGlvbihvZmZlcik7XG5cdFx0XHR9KVxuXHRcdFx0LnRoZW4oKCkgPT5cblx0XHRcdHtcblx0XHRcdFx0cmV0dXJuIHRoaXMuX3BjLmNyZWF0ZUFuc3dlcigpO1xuXHRcdFx0fSlcblx0XHRcdC50aGVuKChhbnN3ZXIpID0+XG5cdFx0XHR7XG5cdFx0XHRcdGxvZ2dlci5kZWJ1Zyhcblx0XHRcdFx0XHQncmVtb3ZlQ29uc3VtZXIoKSB8IGNhbGxpbmcgcGMuc2V0TG9jYWxEZXNjcmlwdGlvbigpIFthbnN3ZXI6JW9dJyxcblx0XHRcdFx0XHRhbnN3ZXIpO1xuXG5cdFx0XHRcdHJldHVybiB0aGlzLl9wYy5zZXRMb2NhbERlc2NyaXB0aW9uKGFuc3dlcik7XG5cdFx0XHR9KTtcblx0fVxuXG5cdHJlc3RhcnRJY2UocmVtb3RlSWNlUGFyYW1ldGVycylcblx0e1xuXHRcdGxvZ2dlci5kZWJ1ZygncmVzdGFydEljZSgpJyk7XG5cblx0XHQvLyBQcm92aWRlIHRoZSByZW1vdGUgU0RQIGhhbmRsZXIgd2l0aCBuZXcgcmVtb3RlIElDRSBwYXJhbWV0ZXJzLlxuXHRcdHRoaXMuX3JlbW90ZVNkcC51cGRhdGVUcmFuc3BvcnRSZW1vdGVJY2VQYXJhbWV0ZXJzKHJlbW90ZUljZVBhcmFtZXRlcnMpO1xuXG5cdFx0cmV0dXJuIFByb21pc2UucmVzb2x2ZSgpXG5cdFx0XHQudGhlbigoKSA9PlxuXHRcdFx0e1xuXHRcdFx0XHRjb25zdCByZW1vdGVTZHAgPSB0aGlzLl9yZW1vdGVTZHAuY3JlYXRlT2ZmZXJTZHAoXG5cdFx0XHRcdFx0QXJyYXkuZnJvbSh0aGlzLl9raW5kcyksIEFycmF5LmZyb20odGhpcy5fY29uc3VtZXJJbmZvcy52YWx1ZXMoKSkpO1xuXHRcdFx0XHRjb25zdCBvZmZlciA9IHsgdHlwZTogJ29mZmVyJywgc2RwOiByZW1vdGVTZHAgfTtcblxuXHRcdFx0XHRsb2dnZXIuZGVidWcoXG5cdFx0XHRcdFx0J3Jlc3RhcnRJY2UoKSB8IGNhbGxpbmcgcGMuc2V0UmVtb3RlRGVzY3JpcHRpb24oKSBbb2ZmZXI6JW9dJyxcblx0XHRcdFx0XHRvZmZlcik7XG5cblx0XHRcdFx0cmV0dXJuIHRoaXMuX3BjLnNldFJlbW90ZURlc2NyaXB0aW9uKG9mZmVyKTtcblx0XHRcdH0pXG5cdFx0XHQudGhlbigoKSA9PlxuXHRcdFx0e1xuXHRcdFx0XHRyZXR1cm4gdGhpcy5fcGMuY3JlYXRlQW5zd2VyKCk7XG5cdFx0XHR9KVxuXHRcdFx0LnRoZW4oKGFuc3dlcikgPT5cblx0XHRcdHtcblx0XHRcdFx0bG9nZ2VyLmRlYnVnKFxuXHRcdFx0XHRcdCdyZXN0YXJ0SWNlKCkgfCBjYWxsaW5nIHBjLnNldExvY2FsRGVzY3JpcHRpb24oKSBbYW5zd2VyOiVvXScsXG5cdFx0XHRcdFx0YW5zd2VyKTtcblxuXHRcdFx0XHRyZXR1cm4gdGhpcy5fcGMuc2V0TG9jYWxEZXNjcmlwdGlvbihhbnN3ZXIpO1xuXHRcdFx0fSk7XG5cdH1cblxuXHRfc2V0dXBUcmFuc3BvcnQoKVxuXHR7XG5cdFx0bG9nZ2VyLmRlYnVnKCdfc2V0dXBUcmFuc3BvcnQoKScpO1xuXG5cdFx0cmV0dXJuIFByb21pc2UucmVzb2x2ZSgpXG5cdFx0XHQudGhlbigoKSA9PlxuXHRcdFx0e1xuXHRcdFx0XHQvLyBXZSBuZWVkIHRyYW5zcG9ydCByZW1vdGUgcGFyYW1ldGVycy5cblx0XHRcdFx0cmV0dXJuIHRoaXMuc2FmZUVtaXRBc1Byb21pc2UoJ0BuZWVkY3JlYXRldHJhbnNwb3J0JywgbnVsbCk7XG5cdFx0XHR9KVxuXHRcdFx0LnRoZW4oKHRyYW5zcG9ydFJlbW90ZVBhcmFtZXRlcnMpID0+XG5cdFx0XHR7XG5cdFx0XHRcdC8vIFByb3ZpZGUgdGhlIHJlbW90ZSBTRFAgaGFuZGxlciB3aXRoIHRyYW5zcG9ydCByZW1vdGUgcGFyYW1ldGVycy5cblx0XHRcdFx0dGhpcy5fcmVtb3RlU2RwLnNldFRyYW5zcG9ydFJlbW90ZVBhcmFtZXRlcnModHJhbnNwb3J0UmVtb3RlUGFyYW1ldGVycyk7XG5cblx0XHRcdFx0dGhpcy5fdHJhbnNwb3J0Q3JlYXRlZCA9IHRydWU7XG5cdFx0XHR9KTtcblx0fVxuXG5cdF91cGRhdGVUcmFuc3BvcnQoKVxuXHR7XG5cdFx0bG9nZ2VyLmRlYnVnKCdfdXBkYXRlVHJhbnNwb3J0KCknKTtcblxuXHRcdC8vIEdldCBvdXIgbG9jYWwgRFRMUyBwYXJhbWV0ZXJzLlxuXHRcdC8vIGNvbnN0IHRyYW5zcG9ydExvY2FsUGFyYW1ldGVycyA9IHt9O1xuXHRcdGNvbnN0IHNkcCA9IHRoaXMuX3BjLmxvY2FsRGVzY3JpcHRpb24uc2RwO1xuXHRcdGNvbnN0IHNkcE9iaiA9IHNkcFRyYW5zZm9ybS5wYXJzZShzZHApO1xuXHRcdGNvbnN0IGR0bHNQYXJhbWV0ZXJzID0gc2RwQ29tbW9uVXRpbHMuZXh0cmFjdER0bHNQYXJhbWV0ZXJzKHNkcE9iaik7XG5cdFx0Y29uc3QgdHJhbnNwb3J0TG9jYWxQYXJhbWV0ZXJzID0geyBkdGxzUGFyYW1ldGVycyB9O1xuXG5cdFx0Ly8gV2UgbmVlZCB0byBwcm92aWRlIHRyYW5zcG9ydCBsb2NhbCBwYXJhbWV0ZXJzLlxuXHRcdHRoaXMuc2FmZUVtaXQoJ0BuZWVkdXBkYXRldHJhbnNwb3J0JywgdHJhbnNwb3J0TG9jYWxQYXJhbWV0ZXJzKTtcblxuXHRcdHRoaXMuX3RyYW5zcG9ydFVwZGF0ZWQgPSB0cnVlO1xuXHR9XG59XG5cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIENocm9tZTY3XG57XG5cdHN0YXRpYyBnZXQgdGFnKClcblx0e1xuXHRcdHJldHVybiAnQ2hyb21lNjcnO1xuXHR9XG5cblx0c3RhdGljIGdldE5hdGl2ZVJ0cENhcGFiaWxpdGllcygpXG5cdHtcblx0XHRsb2dnZXIuZGVidWcoJ2dldE5hdGl2ZVJ0cENhcGFiaWxpdGllcygpJyk7XG5cblx0XHRjb25zdCBwYyA9IG5ldyBSVENQZWVyQ29ubmVjdGlvbihcblx0XHRcdHtcblx0XHRcdFx0aWNlU2VydmVycyAgICAgICAgIDogW10sXG5cdFx0XHRcdGljZVRyYW5zcG9ydFBvbGljeSA6ICdhbGwnLFxuXHRcdFx0XHRidW5kbGVQb2xpY3kgICAgICAgOiAnbWF4LWJ1bmRsZScsXG5cdFx0XHRcdHJ0Y3BNdXhQb2xpY3kgICAgICA6ICdyZXF1aXJlJ1xuXHRcdFx0fSk7XG5cblx0XHRyZXR1cm4gcGMuY3JlYXRlT2ZmZXIoXG5cdFx0XHR7XG5cdFx0XHRcdG9mZmVyVG9SZWNlaXZlQXVkaW8gOiB0cnVlLFxuXHRcdFx0XHRvZmZlclRvUmVjZWl2ZVZpZGVvIDogdHJ1ZVxuXHRcdFx0fSlcblx0XHRcdC50aGVuKChvZmZlcikgPT5cblx0XHRcdHtcblx0XHRcdFx0dHJ5IHsgcGMuY2xvc2UoKTsgfVxuXHRcdFx0XHRjYXRjaCAoZXJyb3IpIHt9XG5cblx0XHRcdFx0Y29uc3Qgc2RwT2JqID0gc2RwVHJhbnNmb3JtLnBhcnNlKG9mZmVyLnNkcCk7XG5cdFx0XHRcdGNvbnN0IG5hdGl2ZVJ0cENhcGFiaWxpdGllcyA9IHNkcENvbW1vblV0aWxzLmV4dHJhY3RSdHBDYXBhYmlsaXRpZXMoc2RwT2JqKTtcblxuXHRcdFx0XHRyZXR1cm4gbmF0aXZlUnRwQ2FwYWJpbGl0aWVzO1xuXHRcdFx0fSlcblx0XHRcdC5jYXRjaCgoZXJyb3IpID0+XG5cdFx0XHR7XG5cdFx0XHRcdHRyeSB7IHBjLmNsb3NlKCk7IH1cblx0XHRcdFx0Y2F0Y2ggKGVycm9yMikge31cblxuXHRcdFx0XHR0aHJvdyBlcnJvcjtcblx0XHRcdH0pO1xuXHR9XG5cblx0Y29uc3RydWN0b3IoZGlyZWN0aW9uLCBleHRlbmRlZFJ0cENhcGFiaWxpdGllcywgc2V0dGluZ3MpXG5cdHtcblx0XHRsb2dnZXIuZGVidWcoXG5cdFx0XHQnY29uc3RydWN0b3IoKSBbZGlyZWN0aW9uOiVzLCBleHRlbmRlZFJ0cENhcGFiaWxpdGllczolb10nLFxuXHRcdFx0ZGlyZWN0aW9uLCBleHRlbmRlZFJ0cENhcGFiaWxpdGllcyk7XG5cblx0XHRsZXQgcnRwUGFyYW1ldGVyc0J5S2luZDtcblxuXHRcdHN3aXRjaCAoZGlyZWN0aW9uKVxuXHRcdHtcblx0XHRcdGNhc2UgJ3NlbmQnOlxuXHRcdFx0e1xuXHRcdFx0XHRydHBQYXJhbWV0ZXJzQnlLaW5kID1cblx0XHRcdFx0e1xuXHRcdFx0XHRcdGF1ZGlvIDogb3J0Yy5nZXRTZW5kaW5nUnRwUGFyYW1ldGVycygnYXVkaW8nLCBleHRlbmRlZFJ0cENhcGFiaWxpdGllcyksXG5cdFx0XHRcdFx0dmlkZW8gOiBvcnRjLmdldFNlbmRpbmdSdHBQYXJhbWV0ZXJzKCd2aWRlbycsIGV4dGVuZGVkUnRwQ2FwYWJpbGl0aWVzKVxuXHRcdFx0XHR9O1xuXG5cdFx0XHRcdHJldHVybiBuZXcgU2VuZEhhbmRsZXIocnRwUGFyYW1ldGVyc0J5S2luZCwgc2V0dGluZ3MpO1xuXHRcdFx0fVxuXHRcdFx0Y2FzZSAncmVjdic6XG5cdFx0XHR7XG5cdFx0XHRcdHJ0cFBhcmFtZXRlcnNCeUtpbmQgPVxuXHRcdFx0XHR7XG5cdFx0XHRcdFx0YXVkaW8gOiBvcnRjLmdldFJlY2VpdmluZ0Z1bGxSdHBQYXJhbWV0ZXJzKCdhdWRpbycsIGV4dGVuZGVkUnRwQ2FwYWJpbGl0aWVzKSxcblx0XHRcdFx0XHR2aWRlbyA6IG9ydGMuZ2V0UmVjZWl2aW5nRnVsbFJ0cFBhcmFtZXRlcnMoJ3ZpZGVvJywgZXh0ZW5kZWRSdHBDYXBhYmlsaXRpZXMpXG5cdFx0XHRcdH07XG5cblx0XHRcdFx0cmV0dXJuIG5ldyBSZWN2SGFuZGxlcihydHBQYXJhbWV0ZXJzQnlLaW5kLCBzZXR0aW5ncyk7XG5cdFx0XHR9XG5cdFx0fVxuXHR9XG59XG4iLCIvKiBnbG9iYWwgUlRDSWNlR2F0aGVyZXIsIFJUQ0ljZVRyYW5zcG9ydCwgUlRDRHRsc1RyYW5zcG9ydCwgUlRDUnRwUmVjZWl2ZXIsIFJUQ1J0cFNlbmRlciAqL1xuXG5pbXBvcnQgTG9nZ2VyIGZyb20gJy4uL0xvZ2dlcic7XG5pbXBvcnQgRW5oYW5jZWRFdmVudEVtaXR0ZXIgZnJvbSAnLi4vRW5oYW5jZWRFdmVudEVtaXR0ZXInO1xuaW1wb3J0ICogYXMgdXRpbHMgZnJvbSAnLi4vdXRpbHMnO1xuaW1wb3J0ICogYXMgb3J0YyBmcm9tICcuLi9vcnRjJztcbmltcG9ydCAqIGFzIGVkZ2VVdGlscyBmcm9tICcuL29ydGMvZWRnZVV0aWxzJztcblxuY29uc3QgQ05BTUUgPSBgQ05BTUUtRURHRS0ke3V0aWxzLnJhbmRvbU51bWJlcigpfWA7XG5cbmNvbnN0IGxvZ2dlciA9IG5ldyBMb2dnZXIoJ0VkZ2UxMScpO1xuXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBFZGdlMTEgZXh0ZW5kcyBFbmhhbmNlZEV2ZW50RW1pdHRlclxue1xuXHRzdGF0aWMgZ2V0IHRhZygpXG5cdHtcblx0XHRyZXR1cm4gJ0VkZ2UxMSc7XG5cdH1cblxuXHRzdGF0aWMgZ2V0TmF0aXZlUnRwQ2FwYWJpbGl0aWVzKClcblx0e1xuXHRcdGxvZ2dlci5kZWJ1ZygnZ2V0TmF0aXZlUnRwQ2FwYWJpbGl0aWVzKCknKTtcblxuXHRcdHJldHVybiBlZGdlVXRpbHMuZ2V0Q2FwYWJpbGl0aWVzKCk7XG5cdH1cblxuXHRjb25zdHJ1Y3RvcihkaXJlY3Rpb24sIGV4dGVuZGVkUnRwQ2FwYWJpbGl0aWVzLCBzZXR0aW5ncylcblx0e1xuXHRcdHN1cGVyKGxvZ2dlcik7XG5cblx0XHRsb2dnZXIuZGVidWcoXG5cdFx0XHQnY29uc3RydWN0b3IoKSBbZGlyZWN0aW9uOiVzLCBleHRlbmRlZFJ0cENhcGFiaWxpdGllczolb10nLFxuXHRcdFx0ZGlyZWN0aW9uLCBleHRlbmRlZFJ0cENhcGFiaWxpdGllcyk7XG5cblx0XHQvLyBHZW5lcmljIHNlbmRpbmcgUlRQIHBhcmFtZXRlcnMgZm9yIGF1ZGlvIGFuZCB2aWRlby5cblx0XHQvLyBAdHlwZSB7T2JqZWN0fVxuXHRcdHRoaXMuX3J0cFBhcmFtZXRlcnNCeUtpbmQgPVxuXHRcdHtcblx0XHRcdGF1ZGlvIDogb3J0Yy5nZXRTZW5kaW5nUnRwUGFyYW1ldGVycygnYXVkaW8nLCBleHRlbmRlZFJ0cENhcGFiaWxpdGllcyksXG5cdFx0XHR2aWRlbyA6IG9ydGMuZ2V0U2VuZGluZ1J0cFBhcmFtZXRlcnMoJ3ZpZGVvJywgZXh0ZW5kZWRSdHBDYXBhYmlsaXRpZXMpXG5cdFx0fTtcblxuXHRcdC8vIEdvdCB0cmFuc3BvcnQgbG9jYWwgYW5kIHJlbW90ZSBwYXJhbWV0ZXJzLlxuXHRcdC8vIEB0eXBlIHtCb29sZWFufVxuXHRcdHRoaXMuX3RyYW5zcG9ydFJlYWR5ID0gZmFsc2U7XG5cblx0XHQvLyBJQ0UgZ2F0aGVyZXIuXG5cdFx0dGhpcy5faWNlR2F0aGVyZXIgPSBudWxsO1xuXG5cdFx0Ly8gSUNFIHRyYW5zcG9ydC5cblx0XHR0aGlzLl9pY2VUcmFuc3BvcnQgPSBudWxsO1xuXG5cdFx0Ly8gRFRMUyB0cmFuc3BvcnQuXG5cdFx0Ly8gQHR5cGUge1JUQ0R0bHNUcmFuc3BvcnR9XG5cdFx0dGhpcy5fZHRsc1RyYW5zcG9ydCA9IG51bGw7XG5cblx0XHQvLyBNYXAgb2YgUlRDUnRwU2VuZGVycyBpbmRleGVkIGJ5IFByb2R1Y2VyLmlkLlxuXHRcdC8vIEB0eXBlIHtNYXA8TnVtYmVyLCBSVENSdHBTZW5kZXJ9XG5cdFx0dGhpcy5fcnRwU2VuZGVycyA9IG5ldyBNYXAoKTtcblxuXHRcdC8vIE1hcCBvZiBSVENSdHBSZWNlaXZlcnMgaW5kZXhlZCBieSBDb25zdW1lci5pZC5cblx0XHQvLyBAdHlwZSB7TWFwPE51bWJlciwgUlRDUnRwUmVjZWl2ZXJ9XG5cdFx0dGhpcy5fcnRwUmVjZWl2ZXJzID0gbmV3IE1hcCgpO1xuXG5cdFx0Ly8gUmVtb3RlIFRyYW5zcG9ydCBwYXJhbWV0ZXJzLlxuXHRcdC8vIEB0eXBlIHtPYmplY3R9XG5cdFx0dGhpcy5fdHJhbnNwb3J0UmVtb3RlUGFyYW1ldGVycyA9IG51bGw7XG5cblx0XHR0aGlzLl9zZXRJY2VHYXRoZXJlcihzZXR0aW5ncyk7XG5cdFx0dGhpcy5fc2V0SWNlVHJhbnNwb3J0KCk7XG5cdFx0dGhpcy5fc2V0RHRsc1RyYW5zcG9ydCgpO1xuXHR9XG5cblx0Y2xvc2UoKVxuXHR7XG5cdFx0bG9nZ2VyLmRlYnVnKCdjbG9zZSgpJyk7XG5cblx0XHQvLyBDbG9zZSB0aGUgSUNFIGdhdGhlcmVyLlxuXHRcdC8vIE5PVEU6IE5vdCB5ZXQgaW1wbGVtZW50ZWQgYnkgRWRnZS5cblx0XHR0cnkgeyB0aGlzLl9pY2VHYXRoZXJlci5jbG9zZSgpOyB9XG5cdFx0Y2F0Y2ggKGVycm9yKSB7fVxuXG5cdFx0Ly8gQ2xvc2UgdGhlIElDRSB0cmFuc3BvcnQuXG5cdFx0dHJ5IHsgdGhpcy5faWNlVHJhbnNwb3J0LnN0b3AoKTsgfVxuXHRcdGNhdGNoIChlcnJvcikge31cblxuXHRcdC8vIENsb3NlIHRoZSBEVExTIHRyYW5zcG9ydC5cblx0XHR0cnkgeyB0aGlzLl9kdGxzVHJhbnNwb3J0LnN0b3AoKTsgfVxuXHRcdGNhdGNoIChlcnJvcikge31cblxuXHRcdC8vIENsb3NlIFJUQ1J0cFNlbmRlcnMuXG5cdFx0Zm9yIChjb25zdCBydHBTZW5kZXIgb2YgdGhpcy5fcnRwU2VuZGVycy52YWx1ZXMoKSlcblx0XHR7XG5cdFx0XHR0cnkgeyBydHBTZW5kZXIuc3RvcCgpOyB9XG5cdFx0XHRjYXRjaCAoZXJyb3IpIHt9XG5cdFx0fVxuXG5cdFx0Ly8gQ2xvc2UgUlRDUnRwUmVjZWl2ZXJzLlxuXHRcdGZvciAoY29uc3QgcnRwUmVjZWl2ZXIgb2YgdGhpcy5fcnRwUmVjZWl2ZXJzLnZhbHVlcygpKVxuXHRcdHtcblx0XHRcdHRyeSB7IHJ0cFJlY2VpdmVyLnN0b3AoKTsgfVxuXHRcdFx0Y2F0Y2ggKGVycm9yKSB7fVxuXHRcdH1cblx0fVxuXG5cdGFkZFByb2R1Y2VyKHByb2R1Y2VyKVxuXHR7XG5cdFx0Y29uc3QgeyB0cmFjayB9ID0gcHJvZHVjZXI7XG5cblx0XHRsb2dnZXIuZGVidWcoXG5cdFx0XHQnYWRkUHJvZHVjZXIoKSBbaWQ6JXMsIGtpbmQ6JXMsIHRyYWNrSWQ6JXNdJyxcblx0XHRcdHByb2R1Y2VyLmlkLCBwcm9kdWNlci5raW5kLCB0cmFjay5pZCk7XG5cblx0XHRpZiAodGhpcy5fcnRwU2VuZGVycy5oYXMocHJvZHVjZXIuaWQpKVxuXHRcdFx0cmV0dXJuIFByb21pc2UucmVqZWN0KG5ldyBFcnJvcignUHJvZHVjZXIgYWxyZWFkeSBhZGRlZCcpKTtcblxuXHRcdHJldHVybiBQcm9taXNlLnJlc29sdmUoKVxuXHRcdFx0LnRoZW4oKCkgPT5cblx0XHRcdHtcblx0XHRcdFx0aWYgKCF0aGlzLl90cmFuc3BvcnRSZWFkeSlcblx0XHRcdFx0XHRyZXR1cm4gdGhpcy5fc2V0dXBUcmFuc3BvcnQoKTtcblx0XHRcdH0pXG5cdFx0XHQudGhlbigoKSA9PlxuXHRcdFx0e1xuXHRcdFx0XHRsb2dnZXIuZGVidWcoJ2FkZFByb2R1Y2VyKCkgfCBjYWxsaW5nIG5ldyBSVENSdHBTZW5kZXIoKScpO1xuXG5cdFx0XHRcdGNvbnN0IHJ0cFNlbmRlciA9IG5ldyBSVENSdHBTZW5kZXIodHJhY2ssIHRoaXMuX2R0bHNUcmFuc3BvcnQpO1xuXHRcdFx0XHRjb25zdCBydHBQYXJhbWV0ZXJzID1cblx0XHRcdFx0XHR1dGlscy5jbG9uZSh0aGlzLl9ydHBQYXJhbWV0ZXJzQnlLaW5kW3Byb2R1Y2VyLmtpbmRdKTtcblxuXHRcdFx0XHQvLyBGaWxsIFJUQ1J0cFBhcmFtZXRlcnMuZW5jb2RpbmdzLlxuXHRcdFx0XHRjb25zdCBlbmNvZGluZyA9XG5cdFx0XHRcdHtcblx0XHRcdFx0XHRzc3JjIDogdXRpbHMucmFuZG9tTnVtYmVyKClcblx0XHRcdFx0fTtcblxuXHRcdFx0XHRpZiAocnRwUGFyYW1ldGVycy5jb2RlY3Muc29tZSgoY29kZWMpID0+IGNvZGVjLm5hbWUgPT09ICdydHgnKSlcblx0XHRcdFx0e1xuXHRcdFx0XHRcdGVuY29kaW5nLnJ0eCA9XG5cdFx0XHRcdFx0e1xuXHRcdFx0XHRcdFx0c3NyYyA6IHV0aWxzLnJhbmRvbU51bWJlcigpXG5cdFx0XHRcdFx0fTtcblx0XHRcdFx0fVxuXG5cdFx0XHRcdHJ0cFBhcmFtZXRlcnMuZW5jb2RpbmdzLnB1c2goZW5jb2RpbmcpO1xuXG5cdFx0XHRcdC8vIEZpbGwgUlRDUnRwUGFyYW1ldGVycy5ydGNwLlxuXHRcdFx0XHRydHBQYXJhbWV0ZXJzLnJ0Y3AgPVxuXHRcdFx0XHR7XG5cdFx0XHRcdFx0Y25hbWUgICAgICAgOiBDTkFNRSxcblx0XHRcdFx0XHRyZWR1Y2VkU2l6ZSA6IHRydWUsXG5cdFx0XHRcdFx0bXV4ICAgICAgICAgOiB0cnVlXG5cdFx0XHRcdH07XG5cblx0XHRcdFx0Ly8gTk9URTogQ29udmVydCBvdXIgc3RhbmRhcmQgUlRDUnRwUGFyYW1ldGVycyBpbnRvIHRob3NlIHRoYXQgRWRnZVxuXHRcdFx0XHQvLyBleHBlY3RzLlxuXHRcdFx0XHRjb25zdCBlZGdlUnRwUGFyYW1ldGVycyA9XG5cdFx0XHRcdFx0ZWRnZVV0aWxzLm1hbmdsZVJ0cFBhcmFtZXRlcnMocnRwUGFyYW1ldGVycyk7XG5cblx0XHRcdFx0bG9nZ2VyLmRlYnVnKFxuXHRcdFx0XHRcdCdhZGRQcm9kdWNlcigpIHwgY2FsbGluZyBydHBTZW5kZXIuc2VuZCgpIFtwYXJhbXM6JW9dJyxcblx0XHRcdFx0XHRlZGdlUnRwUGFyYW1ldGVycyk7XG5cblx0XHRcdFx0cnRwU2VuZGVyLnNlbmQoZWRnZVJ0cFBhcmFtZXRlcnMpO1xuXG5cdFx0XHRcdC8vIFN0b3JlIGl0LlxuXHRcdFx0XHR0aGlzLl9ydHBTZW5kZXJzLnNldChwcm9kdWNlci5pZCwgcnRwU2VuZGVyKTtcblxuXHRcdFx0XHRyZXR1cm4gcnRwUGFyYW1ldGVycztcblx0XHRcdH0pO1xuXHR9XG5cblx0cmVtb3ZlUHJvZHVjZXIocHJvZHVjZXIpXG5cdHtcblx0XHRjb25zdCB7IHRyYWNrIH0gPSBwcm9kdWNlcjtcblxuXHRcdGxvZ2dlci5kZWJ1Zyhcblx0XHRcdCdyZW1vdmVQcm9kdWNlcigpIFtpZDolcywga2luZDolcywgdHJhY2tJZDolc10nLFxuXHRcdFx0cHJvZHVjZXIuaWQsIHByb2R1Y2VyLmtpbmQsIHRyYWNrLmlkKTtcblxuXHRcdHJldHVybiBQcm9taXNlLnJlc29sdmUoKVxuXHRcdFx0LnRoZW4oKCkgPT5cblx0XHRcdHtcblx0XHRcdFx0Y29uc3QgcnRwU2VuZGVyID0gdGhpcy5fcnRwU2VuZGVycy5nZXQocHJvZHVjZXIuaWQpO1xuXG5cdFx0XHRcdGlmICghcnRwU2VuZGVyKVxuXHRcdFx0XHRcdHRocm93IG5ldyBFcnJvcignUlRDUnRwU2VuZGVyIG5vdCBmb3VuZCcpO1xuXG5cdFx0XHRcdHRoaXMuX3J0cFNlbmRlcnMuZGVsZXRlKHByb2R1Y2VyLmlkKTtcblxuXHRcdFx0XHR0cnlcblx0XHRcdFx0e1xuXHRcdFx0XHRcdGxvZ2dlci5kZWJ1ZygncmVtb3ZlUHJvZHVjZXIoKSB8IGNhbGxpbmcgcnRwU2VuZGVyLnN0b3AoKScpO1xuXG5cdFx0XHRcdFx0cnRwU2VuZGVyLnN0b3AoKTtcblx0XHRcdFx0fVxuXHRcdFx0XHRjYXRjaCAoZXJyb3IpXG5cdFx0XHRcdHtcblx0XHRcdFx0XHRsb2dnZXIud2FybigncnRwU2VuZGVyLnN0b3AoKSBmYWlsZWQ6JW8nLCBlcnJvcik7XG5cdFx0XHRcdH1cblx0XHRcdH0pO1xuXHR9XG5cblx0cmVwbGFjZVByb2R1Y2VyVHJhY2socHJvZHVjZXIsIHRyYWNrKVxuXHR7XG5cdFx0bG9nZ2VyLmRlYnVnKFxuXHRcdFx0J3JlcGxhY2VQcm9kdWNlclRyYWNrKCkgW2lkOiVzLCBraW5kOiVzLCB0cmFja0lkOiVzXScsXG5cdFx0XHRwcm9kdWNlci5pZCwgcHJvZHVjZXIua2luZCwgdHJhY2suaWQpO1xuXG5cdFx0cmV0dXJuIFByb21pc2UucmVzb2x2ZSgpXG5cdFx0XHQudGhlbigoKSA9PlxuXHRcdFx0e1xuXHRcdFx0XHRjb25zdCBydHBTZW5kZXIgPSB0aGlzLl9ydHBTZW5kZXJzLmdldChwcm9kdWNlci5pZCk7XG5cblx0XHRcdFx0aWYgKCFydHBTZW5kZXIpXG5cdFx0XHRcdFx0dGhyb3cgbmV3IEVycm9yKCdSVENSdHBTZW5kZXIgbm90IGZvdW5kJyk7XG5cblx0XHRcdFx0cnRwU2VuZGVyLnNldFRyYWNrKHRyYWNrKTtcblx0XHRcdH0pO1xuXHR9XG5cblx0YWRkQ29uc3VtZXIoY29uc3VtZXIpXG5cdHtcblx0XHRsb2dnZXIuZGVidWcoXG5cdFx0XHQnYWRkQ29uc3VtZXIoKSBbaWQ6JXMsIGtpbmQ6JXNdJywgY29uc3VtZXIuaWQsIGNvbnN1bWVyLmtpbmQpO1xuXG5cdFx0aWYgKHRoaXMuX3J0cFJlY2VpdmVycy5oYXMoY29uc3VtZXIuaWQpKVxuXHRcdFx0cmV0dXJuIFByb21pc2UucmVqZWN0KG5ldyBFcnJvcignQ29uc3VtZXIgYWxyZWFkeSBhZGRlZCcpKTtcblxuXHRcdHJldHVybiBQcm9taXNlLnJlc29sdmUoKVxuXHRcdFx0LnRoZW4oKCkgPT5cblx0XHRcdHtcblx0XHRcdFx0aWYgKCF0aGlzLl90cmFuc3BvcnRSZWFkeSlcblx0XHRcdFx0XHRyZXR1cm4gdGhpcy5fc2V0dXBUcmFuc3BvcnQoKTtcblx0XHRcdH0pXG5cdFx0XHQudGhlbigoKSA9PlxuXHRcdFx0e1xuXHRcdFx0XHRsb2dnZXIuZGVidWcoJ2FkZFByb2R1Y2VyKCkgfCBjYWxsaW5nIG5ldyBSVENSdHBSZWNlaXZlcigpJyk7XG5cblx0XHRcdFx0Y29uc3QgcnRwUmVjZWl2ZXIgPVxuXHRcdFx0XHRcdG5ldyBSVENSdHBSZWNlaXZlcih0aGlzLl9kdGxzVHJhbnNwb3J0LCBjb25zdW1lci5raW5kKTtcblxuXHRcdFx0XHRydHBSZWNlaXZlci5hZGRFdmVudExpc3RlbmVyKCdlcnJvcicsIChldmVudCkgPT5cblx0XHRcdFx0e1xuXHRcdFx0XHRcdGxvZ2dlci5lcnJvcignaWNlR2F0aGVyZXIgXCJlcnJvclwiIGV2ZW50IFtldmVudDolb10nLCBldmVudCk7XG5cdFx0XHRcdH0pO1xuXG5cdFx0XHRcdC8vIE5PVEU6IENvbnZlcnQgb3VyIHN0YW5kYXJkIFJUQ1J0cFBhcmFtZXRlcnMgaW50byB0aG9zZSB0aGF0IEVkZ2Vcblx0XHRcdFx0Ly8gZXhwZWN0cy5cblx0XHRcdFx0Y29uc3QgZWRnZVJ0cFBhcmFtZXRlcnMgPVxuXHRcdFx0XHRcdGVkZ2VVdGlscy5tYW5nbGVSdHBQYXJhbWV0ZXJzKGNvbnN1bWVyLnJ0cFBhcmFtZXRlcnMpO1xuXG5cdFx0XHRcdGxvZ2dlci5kZWJ1Zyhcblx0XHRcdFx0XHQnYWRkUHJvZHVjZXIoKSB8IGNhbGxpbmcgcnRwUmVjZWl2ZXIucmVjZWl2ZSgpIFtwYXJhbXM6JW9dJyxcblx0XHRcdFx0XHRlZGdlUnRwUGFyYW1ldGVycyk7XG5cblx0XHRcdFx0cnRwUmVjZWl2ZXIucmVjZWl2ZShlZGdlUnRwUGFyYW1ldGVycyk7XG5cblx0XHRcdFx0Ly8gU3RvcmUgaXQuXG5cdFx0XHRcdHRoaXMuX3J0cFJlY2VpdmVycy5zZXQoY29uc3VtZXIuaWQsIHJ0cFJlY2VpdmVyKTtcblxuXHRcdFx0XHRyZXR1cm4gcnRwUmVjZWl2ZXIudHJhY2s7XG5cdFx0XHR9KTtcblx0fVxuXG5cdHJlbW92ZUNvbnN1bWVyKGNvbnN1bWVyKVxuXHR7XG5cdFx0bG9nZ2VyLmRlYnVnKFxuXHRcdFx0J3JlbW92ZUNvbnN1bWVyKCkgW2lkOiVzLCBraW5kOiVzXScsIGNvbnN1bWVyLmlkLCBjb25zdW1lci5raW5kKTtcblxuXHRcdHJldHVybiBQcm9taXNlLnJlc29sdmUoKVxuXHRcdFx0LnRoZW4oKCkgPT5cblx0XHRcdHtcblx0XHRcdFx0Y29uc3QgcnRwUmVjZWl2ZXIgPSB0aGlzLl9ydHBSZWNlaXZlcnMuZ2V0KGNvbnN1bWVyLmlkKTtcblxuXHRcdFx0XHRpZiAoIXJ0cFJlY2VpdmVyKVxuXHRcdFx0XHRcdHRocm93IG5ldyBFcnJvcignUlRDUnRwUmVjZWl2ZXIgbm90IGZvdW5kJyk7XG5cblx0XHRcdFx0dGhpcy5fcnRwUmVjZWl2ZXJzLmRlbGV0ZShjb25zdW1lci5pZCk7XG5cblx0XHRcdFx0dHJ5XG5cdFx0XHRcdHtcblx0XHRcdFx0XHRsb2dnZXIuZGVidWcoJ3JlbW92ZUNvbnN1bWVyKCkgfCBjYWxsaW5nIHJ0cFJlY2VpdmVyLnN0b3AoKScpO1xuXG5cdFx0XHRcdFx0cnRwUmVjZWl2ZXIuc3RvcCgpO1xuXHRcdFx0XHR9XG5cdFx0XHRcdGNhdGNoIChlcnJvcilcblx0XHRcdFx0e1xuXHRcdFx0XHRcdGxvZ2dlci53YXJuKCdydHBSZWNlaXZlci5zdG9wKCkgZmFpbGVkOiVvJywgZXJyb3IpO1xuXHRcdFx0XHR9XG5cdFx0XHR9KTtcblx0fVxuXG5cdHJlc3RhcnRJY2UocmVtb3RlSWNlUGFyYW1ldGVycylcblx0e1xuXHRcdGxvZ2dlci5kZWJ1ZygncmVzdGFydEljZSgpJyk7XG5cblx0XHRQcm9taXNlLnJlc29sdmUoKVxuXHRcdFx0LnRoZW4oKCkgPT5cblx0XHRcdHtcblx0XHRcdFx0dGhpcy5fdHJhbnNwb3J0UmVtb3RlUGFyYW1ldGVycy5pY2VQYXJhbWV0ZXJzID0gcmVtb3RlSWNlUGFyYW1ldGVycztcblxuXHRcdFx0XHRjb25zdCByZW1vdGVJY2VDYW5kaWRhdGVzID0gdGhpcy5fdHJhbnNwb3J0UmVtb3RlUGFyYW1ldGVycy5pY2VDYW5kaWRhdGVzO1xuXG5cdFx0XHRcdGxvZ2dlci5kZWJ1ZygncmVzdGFydEljZSgpIHwgY2FsbGluZyBpY2VUcmFuc3BvcnQuc3RhcnQoKScpO1xuXG5cdFx0XHRcdHRoaXMuX2ljZVRyYW5zcG9ydC5zdGFydChcblx0XHRcdFx0XHR0aGlzLl9pY2VHYXRoZXJlciwgcmVtb3RlSWNlUGFyYW1ldGVycywgJ2NvbnRyb2xsaW5nJyk7XG5cblx0XHRcdFx0Zm9yIChjb25zdCBjYW5kaWRhdGUgb2YgcmVtb3RlSWNlQ2FuZGlkYXRlcylcblx0XHRcdFx0e1xuXHRcdFx0XHRcdHRoaXMuX2ljZVRyYW5zcG9ydC5hZGRSZW1vdGVDYW5kaWRhdGUoY2FuZGlkYXRlKTtcblx0XHRcdFx0fVxuXG5cdFx0XHRcdHRoaXMuX2ljZVRyYW5zcG9ydC5hZGRSZW1vdGVDYW5kaWRhdGUoe30pO1xuXHRcdFx0fSk7XG5cdH1cblxuXHRfc2V0SWNlR2F0aGVyZXIoc2V0dGluZ3MpXG5cdHtcblx0XHRjb25zdCBpY2VHYXRoZXJlciA9IG5ldyBSVENJY2VHYXRoZXJlcihcblx0XHRcdHtcblx0XHRcdFx0aWNlU2VydmVycyAgIDogc2V0dGluZ3MudHVyblNlcnZlcnMgfHwgW10sXG5cdFx0XHRcdGdhdGhlclBvbGljeSA6ICdhbGwnXG5cdFx0XHR9KTtcblxuXHRcdGljZUdhdGhlcmVyLmFkZEV2ZW50TGlzdGVuZXIoJ2Vycm9yJywgKGV2ZW50KSA9PlxuXHRcdHtcblx0XHRcdGxvZ2dlci5lcnJvcignaWNlR2F0aGVyZXIgXCJlcnJvclwiIGV2ZW50IFtldmVudDolb10nLCBldmVudCk7XG5cdFx0fSk7XG5cblx0XHQvLyBOT1RFOiBOb3QgeWV0IGltcGxlbWVudGVkIGJ5IEVkZ2UsIHdoaWNoIHN0YXJ0cyBnYXRoZXJpbmcgYXV0b21hdGljYWxseS5cblx0XHR0cnlcblx0XHR7XG5cdFx0XHRpY2VHYXRoZXJlci5nYXRoZXIoKTtcblx0XHR9XG5cdFx0Y2F0Y2ggKGVycm9yKVxuXHRcdHtcblx0XHRcdGxvZ2dlci5kZWJ1ZygnaWNlR2F0aGVyZXIuZ2F0aGVyKCkgZmFpbGVkOiAlcycsIGVycm9yLnRvU3RyaW5nKCkpO1xuXHRcdH1cblxuXHRcdHRoaXMuX2ljZUdhdGhlcmVyID0gaWNlR2F0aGVyZXI7XG5cdH1cblxuXHRfc2V0SWNlVHJhbnNwb3J0KClcblx0e1xuXHRcdGNvbnN0IGljZVRyYW5zcG9ydCA9IG5ldyBSVENJY2VUcmFuc3BvcnQodGhpcy5faWNlR2F0aGVyZXIpO1xuXG5cdFx0Ly8gTk9URTogTm90IHlldCBpbXBsZW1lbnRlZCBieSBFZGdlLlxuXHRcdGljZVRyYW5zcG9ydC5hZGRFdmVudExpc3RlbmVyKCdzdGF0ZWNoYW5nZScsICgpID0+XG5cdFx0e1xuXHRcdFx0c3dpdGNoIChpY2VUcmFuc3BvcnQuc3RhdGUpXG5cdFx0XHR7XG5cdFx0XHRcdGNhc2UgJ2NoZWNraW5nJzpcblx0XHRcdFx0XHR0aGlzLmVtaXQoJ0Bjb25uZWN0aW9uc3RhdGVjaGFuZ2UnLCAnY29ubmVjdGluZycpO1xuXHRcdFx0XHRcdGJyZWFrO1xuXHRcdFx0XHRjYXNlICdjb25uZWN0ZWQnOlxuXHRcdFx0XHRjYXNlICdjb21wbGV0ZWQnOlxuXHRcdFx0XHRcdHRoaXMuZW1pdCgnQGNvbm5lY3Rpb25zdGF0ZWNoYW5nZScsICdjb25uZWN0ZWQnKTtcblx0XHRcdFx0XHRicmVhaztcblx0XHRcdFx0Y2FzZSAnZmFpbGVkJzpcblx0XHRcdFx0XHR0aGlzLmVtaXQoJ0Bjb25uZWN0aW9uc3RhdGVjaGFuZ2UnLCAnZmFpbGVkJyk7XG5cdFx0XHRcdFx0YnJlYWs7XG5cdFx0XHRcdGNhc2UgJ2Rpc2Nvbm5lY3RlZCc6XG5cdFx0XHRcdFx0dGhpcy5lbWl0KCdAY29ubmVjdGlvbnN0YXRlY2hhbmdlJywgJ2Rpc2Nvbm5lY3RlZCcpO1xuXHRcdFx0XHRcdGJyZWFrO1xuXHRcdFx0XHRjYXNlICdjbG9zZWQnOlxuXHRcdFx0XHRcdHRoaXMuZW1pdCgnQGNvbm5lY3Rpb25zdGF0ZWNoYW5nZScsICdjbG9zZWQnKTtcblx0XHRcdFx0XHRicmVhaztcblx0XHRcdH1cblx0XHR9KTtcblxuXHRcdC8vIE5PVEU6IE5vdCBzdGFuZGFyZCwgYnV0IGltcGxlbWVudGVkIGJ5IEVkZ2UuXG5cdFx0aWNlVHJhbnNwb3J0LmFkZEV2ZW50TGlzdGVuZXIoJ2ljZXN0YXRlY2hhbmdlJywgKCkgPT5cblx0XHR7XG5cdFx0XHRzd2l0Y2ggKGljZVRyYW5zcG9ydC5zdGF0ZSlcblx0XHRcdHtcblx0XHRcdFx0Y2FzZSAnY2hlY2tpbmcnOlxuXHRcdFx0XHRcdHRoaXMuZW1pdCgnQGNvbm5lY3Rpb25zdGF0ZWNoYW5nZScsICdjb25uZWN0aW5nJyk7XG5cdFx0XHRcdFx0YnJlYWs7XG5cdFx0XHRcdGNhc2UgJ2Nvbm5lY3RlZCc6XG5cdFx0XHRcdGNhc2UgJ2NvbXBsZXRlZCc6XG5cdFx0XHRcdFx0dGhpcy5lbWl0KCdAY29ubmVjdGlvbnN0YXRlY2hhbmdlJywgJ2Nvbm5lY3RlZCcpO1xuXHRcdFx0XHRcdGJyZWFrO1xuXHRcdFx0XHRjYXNlICdmYWlsZWQnOlxuXHRcdFx0XHRcdHRoaXMuZW1pdCgnQGNvbm5lY3Rpb25zdGF0ZWNoYW5nZScsICdmYWlsZWQnKTtcblx0XHRcdFx0XHRicmVhaztcblx0XHRcdFx0Y2FzZSAnZGlzY29ubmVjdGVkJzpcblx0XHRcdFx0XHR0aGlzLmVtaXQoJ0Bjb25uZWN0aW9uc3RhdGVjaGFuZ2UnLCAnZGlzY29ubmVjdGVkJyk7XG5cdFx0XHRcdFx0YnJlYWs7XG5cdFx0XHRcdGNhc2UgJ2Nsb3NlZCc6XG5cdFx0XHRcdFx0dGhpcy5lbWl0KCdAY29ubmVjdGlvbnN0YXRlY2hhbmdlJywgJ2Nsb3NlZCcpO1xuXHRcdFx0XHRcdGJyZWFrO1xuXHRcdFx0fVxuXHRcdH0pO1xuXG5cdFx0aWNlVHJhbnNwb3J0LmFkZEV2ZW50TGlzdGVuZXIoJ2NhbmRpZGF0ZXBhaXJjaGFuZ2UnLCAoZXZlbnQpID0+XG5cdFx0e1xuXHRcdFx0bG9nZ2VyLmRlYnVnKFxuXHRcdFx0XHQnaWNlVHJhbnNwb3J0IFwiY2FuZGlkYXRlcGFpcmNoYW5nZVwiIGV2ZW50IFtwYWlyOiVvXScsIGV2ZW50LnBhaXIpO1xuXHRcdH0pO1xuXG5cdFx0dGhpcy5faWNlVHJhbnNwb3J0ID0gaWNlVHJhbnNwb3J0O1xuXHR9XG5cblx0X3NldER0bHNUcmFuc3BvcnQoKVxuXHR7XG5cdFx0Y29uc3QgZHRsc1RyYW5zcG9ydCA9IG5ldyBSVENEdGxzVHJhbnNwb3J0KHRoaXMuX2ljZVRyYW5zcG9ydCk7XG5cblx0XHQvLyBOT1RFOiBOb3QgeWV0IGltcGxlbWVudGVkIGJ5IEVkZ2UuXG5cdFx0ZHRsc1RyYW5zcG9ydC5hZGRFdmVudExpc3RlbmVyKCdzdGF0ZWNoYW5nZScsICgpID0+XG5cdFx0e1xuXHRcdFx0bG9nZ2VyLmRlYnVnKFxuXHRcdFx0XHQnZHRsc1RyYW5zcG9ydCBcInN0YXRlY2hhbmdlXCIgZXZlbnQgW3N0YXRlOiVzXScsIGR0bHNUcmFuc3BvcnQuc3RhdGUpO1xuXHRcdH0pO1xuXG5cdFx0Ly8gTk9URTogTm90IHN0YW5kYXJkLCBidXQgaW1wbGVtZW50ZWQgYnkgRWRnZS5cblx0XHRkdGxzVHJhbnNwb3J0LmFkZEV2ZW50TGlzdGVuZXIoJ2R0bHNzdGF0ZWNoYW5nZScsICgpID0+XG5cdFx0e1xuXHRcdFx0bG9nZ2VyLmRlYnVnKFxuXHRcdFx0XHQnZHRsc1RyYW5zcG9ydCBcImR0bHNzdGF0ZWNoYW5nZVwiIGV2ZW50IFtzdGF0ZTolc10nLCBkdGxzVHJhbnNwb3J0LnN0YXRlKTtcblx0XHR9KTtcblxuXHRcdGR0bHNUcmFuc3BvcnQuYWRkRXZlbnRMaXN0ZW5lcignZXJyb3InLCAoZXZlbnQpID0+XG5cdFx0e1xuXHRcdFx0bG9nZ2VyLmVycm9yKCdkdGxzVHJhbnNwb3J0IFwiZXJyb3JcIiBldmVudCBbZXZlbnQ6JW9dJywgZXZlbnQpO1xuXHRcdH0pO1xuXG5cdFx0dGhpcy5fZHRsc1RyYW5zcG9ydCA9IGR0bHNUcmFuc3BvcnQ7XG5cdH1cblxuXHRfc2V0dXBUcmFuc3BvcnQoKVxuXHR7XG5cdFx0bG9nZ2VyLmRlYnVnKCdfc2V0dXBUcmFuc3BvcnQoKScpO1xuXG5cdFx0cmV0dXJuIFByb21pc2UucmVzb2x2ZSgpXG5cdFx0XHQudGhlbigoKSA9PlxuXHRcdFx0e1xuXHRcdFx0XHQvLyBHZXQgb3VyIGxvY2FsIERUTFMgcGFyYW1ldGVycy5cblx0XHRcdFx0Y29uc3QgdHJhbnNwb3J0TG9jYWxQYXJhbWV0ZXJzID0ge307XG5cdFx0XHRcdGNvbnN0IGR0bHNQYXJhbWV0ZXJzID0gdGhpcy5fZHRsc1RyYW5zcG9ydC5nZXRMb2NhbFBhcmFtZXRlcnMoKTtcblxuXHRcdFx0XHQvLyBMZXQncyBkZWNpZGUgdGhhdCB3ZSdsbCBiZSBEVExTIHNlcnZlciAoYmVjYXVzZSB3ZSBjYW4pLlxuXHRcdFx0XHRkdGxzUGFyYW1ldGVycy5yb2xlID0gJ3NlcnZlcic7XG5cblx0XHRcdFx0dHJhbnNwb3J0TG9jYWxQYXJhbWV0ZXJzLmR0bHNQYXJhbWV0ZXJzID0gZHRsc1BhcmFtZXRlcnM7XG5cblx0XHRcdFx0Ly8gV2UgbmVlZCB0cmFuc3BvcnQgcmVtb3RlIHBhcmFtZXRlcnMuXG5cdFx0XHRcdHJldHVybiB0aGlzLnNhZmVFbWl0QXNQcm9taXNlKFxuXHRcdFx0XHRcdCdAbmVlZGNyZWF0ZXRyYW5zcG9ydCcsIHRyYW5zcG9ydExvY2FsUGFyYW1ldGVycyk7XG5cdFx0XHR9KVxuXHRcdFx0LnRoZW4oKHRyYW5zcG9ydFJlbW90ZVBhcmFtZXRlcnMpID0+XG5cdFx0XHR7XG5cdFx0XHRcdHRoaXMuX3RyYW5zcG9ydFJlbW90ZVBhcmFtZXRlcnMgPSB0cmFuc3BvcnRSZW1vdGVQYXJhbWV0ZXJzO1xuXG5cdFx0XHRcdGNvbnN0IHJlbW90ZUljZVBhcmFtZXRlcnMgPSB0cmFuc3BvcnRSZW1vdGVQYXJhbWV0ZXJzLmljZVBhcmFtZXRlcnM7XG5cdFx0XHRcdGNvbnN0IHJlbW90ZUljZUNhbmRpZGF0ZXMgPSB0cmFuc3BvcnRSZW1vdGVQYXJhbWV0ZXJzLmljZUNhbmRpZGF0ZXM7XG5cdFx0XHRcdGNvbnN0IHJlbW90ZUR0bHNQYXJhbWV0ZXJzID0gdHJhbnNwb3J0UmVtb3RlUGFyYW1ldGVycy5kdGxzUGFyYW1ldGVycztcblxuXHRcdFx0XHQvLyBTdGFydCB0aGUgUlRDSWNlVHJhbnNwb3J0LlxuXHRcdFx0XHR0aGlzLl9pY2VUcmFuc3BvcnQuc3RhcnQoXG5cdFx0XHRcdFx0dGhpcy5faWNlR2F0aGVyZXIsIHJlbW90ZUljZVBhcmFtZXRlcnMsICdjb250cm9sbGluZycpO1xuXG5cdFx0XHRcdC8vIEFkZCByZW1vdGUgSUNFIGNhbmRpZGF0ZXMuXG5cdFx0XHRcdGZvciAoY29uc3QgY2FuZGlkYXRlIG9mIHJlbW90ZUljZUNhbmRpZGF0ZXMpXG5cdFx0XHRcdHtcblx0XHRcdFx0XHR0aGlzLl9pY2VUcmFuc3BvcnQuYWRkUmVtb3RlQ2FuZGlkYXRlKGNhbmRpZGF0ZSk7XG5cdFx0XHRcdH1cblxuXHRcdFx0XHQvLyBBbHNvIHNpZ25hbCBhICdjb21wbGV0ZScgY2FuZGlkYXRlIGFzIHBlciBzcGVjLlxuXHRcdFx0XHQvLyBOT1RFOiBJdCBzaG91bGQgYmUge2NvbXBsZXRlOiB0cnVlfSBidXQgRWRnZSBwcmVmZXJzIHt9LlxuXHRcdFx0XHQvLyBOT1RFOiBJZiB3ZSBkb24ndCBzaWduYWwgZW5kIG9mIGNhbmRpZGF0ZXMsIHRoZSBFZGdlIFJUQ0ljZVRyYW5zcG9ydFxuXHRcdFx0XHQvLyB3b24ndCBlbnRlciB0aGUgJ2NvbXBsZXRlZCcgc3RhdGUuXG5cdFx0XHRcdHRoaXMuX2ljZVRyYW5zcG9ydC5hZGRSZW1vdGVDYW5kaWRhdGUoe30pO1xuXG5cdFx0XHRcdC8vIE5PVEU6IEVkZ2UgZG9lcyBub3QgbGlrZSBTSEEgbGVzcyB0aGFuIDI1Ni5cblx0XHRcdFx0cmVtb3RlRHRsc1BhcmFtZXRlcnMuZmluZ2VycHJpbnRzID0gcmVtb3RlRHRsc1BhcmFtZXRlcnMuZmluZ2VycHJpbnRzLlxuXHRcdFx0XHRcdGZpbHRlcigoZmluZ2VycHJpbnQpID0+XG5cdFx0XHRcdFx0e1xuXHRcdFx0XHRcdFx0cmV0dXJuIChcblx0XHRcdFx0XHRcdFx0ZmluZ2VycHJpbnQuYWxnb3JpdGhtID09PSAnc2hhLTI1NicgfHxcblx0XHRcdFx0XHRcdFx0ZmluZ2VycHJpbnQuYWxnb3JpdGhtID09PSAnc2hhLTM4NCcgfHxcblx0XHRcdFx0XHRcdFx0ZmluZ2VycHJpbnQuYWxnb3JpdGhtID09PSAnc2hhLTUxMidcblx0XHRcdFx0XHRcdCk7XG5cdFx0XHRcdFx0fSk7XG5cblx0XHRcdFx0Ly8gU3RhcnQgdGhlIFJUQ0R0bHNUcmFuc3BvcnQuXG5cdFx0XHRcdHRoaXMuX2R0bHNUcmFuc3BvcnQuc3RhcnQocmVtb3RlRHRsc1BhcmFtZXRlcnMpO1xuXG5cdFx0XHRcdHRoaXMuX3RyYW5zcG9ydFJlYWR5ID0gdHJ1ZTtcblx0XHRcdH0pO1xuXHR9XG59XG4iLCJpbXBvcnQgc2RwVHJhbnNmb3JtIGZyb20gJ3NkcC10cmFuc2Zvcm0nO1xuaW1wb3J0IExvZ2dlciBmcm9tICcuLi9Mb2dnZXInO1xuaW1wb3J0IEVuaGFuY2VkRXZlbnRFbWl0dGVyIGZyb20gJy4uL0VuaGFuY2VkRXZlbnRFbWl0dGVyJztcbmltcG9ydCAqIGFzIHV0aWxzIGZyb20gJy4uL3V0aWxzJztcbmltcG9ydCAqIGFzIG9ydGMgZnJvbSAnLi4vb3J0Yyc7XG5pbXBvcnQgKiBhcyBzZHBDb21tb25VdGlscyBmcm9tICcuL3NkcC9jb21tb25VdGlscyc7XG5pbXBvcnQgKiBhcyBzZHBVbmlmaWVkUGxhblV0aWxzIGZyb20gJy4vc2RwL3VuaWZpZWRQbGFuVXRpbHMnO1xuaW1wb3J0IFJlbW90ZVVuaWZpZWRQbGFuU2RwIGZyb20gJy4vc2RwL1JlbW90ZVVuaWZpZWRQbGFuU2RwJztcblxuY29uc3QgbG9nZ2VyID0gbmV3IExvZ2dlcignRmlyZWZveDUwJyk7XG5cbmNsYXNzIEhhbmRsZXIgZXh0ZW5kcyBFbmhhbmNlZEV2ZW50RW1pdHRlclxue1xuXHRjb25zdHJ1Y3RvcihkaXJlY3Rpb24sIHJ0cFBhcmFtZXRlcnNCeUtpbmQsIHNldHRpbmdzKVxuXHR7XG5cdFx0c3VwZXIobG9nZ2VyKTtcblxuXHRcdC8vIFJUQ1BlZXJDb25uZWN0aW9uIGluc3RhbmNlLlxuXHRcdC8vIEB0eXBlIHtSVENQZWVyQ29ubmVjdGlvbn1cblx0XHR0aGlzLl9wYyA9IG5ldyBSVENQZWVyQ29ubmVjdGlvbihcblx0XHRcdHtcblx0XHRcdFx0aWNlU2VydmVycyAgICAgICAgIDogc2V0dGluZ3MudHVyblNlcnZlcnMgfHwgW10sXG5cdFx0XHRcdGljZVRyYW5zcG9ydFBvbGljeSA6ICdhbGwnLFxuXHRcdFx0XHRidW5kbGVQb2xpY3kgICAgICAgOiAnbWF4LWJ1bmRsZScsXG5cdFx0XHRcdHJ0Y3BNdXhQb2xpY3kgICAgICA6ICdyZXF1aXJlJ1xuXHRcdFx0fSk7XG5cblx0XHQvLyBHZW5lcmljIHNlbmRpbmcgUlRQIHBhcmFtZXRlcnMgZm9yIGF1ZGlvIGFuZCB2aWRlby5cblx0XHQvLyBAdHlwZSB7T2JqZWN0fVxuXHRcdHRoaXMuX3J0cFBhcmFtZXRlcnNCeUtpbmQgPSBydHBQYXJhbWV0ZXJzQnlLaW5kO1xuXG5cdFx0Ly8gUmVtb3RlIFNEUCBoYW5kbGVyLlxuXHRcdC8vIEB0eXBlIHtSZW1vdGVVbmlmaWVkUGxhblNkcH1cblx0XHR0aGlzLl9yZW1vdGVTZHAgPSBuZXcgUmVtb3RlVW5pZmllZFBsYW5TZHAoZGlyZWN0aW9uLCBydHBQYXJhbWV0ZXJzQnlLaW5kKTtcblxuXHRcdC8vIEhhbmRsZSBSVENQZWVyQ29ubmVjdGlvbiBjb25uZWN0aW9uIHN0YXR1cy5cblx0XHR0aGlzLl9wYy5hZGRFdmVudExpc3RlbmVyKCdpY2Vjb25uZWN0aW9uc3RhdGVjaGFuZ2UnLCAoKSA9PlxuXHRcdHtcblx0XHRcdHN3aXRjaCAodGhpcy5fcGMuaWNlQ29ubmVjdGlvblN0YXRlKVxuXHRcdFx0e1xuXHRcdFx0XHRjYXNlICdjaGVja2luZyc6XG5cdFx0XHRcdFx0dGhpcy5lbWl0KCdAY29ubmVjdGlvbnN0YXRlY2hhbmdlJywgJ2Nvbm5lY3RpbmcnKTtcblx0XHRcdFx0XHRicmVhaztcblx0XHRcdFx0Y2FzZSAnY29ubmVjdGVkJzpcblx0XHRcdFx0Y2FzZSAnY29tcGxldGVkJzpcblx0XHRcdFx0XHR0aGlzLmVtaXQoJ0Bjb25uZWN0aW9uc3RhdGVjaGFuZ2UnLCAnY29ubmVjdGVkJyk7XG5cdFx0XHRcdFx0YnJlYWs7XG5cdFx0XHRcdGNhc2UgJ2ZhaWxlZCc6XG5cdFx0XHRcdFx0dGhpcy5lbWl0KCdAY29ubmVjdGlvbnN0YXRlY2hhbmdlJywgJ2ZhaWxlZCcpO1xuXHRcdFx0XHRcdGJyZWFrO1xuXHRcdFx0XHRjYXNlICdkaXNjb25uZWN0ZWQnOlxuXHRcdFx0XHRcdHRoaXMuZW1pdCgnQGNvbm5lY3Rpb25zdGF0ZWNoYW5nZScsICdkaXNjb25uZWN0ZWQnKTtcblx0XHRcdFx0XHRicmVhaztcblx0XHRcdFx0Y2FzZSAnY2xvc2VkJzpcblx0XHRcdFx0XHR0aGlzLmVtaXQoJ0Bjb25uZWN0aW9uc3RhdGVjaGFuZ2UnLCAnY2xvc2VkJyk7XG5cdFx0XHRcdFx0YnJlYWs7XG5cdFx0XHR9XG5cdFx0fSk7XG5cdH1cblxuXHRjbG9zZSgpXG5cdHtcblx0XHRsb2dnZXIuZGVidWcoJ2Nsb3NlKCknKTtcblxuXHRcdC8vIENsb3NlIFJUQ1BlZXJDb25uZWN0aW9uLlxuXHRcdHRyeSB7IHRoaXMuX3BjLmNsb3NlKCk7IH1cblx0XHRjYXRjaCAoZXJyb3IpIHt9XG5cdH1cbn1cblxuY2xhc3MgU2VuZEhhbmRsZXIgZXh0ZW5kcyBIYW5kbGVyXG57XG5cdGNvbnN0cnVjdG9yKHJ0cFBhcmFtZXRlcnNCeUtpbmQsIHNldHRpbmdzKVxuXHR7XG5cdFx0c3VwZXIoJ3NlbmQnLCBydHBQYXJhbWV0ZXJzQnlLaW5kLCBzZXR0aW5ncyk7XG5cblx0XHQvLyBHb3QgdHJhbnNwb3J0IGxvY2FsIGFuZCByZW1vdGUgcGFyYW1ldGVycy5cblx0XHQvLyBAdHlwZSB7Qm9vbGVhbn1cblx0XHR0aGlzLl90cmFuc3BvcnRSZWFkeSA9IGZhbHNlO1xuXG5cdFx0Ly8gTG9jYWwgc3RyZWFtLlxuXHRcdC8vIEB0eXBlIHtNZWRpYVN0cmVhbX1cblx0XHR0aGlzLl9zdHJlYW0gPSBuZXcgTWVkaWFTdHJlYW0oKTtcblxuXHRcdC8vIFJJRCB2YWx1ZSBjb3VudGVyIGZvciBzaW11bGNhc3QgKHNvIHRoZXkgbmV2ZXIgbWF0Y2gpLlxuXHRcdC8vIEB0eXBlIHtOdW1iZXJ9XG5cdFx0dGhpcy5fbmV4dFJpZCA9IDE7XG5cdH1cblxuXHRhZGRQcm9kdWNlcihwcm9kdWNlcilcblx0e1xuXHRcdGNvbnN0IHsgdHJhY2sgfSA9IHByb2R1Y2VyO1xuXG5cdFx0bG9nZ2VyLmRlYnVnKFxuXHRcdFx0J2FkZFByb2R1Y2VyKCkgW2lkOiVzLCBraW5kOiVzLCB0cmFja0lkOiVzXScsXG5cdFx0XHRwcm9kdWNlci5pZCwgcHJvZHVjZXIua2luZCwgdHJhY2suaWQpO1xuXG5cdFx0aWYgKHRoaXMuX3N0cmVhbS5nZXRUcmFja0J5SWQodHJhY2suaWQpKVxuXHRcdFx0cmV0dXJuIFByb21pc2UucmVqZWN0KG5ldyBFcnJvcigndHJhY2sgYWxyZWFkeSBhZGRlZCcpKTtcblxuXHRcdGxldCBydHBTZW5kZXI7XG5cdFx0bGV0IGxvY2FsU2RwT2JqO1xuXG5cdFx0cmV0dXJuIFByb21pc2UucmVzb2x2ZSgpXG5cdFx0XHQudGhlbigoKSA9PlxuXHRcdFx0e1xuXHRcdFx0XHR0aGlzLl9zdHJlYW0uYWRkVHJhY2sodHJhY2spO1xuXG5cdFx0XHRcdC8vIEFkZCB0aGUgc3RyZWFtIHRvIHRoZSBQZWVyQ29ubmVjdGlvbi5cblx0XHRcdFx0cnRwU2VuZGVyID0gdGhpcy5fcGMuYWRkVHJhY2sodHJhY2ssIHRoaXMuX3N0cmVhbSk7XG5cdFx0XHR9KVxuXHRcdFx0LnRoZW4oKCkgPT5cblx0XHRcdHtcblx0XHRcdFx0Ly8gSWYgc2ltdWxjYXN0IGlzIG5vdCBlbmFibGVkLCBkbyBub3RoaW5nLlxuXHRcdFx0XHRpZiAoIXByb2R1Y2VyLnNpbXVsY2FzdClcblx0XHRcdFx0XHRyZXR1cm47XG5cblx0XHRcdFx0bG9nZ2VyLmRlYnVnKCdhZGRQcm9kdWNlcigpIHwgZW5hYmxpbmcgc2ltdWxjYXN0Jyk7XG5cblx0XHRcdFx0Y29uc3QgZW5jb2RpbmdzID0gW107XG5cblx0XHRcdFx0aWYgKHByb2R1Y2VyLnNpbXVsY2FzdC5oaWdoKVxuXHRcdFx0XHR7XG5cdFx0XHRcdFx0ZW5jb2RpbmdzLnB1c2goXG5cdFx0XHRcdFx0XHR7XG5cdFx0XHRcdFx0XHRcdHJpZCAgICAgICAgOiBgaGlnaCR7dGhpcy5fbmV4dFJpZH1gLFxuXHRcdFx0XHRcdFx0XHRhY3RpdmUgICAgIDogdHJ1ZSxcblx0XHRcdFx0XHRcdFx0cHJpb3JpdHkgICA6ICdoaWdoJyxcblx0XHRcdFx0XHRcdFx0bWF4Qml0cmF0ZSA6IHByb2R1Y2VyLnNpbXVsY2FzdC5oaWdoXG5cdFx0XHRcdFx0XHR9KTtcblx0XHRcdFx0fVxuXG5cdFx0XHRcdGlmIChwcm9kdWNlci5zaW11bGNhc3QubWVkaXVtKVxuXHRcdFx0XHR7XG5cdFx0XHRcdFx0ZW5jb2RpbmdzLnB1c2goXG5cdFx0XHRcdFx0XHR7XG5cdFx0XHRcdFx0XHRcdHJpZCAgICAgICAgOiBgbWVkaXVtJHt0aGlzLl9uZXh0UmlkfWAsXG5cdFx0XHRcdFx0XHRcdGFjdGl2ZSAgICAgOiB0cnVlLFxuXHRcdFx0XHRcdFx0XHRwcmlvcml0eSAgIDogJ21lZGl1bScsXG5cdFx0XHRcdFx0XHRcdG1heEJpdHJhdGUgOiBwcm9kdWNlci5zaW11bGNhc3QubWVkaXVtXG5cdFx0XHRcdFx0XHR9KTtcblx0XHRcdFx0fVxuXG5cdFx0XHRcdGlmIChwcm9kdWNlci5zaW11bGNhc3QubG93KVxuXHRcdFx0XHR7XG5cdFx0XHRcdFx0ZW5jb2RpbmdzLnB1c2goXG5cdFx0XHRcdFx0XHR7XG5cdFx0XHRcdFx0XHRcdHJpZCAgICAgICAgOiBgbG93JHt0aGlzLl9uZXh0UmlkfWAsXG5cdFx0XHRcdFx0XHRcdGFjdGl2ZSAgICAgOiB0cnVlLFxuXHRcdFx0XHRcdFx0XHRwcmlvcml0eSAgIDogJ2xvdycsXG5cdFx0XHRcdFx0XHRcdG1heEJpdHJhdGUgOiBwcm9kdWNlci5zaW11bGNhc3QubG93XG5cdFx0XHRcdFx0XHR9KTtcblx0XHRcdFx0fVxuXG5cdFx0XHRcdC8vIFVwZGF0ZSBSSUQgY291bnRlciBmb3IgZnV0dXJlIG9uZXMuXG5cdFx0XHRcdHRoaXMuX25leHRSaWQrKztcblxuXHRcdFx0XHRyZXR1cm4gcnRwU2VuZGVyLnNldFBhcmFtZXRlcnMoeyBlbmNvZGluZ3MgfSk7XG5cdFx0XHR9KVxuXHRcdFx0LnRoZW4oKCkgPT5cblx0XHRcdHtcblx0XHRcdFx0cmV0dXJuIHRoaXMuX3BjLmNyZWF0ZU9mZmVyKCk7XG5cdFx0XHR9KVxuXHRcdFx0LnRoZW4oKG9mZmVyKSA9PlxuXHRcdFx0e1xuXHRcdFx0XHRsb2dnZXIuZGVidWcoXG5cdFx0XHRcdFx0J2FkZFByb2R1Y2VyKCkgfCBjYWxsaW5nIHBjLnNldExvY2FsRGVzY3JpcHRpb24oKSBbb2ZmZXI6JW9dJyxcblx0XHRcdFx0XHRvZmZlcik7XG5cblx0XHRcdFx0cmV0dXJuIHRoaXMuX3BjLnNldExvY2FsRGVzY3JpcHRpb24ob2ZmZXIpO1xuXHRcdFx0fSlcblx0XHRcdC50aGVuKCgpID0+XG5cdFx0XHR7XG5cdFx0XHRcdGlmICghdGhpcy5fdHJhbnNwb3J0UmVhZHkpXG5cdFx0XHRcdFx0cmV0dXJuIHRoaXMuX3NldHVwVHJhbnNwb3J0KCk7XG5cdFx0XHR9KVxuXHRcdFx0LnRoZW4oKCkgPT5cblx0XHRcdHtcblx0XHRcdFx0bG9jYWxTZHBPYmogPSBzZHBUcmFuc2Zvcm0ucGFyc2UodGhpcy5fcGMubG9jYWxEZXNjcmlwdGlvbi5zZHApO1xuXG5cdFx0XHRcdGNvbnN0IHJlbW90ZVNkcCA9IHRoaXMuX3JlbW90ZVNkcC5jcmVhdGVBbnN3ZXJTZHAobG9jYWxTZHBPYmopO1xuXHRcdFx0XHRjb25zdCBhbnN3ZXIgPSB7IHR5cGU6ICdhbnN3ZXInLCBzZHA6IHJlbW90ZVNkcCB9O1xuXG5cdFx0XHRcdGxvZ2dlci5kZWJ1Zyhcblx0XHRcdFx0XHQnYWRkUHJvZHVjZXIoKSB8IGNhbGxpbmcgcGMuc2V0UmVtb3RlRGVzY3JpcHRpb24oKSBbYW5zd2VyOiVvXScsXG5cdFx0XHRcdFx0YW5zd2VyKTtcblxuXHRcdFx0XHRyZXR1cm4gdGhpcy5fcGMuc2V0UmVtb3RlRGVzY3JpcHRpb24oYW5zd2VyKTtcblx0XHRcdH0pXG5cdFx0XHQudGhlbigoKSA9PlxuXHRcdFx0e1xuXHRcdFx0XHRjb25zdCBydHBQYXJhbWV0ZXJzID0gdXRpbHMuY2xvbmUodGhpcy5fcnRwUGFyYW1ldGVyc0J5S2luZFtwcm9kdWNlci5raW5kXSk7XG5cblx0XHRcdFx0Ly8gRmlsbCB0aGUgUlRQIHBhcmFtZXRlcnMgZm9yIHRoaXMgdHJhY2suXG5cdFx0XHRcdHNkcFVuaWZpZWRQbGFuVXRpbHMuZmlsbFJ0cFBhcmFtZXRlcnNGb3JUcmFjayhcblx0XHRcdFx0XHRydHBQYXJhbWV0ZXJzLCBsb2NhbFNkcE9iaiwgdHJhY2spO1xuXG5cdFx0XHRcdHJldHVybiBydHBQYXJhbWV0ZXJzO1xuXHRcdFx0fSlcblx0XHRcdC5jYXRjaCgoZXJyb3IpID0+XG5cdFx0XHR7XG5cdFx0XHRcdC8vIFBhbmljIGhlcmUuIFRyeSB0byB1bmRvIHRoaW5ncy5cblxuXHRcdFx0XHR0cnkgeyB0aGlzLl9wYy5yZW1vdmVUcmFjayhydHBTZW5kZXIpOyB9XG5cdFx0XHRcdGNhdGNoIChlcnJvcjIpIHt9XG5cblx0XHRcdFx0dGhpcy5fc3RyZWFtLnJlbW92ZVRyYWNrKHRyYWNrKTtcblxuXHRcdFx0XHR0aHJvdyBlcnJvcjtcblx0XHRcdH0pO1xuXHR9XG5cblx0cmVtb3ZlUHJvZHVjZXIocHJvZHVjZXIpXG5cdHtcblx0XHRjb25zdCB7IHRyYWNrIH0gPSBwcm9kdWNlcjtcblxuXHRcdGxvZ2dlci5kZWJ1Zyhcblx0XHRcdCdyZW1vdmVQcm9kdWNlcigpIFtpZDolcywga2luZDolcywgdHJhY2tJZDolc10nLFxuXHRcdFx0cHJvZHVjZXIuaWQsIHByb2R1Y2VyLmtpbmQsIHRyYWNrLmlkKTtcblxuXHRcdHJldHVybiBQcm9taXNlLnJlc29sdmUoKVxuXHRcdFx0LnRoZW4oKCkgPT5cblx0XHRcdHtcblx0XHRcdFx0Ly8gR2V0IHRoZSBhc3NvY2lhdGVkIFJUQ1J0cFNlbmRlci5cblx0XHRcdFx0Y29uc3QgcnRwU2VuZGVyID0gdGhpcy5fcGMuZ2V0U2VuZGVycygpXG5cdFx0XHRcdFx0LmZpbmQoKHMpID0+IHMudHJhY2sgPT09IHRyYWNrKTtcblxuXHRcdFx0XHRpZiAoIXJ0cFNlbmRlcilcblx0XHRcdFx0XHR0aHJvdyBuZXcgRXJyb3IoJ1JUQ1J0cFNlbmRlciBmb3VuZCcpO1xuXG5cdFx0XHRcdC8vIFJlbW92ZSB0aGUgYXNzb2NpYXRlZCBSdHBTZW5kZXIuXG5cdFx0XHRcdHRoaXMuX3BjLnJlbW92ZVRyYWNrKHJ0cFNlbmRlcik7XG5cblx0XHRcdFx0Ly8gUmVtb3ZlIHRoZSB0cmFjayBmcm9tIHRoZSBsb2NhbCBzdHJlYW0uXG5cdFx0XHRcdHRoaXMuX3N0cmVhbS5yZW1vdmVUcmFjayh0cmFjayk7XG5cblx0XHRcdFx0cmV0dXJuIFByb21pc2UucmVzb2x2ZSgpXG5cdFx0XHRcdFx0LnRoZW4oKCkgPT5cblx0XHRcdFx0XHR7XG5cdFx0XHRcdFx0XHRyZXR1cm4gdGhpcy5fcGMuY3JlYXRlT2ZmZXIoKTtcblx0XHRcdFx0XHR9KVxuXHRcdFx0XHRcdC50aGVuKChvZmZlcikgPT5cblx0XHRcdFx0XHR7XG5cdFx0XHRcdFx0XHRsb2dnZXIuZGVidWcoXG5cdFx0XHRcdFx0XHRcdCdyZW1vdmVQcm9kdWNlcigpIHwgY2FsbGluZyBwYy5zZXRMb2NhbERlc2NyaXB0aW9uKCkgW29mZmVyOiVvXScsXG5cdFx0XHRcdFx0XHRcdG9mZmVyKTtcblxuXHRcdFx0XHRcdFx0cmV0dXJuIHRoaXMuX3BjLnNldExvY2FsRGVzY3JpcHRpb24ob2ZmZXIpO1xuXHRcdFx0XHRcdH0pO1xuXHRcdFx0fSlcblx0XHRcdC50aGVuKCgpID0+XG5cdFx0XHR7XG5cdFx0XHRcdGNvbnN0IGxvY2FsU2RwT2JqID0gc2RwVHJhbnNmb3JtLnBhcnNlKHRoaXMuX3BjLmxvY2FsRGVzY3JpcHRpb24uc2RwKTtcblx0XHRcdFx0Y29uc3QgcmVtb3RlU2RwID0gdGhpcy5fcmVtb3RlU2RwLmNyZWF0ZUFuc3dlclNkcChsb2NhbFNkcE9iaik7XG5cdFx0XHRcdGNvbnN0IGFuc3dlciA9IHsgdHlwZTogJ2Fuc3dlcicsIHNkcDogcmVtb3RlU2RwIH07XG5cblx0XHRcdFx0bG9nZ2VyLmRlYnVnKFxuXHRcdFx0XHRcdCdyZW1vdmVQcm9kdWNlcigpIHwgY2FsbGluZyBwYy5zZXRSZW1vdGVEZXNjcmlwdGlvbigpIFthbnN3ZXI6JW9dJyxcblx0XHRcdFx0XHRhbnN3ZXIpO1xuXG5cdFx0XHRcdHJldHVybiB0aGlzLl9wYy5zZXRSZW1vdGVEZXNjcmlwdGlvbihhbnN3ZXIpO1xuXHRcdFx0fSk7XG5cdH1cblxuXHRyZXBsYWNlUHJvZHVjZXJUcmFjayhwcm9kdWNlciwgdHJhY2spXG5cdHtcblx0XHRsb2dnZXIuZGVidWcoXG5cdFx0XHQncmVwbGFjZVByb2R1Y2VyVHJhY2soKSBbaWQ6JXMsIGtpbmQ6JXMsIHRyYWNrSWQ6JXNdJyxcblx0XHRcdHByb2R1Y2VyLmlkLCBwcm9kdWNlci5raW5kLCB0cmFjay5pZCk7XG5cblx0XHRjb25zdCBvbGRUcmFjayA9IHByb2R1Y2VyLnRyYWNrO1xuXG5cdFx0cmV0dXJuIFByb21pc2UucmVzb2x2ZSgpXG5cdFx0XHQudGhlbigoKSA9PlxuXHRcdFx0e1xuXHRcdFx0XHQvLyBHZXQgdGhlIGFzc29jaWF0ZWQgUlRDUnRwU2VuZGVyLlxuXHRcdFx0XHRjb25zdCBydHBTZW5kZXIgPSB0aGlzLl9wYy5nZXRTZW5kZXJzKClcblx0XHRcdFx0XHQuZmluZCgocykgPT4gcy50cmFjayA9PT0gb2xkVHJhY2spO1xuXG5cdFx0XHRcdGlmICghcnRwU2VuZGVyKVxuXHRcdFx0XHRcdHRocm93IG5ldyBFcnJvcignbG9jYWwgdHJhY2sgbm90IGZvdW5kJyk7XG5cblx0XHRcdFx0cmV0dXJuIHJ0cFNlbmRlci5yZXBsYWNlVHJhY2sodHJhY2spO1xuXHRcdFx0fSlcblx0XHRcdC50aGVuKCgpID0+XG5cdFx0XHR7XG5cdFx0XHRcdC8vIFJlbW92ZSB0aGUgb2xkIHRyYWNrIGZyb20gdGhlIGxvY2FsIHN0cmVhbS5cblx0XHRcdFx0dGhpcy5fc3RyZWFtLnJlbW92ZVRyYWNrKG9sZFRyYWNrKTtcblxuXHRcdFx0XHQvLyBBZGQgdGhlIG5ldyB0cmFjayB0byB0aGUgbG9jYWwgc3RyZWFtLlxuXHRcdFx0XHR0aGlzLl9zdHJlYW0uYWRkVHJhY2sodHJhY2spO1xuXHRcdFx0fSk7XG5cdH1cblxuXHRyZXN0YXJ0SWNlKHJlbW90ZUljZVBhcmFtZXRlcnMpXG5cdHtcblx0XHRsb2dnZXIuZGVidWcoJ3Jlc3RhcnRJY2UoKScpO1xuXG5cdFx0Ly8gUHJvdmlkZSB0aGUgcmVtb3RlIFNEUCBoYW5kbGVyIHdpdGggbmV3IHJlbW90ZSBJQ0UgcGFyYW1ldGVycy5cblx0XHR0aGlzLl9yZW1vdGVTZHAudXBkYXRlVHJhbnNwb3J0UmVtb3RlSWNlUGFyYW1ldGVycyhyZW1vdGVJY2VQYXJhbWV0ZXJzKTtcblxuXHRcdHJldHVybiBQcm9taXNlLnJlc29sdmUoKVxuXHRcdFx0LnRoZW4oKCkgPT5cblx0XHRcdHtcblx0XHRcdFx0cmV0dXJuIHRoaXMuX3BjLmNyZWF0ZU9mZmVyKHsgaWNlUmVzdGFydDogdHJ1ZSB9KTtcblx0XHRcdH0pXG5cdFx0XHQudGhlbigob2ZmZXIpID0+XG5cdFx0XHR7XG5cdFx0XHRcdGxvZ2dlci5kZWJ1Zyhcblx0XHRcdFx0XHQncmVzdGFydEljZSgpIHwgY2FsbGluZyBwYy5zZXRMb2NhbERlc2NyaXB0aW9uKCkgW29mZmVyOiVvXScsXG5cdFx0XHRcdFx0b2ZmZXIpO1xuXG5cdFx0XHRcdHJldHVybiB0aGlzLl9wYy5zZXRMb2NhbERlc2NyaXB0aW9uKG9mZmVyKTtcblx0XHRcdH0pXG5cdFx0XHQudGhlbigoKSA9PlxuXHRcdFx0e1xuXHRcdFx0XHRjb25zdCBsb2NhbFNkcE9iaiA9IHNkcFRyYW5zZm9ybS5wYXJzZSh0aGlzLl9wYy5sb2NhbERlc2NyaXB0aW9uLnNkcCk7XG5cdFx0XHRcdGNvbnN0IHJlbW90ZVNkcCA9IHRoaXMuX3JlbW90ZVNkcC5jcmVhdGVBbnN3ZXJTZHAobG9jYWxTZHBPYmopO1xuXHRcdFx0XHRjb25zdCBhbnN3ZXIgPSB7IHR5cGU6ICdhbnN3ZXInLCBzZHA6IHJlbW90ZVNkcCB9O1xuXG5cdFx0XHRcdGxvZ2dlci5kZWJ1Zyhcblx0XHRcdFx0XHQncmVzdGFydEljZSgpIHwgY2FsbGluZyBwYy5zZXRSZW1vdGVEZXNjcmlwdGlvbigpIFthbnN3ZXI6JW9dJyxcblx0XHRcdFx0XHRhbnN3ZXIpO1xuXG5cdFx0XHRcdHJldHVybiB0aGlzLl9wYy5zZXRSZW1vdGVEZXNjcmlwdGlvbihhbnN3ZXIpO1xuXHRcdFx0fSk7XG5cdH1cblxuXHRfc2V0dXBUcmFuc3BvcnQoKVxuXHR7XG5cdFx0bG9nZ2VyLmRlYnVnKCdfc2V0dXBUcmFuc3BvcnQoKScpO1xuXG5cdFx0cmV0dXJuIFByb21pc2UucmVzb2x2ZSgpXG5cdFx0XHQudGhlbigoKSA9PlxuXHRcdFx0e1xuXHRcdFx0XHQvLyBHZXQgb3VyIGxvY2FsIERUTFMgcGFyYW1ldGVycy5cblx0XHRcdFx0Y29uc3QgdHJhbnNwb3J0TG9jYWxQYXJhbWV0ZXJzID0ge307XG5cdFx0XHRcdGNvbnN0IHNkcCA9IHRoaXMuX3BjLmxvY2FsRGVzY3JpcHRpb24uc2RwO1xuXHRcdFx0XHRjb25zdCBzZHBPYmogPSBzZHBUcmFuc2Zvcm0ucGFyc2Uoc2RwKTtcblx0XHRcdFx0Y29uc3QgZHRsc1BhcmFtZXRlcnMgPSBzZHBDb21tb25VdGlscy5leHRyYWN0RHRsc1BhcmFtZXRlcnMoc2RwT2JqKTtcblxuXHRcdFx0XHQvLyBMZXQncyBkZWNpZGUgdGhhdCB3ZSdsbCBiZSBEVExTIHNlcnZlciAoYmVjYXVzZSB3ZSBjYW4pLlxuXHRcdFx0XHRkdGxzUGFyYW1ldGVycy5yb2xlID0gJ3NlcnZlcic7XG5cblx0XHRcdFx0dHJhbnNwb3J0TG9jYWxQYXJhbWV0ZXJzLmR0bHNQYXJhbWV0ZXJzID0gZHRsc1BhcmFtZXRlcnM7XG5cblx0XHRcdFx0Ly8gUHJvdmlkZSB0aGUgcmVtb3RlIFNEUCBoYW5kbGVyIHdpdGggdHJhbnNwb3J0IGxvY2FsIHBhcmFtZXRlcnMuXG5cdFx0XHRcdHRoaXMuX3JlbW90ZVNkcC5zZXRUcmFuc3BvcnRMb2NhbFBhcmFtZXRlcnModHJhbnNwb3J0TG9jYWxQYXJhbWV0ZXJzKTtcblxuXHRcdFx0XHQvLyBXZSBuZWVkIHRyYW5zcG9ydCByZW1vdGUgcGFyYW1ldGVycy5cblx0XHRcdFx0cmV0dXJuIHRoaXMuc2FmZUVtaXRBc1Byb21pc2UoXG5cdFx0XHRcdFx0J0BuZWVkY3JlYXRldHJhbnNwb3J0JywgdHJhbnNwb3J0TG9jYWxQYXJhbWV0ZXJzKTtcblx0XHRcdH0pXG5cdFx0XHQudGhlbigodHJhbnNwb3J0UmVtb3RlUGFyYW1ldGVycykgPT5cblx0XHRcdHtcblx0XHRcdFx0Ly8gUHJvdmlkZSB0aGUgcmVtb3RlIFNEUCBoYW5kbGVyIHdpdGggdHJhbnNwb3J0IHJlbW90ZSBwYXJhbWV0ZXJzLlxuXHRcdFx0XHR0aGlzLl9yZW1vdGVTZHAuc2V0VHJhbnNwb3J0UmVtb3RlUGFyYW1ldGVycyh0cmFuc3BvcnRSZW1vdGVQYXJhbWV0ZXJzKTtcblxuXHRcdFx0XHR0aGlzLl90cmFuc3BvcnRSZWFkeSA9IHRydWU7XG5cdFx0XHR9KTtcblx0fVxufVxuXG5jbGFzcyBSZWN2SGFuZGxlciBleHRlbmRzIEhhbmRsZXJcbntcblx0Y29uc3RydWN0b3IocnRwUGFyYW1ldGVyc0J5S2luZCwgc2V0dGluZ3MpXG5cdHtcblx0XHRzdXBlcigncmVjdicsIHJ0cFBhcmFtZXRlcnNCeUtpbmQsIHNldHRpbmdzKTtcblxuXHRcdC8vIEdvdCB0cmFuc3BvcnQgcmVtb3RlIHBhcmFtZXRlcnMuXG5cdFx0Ly8gQHR5cGUge0Jvb2xlYW59XG5cdFx0dGhpcy5fdHJhbnNwb3J0Q3JlYXRlZCA9IGZhbHNlO1xuXG5cdFx0Ly8gR290IHRyYW5zcG9ydCBsb2NhbCBwYXJhbWV0ZXJzLlxuXHRcdC8vIEB0eXBlIHtCb29sZWFufVxuXHRcdHRoaXMuX3RyYW5zcG9ydFVwZGF0ZWQgPSBmYWxzZTtcblxuXHRcdC8vIE1hcCBvZiBDb25zdW1lcnMgaW5mb3JtYXRpb24gaW5kZXhlZCBieSBjb25zdW1lci5pZC5cblx0XHQvLyAtIG1pZCB7U3RyaW5nfVxuXHRcdC8vIC0ga2luZCB7U3RyaW5nfVxuXHRcdC8vIC0gY2xvc2VkIHtCb29sZWFufVxuXHRcdC8vIC0gdHJhY2tJZCB7U3RyaW5nfVxuXHRcdC8vIC0gc3NyYyB7TnVtYmVyfVxuXHRcdC8vIC0gcnR4U3NyYyB7TnVtYmVyfVxuXHRcdC8vIC0gY25hbWUge1N0cmluZ31cblx0XHQvLyBAdHlwZSB7TWFwPE51bWJlciwgT2JqZWN0Pn1cblx0XHR0aGlzLl9jb25zdW1lckluZm9zID0gbmV3IE1hcCgpO1xuXG5cdFx0Ly8gQWRkIGFuIGVudHJ5IGludG8gY29uc3VtZXJzIGluZm8gdG8gaG9sZCBhIGZha2UgRGF0YUNoYW5uZWwsIHNvXG5cdFx0Ly8gdGhlIGZpcnN0IG09IHNlY3Rpb24gb2YgdGhlIHJlbW90ZSBTRFAgaXMgYWx3YXlzIFwiYWN0aXZlXCIgYW5kIEZpcmVmb3hcblx0XHQvLyBkb2VzIG5vdCBjbG9zZSB0aGUgdHJhbnNwb3J0IHdoZW4gdGhlcmUgaXMgbm8gcmVtb3RlIGF1ZGlvL3ZpZGVvIENvbnN1bWVycy5cblx0XHQvL1xuXHRcdC8vIElTU1VFOiBodHRwczovL2dpdGh1Yi5jb20vdmVyc2F0aWNhL21lZGlhc291cC1jbGllbnQvaXNzdWVzLzJcblx0XHRjb25zdCBmYWtlRGF0YUNoYW5uZWxDb25zdW1lckluZm8gPVxuXHRcdHtcblx0XHRcdG1pZCAgICA6ICdmYWtlLWRjJyxcblx0XHRcdGtpbmQgICA6ICdhcHBsaWNhdGlvbicsXG5cdFx0XHRjbG9zZWQgOiBmYWxzZSxcblx0XHRcdGNuYW1lICA6IG51bGxcblx0XHR9O1xuXG5cdFx0dGhpcy5fY29uc3VtZXJJbmZvcy5zZXQoNTU1LCBmYWtlRGF0YUNoYW5uZWxDb25zdW1lckluZm8pO1xuXHR9XG5cblx0YWRkQ29uc3VtZXIoY29uc3VtZXIpXG5cdHtcblx0XHRsb2dnZXIuZGVidWcoXG5cdFx0XHQnYWRkQ29uc3VtZXIoKSBbaWQ6JXMsIGtpbmQ6JXNdJywgY29uc3VtZXIuaWQsIGNvbnN1bWVyLmtpbmQpO1xuXG5cdFx0aWYgKHRoaXMuX2NvbnN1bWVySW5mb3MuaGFzKGNvbnN1bWVyLmlkKSlcblx0XHRcdHJldHVybiBQcm9taXNlLnJlamVjdChuZXcgRXJyb3IoJ0NvbnN1bWVyIGFscmVhZHkgYWRkZWQnKSk7XG5cblx0XHRjb25zdCBlbmNvZGluZyA9IGNvbnN1bWVyLnJ0cFBhcmFtZXRlcnMuZW5jb2RpbmdzWzBdO1xuXHRcdGNvbnN0IGNuYW1lID0gY29uc3VtZXIucnRwUGFyYW1ldGVycy5ydGNwLmNuYW1lO1xuXHRcdGNvbnN0IGNvbnN1bWVySW5mbyA9XG5cdFx0e1xuXHRcdFx0bWlkICAgICAgOiBgJHtjb25zdW1lci5raW5kWzBdfSR7Y29uc3VtZXIuaWR9YCxcblx0XHRcdGtpbmQgICAgIDogY29uc3VtZXIua2luZCxcblx0XHRcdGNsb3NlZCAgIDogY29uc3VtZXIuY2xvc2VkLFxuXHRcdFx0c3RyZWFtSWQgOiBgcmVjdi1zdHJlYW0tJHtjb25zdW1lci5pZH1gLFxuXHRcdFx0dHJhY2tJZCAgOiBgY29uc3VtZXItJHtjb25zdW1lci5raW5kfS0ke2NvbnN1bWVyLmlkfWAsXG5cdFx0XHRzc3JjICAgICA6IGVuY29kaW5nLnNzcmMsXG5cdFx0XHRjbmFtZSAgICA6IGNuYW1lXG5cdFx0fTtcblxuXHRcdGlmIChlbmNvZGluZy5ydHggJiYgZW5jb2RpbmcucnR4LnNzcmMpXG5cdFx0XHRjb25zdW1lckluZm8ucnR4U3NyYyA9IGVuY29kaW5nLnJ0eC5zc3JjO1xuXG5cdFx0dGhpcy5fY29uc3VtZXJJbmZvcy5zZXQoY29uc3VtZXIuaWQsIGNvbnN1bWVySW5mbyk7XG5cblx0XHRyZXR1cm4gUHJvbWlzZS5yZXNvbHZlKClcblx0XHRcdC50aGVuKCgpID0+XG5cdFx0XHR7XG5cdFx0XHRcdGlmICghdGhpcy5fdHJhbnNwb3J0Q3JlYXRlZClcblx0XHRcdFx0XHRyZXR1cm4gdGhpcy5fc2V0dXBUcmFuc3BvcnQoKTtcblx0XHRcdH0pXG5cdFx0XHQudGhlbigoKSA9PlxuXHRcdFx0e1xuXHRcdFx0XHRjb25zdCByZW1vdGVTZHAgPSB0aGlzLl9yZW1vdGVTZHAuY3JlYXRlT2ZmZXJTZHAoXG5cdFx0XHRcdFx0QXJyYXkuZnJvbSh0aGlzLl9jb25zdW1lckluZm9zLnZhbHVlcygpKSk7XG5cdFx0XHRcdGNvbnN0IG9mZmVyID0geyB0eXBlOiAnb2ZmZXInLCBzZHA6IHJlbW90ZVNkcCB9O1xuXG5cdFx0XHRcdGxvZ2dlci5kZWJ1Zyhcblx0XHRcdFx0XHQnYWRkQ29uc3VtZXIoKSB8IGNhbGxpbmcgcGMuc2V0UmVtb3RlRGVzY3JpcHRpb24oKSBbb2ZmZXI6JW9dJyxcblx0XHRcdFx0XHRvZmZlcik7XG5cblx0XHRcdFx0cmV0dXJuIHRoaXMuX3BjLnNldFJlbW90ZURlc2NyaXB0aW9uKG9mZmVyKTtcblx0XHRcdH0pXG5cdFx0XHQudGhlbigoKSA9PlxuXHRcdFx0e1xuXHRcdFx0XHRyZXR1cm4gdGhpcy5fcGMuY3JlYXRlQW5zd2VyKCk7XG5cdFx0XHR9KVxuXHRcdFx0LnRoZW4oKGFuc3dlcikgPT5cblx0XHRcdHtcblx0XHRcdFx0bG9nZ2VyLmRlYnVnKFxuXHRcdFx0XHRcdCdhZGRDb25zdW1lcigpIHwgY2FsbGluZyBwYy5zZXRMb2NhbERlc2NyaXB0aW9uKCkgW2Fuc3dlcjolb10nLFxuXHRcdFx0XHRcdGFuc3dlcik7XG5cblx0XHRcdFx0cmV0dXJuIHRoaXMuX3BjLnNldExvY2FsRGVzY3JpcHRpb24oYW5zd2VyKTtcblx0XHRcdH0pXG5cdFx0XHQudGhlbigoKSA9PlxuXHRcdFx0e1xuXHRcdFx0XHRpZiAoIXRoaXMuX3RyYW5zcG9ydFVwZGF0ZWQpXG5cdFx0XHRcdFx0cmV0dXJuIHRoaXMuX3VwZGF0ZVRyYW5zcG9ydCgpO1xuXHRcdFx0fSlcblx0XHRcdC50aGVuKCgpID0+XG5cdFx0XHR7XG5cdFx0XHRcdGNvbnN0IG5ld1J0cFJlY2VpdmVyID0gdGhpcy5fcGMuZ2V0UmVjZWl2ZXJzKClcblx0XHRcdFx0XHQuZmluZCgocnRwUmVjZWl2ZXIpID0+XG5cdFx0XHRcdFx0e1xuXHRcdFx0XHRcdFx0Y29uc3QgeyB0cmFjayB9ID0gcnRwUmVjZWl2ZXI7XG5cblx0XHRcdFx0XHRcdGlmICghdHJhY2spXG5cdFx0XHRcdFx0XHRcdHJldHVybiBmYWxzZTtcblxuXHRcdFx0XHRcdFx0cmV0dXJuIHRyYWNrLmlkID09PSBjb25zdW1lckluZm8udHJhY2tJZDtcblx0XHRcdFx0XHR9KTtcblxuXHRcdFx0XHRpZiAoIW5ld1J0cFJlY2VpdmVyKVxuXHRcdFx0XHRcdHRocm93IG5ldyBFcnJvcigncmVtb3RlIHRyYWNrIG5vdCBmb3VuZCcpO1xuXG5cdFx0XHRcdHJldHVybiBuZXdSdHBSZWNlaXZlci50cmFjaztcblx0XHRcdH0pO1xuXHR9XG5cblx0cmVtb3ZlQ29uc3VtZXIoY29uc3VtZXIpXG5cdHtcblx0XHRsb2dnZXIuZGVidWcoXG5cdFx0XHQncmVtb3ZlQ29uc3VtZXIoKSBbaWQ6JXMsIGtpbmQ6JXNdJywgY29uc3VtZXIuaWQsIGNvbnN1bWVyLmtpbmQpO1xuXG5cdFx0Y29uc3QgY29uc3VtZXJJbmZvID0gdGhpcy5fY29uc3VtZXJJbmZvcy5nZXQoY29uc3VtZXIuaWQpO1xuXG5cdFx0aWYgKCFjb25zdW1lckluZm8pXG5cdFx0XHRyZXR1cm4gUHJvbWlzZS5yZWplY3QobmV3IEVycm9yKCdDb25zdW1lciBub3QgZm91bmQnKSk7XG5cblx0XHRjb25zdW1lckluZm8uY2xvc2VkID0gdHJ1ZTtcblxuXHRcdHJldHVybiBQcm9taXNlLnJlc29sdmUoKVxuXHRcdFx0LnRoZW4oKCkgPT5cblx0XHRcdHtcblx0XHRcdFx0Y29uc3QgcmVtb3RlU2RwID0gdGhpcy5fcmVtb3RlU2RwLmNyZWF0ZU9mZmVyU2RwKFxuXHRcdFx0XHRcdEFycmF5LmZyb20odGhpcy5fY29uc3VtZXJJbmZvcy52YWx1ZXMoKSkpO1xuXHRcdFx0XHRjb25zdCBvZmZlciA9IHsgdHlwZTogJ29mZmVyJywgc2RwOiByZW1vdGVTZHAgfTtcblxuXHRcdFx0XHRsb2dnZXIuZGVidWcoXG5cdFx0XHRcdFx0J3JlbW92ZUNvbnN1bWVyKCkgfCBjYWxsaW5nIHBjLnNldFJlbW90ZURlc2NyaXB0aW9uKCkgW29mZmVyOiVvXScsXG5cdFx0XHRcdFx0b2ZmZXIpO1xuXG5cdFx0XHRcdHJldHVybiB0aGlzLl9wYy5zZXRSZW1vdGVEZXNjcmlwdGlvbihvZmZlcik7XG5cdFx0XHR9KVxuXHRcdFx0LnRoZW4oKCkgPT5cblx0XHRcdHtcblx0XHRcdFx0cmV0dXJuIHRoaXMuX3BjLmNyZWF0ZUFuc3dlcigpO1xuXHRcdFx0fSlcblx0XHRcdC50aGVuKChhbnN3ZXIpID0+XG5cdFx0XHR7XG5cdFx0XHRcdGxvZ2dlci5kZWJ1Zyhcblx0XHRcdFx0XHQncmVtb3ZlQ29uc3VtZXIoKSB8IGNhbGxpbmcgcGMuc2V0TG9jYWxEZXNjcmlwdGlvbigpIFthbnN3ZXI6JW9dJyxcblx0XHRcdFx0XHRhbnN3ZXIpO1xuXG5cdFx0XHRcdHJldHVybiB0aGlzLl9wYy5zZXRMb2NhbERlc2NyaXB0aW9uKGFuc3dlcik7XG5cdFx0XHR9KTtcblx0fVxuXG5cdHJlc3RhcnRJY2UocmVtb3RlSWNlUGFyYW1ldGVycylcblx0e1xuXHRcdGxvZ2dlci5kZWJ1ZygncmVzdGFydEljZSgpJyk7XG5cblx0XHQvLyBQcm92aWRlIHRoZSByZW1vdGUgU0RQIGhhbmRsZXIgd2l0aCBuZXcgcmVtb3RlIElDRSBwYXJhbWV0ZXJzLlxuXHRcdHRoaXMuX3JlbW90ZVNkcC51cGRhdGVUcmFuc3BvcnRSZW1vdGVJY2VQYXJhbWV0ZXJzKHJlbW90ZUljZVBhcmFtZXRlcnMpO1xuXG5cdFx0cmV0dXJuIFByb21pc2UucmVzb2x2ZSgpXG5cdFx0XHQudGhlbigoKSA9PlxuXHRcdFx0e1xuXHRcdFx0XHRjb25zdCByZW1vdGVTZHAgPSB0aGlzLl9yZW1vdGVTZHAuY3JlYXRlT2ZmZXJTZHAoXG5cdFx0XHRcdFx0QXJyYXkuZnJvbSh0aGlzLl9jb25zdW1lckluZm9zLnZhbHVlcygpKSk7XG5cdFx0XHRcdGNvbnN0IG9mZmVyID0geyB0eXBlOiAnb2ZmZXInLCBzZHA6IHJlbW90ZVNkcCB9O1xuXG5cdFx0XHRcdGxvZ2dlci5kZWJ1Zyhcblx0XHRcdFx0XHQncmVzdGFydEljZSgpIHwgY2FsbGluZyBwYy5zZXRSZW1vdGVEZXNjcmlwdGlvbigpIFtvZmZlcjolb10nLFxuXHRcdFx0XHRcdG9mZmVyKTtcblxuXHRcdFx0XHRyZXR1cm4gdGhpcy5fcGMuc2V0UmVtb3RlRGVzY3JpcHRpb24ob2ZmZXIpO1xuXHRcdFx0fSlcblx0XHRcdC50aGVuKCgpID0+XG5cdFx0XHR7XG5cdFx0XHRcdHJldHVybiB0aGlzLl9wYy5jcmVhdGVBbnN3ZXIoKTtcblx0XHRcdH0pXG5cdFx0XHQudGhlbigoYW5zd2VyKSA9PlxuXHRcdFx0e1xuXHRcdFx0XHRsb2dnZXIuZGVidWcoXG5cdFx0XHRcdFx0J3Jlc3RhcnRJY2UoKSB8IGNhbGxpbmcgcGMuc2V0TG9jYWxEZXNjcmlwdGlvbigpIFthbnN3ZXI6JW9dJyxcblx0XHRcdFx0XHRhbnN3ZXIpO1xuXG5cdFx0XHRcdHJldHVybiB0aGlzLl9wYy5zZXRMb2NhbERlc2NyaXB0aW9uKGFuc3dlcik7XG5cdFx0XHR9KTtcblx0fVxuXG5cdF9zZXR1cFRyYW5zcG9ydCgpXG5cdHtcblx0XHRsb2dnZXIuZGVidWcoJ19zZXR1cFRyYW5zcG9ydCgpJyk7XG5cblx0XHRyZXR1cm4gUHJvbWlzZS5yZXNvbHZlKClcblx0XHRcdC50aGVuKCgpID0+XG5cdFx0XHR7XG5cdFx0XHRcdC8vIFdlIG5lZWQgdHJhbnNwb3J0IHJlbW90ZSBwYXJhbWV0ZXJzLlxuXHRcdFx0XHRyZXR1cm4gdGhpcy5zYWZlRW1pdEFzUHJvbWlzZSgnQG5lZWRjcmVhdGV0cmFuc3BvcnQnLCBudWxsKTtcblx0XHRcdH0pXG5cdFx0XHQudGhlbigodHJhbnNwb3J0UmVtb3RlUGFyYW1ldGVycykgPT5cblx0XHRcdHtcblx0XHRcdFx0Ly8gUHJvdmlkZSB0aGUgcmVtb3RlIFNEUCBoYW5kbGVyIHdpdGggdHJhbnNwb3J0IHJlbW90ZSBwYXJhbWV0ZXJzLlxuXHRcdFx0XHR0aGlzLl9yZW1vdGVTZHAuc2V0VHJhbnNwb3J0UmVtb3RlUGFyYW1ldGVycyh0cmFuc3BvcnRSZW1vdGVQYXJhbWV0ZXJzKTtcblxuXHRcdFx0XHR0aGlzLl90cmFuc3BvcnRDcmVhdGVkID0gdHJ1ZTtcblx0XHRcdH0pO1xuXHR9XG5cblx0X3VwZGF0ZVRyYW5zcG9ydCgpXG5cdHtcblx0XHRsb2dnZXIuZGVidWcoJ191cGRhdGVUcmFuc3BvcnQoKScpO1xuXG5cdFx0Ly8gR2V0IG91ciBsb2NhbCBEVExTIHBhcmFtZXRlcnMuXG5cdFx0Ly8gY29uc3QgdHJhbnNwb3J0TG9jYWxQYXJhbWV0ZXJzID0ge307XG5cdFx0Y29uc3Qgc2RwID0gdGhpcy5fcGMubG9jYWxEZXNjcmlwdGlvbi5zZHA7XG5cdFx0Y29uc3Qgc2RwT2JqID0gc2RwVHJhbnNmb3JtLnBhcnNlKHNkcCk7XG5cdFx0Y29uc3QgZHRsc1BhcmFtZXRlcnMgPSBzZHBDb21tb25VdGlscy5leHRyYWN0RHRsc1BhcmFtZXRlcnMoc2RwT2JqKTtcblx0XHRjb25zdCB0cmFuc3BvcnRMb2NhbFBhcmFtZXRlcnMgPSB7IGR0bHNQYXJhbWV0ZXJzIH07XG5cblx0XHQvLyBXZSBuZWVkIHRvIHByb3ZpZGUgdHJhbnNwb3J0IGxvY2FsIHBhcmFtZXRlcnMuXG5cdFx0dGhpcy5zYWZlRW1pdCgnQG5lZWR1cGRhdGV0cmFuc3BvcnQnLCB0cmFuc3BvcnRMb2NhbFBhcmFtZXRlcnMpO1xuXG5cdFx0dGhpcy5fdHJhbnNwb3J0VXBkYXRlZCA9IHRydWU7XG5cdH1cbn1cblxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgRmlyZWZveDUwXG57XG5cdHN0YXRpYyBnZXQgdGFnKClcblx0e1xuXHRcdHJldHVybiAnRmlyZWZveDUwJztcblx0fVxuXG5cdHN0YXRpYyBnZXROYXRpdmVSdHBDYXBhYmlsaXRpZXMoKVxuXHR7XG5cdFx0bG9nZ2VyLmRlYnVnKCdnZXROYXRpdmVSdHBDYXBhYmlsaXRpZXMoKScpO1xuXG5cdFx0Y29uc3QgcGMgPSBuZXcgUlRDUGVlckNvbm5lY3Rpb24oXG5cdFx0XHR7XG5cdFx0XHRcdGljZVNlcnZlcnMgICAgICAgICA6IFtdLFxuXHRcdFx0XHRpY2VUcmFuc3BvcnRQb2xpY3kgOiAnYWxsJyxcblx0XHRcdFx0YnVuZGxlUG9saWN5ICAgICAgIDogJ21heC1idW5kbGUnLFxuXHRcdFx0XHRydGNwTXV4UG9saWN5ICAgICAgOiAncmVxdWlyZSdcblx0XHRcdH0pO1xuXG5cdFx0Ly8gTk9URTogV2UgbmVlZCB0byBhZGQgYSByZWFsIHZpZGVvIHRyYWNrIHRvIGdldCB0aGUgUklEIGV4dGVuc2lvbiBtYXBwaW5nLlxuXHRcdGNvbnN0IGNhbnZhcyA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2NhbnZhcycpO1xuXG5cdFx0Ly8gTk9URTogT3RoZXJ3aXNlIEZpcmVmb3ggZmFpbHMgaW4gbmV4dCBsaW5lLlxuXHRcdGNhbnZhcy5nZXRDb250ZXh0KCcyZCcpO1xuXG5cdFx0Y29uc3QgZmFrZVN0cmVhbSA9IGNhbnZhcy5jYXB0dXJlU3RyZWFtKCk7XG5cdFx0Y29uc3QgZmFrZVZpZGVvVHJhY2sgPSBmYWtlU3RyZWFtLmdldFZpZGVvVHJhY2tzKClbMF07XG5cdFx0Y29uc3QgcnRwU2VuZGVyID0gcGMuYWRkVHJhY2soZmFrZVZpZGVvVHJhY2ssIGZha2VTdHJlYW0pO1xuXG5cdFx0cnRwU2VuZGVyLnNldFBhcmFtZXRlcnMoXG5cdFx0XHR7XG5cdFx0XHRcdGVuY29kaW5ncyA6XG5cdFx0XHRcdFtcblx0XHRcdFx0XHR7IHJpZDogJ1JJRDEnLCBtYXhCaXRyYXRlOiA0MDAwMCB9LFxuXHRcdFx0XHRcdHsgcmlkOiAnUklEMicsIG1heEJpdHJhdGU6IDEwMDAwIH1cblx0XHRcdFx0XVxuXHRcdFx0fSk7XG5cblx0XHRyZXR1cm4gcGMuY3JlYXRlT2ZmZXIoXG5cdFx0XHR7XG5cdFx0XHRcdG9mZmVyVG9SZWNlaXZlQXVkaW8gOiB0cnVlLFxuXHRcdFx0XHRvZmZlclRvUmVjZWl2ZVZpZGVvIDogdHJ1ZVxuXHRcdFx0fSlcblx0XHRcdC50aGVuKChvZmZlcikgPT5cblx0XHRcdHtcblx0XHRcdFx0dHJ5IHsgY2FudmFzLnJlbW92ZSgpOyB9XG5cdFx0XHRcdGNhdGNoIChlcnJvcikge31cblxuXHRcdFx0XHR0cnkgeyBwYy5jbG9zZSgpOyB9XG5cdFx0XHRcdGNhdGNoIChlcnJvcikge31cblxuXHRcdFx0XHRjb25zdCBzZHBPYmogPSBzZHBUcmFuc2Zvcm0ucGFyc2Uob2ZmZXIuc2RwKTtcblx0XHRcdFx0Y29uc3QgbmF0aXZlUnRwQ2FwYWJpbGl0aWVzID0gc2RwQ29tbW9uVXRpbHMuZXh0cmFjdFJ0cENhcGFiaWxpdGllcyhzZHBPYmopO1xuXG5cdFx0XHRcdHJldHVybiBuYXRpdmVSdHBDYXBhYmlsaXRpZXM7XG5cdFx0XHR9KVxuXHRcdFx0LmNhdGNoKChlcnJvcikgPT5cblx0XHRcdHtcblx0XHRcdFx0dHJ5IHsgY2FudmFzLnJlbW92ZSgpOyB9XG5cdFx0XHRcdGNhdGNoIChlcnJvcjIpIHt9XG5cblx0XHRcdFx0dHJ5IHsgcGMuY2xvc2UoKTsgfVxuXHRcdFx0XHRjYXRjaCAoZXJyb3IyKSB7fVxuXG5cdFx0XHRcdHRocm93IGVycm9yO1xuXHRcdFx0fSk7XG5cdH1cblxuXHRjb25zdHJ1Y3RvcihkaXJlY3Rpb24sIGV4dGVuZGVkUnRwQ2FwYWJpbGl0aWVzLCBzZXR0aW5ncylcblx0e1xuXHRcdGxvZ2dlci5kZWJ1Zyhcblx0XHRcdCdjb25zdHJ1Y3RvcigpIFtkaXJlY3Rpb246JXMsIGV4dGVuZGVkUnRwQ2FwYWJpbGl0aWVzOiVvXScsXG5cdFx0XHRkaXJlY3Rpb24sIGV4dGVuZGVkUnRwQ2FwYWJpbGl0aWVzKTtcblxuXHRcdGxldCBydHBQYXJhbWV0ZXJzQnlLaW5kO1xuXG5cdFx0c3dpdGNoIChkaXJlY3Rpb24pXG5cdFx0e1xuXHRcdFx0Y2FzZSAnc2VuZCc6XG5cdFx0XHR7XG5cdFx0XHRcdHJ0cFBhcmFtZXRlcnNCeUtpbmQgPVxuXHRcdFx0XHR7XG5cdFx0XHRcdFx0YXVkaW8gOiBvcnRjLmdldFNlbmRpbmdSdHBQYXJhbWV0ZXJzKCdhdWRpbycsIGV4dGVuZGVkUnRwQ2FwYWJpbGl0aWVzKSxcblx0XHRcdFx0XHR2aWRlbyA6IG9ydGMuZ2V0U2VuZGluZ1J0cFBhcmFtZXRlcnMoJ3ZpZGVvJywgZXh0ZW5kZWRSdHBDYXBhYmlsaXRpZXMpXG5cdFx0XHRcdH07XG5cblx0XHRcdFx0cmV0dXJuIG5ldyBTZW5kSGFuZGxlcihydHBQYXJhbWV0ZXJzQnlLaW5kLCBzZXR0aW5ncyk7XG5cdFx0XHR9XG5cdFx0XHRjYXNlICdyZWN2Jzpcblx0XHRcdHtcblx0XHRcdFx0cnRwUGFyYW1ldGVyc0J5S2luZCA9XG5cdFx0XHRcdHtcblx0XHRcdFx0XHRhdWRpbyA6IG9ydGMuZ2V0UmVjZWl2aW5nRnVsbFJ0cFBhcmFtZXRlcnMoJ2F1ZGlvJywgZXh0ZW5kZWRSdHBDYXBhYmlsaXRpZXMpLFxuXHRcdFx0XHRcdHZpZGVvIDogb3J0Yy5nZXRSZWNlaXZpbmdGdWxsUnRwUGFyYW1ldGVycygndmlkZW8nLCBleHRlbmRlZFJ0cENhcGFiaWxpdGllcylcblx0XHRcdFx0fTtcblxuXHRcdFx0XHRyZXR1cm4gbmV3IFJlY3ZIYW5kbGVyKHJ0cFBhcmFtZXRlcnNCeUtpbmQsIHNldHRpbmdzKTtcblx0XHRcdH1cblx0XHR9XG5cdH1cbn1cbiIsImltcG9ydCBzZHBUcmFuc2Zvcm0gZnJvbSAnc2RwLXRyYW5zZm9ybSc7XG5pbXBvcnQgTG9nZ2VyIGZyb20gJy4uL0xvZ2dlcic7XG5pbXBvcnQgRW5oYW5jZWRFdmVudEVtaXR0ZXIgZnJvbSAnLi4vRW5oYW5jZWRFdmVudEVtaXR0ZXInO1xuaW1wb3J0ICogYXMgdXRpbHMgZnJvbSAnLi4vdXRpbHMnO1xuaW1wb3J0ICogYXMgb3J0YyBmcm9tICcuLi9vcnRjJztcbmltcG9ydCAqIGFzIHNkcENvbW1vblV0aWxzIGZyb20gJy4vc2RwL2NvbW1vblV0aWxzJztcbmltcG9ydCAqIGFzIHNkcFVuaWZpZWRQbGFuVXRpbHMgZnJvbSAnLi9zZHAvdW5pZmllZFBsYW5VdGlscyc7XG5pbXBvcnQgUmVtb3RlVW5pZmllZFBsYW5TZHAgZnJvbSAnLi9zZHAvUmVtb3RlVW5pZmllZFBsYW5TZHAnO1xuXG5jb25zdCBsb2dnZXIgPSBuZXcgTG9nZ2VyKCdGaXJlZm94NTknKTtcblxuY2xhc3MgSGFuZGxlciBleHRlbmRzIEVuaGFuY2VkRXZlbnRFbWl0dGVyXG57XG5cdGNvbnN0cnVjdG9yKGRpcmVjdGlvbiwgcnRwUGFyYW1ldGVyc0J5S2luZCwgc2V0dGluZ3MpXG5cdHtcblx0XHRzdXBlcihsb2dnZXIpO1xuXG5cdFx0Ly8gUlRDUGVlckNvbm5lY3Rpb24gaW5zdGFuY2UuXG5cdFx0Ly8gQHR5cGUge1JUQ1BlZXJDb25uZWN0aW9ufVxuXHRcdHRoaXMuX3BjID0gbmV3IFJUQ1BlZXJDb25uZWN0aW9uKFxuXHRcdFx0e1xuXHRcdFx0XHRpY2VTZXJ2ZXJzICAgICAgICAgOiBzZXR0aW5ncy50dXJuU2VydmVycyB8fCBbXSxcblx0XHRcdFx0aWNlVHJhbnNwb3J0UG9saWN5IDogJ2FsbCcsXG5cdFx0XHRcdGJ1bmRsZVBvbGljeSAgICAgICA6ICdtYXgtYnVuZGxlJyxcblx0XHRcdFx0cnRjcE11eFBvbGljeSAgICAgIDogJ3JlcXVpcmUnXG5cdFx0XHR9KTtcblxuXHRcdC8vIEdlbmVyaWMgc2VuZGluZyBSVFAgcGFyYW1ldGVycyBmb3IgYXVkaW8gYW5kIHZpZGVvLlxuXHRcdC8vIEB0eXBlIHtPYmplY3R9XG5cdFx0dGhpcy5fcnRwUGFyYW1ldGVyc0J5S2luZCA9IHJ0cFBhcmFtZXRlcnNCeUtpbmQ7XG5cblx0XHQvLyBSZW1vdGUgU0RQIGhhbmRsZXIuXG5cdFx0Ly8gQHR5cGUge1JlbW90ZVVuaWZpZWRQbGFuU2RwfVxuXHRcdHRoaXMuX3JlbW90ZVNkcCA9IG5ldyBSZW1vdGVVbmlmaWVkUGxhblNkcChkaXJlY3Rpb24sIHJ0cFBhcmFtZXRlcnNCeUtpbmQpO1xuXG5cdFx0Ly8gSGFuZGxlIFJUQ1BlZXJDb25uZWN0aW9uIGNvbm5lY3Rpb24gc3RhdHVzLlxuXHRcdHRoaXMuX3BjLmFkZEV2ZW50TGlzdGVuZXIoJ2ljZWNvbm5lY3Rpb25zdGF0ZWNoYW5nZScsICgpID0+XG5cdFx0e1xuXHRcdFx0c3dpdGNoICh0aGlzLl9wYy5pY2VDb25uZWN0aW9uU3RhdGUpXG5cdFx0XHR7XG5cdFx0XHRcdGNhc2UgJ2NoZWNraW5nJzpcblx0XHRcdFx0XHR0aGlzLmVtaXQoJ0Bjb25uZWN0aW9uc3RhdGVjaGFuZ2UnLCAnY29ubmVjdGluZycpO1xuXHRcdFx0XHRcdGJyZWFrO1xuXHRcdFx0XHRjYXNlICdjb25uZWN0ZWQnOlxuXHRcdFx0XHRjYXNlICdjb21wbGV0ZWQnOlxuXHRcdFx0XHRcdHRoaXMuZW1pdCgnQGNvbm5lY3Rpb25zdGF0ZWNoYW5nZScsICdjb25uZWN0ZWQnKTtcblx0XHRcdFx0XHRicmVhaztcblx0XHRcdFx0Y2FzZSAnZmFpbGVkJzpcblx0XHRcdFx0XHR0aGlzLmVtaXQoJ0Bjb25uZWN0aW9uc3RhdGVjaGFuZ2UnLCAnZmFpbGVkJyk7XG5cdFx0XHRcdFx0YnJlYWs7XG5cdFx0XHRcdGNhc2UgJ2Rpc2Nvbm5lY3RlZCc6XG5cdFx0XHRcdFx0dGhpcy5lbWl0KCdAY29ubmVjdGlvbnN0YXRlY2hhbmdlJywgJ2Rpc2Nvbm5lY3RlZCcpO1xuXHRcdFx0XHRcdGJyZWFrO1xuXHRcdFx0XHRjYXNlICdjbG9zZWQnOlxuXHRcdFx0XHRcdHRoaXMuZW1pdCgnQGNvbm5lY3Rpb25zdGF0ZWNoYW5nZScsICdjbG9zZWQnKTtcblx0XHRcdFx0XHRicmVhaztcblx0XHRcdH1cblx0XHR9KTtcblx0fVxuXG5cdGNsb3NlKClcblx0e1xuXHRcdGxvZ2dlci5kZWJ1ZygnY2xvc2UoKScpO1xuXG5cdFx0Ly8gQ2xvc2UgUlRDUGVlckNvbm5lY3Rpb24uXG5cdFx0dHJ5IHsgdGhpcy5fcGMuY2xvc2UoKTsgfVxuXHRcdGNhdGNoIChlcnJvcikge31cblx0fVxufVxuXG5jbGFzcyBTZW5kSGFuZGxlciBleHRlbmRzIEhhbmRsZXJcbntcblx0Y29uc3RydWN0b3IocnRwUGFyYW1ldGVyc0J5S2luZCwgc2V0dGluZ3MpXG5cdHtcblx0XHRzdXBlcignc2VuZCcsIHJ0cFBhcmFtZXRlcnNCeUtpbmQsIHNldHRpbmdzKTtcblxuXHRcdC8vIEdvdCB0cmFuc3BvcnQgbG9jYWwgYW5kIHJlbW90ZSBwYXJhbWV0ZXJzLlxuXHRcdC8vIEB0eXBlIHtCb29sZWFufVxuXHRcdHRoaXMuX3RyYW5zcG9ydFJlYWR5ID0gZmFsc2U7XG5cblx0XHQvLyBMb2NhbCBzdHJlYW0uXG5cdFx0Ly8gQHR5cGUge01lZGlhU3RyZWFtfVxuXHRcdHRoaXMuX3N0cmVhbSA9IG5ldyBNZWRpYVN0cmVhbSgpO1xuXG5cdFx0Ly8gUklEIHZhbHVlIGNvdW50ZXIgZm9yIHNpbXVsY2FzdCAoc28gdGhleSBuZXZlciBtYXRjaCkuXG5cdFx0Ly8gQHR5cGUge051bWJlcn1cblx0XHR0aGlzLl9uZXh0UmlkID0gMTtcblx0fVxuXG5cdGFkZFByb2R1Y2VyKHByb2R1Y2VyKVxuXHR7XG5cdFx0Y29uc3QgeyB0cmFjayB9ID0gcHJvZHVjZXI7XG5cblx0XHRsb2dnZXIuZGVidWcoXG5cdFx0XHQnYWRkUHJvZHVjZXIoKSBbaWQ6JXMsIGtpbmQ6JXMsIHRyYWNrSWQ6JXNdJyxcblx0XHRcdHByb2R1Y2VyLmlkLCBwcm9kdWNlci5raW5kLCB0cmFjay5pZCk7XG5cblx0XHRpZiAodGhpcy5fc3RyZWFtLmdldFRyYWNrQnlJZCh0cmFjay5pZCkpXG5cdFx0XHRyZXR1cm4gUHJvbWlzZS5yZWplY3QobmV3IEVycm9yKCd0cmFjayBhbHJlYWR5IGFkZGVkJykpO1xuXG5cdFx0bGV0IHJ0cFNlbmRlcjtcblx0XHRsZXQgbG9jYWxTZHBPYmo7XG5cblx0XHRyZXR1cm4gUHJvbWlzZS5yZXNvbHZlKClcblx0XHRcdC50aGVuKCgpID0+XG5cdFx0XHR7XG5cdFx0XHRcdHRoaXMuX3N0cmVhbS5hZGRUcmFjayh0cmFjayk7XG5cblx0XHRcdFx0Ly8gQWRkIHRoZSBzdHJlYW0gdG8gdGhlIFBlZXJDb25uZWN0aW9uLlxuXHRcdFx0XHRydHBTZW5kZXIgPSB0aGlzLl9wYy5hZGRUcmFjayh0cmFjaywgdGhpcy5fc3RyZWFtKTtcblx0XHRcdH0pXG5cdFx0XHQudGhlbigoKSA9PlxuXHRcdFx0e1xuXHRcdFx0XHQvLyBJZiBzaW11bGNhc3QgaXMgbm90IGVuYWJsZWQsIGRvIG5vdGhpbmcuXG5cdFx0XHRcdGlmICghcHJvZHVjZXIuc2ltdWxjYXN0KVxuXHRcdFx0XHRcdHJldHVybjtcblxuXHRcdFx0XHRsb2dnZXIuZGVidWcoJ2FkZFByb2R1Y2VyKCkgfCBlbmFibGluZyBzaW11bGNhc3QnKTtcblxuXHRcdFx0XHRjb25zdCBlbmNvZGluZ3MgPSBbXTtcblxuXHRcdFx0XHRpZiAocHJvZHVjZXIuc2ltdWxjYXN0LmhpZ2gpXG5cdFx0XHRcdHtcblx0XHRcdFx0XHRlbmNvZGluZ3MucHVzaChcblx0XHRcdFx0XHRcdHtcblx0XHRcdFx0XHRcdFx0cmlkICAgICAgICA6IGBoaWdoJHt0aGlzLl9uZXh0UmlkfWAsXG5cdFx0XHRcdFx0XHRcdGFjdGl2ZSAgICAgOiB0cnVlLFxuXHRcdFx0XHRcdFx0XHRwcmlvcml0eSAgIDogJ2hpZ2gnLFxuXHRcdFx0XHRcdFx0XHRtYXhCaXRyYXRlIDogcHJvZHVjZXIuc2ltdWxjYXN0LmhpZ2hcblx0XHRcdFx0XHRcdH0pO1xuXHRcdFx0XHR9XG5cblx0XHRcdFx0aWYgKHByb2R1Y2VyLnNpbXVsY2FzdC5tZWRpdW0pXG5cdFx0XHRcdHtcblx0XHRcdFx0XHRlbmNvZGluZ3MucHVzaChcblx0XHRcdFx0XHRcdHtcblx0XHRcdFx0XHRcdFx0cmlkICAgICAgICA6IGBtZWRpdW0ke3RoaXMuX25leHRSaWR9YCxcblx0XHRcdFx0XHRcdFx0YWN0aXZlICAgICA6IHRydWUsXG5cdFx0XHRcdFx0XHRcdHByaW9yaXR5ICAgOiAnbWVkaXVtJyxcblx0XHRcdFx0XHRcdFx0bWF4Qml0cmF0ZSA6IHByb2R1Y2VyLnNpbXVsY2FzdC5tZWRpdW1cblx0XHRcdFx0XHRcdH0pO1xuXHRcdFx0XHR9XG5cblx0XHRcdFx0aWYgKHByb2R1Y2VyLnNpbXVsY2FzdC5sb3cpXG5cdFx0XHRcdHtcblx0XHRcdFx0XHRlbmNvZGluZ3MucHVzaChcblx0XHRcdFx0XHRcdHtcblx0XHRcdFx0XHRcdFx0cmlkICAgICAgICA6IGBsb3cke3RoaXMuX25leHRSaWR9YCxcblx0XHRcdFx0XHRcdFx0YWN0aXZlICAgICA6IHRydWUsXG5cdFx0XHRcdFx0XHRcdHByaW9yaXR5ICAgOiAnbG93Jyxcblx0XHRcdFx0XHRcdFx0bWF4Qml0cmF0ZSA6IHByb2R1Y2VyLnNpbXVsY2FzdC5sb3dcblx0XHRcdFx0XHRcdH0pO1xuXHRcdFx0XHR9XG5cblx0XHRcdFx0Ly8gVXBkYXRlIFJJRCBjb3VudGVyIGZvciBmdXR1cmUgb25lcy5cblx0XHRcdFx0dGhpcy5fbmV4dFJpZCsrO1xuXG5cdFx0XHRcdHJldHVybiBydHBTZW5kZXIuc2V0UGFyYW1ldGVycyh7IGVuY29kaW5ncyB9KTtcblx0XHRcdH0pXG5cdFx0XHQudGhlbigoKSA9PlxuXHRcdFx0e1xuXHRcdFx0XHRyZXR1cm4gdGhpcy5fcGMuY3JlYXRlT2ZmZXIoKTtcblx0XHRcdH0pXG5cdFx0XHQudGhlbigob2ZmZXIpID0+XG5cdFx0XHR7XG5cdFx0XHRcdGxvZ2dlci5kZWJ1Zyhcblx0XHRcdFx0XHQnYWRkUHJvZHVjZXIoKSB8IGNhbGxpbmcgcGMuc2V0TG9jYWxEZXNjcmlwdGlvbigpIFtvZmZlcjolb10nLFxuXHRcdFx0XHRcdG9mZmVyKTtcblxuXHRcdFx0XHRyZXR1cm4gdGhpcy5fcGMuc2V0TG9jYWxEZXNjcmlwdGlvbihvZmZlcik7XG5cdFx0XHR9KVxuXHRcdFx0LnRoZW4oKCkgPT5cblx0XHRcdHtcblx0XHRcdFx0aWYgKCF0aGlzLl90cmFuc3BvcnRSZWFkeSlcblx0XHRcdFx0XHRyZXR1cm4gdGhpcy5fc2V0dXBUcmFuc3BvcnQoKTtcblx0XHRcdH0pXG5cdFx0XHQudGhlbigoKSA9PlxuXHRcdFx0e1xuXHRcdFx0XHRsb2NhbFNkcE9iaiA9IHNkcFRyYW5zZm9ybS5wYXJzZSh0aGlzLl9wYy5sb2NhbERlc2NyaXB0aW9uLnNkcCk7XG5cblx0XHRcdFx0Y29uc3QgcmVtb3RlU2RwID0gdGhpcy5fcmVtb3RlU2RwLmNyZWF0ZUFuc3dlclNkcChsb2NhbFNkcE9iaik7XG5cdFx0XHRcdGNvbnN0IGFuc3dlciA9IHsgdHlwZTogJ2Fuc3dlcicsIHNkcDogcmVtb3RlU2RwIH07XG5cblx0XHRcdFx0bG9nZ2VyLmRlYnVnKFxuXHRcdFx0XHRcdCdhZGRQcm9kdWNlcigpIHwgY2FsbGluZyBwYy5zZXRSZW1vdGVEZXNjcmlwdGlvbigpIFthbnN3ZXI6JW9dJyxcblx0XHRcdFx0XHRhbnN3ZXIpO1xuXG5cdFx0XHRcdHJldHVybiB0aGlzLl9wYy5zZXRSZW1vdGVEZXNjcmlwdGlvbihhbnN3ZXIpO1xuXHRcdFx0fSlcblx0XHRcdC50aGVuKCgpID0+XG5cdFx0XHR7XG5cdFx0XHRcdGNvbnN0IHJ0cFBhcmFtZXRlcnMgPSB1dGlscy5jbG9uZSh0aGlzLl9ydHBQYXJhbWV0ZXJzQnlLaW5kW3Byb2R1Y2VyLmtpbmRdKTtcblxuXHRcdFx0XHQvLyBGaWxsIHRoZSBSVFAgcGFyYW1ldGVycyBmb3IgdGhpcyB0cmFjay5cblx0XHRcdFx0c2RwVW5pZmllZFBsYW5VdGlscy5maWxsUnRwUGFyYW1ldGVyc0ZvclRyYWNrKFxuXHRcdFx0XHRcdHJ0cFBhcmFtZXRlcnMsIGxvY2FsU2RwT2JqLCB0cmFjayk7XG5cblx0XHRcdFx0cmV0dXJuIHJ0cFBhcmFtZXRlcnM7XG5cdFx0XHR9KVxuXHRcdFx0LmNhdGNoKChlcnJvcikgPT5cblx0XHRcdHtcblx0XHRcdFx0Ly8gUGFuaWMgaGVyZS4gVHJ5IHRvIHVuZG8gdGhpbmdzLlxuXG5cdFx0XHRcdHRyeSB7IHRoaXMuX3BjLnJlbW92ZVRyYWNrKHJ0cFNlbmRlcik7IH1cblx0XHRcdFx0Y2F0Y2ggKGVycm9yMikge31cblxuXHRcdFx0XHR0aGlzLl9zdHJlYW0ucmVtb3ZlVHJhY2sodHJhY2spO1xuXG5cdFx0XHRcdHRocm93IGVycm9yO1xuXHRcdFx0fSk7XG5cdH1cblxuXHRyZW1vdmVQcm9kdWNlcihwcm9kdWNlcilcblx0e1xuXHRcdGNvbnN0IHsgdHJhY2sgfSA9IHByb2R1Y2VyO1xuXG5cdFx0bG9nZ2VyLmRlYnVnKFxuXHRcdFx0J3JlbW92ZVByb2R1Y2VyKCkgW2lkOiVzLCBraW5kOiVzLCB0cmFja0lkOiVzXScsXG5cdFx0XHRwcm9kdWNlci5pZCwgcHJvZHVjZXIua2luZCwgdHJhY2suaWQpO1xuXG5cdFx0cmV0dXJuIFByb21pc2UucmVzb2x2ZSgpXG5cdFx0XHQudGhlbigoKSA9PlxuXHRcdFx0e1xuXHRcdFx0XHQvLyBHZXQgdGhlIGFzc29jaWF0ZWQgUlRDUnRwU2VuZGVyLlxuXHRcdFx0XHRjb25zdCBydHBTZW5kZXIgPSB0aGlzLl9wYy5nZXRTZW5kZXJzKClcblx0XHRcdFx0XHQuZmluZCgocykgPT4gcy50cmFjayA9PT0gdHJhY2spO1xuXG5cdFx0XHRcdGlmICghcnRwU2VuZGVyKVxuXHRcdFx0XHRcdHRocm93IG5ldyBFcnJvcignUlRDUnRwU2VuZGVyIGZvdW5kJyk7XG5cblx0XHRcdFx0Ly8gUmVtb3ZlIHRoZSBhc3NvY2lhdGVkIFJ0cFNlbmRlci5cblx0XHRcdFx0dGhpcy5fcGMucmVtb3ZlVHJhY2socnRwU2VuZGVyKTtcblxuXHRcdFx0XHQvLyBSZW1vdmUgdGhlIHRyYWNrIGZyb20gdGhlIGxvY2FsIHN0cmVhbS5cblx0XHRcdFx0dGhpcy5fc3RyZWFtLnJlbW92ZVRyYWNrKHRyYWNrKTtcblxuXHRcdFx0XHRyZXR1cm4gUHJvbWlzZS5yZXNvbHZlKClcblx0XHRcdFx0XHQudGhlbigoKSA9PlxuXHRcdFx0XHRcdHtcblx0XHRcdFx0XHRcdHJldHVybiB0aGlzLl9wYy5jcmVhdGVPZmZlcigpO1xuXHRcdFx0XHRcdH0pXG5cdFx0XHRcdFx0LnRoZW4oKG9mZmVyKSA9PlxuXHRcdFx0XHRcdHtcblx0XHRcdFx0XHRcdGxvZ2dlci5kZWJ1Zyhcblx0XHRcdFx0XHRcdFx0J3JlbW92ZVByb2R1Y2VyKCkgfCBjYWxsaW5nIHBjLnNldExvY2FsRGVzY3JpcHRpb24oKSBbb2ZmZXI6JW9dJyxcblx0XHRcdFx0XHRcdFx0b2ZmZXIpO1xuXG5cdFx0XHRcdFx0XHRyZXR1cm4gdGhpcy5fcGMuc2V0TG9jYWxEZXNjcmlwdGlvbihvZmZlcik7XG5cdFx0XHRcdFx0fSk7XG5cdFx0XHR9KVxuXHRcdFx0LnRoZW4oKCkgPT5cblx0XHRcdHtcblx0XHRcdFx0Y29uc3QgbG9jYWxTZHBPYmogPSBzZHBUcmFuc2Zvcm0ucGFyc2UodGhpcy5fcGMubG9jYWxEZXNjcmlwdGlvbi5zZHApO1xuXHRcdFx0XHRjb25zdCByZW1vdGVTZHAgPSB0aGlzLl9yZW1vdGVTZHAuY3JlYXRlQW5zd2VyU2RwKGxvY2FsU2RwT2JqKTtcblx0XHRcdFx0Y29uc3QgYW5zd2VyID0geyB0eXBlOiAnYW5zd2VyJywgc2RwOiByZW1vdGVTZHAgfTtcblxuXHRcdFx0XHRsb2dnZXIuZGVidWcoXG5cdFx0XHRcdFx0J3JlbW92ZVByb2R1Y2VyKCkgfCBjYWxsaW5nIHBjLnNldFJlbW90ZURlc2NyaXB0aW9uKCkgW2Fuc3dlcjolb10nLFxuXHRcdFx0XHRcdGFuc3dlcik7XG5cblx0XHRcdFx0cmV0dXJuIHRoaXMuX3BjLnNldFJlbW90ZURlc2NyaXB0aW9uKGFuc3dlcik7XG5cdFx0XHR9KTtcblx0fVxuXG5cdHJlcGxhY2VQcm9kdWNlclRyYWNrKHByb2R1Y2VyLCB0cmFjaylcblx0e1xuXHRcdGxvZ2dlci5kZWJ1Zyhcblx0XHRcdCdyZXBsYWNlUHJvZHVjZXJUcmFjaygpIFtpZDolcywga2luZDolcywgdHJhY2tJZDolc10nLFxuXHRcdFx0cHJvZHVjZXIuaWQsIHByb2R1Y2VyLmtpbmQsIHRyYWNrLmlkKTtcblxuXHRcdGNvbnN0IG9sZFRyYWNrID0gcHJvZHVjZXIudHJhY2s7XG5cblx0XHRyZXR1cm4gUHJvbWlzZS5yZXNvbHZlKClcblx0XHRcdC50aGVuKCgpID0+XG5cdFx0XHR7XG5cdFx0XHRcdC8vIEdldCB0aGUgYXNzb2NpYXRlZCBSVENSdHBTZW5kZXIuXG5cdFx0XHRcdGNvbnN0IHJ0cFNlbmRlciA9IHRoaXMuX3BjLmdldFNlbmRlcnMoKVxuXHRcdFx0XHRcdC5maW5kKChzKSA9PiBzLnRyYWNrID09PSBvbGRUcmFjayk7XG5cblx0XHRcdFx0aWYgKCFydHBTZW5kZXIpXG5cdFx0XHRcdFx0dGhyb3cgbmV3IEVycm9yKCdsb2NhbCB0cmFjayBub3QgZm91bmQnKTtcblxuXHRcdFx0XHRyZXR1cm4gcnRwU2VuZGVyLnJlcGxhY2VUcmFjayh0cmFjayk7XG5cdFx0XHR9KVxuXHRcdFx0LnRoZW4oKCkgPT5cblx0XHRcdHtcblx0XHRcdFx0Ly8gUmVtb3ZlIHRoZSBvbGQgdHJhY2sgZnJvbSB0aGUgbG9jYWwgc3RyZWFtLlxuXHRcdFx0XHR0aGlzLl9zdHJlYW0ucmVtb3ZlVHJhY2sob2xkVHJhY2spO1xuXG5cdFx0XHRcdC8vIEFkZCB0aGUgbmV3IHRyYWNrIHRvIHRoZSBsb2NhbCBzdHJlYW0uXG5cdFx0XHRcdHRoaXMuX3N0cmVhbS5hZGRUcmFjayh0cmFjayk7XG5cdFx0XHR9KTtcblx0fVxuXG5cdHJlc3RhcnRJY2UocmVtb3RlSWNlUGFyYW1ldGVycylcblx0e1xuXHRcdGxvZ2dlci5kZWJ1ZygncmVzdGFydEljZSgpJyk7XG5cblx0XHQvLyBQcm92aWRlIHRoZSByZW1vdGUgU0RQIGhhbmRsZXIgd2l0aCBuZXcgcmVtb3RlIElDRSBwYXJhbWV0ZXJzLlxuXHRcdHRoaXMuX3JlbW90ZVNkcC51cGRhdGVUcmFuc3BvcnRSZW1vdGVJY2VQYXJhbWV0ZXJzKHJlbW90ZUljZVBhcmFtZXRlcnMpO1xuXG5cdFx0cmV0dXJuIFByb21pc2UucmVzb2x2ZSgpXG5cdFx0XHQudGhlbigoKSA9PlxuXHRcdFx0e1xuXHRcdFx0XHRyZXR1cm4gdGhpcy5fcGMuY3JlYXRlT2ZmZXIoeyBpY2VSZXN0YXJ0OiB0cnVlIH0pO1xuXHRcdFx0fSlcblx0XHRcdC50aGVuKChvZmZlcikgPT5cblx0XHRcdHtcblx0XHRcdFx0bG9nZ2VyLmRlYnVnKFxuXHRcdFx0XHRcdCdyZXN0YXJ0SWNlKCkgfCBjYWxsaW5nIHBjLnNldExvY2FsRGVzY3JpcHRpb24oKSBbb2ZmZXI6JW9dJyxcblx0XHRcdFx0XHRvZmZlcik7XG5cblx0XHRcdFx0cmV0dXJuIHRoaXMuX3BjLnNldExvY2FsRGVzY3JpcHRpb24ob2ZmZXIpO1xuXHRcdFx0fSlcblx0XHRcdC50aGVuKCgpID0+XG5cdFx0XHR7XG5cdFx0XHRcdGNvbnN0IGxvY2FsU2RwT2JqID0gc2RwVHJhbnNmb3JtLnBhcnNlKHRoaXMuX3BjLmxvY2FsRGVzY3JpcHRpb24uc2RwKTtcblx0XHRcdFx0Y29uc3QgcmVtb3RlU2RwID0gdGhpcy5fcmVtb3RlU2RwLmNyZWF0ZUFuc3dlclNkcChsb2NhbFNkcE9iaik7XG5cdFx0XHRcdGNvbnN0IGFuc3dlciA9IHsgdHlwZTogJ2Fuc3dlcicsIHNkcDogcmVtb3RlU2RwIH07XG5cblx0XHRcdFx0bG9nZ2VyLmRlYnVnKFxuXHRcdFx0XHRcdCdyZXN0YXJ0SWNlKCkgfCBjYWxsaW5nIHBjLnNldFJlbW90ZURlc2NyaXB0aW9uKCkgW2Fuc3dlcjolb10nLFxuXHRcdFx0XHRcdGFuc3dlcik7XG5cblx0XHRcdFx0cmV0dXJuIHRoaXMuX3BjLnNldFJlbW90ZURlc2NyaXB0aW9uKGFuc3dlcik7XG5cdFx0XHR9KTtcblx0fVxuXG5cdF9zZXR1cFRyYW5zcG9ydCgpXG5cdHtcblx0XHRsb2dnZXIuZGVidWcoJ19zZXR1cFRyYW5zcG9ydCgpJyk7XG5cblx0XHRyZXR1cm4gUHJvbWlzZS5yZXNvbHZlKClcblx0XHRcdC50aGVuKCgpID0+XG5cdFx0XHR7XG5cdFx0XHRcdC8vIEdldCBvdXIgbG9jYWwgRFRMUyBwYXJhbWV0ZXJzLlxuXHRcdFx0XHRjb25zdCB0cmFuc3BvcnRMb2NhbFBhcmFtZXRlcnMgPSB7fTtcblx0XHRcdFx0Y29uc3Qgc2RwID0gdGhpcy5fcGMubG9jYWxEZXNjcmlwdGlvbi5zZHA7XG5cdFx0XHRcdGNvbnN0IHNkcE9iaiA9IHNkcFRyYW5zZm9ybS5wYXJzZShzZHApO1xuXHRcdFx0XHRjb25zdCBkdGxzUGFyYW1ldGVycyA9IHNkcENvbW1vblV0aWxzLmV4dHJhY3REdGxzUGFyYW1ldGVycyhzZHBPYmopO1xuXG5cdFx0XHRcdC8vIExldCdzIGRlY2lkZSB0aGF0IHdlJ2xsIGJlIERUTFMgc2VydmVyIChiZWNhdXNlIHdlIGNhbikuXG5cdFx0XHRcdGR0bHNQYXJhbWV0ZXJzLnJvbGUgPSAnc2VydmVyJztcblxuXHRcdFx0XHR0cmFuc3BvcnRMb2NhbFBhcmFtZXRlcnMuZHRsc1BhcmFtZXRlcnMgPSBkdGxzUGFyYW1ldGVycztcblxuXHRcdFx0XHQvLyBQcm92aWRlIHRoZSByZW1vdGUgU0RQIGhhbmRsZXIgd2l0aCB0cmFuc3BvcnQgbG9jYWwgcGFyYW1ldGVycy5cblx0XHRcdFx0dGhpcy5fcmVtb3RlU2RwLnNldFRyYW5zcG9ydExvY2FsUGFyYW1ldGVycyh0cmFuc3BvcnRMb2NhbFBhcmFtZXRlcnMpO1xuXG5cdFx0XHRcdC8vIFdlIG5lZWQgdHJhbnNwb3J0IHJlbW90ZSBwYXJhbWV0ZXJzLlxuXHRcdFx0XHRyZXR1cm4gdGhpcy5zYWZlRW1pdEFzUHJvbWlzZShcblx0XHRcdFx0XHQnQG5lZWRjcmVhdGV0cmFuc3BvcnQnLCB0cmFuc3BvcnRMb2NhbFBhcmFtZXRlcnMpO1xuXHRcdFx0fSlcblx0XHRcdC50aGVuKCh0cmFuc3BvcnRSZW1vdGVQYXJhbWV0ZXJzKSA9PlxuXHRcdFx0e1xuXHRcdFx0XHQvLyBQcm92aWRlIHRoZSByZW1vdGUgU0RQIGhhbmRsZXIgd2l0aCB0cmFuc3BvcnQgcmVtb3RlIHBhcmFtZXRlcnMuXG5cdFx0XHRcdHRoaXMuX3JlbW90ZVNkcC5zZXRUcmFuc3BvcnRSZW1vdGVQYXJhbWV0ZXJzKHRyYW5zcG9ydFJlbW90ZVBhcmFtZXRlcnMpO1xuXG5cdFx0XHRcdHRoaXMuX3RyYW5zcG9ydFJlYWR5ID0gdHJ1ZTtcblx0XHRcdH0pO1xuXHR9XG59XG5cbmNsYXNzIFJlY3ZIYW5kbGVyIGV4dGVuZHMgSGFuZGxlclxue1xuXHRjb25zdHJ1Y3RvcihydHBQYXJhbWV0ZXJzQnlLaW5kLCBzZXR0aW5ncylcblx0e1xuXHRcdHN1cGVyKCdyZWN2JywgcnRwUGFyYW1ldGVyc0J5S2luZCwgc2V0dGluZ3MpO1xuXG5cdFx0Ly8gR290IHRyYW5zcG9ydCByZW1vdGUgcGFyYW1ldGVycy5cblx0XHQvLyBAdHlwZSB7Qm9vbGVhbn1cblx0XHR0aGlzLl90cmFuc3BvcnRDcmVhdGVkID0gZmFsc2U7XG5cblx0XHQvLyBHb3QgdHJhbnNwb3J0IGxvY2FsIHBhcmFtZXRlcnMuXG5cdFx0Ly8gQHR5cGUge0Jvb2xlYW59XG5cdFx0dGhpcy5fdHJhbnNwb3J0VXBkYXRlZCA9IGZhbHNlO1xuXG5cdFx0Ly8gTWFwIG9mIENvbnN1bWVycyBpbmZvcm1hdGlvbiBpbmRleGVkIGJ5IGNvbnN1bWVyLmlkLlxuXHRcdC8vIC0gbWlkIHtTdHJpbmd9XG5cdFx0Ly8gLSBraW5kIHtTdHJpbmd9XG5cdFx0Ly8gLSBjbG9zZWQge0Jvb2xlYW59XG5cdFx0Ly8gLSB0cmFja0lkIHtTdHJpbmd9XG5cdFx0Ly8gLSBzc3JjIHtOdW1iZXJ9XG5cdFx0Ly8gLSBydHhTc3JjIHtOdW1iZXJ9XG5cdFx0Ly8gLSBjbmFtZSB7U3RyaW5nfVxuXHRcdC8vIEB0eXBlIHtNYXA8TnVtYmVyLCBPYmplY3Q+fVxuXHRcdHRoaXMuX2NvbnN1bWVySW5mb3MgPSBuZXcgTWFwKCk7XG5cdH1cblxuXHRhZGRDb25zdW1lcihjb25zdW1lcilcblx0e1xuXHRcdGxvZ2dlci5kZWJ1Zyhcblx0XHRcdCdhZGRDb25zdW1lcigpIFtpZDolcywga2luZDolc10nLCBjb25zdW1lci5pZCwgY29uc3VtZXIua2luZCk7XG5cblx0XHRpZiAodGhpcy5fY29uc3VtZXJJbmZvcy5oYXMoY29uc3VtZXIuaWQpKVxuXHRcdFx0cmV0dXJuIFByb21pc2UucmVqZWN0KG5ldyBFcnJvcignQ29uc3VtZXIgYWxyZWFkeSBhZGRlZCcpKTtcblxuXHRcdGNvbnN0IGVuY29kaW5nID0gY29uc3VtZXIucnRwUGFyYW1ldGVycy5lbmNvZGluZ3NbMF07XG5cdFx0Y29uc3QgY25hbWUgPSBjb25zdW1lci5ydHBQYXJhbWV0ZXJzLnJ0Y3AuY25hbWU7XG5cdFx0Y29uc3QgY29uc3VtZXJJbmZvID1cblx0XHR7XG5cdFx0XHRtaWQgICAgICA6IGAke2NvbnN1bWVyLmtpbmRbMF19JHtjb25zdW1lci5pZH1gLFxuXHRcdFx0a2luZCAgICAgOiBjb25zdW1lci5raW5kLFxuXHRcdFx0Y2xvc2VkICAgOiBjb25zdW1lci5jbG9zZWQsXG5cdFx0XHRzdHJlYW1JZCA6IGByZWN2LXN0cmVhbS0ke2NvbnN1bWVyLmlkfWAsXG5cdFx0XHR0cmFja0lkICA6IGBjb25zdW1lci0ke2NvbnN1bWVyLmtpbmR9LSR7Y29uc3VtZXIuaWR9YCxcblx0XHRcdHNzcmMgICAgIDogZW5jb2Rpbmcuc3NyYyxcblx0XHRcdGNuYW1lICAgIDogY25hbWVcblx0XHR9O1xuXG5cdFx0aWYgKGVuY29kaW5nLnJ0eCAmJiBlbmNvZGluZy5ydHguc3NyYylcblx0XHRcdGNvbnN1bWVySW5mby5ydHhTc3JjID0gZW5jb2RpbmcucnR4LnNzcmM7XG5cblx0XHR0aGlzLl9jb25zdW1lckluZm9zLnNldChjb25zdW1lci5pZCwgY29uc3VtZXJJbmZvKTtcblxuXHRcdHJldHVybiBQcm9taXNlLnJlc29sdmUoKVxuXHRcdFx0LnRoZW4oKCkgPT5cblx0XHRcdHtcblx0XHRcdFx0aWYgKCF0aGlzLl90cmFuc3BvcnRDcmVhdGVkKVxuXHRcdFx0XHRcdHJldHVybiB0aGlzLl9zZXR1cFRyYW5zcG9ydCgpO1xuXHRcdFx0fSlcblx0XHRcdC50aGVuKCgpID0+XG5cdFx0XHR7XG5cdFx0XHRcdGNvbnN0IHJlbW90ZVNkcCA9IHRoaXMuX3JlbW90ZVNkcC5jcmVhdGVPZmZlclNkcChcblx0XHRcdFx0XHRBcnJheS5mcm9tKHRoaXMuX2NvbnN1bWVySW5mb3MudmFsdWVzKCkpKTtcblx0XHRcdFx0Y29uc3Qgb2ZmZXIgPSB7IHR5cGU6ICdvZmZlcicsIHNkcDogcmVtb3RlU2RwIH07XG5cblx0XHRcdFx0bG9nZ2VyLmRlYnVnKFxuXHRcdFx0XHRcdCdhZGRDb25zdW1lcigpIHwgY2FsbGluZyBwYy5zZXRSZW1vdGVEZXNjcmlwdGlvbigpIFtvZmZlcjolb10nLFxuXHRcdFx0XHRcdG9mZmVyKTtcblxuXHRcdFx0XHRyZXR1cm4gdGhpcy5fcGMuc2V0UmVtb3RlRGVzY3JpcHRpb24ob2ZmZXIpO1xuXHRcdFx0fSlcblx0XHRcdC50aGVuKCgpID0+XG5cdFx0XHR7XG5cdFx0XHRcdHJldHVybiB0aGlzLl9wYy5jcmVhdGVBbnN3ZXIoKTtcblx0XHRcdH0pXG5cdFx0XHQudGhlbigoYW5zd2VyKSA9PlxuXHRcdFx0e1xuXHRcdFx0XHRsb2dnZXIuZGVidWcoXG5cdFx0XHRcdFx0J2FkZENvbnN1bWVyKCkgfCBjYWxsaW5nIHBjLnNldExvY2FsRGVzY3JpcHRpb24oKSBbYW5zd2VyOiVvXScsXG5cdFx0XHRcdFx0YW5zd2VyKTtcblxuXHRcdFx0XHRyZXR1cm4gdGhpcy5fcGMuc2V0TG9jYWxEZXNjcmlwdGlvbihhbnN3ZXIpO1xuXHRcdFx0fSlcblx0XHRcdC50aGVuKCgpID0+XG5cdFx0XHR7XG5cdFx0XHRcdGlmICghdGhpcy5fdHJhbnNwb3J0VXBkYXRlZClcblx0XHRcdFx0XHRyZXR1cm4gdGhpcy5fdXBkYXRlVHJhbnNwb3J0KCk7XG5cdFx0XHR9KVxuXHRcdFx0LnRoZW4oKCkgPT5cblx0XHRcdHtcblx0XHRcdFx0Y29uc3QgbmV3VHJhbnNjZWl2ZXIgPSB0aGlzLl9wYy5nZXRUcmFuc2NlaXZlcnMoKVxuXHRcdFx0XHRcdC5maW5kKCh0cmFuc2NlaXZlcikgPT5cblx0XHRcdFx0XHR7XG5cdFx0XHRcdFx0XHRjb25zdCB7IHJlY2VpdmVyIH0gPSB0cmFuc2NlaXZlcjtcblxuXHRcdFx0XHRcdFx0aWYgKCFyZWNlaXZlcilcblx0XHRcdFx0XHRcdFx0cmV0dXJuIGZhbHNlO1xuXG5cdFx0XHRcdFx0XHRjb25zdCB7IHRyYWNrIH0gPSByZWNlaXZlcjtcblxuXHRcdFx0XHRcdFx0aWYgKCF0cmFjaylcblx0XHRcdFx0XHRcdFx0cmV0dXJuIGZhbHNlO1xuXG5cdFx0XHRcdFx0XHRyZXR1cm4gdHJhbnNjZWl2ZXIubWlkID09PSBjb25zdW1lckluZm8ubWlkO1xuXHRcdFx0XHRcdH0pO1xuXG5cdFx0XHRcdGlmICghbmV3VHJhbnNjZWl2ZXIpXG5cdFx0XHRcdFx0dGhyb3cgbmV3IEVycm9yKCdyZW1vdGUgdHJhY2sgbm90IGZvdW5kJyk7XG5cblx0XHRcdFx0cmV0dXJuIG5ld1RyYW5zY2VpdmVyLnJlY2VpdmVyLnRyYWNrO1xuXHRcdFx0fSk7XG5cdH1cblxuXHRyZW1vdmVDb25zdW1lcihjb25zdW1lcilcblx0e1xuXHRcdGxvZ2dlci5kZWJ1Zyhcblx0XHRcdCdyZW1vdmVDb25zdW1lcigpIFtpZDolcywga2luZDolc10nLCBjb25zdW1lci5pZCwgY29uc3VtZXIua2luZCk7XG5cblx0XHRjb25zdCBjb25zdW1lckluZm8gPSB0aGlzLl9jb25zdW1lckluZm9zLmdldChjb25zdW1lci5pZCk7XG5cblx0XHRpZiAoIWNvbnN1bWVySW5mbylcblx0XHRcdHJldHVybiBQcm9taXNlLnJlamVjdChuZXcgRXJyb3IoJ0NvbnN1bWVyIG5vdCBmb3VuZCcpKTtcblxuXHRcdGNvbnN1bWVySW5mby5jbG9zZWQgPSB0cnVlO1xuXG5cdFx0cmV0dXJuIFByb21pc2UucmVzb2x2ZSgpXG5cdFx0XHQudGhlbigoKSA9PlxuXHRcdFx0e1xuXHRcdFx0XHRjb25zdCByZW1vdGVTZHAgPSB0aGlzLl9yZW1vdGVTZHAuY3JlYXRlT2ZmZXJTZHAoXG5cdFx0XHRcdFx0QXJyYXkuZnJvbSh0aGlzLl9jb25zdW1lckluZm9zLnZhbHVlcygpKSk7XG5cdFx0XHRcdGNvbnN0IG9mZmVyID0geyB0eXBlOiAnb2ZmZXInLCBzZHA6IHJlbW90ZVNkcCB9O1xuXG5cdFx0XHRcdGxvZ2dlci5kZWJ1Zyhcblx0XHRcdFx0XHQncmVtb3ZlQ29uc3VtZXIoKSB8IGNhbGxpbmcgcGMuc2V0UmVtb3RlRGVzY3JpcHRpb24oKSBbb2ZmZXI6JW9dJyxcblx0XHRcdFx0XHRvZmZlcik7XG5cblx0XHRcdFx0cmV0dXJuIHRoaXMuX3BjLnNldFJlbW90ZURlc2NyaXB0aW9uKG9mZmVyKTtcblx0XHRcdH0pXG5cdFx0XHQudGhlbigoKSA9PlxuXHRcdFx0e1xuXHRcdFx0XHRyZXR1cm4gdGhpcy5fcGMuY3JlYXRlQW5zd2VyKCk7XG5cdFx0XHR9KVxuXHRcdFx0LnRoZW4oKGFuc3dlcikgPT5cblx0XHRcdHtcblx0XHRcdFx0bG9nZ2VyLmRlYnVnKFxuXHRcdFx0XHRcdCdyZW1vdmVDb25zdW1lcigpIHwgY2FsbGluZyBwYy5zZXRMb2NhbERlc2NyaXB0aW9uKCkgW2Fuc3dlcjolb10nLFxuXHRcdFx0XHRcdGFuc3dlcik7XG5cblx0XHRcdFx0cmV0dXJuIHRoaXMuX3BjLnNldExvY2FsRGVzY3JpcHRpb24oYW5zd2VyKTtcblx0XHRcdH0pO1xuXHR9XG5cblx0cmVzdGFydEljZShyZW1vdGVJY2VQYXJhbWV0ZXJzKVxuXHR7XG5cdFx0bG9nZ2VyLmRlYnVnKCdyZXN0YXJ0SWNlKCknKTtcblxuXHRcdC8vIFByb3ZpZGUgdGhlIHJlbW90ZSBTRFAgaGFuZGxlciB3aXRoIG5ldyByZW1vdGUgSUNFIHBhcmFtZXRlcnMuXG5cdFx0dGhpcy5fcmVtb3RlU2RwLnVwZGF0ZVRyYW5zcG9ydFJlbW90ZUljZVBhcmFtZXRlcnMocmVtb3RlSWNlUGFyYW1ldGVycyk7XG5cblx0XHRyZXR1cm4gUHJvbWlzZS5yZXNvbHZlKClcblx0XHRcdC50aGVuKCgpID0+XG5cdFx0XHR7XG5cdFx0XHRcdGNvbnN0IHJlbW90ZVNkcCA9IHRoaXMuX3JlbW90ZVNkcC5jcmVhdGVPZmZlclNkcChcblx0XHRcdFx0XHRBcnJheS5mcm9tKHRoaXMuX2NvbnN1bWVySW5mb3MudmFsdWVzKCkpKTtcblx0XHRcdFx0Y29uc3Qgb2ZmZXIgPSB7IHR5cGU6ICdvZmZlcicsIHNkcDogcmVtb3RlU2RwIH07XG5cblx0XHRcdFx0bG9nZ2VyLmRlYnVnKFxuXHRcdFx0XHRcdCdyZXN0YXJ0SWNlKCkgfCBjYWxsaW5nIHBjLnNldFJlbW90ZURlc2NyaXB0aW9uKCkgW29mZmVyOiVvXScsXG5cdFx0XHRcdFx0b2ZmZXIpO1xuXG5cdFx0XHRcdHJldHVybiB0aGlzLl9wYy5zZXRSZW1vdGVEZXNjcmlwdGlvbihvZmZlcik7XG5cdFx0XHR9KVxuXHRcdFx0LnRoZW4oKCkgPT5cblx0XHRcdHtcblx0XHRcdFx0cmV0dXJuIHRoaXMuX3BjLmNyZWF0ZUFuc3dlcigpO1xuXHRcdFx0fSlcblx0XHRcdC50aGVuKChhbnN3ZXIpID0+XG5cdFx0XHR7XG5cdFx0XHRcdGxvZ2dlci5kZWJ1Zyhcblx0XHRcdFx0XHQncmVzdGFydEljZSgpIHwgY2FsbGluZyBwYy5zZXRMb2NhbERlc2NyaXB0aW9uKCkgW2Fuc3dlcjolb10nLFxuXHRcdFx0XHRcdGFuc3dlcik7XG5cblx0XHRcdFx0cmV0dXJuIHRoaXMuX3BjLnNldExvY2FsRGVzY3JpcHRpb24oYW5zd2VyKTtcblx0XHRcdH0pO1xuXHR9XG5cblx0X3NldHVwVHJhbnNwb3J0KClcblx0e1xuXHRcdGxvZ2dlci5kZWJ1ZygnX3NldHVwVHJhbnNwb3J0KCknKTtcblxuXHRcdHJldHVybiBQcm9taXNlLnJlc29sdmUoKVxuXHRcdFx0LnRoZW4oKCkgPT5cblx0XHRcdHtcblx0XHRcdFx0Ly8gV2UgbmVlZCB0cmFuc3BvcnQgcmVtb3RlIHBhcmFtZXRlcnMuXG5cdFx0XHRcdHJldHVybiB0aGlzLnNhZmVFbWl0QXNQcm9taXNlKCdAbmVlZGNyZWF0ZXRyYW5zcG9ydCcsIG51bGwpO1xuXHRcdFx0fSlcblx0XHRcdC50aGVuKCh0cmFuc3BvcnRSZW1vdGVQYXJhbWV0ZXJzKSA9PlxuXHRcdFx0e1xuXHRcdFx0XHQvLyBQcm92aWRlIHRoZSByZW1vdGUgU0RQIGhhbmRsZXIgd2l0aCB0cmFuc3BvcnQgcmVtb3RlIHBhcmFtZXRlcnMuXG5cdFx0XHRcdHRoaXMuX3JlbW90ZVNkcC5zZXRUcmFuc3BvcnRSZW1vdGVQYXJhbWV0ZXJzKHRyYW5zcG9ydFJlbW90ZVBhcmFtZXRlcnMpO1xuXG5cdFx0XHRcdHRoaXMuX3RyYW5zcG9ydENyZWF0ZWQgPSB0cnVlO1xuXHRcdFx0fSk7XG5cdH1cblxuXHRfdXBkYXRlVHJhbnNwb3J0KClcblx0e1xuXHRcdGxvZ2dlci5kZWJ1ZygnX3VwZGF0ZVRyYW5zcG9ydCgpJyk7XG5cblx0XHQvLyBHZXQgb3VyIGxvY2FsIERUTFMgcGFyYW1ldGVycy5cblx0XHQvLyBjb25zdCB0cmFuc3BvcnRMb2NhbFBhcmFtZXRlcnMgPSB7fTtcblx0XHRjb25zdCBzZHAgPSB0aGlzLl9wYy5sb2NhbERlc2NyaXB0aW9uLnNkcDtcblx0XHRjb25zdCBzZHBPYmogPSBzZHBUcmFuc2Zvcm0ucGFyc2Uoc2RwKTtcblx0XHRjb25zdCBkdGxzUGFyYW1ldGVycyA9IHNkcENvbW1vblV0aWxzLmV4dHJhY3REdGxzUGFyYW1ldGVycyhzZHBPYmopO1xuXHRcdGNvbnN0IHRyYW5zcG9ydExvY2FsUGFyYW1ldGVycyA9IHsgZHRsc1BhcmFtZXRlcnMgfTtcblxuXHRcdC8vIFdlIG5lZWQgdG8gcHJvdmlkZSB0cmFuc3BvcnQgbG9jYWwgcGFyYW1ldGVycy5cblx0XHR0aGlzLnNhZmVFbWl0KCdAbmVlZHVwZGF0ZXRyYW5zcG9ydCcsIHRyYW5zcG9ydExvY2FsUGFyYW1ldGVycyk7XG5cblx0XHR0aGlzLl90cmFuc3BvcnRVcGRhdGVkID0gdHJ1ZTtcblx0fVxufVxuXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBGaXJlZm94NTlcbntcblx0c3RhdGljIGdldCB0YWcoKVxuXHR7XG5cdFx0cmV0dXJuICdGaXJlZm94NTknO1xuXHR9XG5cblx0c3RhdGljIGdldE5hdGl2ZVJ0cENhcGFiaWxpdGllcygpXG5cdHtcblx0XHRsb2dnZXIuZGVidWcoJ2dldE5hdGl2ZVJ0cENhcGFiaWxpdGllcygpJyk7XG5cblx0XHRjb25zdCBwYyA9IG5ldyBSVENQZWVyQ29ubmVjdGlvbihcblx0XHRcdHtcblx0XHRcdFx0aWNlU2VydmVycyAgICAgICAgIDogW10sXG5cdFx0XHRcdGljZVRyYW5zcG9ydFBvbGljeSA6ICdhbGwnLFxuXHRcdFx0XHRidW5kbGVQb2xpY3kgICAgICAgOiAnbWF4LWJ1bmRsZScsXG5cdFx0XHRcdHJ0Y3BNdXhQb2xpY3kgICAgICA6ICdyZXF1aXJlJ1xuXHRcdFx0fSk7XG5cblx0XHQvLyBOT1RFOiBXZSBuZWVkIHRvIGFkZCBhIHJlYWwgdmlkZW8gdHJhY2sgdG8gZ2V0IHRoZSBSSUQgZXh0ZW5zaW9uIG1hcHBpbmcuXG5cdFx0Y29uc3QgY2FudmFzID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnY2FudmFzJyk7XG5cblx0XHQvLyBOT1RFOiBPdGhlcndpc2UgRmlyZWZveCBmYWlscyBpbiBuZXh0IGxpbmUuXG5cdFx0Y2FudmFzLmdldENvbnRleHQoJzJkJyk7XG5cblx0XHRjb25zdCBmYWtlU3RyZWFtID0gY2FudmFzLmNhcHR1cmVTdHJlYW0oKTtcblx0XHRjb25zdCBmYWtlVmlkZW9UcmFjayA9IGZha2VTdHJlYW0uZ2V0VmlkZW9UcmFja3MoKVswXTtcblx0XHRjb25zdCBydHBTZW5kZXIgPSBwYy5hZGRUcmFjayhmYWtlVmlkZW9UcmFjaywgZmFrZVN0cmVhbSk7XG5cblx0XHRydHBTZW5kZXIuc2V0UGFyYW1ldGVycyhcblx0XHRcdHtcblx0XHRcdFx0ZW5jb2RpbmdzIDpcblx0XHRcdFx0W1xuXHRcdFx0XHRcdHsgcmlkOiAnUklEMScsIG1heEJpdHJhdGU6IDQwMDAwIH0sXG5cdFx0XHRcdFx0eyByaWQ6ICdSSUQyJywgbWF4Qml0cmF0ZTogMTAwMDAgfVxuXHRcdFx0XHRdXG5cdFx0XHR9KTtcblxuXHRcdHJldHVybiBwYy5jcmVhdGVPZmZlcihcblx0XHRcdHtcblx0XHRcdFx0b2ZmZXJUb1JlY2VpdmVBdWRpbyA6IHRydWUsXG5cdFx0XHRcdG9mZmVyVG9SZWNlaXZlVmlkZW8gOiB0cnVlXG5cdFx0XHR9KVxuXHRcdFx0LnRoZW4oKG9mZmVyKSA9PlxuXHRcdFx0e1xuXHRcdFx0XHR0cnkgeyBjYW52YXMucmVtb3ZlKCk7IH1cblx0XHRcdFx0Y2F0Y2ggKGVycm9yKSB7fVxuXG5cdFx0XHRcdHRyeSB7IHBjLmNsb3NlKCk7IH1cblx0XHRcdFx0Y2F0Y2ggKGVycm9yKSB7fVxuXG5cdFx0XHRcdGNvbnN0IHNkcE9iaiA9IHNkcFRyYW5zZm9ybS5wYXJzZShvZmZlci5zZHApO1xuXHRcdFx0XHRjb25zdCBuYXRpdmVSdHBDYXBhYmlsaXRpZXMgPSBzZHBDb21tb25VdGlscy5leHRyYWN0UnRwQ2FwYWJpbGl0aWVzKHNkcE9iaik7XG5cblx0XHRcdFx0cmV0dXJuIG5hdGl2ZVJ0cENhcGFiaWxpdGllcztcblx0XHRcdH0pXG5cdFx0XHQuY2F0Y2goKGVycm9yKSA9PlxuXHRcdFx0e1xuXHRcdFx0XHR0cnkgeyBjYW52YXMucmVtb3ZlKCk7IH1cblx0XHRcdFx0Y2F0Y2ggKGVycm9yMikge31cblxuXHRcdFx0XHR0cnkgeyBwYy5jbG9zZSgpOyB9XG5cdFx0XHRcdGNhdGNoIChlcnJvcjIpIHt9XG5cblx0XHRcdFx0dGhyb3cgZXJyb3I7XG5cdFx0XHR9KTtcblx0fVxuXG5cdGNvbnN0cnVjdG9yKGRpcmVjdGlvbiwgZXh0ZW5kZWRSdHBDYXBhYmlsaXRpZXMsIHNldHRpbmdzKVxuXHR7XG5cdFx0bG9nZ2VyLmRlYnVnKFxuXHRcdFx0J2NvbnN0cnVjdG9yKCkgW2RpcmVjdGlvbjolcywgZXh0ZW5kZWRSdHBDYXBhYmlsaXRpZXM6JW9dJyxcblx0XHRcdGRpcmVjdGlvbiwgZXh0ZW5kZWRSdHBDYXBhYmlsaXRpZXMpO1xuXG5cdFx0bGV0IHJ0cFBhcmFtZXRlcnNCeUtpbmQ7XG5cblx0XHRzd2l0Y2ggKGRpcmVjdGlvbilcblx0XHR7XG5cdFx0XHRjYXNlICdzZW5kJzpcblx0XHRcdHtcblx0XHRcdFx0cnRwUGFyYW1ldGVyc0J5S2luZCA9XG5cdFx0XHRcdHtcblx0XHRcdFx0XHRhdWRpbyA6IG9ydGMuZ2V0U2VuZGluZ1J0cFBhcmFtZXRlcnMoJ2F1ZGlvJywgZXh0ZW5kZWRSdHBDYXBhYmlsaXRpZXMpLFxuXHRcdFx0XHRcdHZpZGVvIDogb3J0Yy5nZXRTZW5kaW5nUnRwUGFyYW1ldGVycygndmlkZW8nLCBleHRlbmRlZFJ0cENhcGFiaWxpdGllcylcblx0XHRcdFx0fTtcblxuXHRcdFx0XHRyZXR1cm4gbmV3IFNlbmRIYW5kbGVyKHJ0cFBhcmFtZXRlcnNCeUtpbmQsIHNldHRpbmdzKTtcblx0XHRcdH1cblx0XHRcdGNhc2UgJ3JlY3YnOlxuXHRcdFx0e1xuXHRcdFx0XHRydHBQYXJhbWV0ZXJzQnlLaW5kID1cblx0XHRcdFx0e1xuXHRcdFx0XHRcdGF1ZGlvIDogb3J0Yy5nZXRSZWNlaXZpbmdGdWxsUnRwUGFyYW1ldGVycygnYXVkaW8nLCBleHRlbmRlZFJ0cENhcGFiaWxpdGllcyksXG5cdFx0XHRcdFx0dmlkZW8gOiBvcnRjLmdldFJlY2VpdmluZ0Z1bGxSdHBQYXJhbWV0ZXJzKCd2aWRlbycsIGV4dGVuZGVkUnRwQ2FwYWJpbGl0aWVzKVxuXHRcdFx0XHR9O1xuXG5cdFx0XHRcdHJldHVybiBuZXcgUmVjdkhhbmRsZXIocnRwUGFyYW1ldGVyc0J5S2luZCwgc2V0dGluZ3MpO1xuXHRcdFx0fVxuXHRcdH1cblx0fVxufVxuIiwiaW1wb3J0IHNkcFRyYW5zZm9ybSBmcm9tICdzZHAtdHJhbnNmb3JtJztcbmltcG9ydCBMb2dnZXIgZnJvbSAnLi4vTG9nZ2VyJztcbmltcG9ydCBFbmhhbmNlZEV2ZW50RW1pdHRlciBmcm9tICcuLi9FbmhhbmNlZEV2ZW50RW1pdHRlcic7XG5pbXBvcnQgKiBhcyB1dGlscyBmcm9tICcuLi91dGlscyc7XG5pbXBvcnQgKiBhcyBvcnRjIGZyb20gJy4uL29ydGMnO1xuaW1wb3J0ICogYXMgc2RwQ29tbW9uVXRpbHMgZnJvbSAnLi9zZHAvY29tbW9uVXRpbHMnO1xuaW1wb3J0ICogYXMgc2RwUGxhbkJVdGlscyBmcm9tICcuL3NkcC9wbGFuQlV0aWxzJztcbmltcG9ydCBSZW1vdGVQbGFuQlNkcCBmcm9tICcuL3NkcC9SZW1vdGVQbGFuQlNkcCc7XG5cbmNvbnN0IGxvZ2dlciA9IG5ldyBMb2dnZXIoJ1JlYWN0TmF0aXZlJyk7XG5cbmNsYXNzIEhhbmRsZXIgZXh0ZW5kcyBFbmhhbmNlZEV2ZW50RW1pdHRlclxue1xuXHRjb25zdHJ1Y3RvcihkaXJlY3Rpb24sIHJ0cFBhcmFtZXRlcnNCeUtpbmQsIHNldHRpbmdzKVxuXHR7XG5cdFx0c3VwZXIobG9nZ2VyKTtcblxuXHRcdC8vIFJUQ1BlZXJDb25uZWN0aW9uIGluc3RhbmNlLlxuXHRcdC8vIEB0eXBlIHtSVENQZWVyQ29ubmVjdGlvbn1cblx0XHR0aGlzLl9wYyA9IG5ldyBSVENQZWVyQ29ubmVjdGlvbihcblx0XHRcdHtcblx0XHRcdFx0aWNlU2VydmVycyAgICAgICAgIDogc2V0dGluZ3MudHVyblNlcnZlcnMgfHwgW10sXG5cdFx0XHRcdGljZVRyYW5zcG9ydFBvbGljeSA6ICdhbGwnLFxuXHRcdFx0XHRidW5kbGVQb2xpY3kgICAgICAgOiAnbWF4LWJ1bmRsZScsXG5cdFx0XHRcdHJ0Y3BNdXhQb2xpY3kgICAgICA6ICdyZXF1aXJlJ1xuXHRcdFx0fSk7XG5cblx0XHQvLyBHZW5lcmljIHNlbmRpbmcgUlRQIHBhcmFtZXRlcnMgZm9yIGF1ZGlvIGFuZCB2aWRlby5cblx0XHQvLyBAdHlwZSB7T2JqZWN0fVxuXHRcdHRoaXMuX3J0cFBhcmFtZXRlcnNCeUtpbmQgPSBydHBQYXJhbWV0ZXJzQnlLaW5kO1xuXG5cdFx0Ly8gUmVtb3RlIFNEUCBoYW5kbGVyLlxuXHRcdC8vIEB0eXBlIHtSZW1vdGVQbGFuQlNkcH1cblx0XHR0aGlzLl9yZW1vdGVTZHAgPSBuZXcgUmVtb3RlUGxhbkJTZHAoZGlyZWN0aW9uLCBydHBQYXJhbWV0ZXJzQnlLaW5kKTtcblxuXHRcdC8vIEhhbmRsZSBSVENQZWVyQ29ubmVjdGlvbiBjb25uZWN0aW9uIHN0YXR1cy5cblx0XHR0aGlzLl9wYy5hZGRFdmVudExpc3RlbmVyKCdpY2Vjb25uZWN0aW9uc3RhdGVjaGFuZ2UnLCAoKSA9PlxuXHRcdHtcblx0XHRcdHN3aXRjaCAodGhpcy5fcGMuaWNlQ29ubmVjdGlvblN0YXRlKVxuXHRcdFx0e1xuXHRcdFx0XHRjYXNlICdjaGVja2luZyc6XG5cdFx0XHRcdFx0dGhpcy5lbWl0KCdAY29ubmVjdGlvbnN0YXRlY2hhbmdlJywgJ2Nvbm5lY3RpbmcnKTtcblx0XHRcdFx0XHRicmVhaztcblx0XHRcdFx0Y2FzZSAnY29ubmVjdGVkJzpcblx0XHRcdFx0Y2FzZSAnY29tcGxldGVkJzpcblx0XHRcdFx0XHR0aGlzLmVtaXQoJ0Bjb25uZWN0aW9uc3RhdGVjaGFuZ2UnLCAnY29ubmVjdGVkJyk7XG5cdFx0XHRcdFx0YnJlYWs7XG5cdFx0XHRcdGNhc2UgJ2ZhaWxlZCc6XG5cdFx0XHRcdFx0dGhpcy5lbWl0KCdAY29ubmVjdGlvbnN0YXRlY2hhbmdlJywgJ2ZhaWxlZCcpO1xuXHRcdFx0XHRcdGJyZWFrO1xuXHRcdFx0XHRjYXNlICdkaXNjb25uZWN0ZWQnOlxuXHRcdFx0XHRcdHRoaXMuZW1pdCgnQGNvbm5lY3Rpb25zdGF0ZWNoYW5nZScsICdkaXNjb25uZWN0ZWQnKTtcblx0XHRcdFx0XHRicmVhaztcblx0XHRcdFx0Y2FzZSAnY2xvc2VkJzpcblx0XHRcdFx0XHR0aGlzLmVtaXQoJ0Bjb25uZWN0aW9uc3RhdGVjaGFuZ2UnLCAnY2xvc2VkJyk7XG5cdFx0XHRcdFx0YnJlYWs7XG5cdFx0XHR9XG5cdFx0fSk7XG5cdH1cblxuXHRjbG9zZSgpXG5cdHtcblx0XHRsb2dnZXIuZGVidWcoJ2Nsb3NlKCknKTtcblxuXHRcdC8vIENsb3NlIFJUQ1BlZXJDb25uZWN0aW9uLlxuXHRcdHRyeSB7IHRoaXMuX3BjLmNsb3NlKCk7IH1cblx0XHRjYXRjaCAoZXJyb3IpIHt9XG5cdH1cbn1cblxuY2xhc3MgU2VuZEhhbmRsZXIgZXh0ZW5kcyBIYW5kbGVyXG57XG5cdGNvbnN0cnVjdG9yKHJ0cFBhcmFtZXRlcnNCeUtpbmQsIHNldHRpbmdzKVxuXHR7XG5cdFx0c3VwZXIoJ3NlbmQnLCBydHBQYXJhbWV0ZXJzQnlLaW5kLCBzZXR0aW5ncyk7XG5cblx0XHQvLyBHb3QgdHJhbnNwb3J0IGxvY2FsIGFuZCByZW1vdGUgcGFyYW1ldGVycy5cblx0XHQvLyBAdHlwZSB7Qm9vbGVhbn1cblx0XHR0aGlzLl90cmFuc3BvcnRSZWFkeSA9IGZhbHNlO1xuXG5cdFx0Ly8gSGFuZGxlZCB0cmFja3MuXG5cdFx0Ly8gQHR5cGUge1NldDxNZWRpYVN0cmVhbVRyYWNrPn1cblx0XHR0aGlzLl90cmFja3MgPSBuZXcgU2V0KCk7XG5cdH1cblxuXHRhZGRQcm9kdWNlcihwcm9kdWNlcilcblx0e1xuXHRcdGNvbnN0IHsgdHJhY2sgfSA9IHByb2R1Y2VyO1xuXG5cdFx0bG9nZ2VyLmRlYnVnKFxuXHRcdFx0J2FkZFByb2R1Y2VyKCkgW2lkOiVzLCBraW5kOiVzLCB0cmFja0lkOiVzXScsXG5cdFx0XHRwcm9kdWNlci5pZCwgcHJvZHVjZXIua2luZCwgdHJhY2suaWQpO1xuXG5cdFx0aWYgKHRoaXMuX3RyYWNrcy5oYXModHJhY2spKVxuXHRcdFx0cmV0dXJuIFByb21pc2UucmVqZWN0KG5ldyBFcnJvcigndHJhY2sgYWxyZWFkeSBhZGRlZCcpKTtcblxuXHRcdGlmICghdHJhY2suc3RyZWFtUmVhY3RUYWcpXG5cdFx0XHRyZXR1cm4gUHJvbWlzZS5yZWplY3QobmV3IEVycm9yKCdubyB0cmFjay5zdHJlYW1SZWFjdFRhZyBwcm9wZXJ0eScpKTtcblxuXHRcdGxldCBzdHJlYW07XG5cdFx0bGV0IGxvY2FsU2RwT2JqO1xuXG5cdFx0cmV0dXJuIFByb21pc2UucmVzb2x2ZSgpXG5cdFx0XHQudGhlbigoKSA9PlxuXHRcdFx0e1xuXHRcdFx0XHQvLyBBZGQgdGhlIHRyYWNrIHRvIHRoZSBTZXQuXG5cdFx0XHRcdHRoaXMuX3RyYWNrcy5hZGQodHJhY2spO1xuXG5cdFx0XHRcdC8vIEhhY2s6IENyZWF0ZSBhIG5ldyBzdHJlYW0gd2l0aCB0cmFjay5zdHJlYW1SZWFjdFRhZyBhcyBpZC5cblx0XHRcdFx0c3RyZWFtID0gbmV3IE1lZGlhU3RyZWFtKHRyYWNrLnN0cmVhbVJlYWN0VGFnKTtcblxuXHRcdFx0XHQvLyBBZGQgdGhlIHRyYWNrIHRvIHRoZSBzdHJlYW0uXG5cdFx0XHRcdHN0cmVhbS5hZGRUcmFjayh0cmFjayk7XG5cblx0XHRcdFx0Ly8gQWRkIHRoZSBzdHJlYW0gdG8gdGhlIFBlZXJDb25uZWN0aW9uLlxuXHRcdFx0XHR0aGlzLl9wYy5hZGRTdHJlYW0oc3RyZWFtKTtcblxuXHRcdFx0XHRyZXR1cm4gdGhpcy5fcGMuY3JlYXRlT2ZmZXIoKTtcblx0XHRcdH0pXG5cdFx0XHQudGhlbigob2ZmZXIpID0+XG5cdFx0XHR7XG5cdFx0XHRcdC8vIElmIHNpbXVsY2FzdCBpcyBzZXQsIG1hbmdsZSB0aGUgb2ZmZXIuXG5cdFx0XHRcdGlmIChwcm9kdWNlci5zaW11bGNhc3QpXG5cdFx0XHRcdHtcblx0XHRcdFx0XHRsb2dnZXIuZGVidWcoJ2FkZFByb2R1Y2VyKCkgfCBlbmFibGluZyBzaW11bGNhc3QnKTtcblxuXHRcdFx0XHRcdGNvbnN0IHNkcE9iamVjdCA9IHNkcFRyYW5zZm9ybS5wYXJzZShvZmZlci5zZHApO1xuXG5cdFx0XHRcdFx0c2RwUGxhbkJVdGlscy5hZGRTaW11bGNhc3RGb3JUcmFjayhzZHBPYmplY3QsIHRyYWNrKTtcblxuXHRcdFx0XHRcdGNvbnN0IG9mZmVyU2RwID0gc2RwVHJhbnNmb3JtLndyaXRlKHNkcE9iamVjdCk7XG5cblx0XHRcdFx0XHRvZmZlciA9IHsgdHlwZTogJ29mZmVyJywgc2RwOiBvZmZlclNkcCB9O1xuXHRcdFx0XHR9XG5cblx0XHRcdFx0bG9nZ2VyLmRlYnVnKFxuXHRcdFx0XHRcdCdhZGRQcm9kdWNlcigpIHwgY2FsbGluZyBwYy5zZXRMb2NhbERlc2NyaXB0aW9uKCkgW29mZmVyOiVvXScsXG5cdFx0XHRcdFx0b2ZmZXIpO1xuXG5cdFx0XHRcdGNvbnN0IG9mZmVyRGVzYyA9IG5ldyBSVENTZXNzaW9uRGVzY3JpcHRpb24ob2ZmZXIpO1xuXG5cdFx0XHRcdHJldHVybiB0aGlzLl9wYy5zZXRMb2NhbERlc2NyaXB0aW9uKG9mZmVyRGVzYyk7XG5cdFx0XHR9KVxuXHRcdFx0LnRoZW4oKCkgPT5cblx0XHRcdHtcblx0XHRcdFx0aWYgKCF0aGlzLl90cmFuc3BvcnRSZWFkeSlcblx0XHRcdFx0XHRyZXR1cm4gdGhpcy5fc2V0dXBUcmFuc3BvcnQoKTtcblx0XHRcdH0pXG5cdFx0XHQudGhlbigoKSA9PlxuXHRcdFx0e1xuXHRcdFx0XHRsb2NhbFNkcE9iaiA9IHNkcFRyYW5zZm9ybS5wYXJzZSh0aGlzLl9wYy5sb2NhbERlc2NyaXB0aW9uLnNkcCk7XG5cblx0XHRcdFx0Y29uc3QgcmVtb3RlU2RwID0gdGhpcy5fcmVtb3RlU2RwLmNyZWF0ZUFuc3dlclNkcChsb2NhbFNkcE9iaik7XG5cdFx0XHRcdGNvbnN0IGFuc3dlciA9IHsgdHlwZTogJ2Fuc3dlcicsIHNkcDogcmVtb3RlU2RwIH07XG5cblx0XHRcdFx0bG9nZ2VyLmRlYnVnKFxuXHRcdFx0XHRcdCdhZGRQcm9kdWNlcigpIHwgY2FsbGluZyBwYy5zZXRSZW1vdGVEZXNjcmlwdGlvbigpIFthbnN3ZXI6JW9dJyxcblx0XHRcdFx0XHRhbnN3ZXIpO1xuXG5cdFx0XHRcdGNvbnN0IGFuc3dlckRlc2MgPSBuZXcgUlRDU2Vzc2lvbkRlc2NyaXB0aW9uKGFuc3dlcik7XG5cblx0XHRcdFx0cmV0dXJuIHRoaXMuX3BjLnNldFJlbW90ZURlc2NyaXB0aW9uKGFuc3dlckRlc2MpO1xuXHRcdFx0fSlcblx0XHRcdC50aGVuKCgpID0+XG5cdFx0XHR7XG5cdFx0XHRcdGNvbnN0IHJ0cFBhcmFtZXRlcnMgPSB1dGlscy5jbG9uZSh0aGlzLl9ydHBQYXJhbWV0ZXJzQnlLaW5kW3Byb2R1Y2VyLmtpbmRdKTtcblxuXHRcdFx0XHQvLyBGaWxsIHRoZSBSVFAgcGFyYW1ldGVycyBmb3IgdGhpcyB0cmFjay5cblx0XHRcdFx0c2RwUGxhbkJVdGlscy5maWxsUnRwUGFyYW1ldGVyc0ZvclRyYWNrKFxuXHRcdFx0XHRcdHJ0cFBhcmFtZXRlcnMsIGxvY2FsU2RwT2JqLCB0cmFjayk7XG5cblx0XHRcdFx0cmV0dXJuIHJ0cFBhcmFtZXRlcnM7XG5cdFx0XHR9KVxuXHRcdFx0LmNhdGNoKChlcnJvcikgPT5cblx0XHRcdHtcblx0XHRcdFx0Ly8gUGFuaWMgaGVyZS4gVHJ5IHRvIHVuZG8gdGhpbmdzLlxuXG5cdFx0XHRcdHRoaXMuX3RyYWNrcy5kZWxldGUodHJhY2spO1xuXHRcdFx0XHRzdHJlYW0ucmVtb3ZlVHJhY2sodHJhY2spO1xuXHRcdFx0XHR0aGlzLl9wYy5hZGRTdHJlYW0oc3RyZWFtKTtcblxuXHRcdFx0XHR0aHJvdyBlcnJvcjtcblx0XHRcdH0pO1xuXHR9XG5cblx0cmVtb3ZlUHJvZHVjZXIocHJvZHVjZXIpXG5cdHtcblx0XHRjb25zdCB7IHRyYWNrIH0gPSBwcm9kdWNlcjtcblxuXHRcdGxvZ2dlci5kZWJ1Zyhcblx0XHRcdCdyZW1vdmVQcm9kdWNlcigpIFtpZDolcywga2luZDolcywgdHJhY2tJZDolc10nLFxuXHRcdFx0cHJvZHVjZXIuaWQsIHByb2R1Y2VyLmtpbmQsIHRyYWNrLmlkKTtcblxuXHRcdGlmICghdHJhY2suc3RyZWFtUmVhY3RUYWcpXG5cdFx0XHRyZXR1cm4gUHJvbWlzZS5yZWplY3QobmV3IEVycm9yKCdubyB0cmFjay5zdHJlYW1SZWFjdFRhZyBwcm9wZXJ0eScpKTtcblxuXHRcdHJldHVybiBQcm9taXNlLnJlc29sdmUoKVxuXHRcdFx0LnRoZW4oKCkgPT5cblx0XHRcdHtcblx0XHRcdFx0Ly8gUmVtb3ZlIHRoZSB0cmFjayBmcm9tIHRoZSBTZXQuXG5cdFx0XHRcdHRoaXMuX3RyYWNrcy5kZWxldGUodHJhY2spO1xuXG5cdFx0XHRcdC8vIEhhY2s6IENyZWF0ZSBhIG5ldyBzdHJlYW0gd2l0aCB0cmFjay5zdHJlYW1SZWFjdFRhZyBhcyBpZC5cblx0XHRcdFx0Y29uc3Qgc3RyZWFtID0gbmV3IE1lZGlhU3RyZWFtKHRyYWNrLnN0cmVhbVJlYWN0VGFnKTtcblxuXHRcdFx0XHQvLyBBZGQgdGhlIHRyYWNrIHRvIHRoZSBzdHJlYW0uXG5cdFx0XHRcdHN0cmVhbS5hZGRUcmFjayh0cmFjayk7XG5cblx0XHRcdFx0Ly8gQWRkIHRoZSBzdHJlYW0gdG8gdGhlIFBlZXJDb25uZWN0aW9uLlxuXHRcdFx0XHR0aGlzLl9wYy5hZGRTdHJlYW0oc3RyZWFtKTtcblxuXHRcdFx0XHRyZXR1cm4gdGhpcy5fcGMuY3JlYXRlT2ZmZXIoKTtcblx0XHRcdH0pXG5cdFx0XHQudGhlbigob2ZmZXIpID0+XG5cdFx0XHR7XG5cdFx0XHRcdGxvZ2dlci5kZWJ1Zyhcblx0XHRcdFx0XHQncmVtb3ZlUHJvZHVjZXIoKSB8IGNhbGxpbmcgcGMuc2V0TG9jYWxEZXNjcmlwdGlvbigpIFtvZmZlcjolb10nLFxuXHRcdFx0XHRcdG9mZmVyKTtcblxuXHRcdFx0XHRyZXR1cm4gdGhpcy5fcGMuc2V0TG9jYWxEZXNjcmlwdGlvbihvZmZlcik7XG5cdFx0XHR9KVxuXHRcdFx0LmNhdGNoKChlcnJvcikgPT5cblx0XHRcdHtcblx0XHRcdFx0Ly8gTk9URTogSWYgdGhlcmUgYXJlIG5vIHNlbmRpbmcgdHJhY2tzLCBzZXRMb2NhbERlc2NyaXB0aW9uKCkgd2lsbCBmYWlsIHdpdGhcblx0XHRcdFx0Ly8gXCJGYWlsZWQgdG8gY3JlYXRlIGNoYW5uZWxzXCIuIElmIHNvLCBpZ25vcmUgaXQuXG5cdFx0XHRcdGlmICh0aGlzLl90cmFja3Muc2l6ZSA9PT0gMClcblx0XHRcdFx0e1xuXHRcdFx0XHRcdGxvZ2dlci53YXJuKFxuXHRcdFx0XHRcdFx0J3JlbW92ZVByb2R1Y2VyKCkgfCBpZ25vcmluZyBleHBlY3RlZCBlcnJvciBkdWUgbm8gc2VuZGluZyB0cmFja3M6ICVzJyxcblx0XHRcdFx0XHRcdGVycm9yLnRvU3RyaW5nKCkpO1xuXG5cdFx0XHRcdFx0cmV0dXJuO1xuXHRcdFx0XHR9XG5cblx0XHRcdFx0dGhyb3cgZXJyb3I7XG5cdFx0XHR9KVxuXHRcdFx0LnRoZW4oKCkgPT5cblx0XHRcdHtcblx0XHRcdFx0aWYgKHRoaXMuX3BjLnNpZ25hbGluZ1N0YXRlID09PSAnc3RhYmxlJylcblx0XHRcdFx0XHRyZXR1cm47XG5cblx0XHRcdFx0Y29uc3QgbG9jYWxTZHBPYmogPSBzZHBUcmFuc2Zvcm0ucGFyc2UodGhpcy5fcGMubG9jYWxEZXNjcmlwdGlvbi5zZHApO1xuXHRcdFx0XHRjb25zdCByZW1vdGVTZHAgPSB0aGlzLl9yZW1vdGVTZHAuY3JlYXRlQW5zd2VyU2RwKGxvY2FsU2RwT2JqKTtcblx0XHRcdFx0Y29uc3QgYW5zd2VyID0geyB0eXBlOiAnYW5zd2VyJywgc2RwOiByZW1vdGVTZHAgfTtcblxuXHRcdFx0XHRsb2dnZXIuZGVidWcoXG5cdFx0XHRcdFx0J3JlbW92ZVByb2R1Y2VyKCkgfCBjYWxsaW5nIHBjLnNldFJlbW90ZURlc2NyaXB0aW9uKCkgW2Fuc3dlcjolb10nLFxuXHRcdFx0XHRcdGFuc3dlcik7XG5cblx0XHRcdFx0Y29uc3QgYW5zd2VyRGVzYyA9IG5ldyBSVENTZXNzaW9uRGVzY3JpcHRpb24oYW5zd2VyKTtcblxuXHRcdFx0XHRyZXR1cm4gdGhpcy5fcGMuc2V0UmVtb3RlRGVzY3JpcHRpb24oYW5zd2VyRGVzYyk7XG5cdFx0XHR9KTtcblx0fVxuXG5cdHJlcGxhY2VQcm9kdWNlclRyYWNrKHByb2R1Y2VyLCB0cmFjaylcblx0e1xuXHRcdGxvZ2dlci5kZWJ1Zyhcblx0XHRcdCdyZXBsYWNlUHJvZHVjZXJUcmFjaygpIFtpZDolcywga2luZDolcywgdHJhY2tJZDolc10nLFxuXHRcdFx0cHJvZHVjZXIuaWQsIHByb2R1Y2VyLmtpbmQsIHRyYWNrLmlkKTtcblxuXHRcdGlmICghdHJhY2suc3RyZWFtUmVhY3RUYWcpXG5cdFx0XHRyZXR1cm4gUHJvbWlzZS5yZWplY3QobmV3IEVycm9yKCdubyB0cmFjay5zdHJlYW1SZWFjdFRhZyBwcm9wZXJ0eScpKTtcblxuXHRcdGNvbnN0IG9sZFRyYWNrID0gcHJvZHVjZXIudHJhY2s7XG5cdFx0bGV0IHN0cmVhbTtcblx0XHRsZXQgbG9jYWxTZHBPYmo7XG5cblx0XHRyZXR1cm4gUHJvbWlzZS5yZXNvbHZlKClcblx0XHRcdC50aGVuKCgpID0+XG5cdFx0XHR7XG5cdFx0XHRcdC8vIEFkZCB0aGUgbmV3IFRyYWNrIHRvIHRoZSBTZXQgYW5kIHJlbW92ZSB0aGUgb2xkIG9uZS5cblx0XHRcdFx0dGhpcy5fdHJhY2tzLmFkZCh0cmFjayk7XG5cdFx0XHRcdHRoaXMuX3RyYWNrcy5kZWxldGUob2xkVHJhY2spO1xuXG5cdFx0XHRcdC8vIEhhY2s6IENyZWF0ZSBhIG5ldyBzdHJlYW0gd2l0aCB0cmFjay5zdHJlYW1SZWFjdFRhZyBhcyBpZC5cblx0XHRcdFx0c3RyZWFtID0gbmV3IE1lZGlhU3RyZWFtKHRyYWNrLnN0cmVhbVJlYWN0VGFnKTtcblxuXHRcdFx0XHQvLyBBZGQgdGhlIHRyYWNrIHRvIHRoZSBzdHJlYW0gYW5kIHJlbW92ZSB0aGUgb2xkIG9uZS5cblx0XHRcdFx0c3RyZWFtLmFkZFRyYWNrKHRyYWNrKTtcblx0XHRcdFx0c3RyZWFtLnJlbW92ZVRyYWNrKG9sZFRyYWNrKTtcblxuXHRcdFx0XHQvLyBBZGQgdGhlIHN0cmVhbSB0byB0aGUgUGVlckNvbm5lY3Rpb24uXG5cdFx0XHRcdHRoaXMuX3BjLmFkZFN0cmVhbShzdHJlYW0pO1xuXG5cdFx0XHRcdHJldHVybiB0aGlzLl9wYy5jcmVhdGVPZmZlcigpO1xuXHRcdFx0fSlcblx0XHRcdC50aGVuKChvZmZlcikgPT5cblx0XHRcdHtcblx0XHRcdFx0Ly8gSWYgc2ltdWxjYXN0IGlzIHNldCwgbWFuZ2xlIHRoZSBvZmZlci5cblx0XHRcdFx0aWYgKHByb2R1Y2VyLnNpbXVsY2FzdClcblx0XHRcdFx0e1xuXHRcdFx0XHRcdGxvZ2dlci5kZWJ1ZygnYWRkUHJvZHVjZXIoKSB8IGVuYWJsaW5nIHNpbXVsY2FzdCcpO1xuXG5cdFx0XHRcdFx0Y29uc3Qgc2RwT2JqZWN0ID0gc2RwVHJhbnNmb3JtLnBhcnNlKG9mZmVyLnNkcCk7XG5cblx0XHRcdFx0XHRzZHBQbGFuQlV0aWxzLmFkZFNpbXVsY2FzdEZvclRyYWNrKHNkcE9iamVjdCwgdHJhY2spO1xuXG5cdFx0XHRcdFx0Y29uc3Qgb2ZmZXJTZHAgPSBzZHBUcmFuc2Zvcm0ud3JpdGUoc2RwT2JqZWN0KTtcblxuXHRcdFx0XHRcdG9mZmVyID0geyB0eXBlOiAnb2ZmZXInLCBzZHA6IG9mZmVyU2RwIH07XG5cdFx0XHRcdH1cblxuXHRcdFx0XHRsb2dnZXIuZGVidWcoXG5cdFx0XHRcdFx0J3JlcGxhY2VQcm9kdWNlclRyYWNrKCkgfCBjYWxsaW5nIHBjLnNldExvY2FsRGVzY3JpcHRpb24oKSBbb2ZmZXI6JW9dJyxcblx0XHRcdFx0XHRvZmZlcik7XG5cblx0XHRcdFx0Y29uc3Qgb2ZmZXJEZXNjID0gbmV3IFJUQ1Nlc3Npb25EZXNjcmlwdGlvbihvZmZlcik7XG5cblx0XHRcdFx0cmV0dXJuIHRoaXMuX3BjLnNldExvY2FsRGVzY3JpcHRpb24ob2ZmZXJEZXNjKTtcblx0XHRcdH0pXG5cdFx0XHQudGhlbigoKSA9PlxuXHRcdFx0e1xuXHRcdFx0XHRsb2NhbFNkcE9iaiA9IHNkcFRyYW5zZm9ybS5wYXJzZSh0aGlzLl9wYy5sb2NhbERlc2NyaXB0aW9uLnNkcCk7XG5cblx0XHRcdFx0Y29uc3QgcmVtb3RlU2RwID0gdGhpcy5fcmVtb3RlU2RwLmNyZWF0ZUFuc3dlclNkcChsb2NhbFNkcE9iaik7XG5cdFx0XHRcdGNvbnN0IGFuc3dlciA9IHsgdHlwZTogJ2Fuc3dlcicsIHNkcDogcmVtb3RlU2RwIH07XG5cblx0XHRcdFx0bG9nZ2VyLmRlYnVnKFxuXHRcdFx0XHRcdCdyZXBsYWNlUHJvZHVjZXJUcmFjaygpIHwgY2FsbGluZyBwYy5zZXRSZW1vdGVEZXNjcmlwdGlvbigpIFthbnN3ZXI6JW9dJyxcblx0XHRcdFx0XHRhbnN3ZXIpO1xuXG5cdFx0XHRcdGNvbnN0IGFuc3dlckRlc2MgPSBuZXcgUlRDU2Vzc2lvbkRlc2NyaXB0aW9uKGFuc3dlcik7XG5cblx0XHRcdFx0cmV0dXJuIHRoaXMuX3BjLnNldFJlbW90ZURlc2NyaXB0aW9uKGFuc3dlckRlc2MpO1xuXHRcdFx0fSlcblx0XHRcdC50aGVuKCgpID0+XG5cdFx0XHR7XG5cdFx0XHRcdGNvbnN0IHJ0cFBhcmFtZXRlcnMgPSB1dGlscy5jbG9uZSh0aGlzLl9ydHBQYXJhbWV0ZXJzQnlLaW5kW3Byb2R1Y2VyLmtpbmRdKTtcblxuXHRcdFx0XHQvLyBGaWxsIHRoZSBSVFAgcGFyYW1ldGVycyBmb3IgdGhlIG5ldyB0cmFjay5cblx0XHRcdFx0c2RwUGxhbkJVdGlscy5maWxsUnRwUGFyYW1ldGVyc0ZvclRyYWNrKFxuXHRcdFx0XHRcdHJ0cFBhcmFtZXRlcnMsIGxvY2FsU2RwT2JqLCB0cmFjayk7XG5cblx0XHRcdFx0Ly8gV2UgbmVlZCB0byBwcm92aWRlIG5ldyBSVFAgcGFyYW1ldGVycy5cblx0XHRcdFx0dGhpcy5zYWZlRW1pdCgnQG5lZWR1cGRhdGVwcm9kdWNlcicsIHByb2R1Y2VyLCBydHBQYXJhbWV0ZXJzKTtcblx0XHRcdH0pXG5cdFx0XHQuY2F0Y2goKGVycm9yKSA9PlxuXHRcdFx0e1xuXHRcdFx0XHQvLyBQYW5pYyBoZXJlLiBUcnkgdG8gdW5kbyB0aGluZ3MuXG5cblx0XHRcdFx0dGhpcy5fdHJhY2tzLmRlbGV0ZSh0cmFjayk7XG5cdFx0XHRcdHN0cmVhbS5yZW1vdmVUcmFjayh0cmFjayk7XG5cdFx0XHRcdHRoaXMuX3BjLmFkZFN0cmVhbShzdHJlYW0pO1xuXG5cdFx0XHRcdHRocm93IGVycm9yO1xuXHRcdFx0fSk7XG5cdH1cblxuXHRyZXN0YXJ0SWNlKHJlbW90ZUljZVBhcmFtZXRlcnMpXG5cdHtcblx0XHRsb2dnZXIuZGVidWcoJ3Jlc3RhcnRJY2UoKScpO1xuXG5cdFx0Ly8gUHJvdmlkZSB0aGUgcmVtb3RlIFNEUCBoYW5kbGVyIHdpdGggbmV3IHJlbW90ZSBJQ0UgcGFyYW1ldGVycy5cblx0XHR0aGlzLl9yZW1vdGVTZHAudXBkYXRlVHJhbnNwb3J0UmVtb3RlSWNlUGFyYW1ldGVycyhyZW1vdGVJY2VQYXJhbWV0ZXJzKTtcblxuXHRcdHJldHVybiBQcm9taXNlLnJlc29sdmUoKVxuXHRcdFx0LnRoZW4oKCkgPT5cblx0XHRcdHtcblx0XHRcdFx0cmV0dXJuIHRoaXMuX3BjLmNyZWF0ZU9mZmVyKHsgaWNlUmVzdGFydDogdHJ1ZSB9KTtcblx0XHRcdH0pXG5cdFx0XHQudGhlbigob2ZmZXIpID0+XG5cdFx0XHR7XG5cdFx0XHRcdGxvZ2dlci5kZWJ1Zyhcblx0XHRcdFx0XHQncmVzdGFydEljZSgpIHwgY2FsbGluZyBwYy5zZXRMb2NhbERlc2NyaXB0aW9uKCkgW29mZmVyOiVvXScsXG5cdFx0XHRcdFx0b2ZmZXIpO1xuXG5cdFx0XHRcdHJldHVybiB0aGlzLl9wYy5zZXRMb2NhbERlc2NyaXB0aW9uKG9mZmVyKTtcblx0XHRcdH0pXG5cdFx0XHQudGhlbigoKSA9PlxuXHRcdFx0e1xuXHRcdFx0XHRjb25zdCBsb2NhbFNkcE9iaiA9IHNkcFRyYW5zZm9ybS5wYXJzZSh0aGlzLl9wYy5sb2NhbERlc2NyaXB0aW9uLnNkcCk7XG5cdFx0XHRcdGNvbnN0IHJlbW90ZVNkcCA9IHRoaXMuX3JlbW90ZVNkcC5jcmVhdGVBbnN3ZXJTZHAobG9jYWxTZHBPYmopO1xuXHRcdFx0XHRjb25zdCBhbnN3ZXIgPSB7IHR5cGU6ICdhbnN3ZXInLCBzZHA6IHJlbW90ZVNkcCB9O1xuXG5cdFx0XHRcdGxvZ2dlci5kZWJ1Zyhcblx0XHRcdFx0XHQncmVzdGFydEljZSgpIHwgY2FsbGluZyBwYy5zZXRSZW1vdGVEZXNjcmlwdGlvbigpIFthbnN3ZXI6JW9dJyxcblx0XHRcdFx0XHRhbnN3ZXIpO1xuXG5cdFx0XHRcdGNvbnN0IGFuc3dlckRlc2MgPSBuZXcgUlRDU2Vzc2lvbkRlc2NyaXB0aW9uKGFuc3dlcik7XG5cblx0XHRcdFx0cmV0dXJuIHRoaXMuX3BjLnNldFJlbW90ZURlc2NyaXB0aW9uKGFuc3dlckRlc2MpO1xuXHRcdFx0fSk7XG5cdH1cblxuXHRfc2V0dXBUcmFuc3BvcnQoKVxuXHR7XG5cdFx0bG9nZ2VyLmRlYnVnKCdfc2V0dXBUcmFuc3BvcnQoKScpO1xuXG5cdFx0cmV0dXJuIFByb21pc2UucmVzb2x2ZSgpXG5cdFx0XHQudGhlbigoKSA9PlxuXHRcdFx0e1xuXHRcdFx0XHQvLyBHZXQgb3VyIGxvY2FsIERUTFMgcGFyYW1ldGVycy5cblx0XHRcdFx0Y29uc3QgdHJhbnNwb3J0TG9jYWxQYXJhbWV0ZXJzID0ge307XG5cdFx0XHRcdGNvbnN0IHNkcCA9IHRoaXMuX3BjLmxvY2FsRGVzY3JpcHRpb24uc2RwO1xuXHRcdFx0XHRjb25zdCBzZHBPYmogPSBzZHBUcmFuc2Zvcm0ucGFyc2Uoc2RwKTtcblx0XHRcdFx0Y29uc3QgZHRsc1BhcmFtZXRlcnMgPSBzZHBDb21tb25VdGlscy5leHRyYWN0RHRsc1BhcmFtZXRlcnMoc2RwT2JqKTtcblxuXHRcdFx0XHQvLyBMZXQncyBkZWNpZGUgdGhhdCB3ZSdsbCBiZSBEVExTIHNlcnZlciAoYmVjYXVzZSB3ZSBjYW4pLlxuXHRcdFx0XHRkdGxzUGFyYW1ldGVycy5yb2xlID0gJ3NlcnZlcic7XG5cblx0XHRcdFx0dHJhbnNwb3J0TG9jYWxQYXJhbWV0ZXJzLmR0bHNQYXJhbWV0ZXJzID0gZHRsc1BhcmFtZXRlcnM7XG5cblx0XHRcdFx0Ly8gUHJvdmlkZSB0aGUgcmVtb3RlIFNEUCBoYW5kbGVyIHdpdGggdHJhbnNwb3J0IGxvY2FsIHBhcmFtZXRlcnMuXG5cdFx0XHRcdHRoaXMuX3JlbW90ZVNkcC5zZXRUcmFuc3BvcnRMb2NhbFBhcmFtZXRlcnModHJhbnNwb3J0TG9jYWxQYXJhbWV0ZXJzKTtcblxuXHRcdFx0XHQvLyBXZSBuZWVkIHRyYW5zcG9ydCByZW1vdGUgcGFyYW1ldGVycy5cblx0XHRcdFx0cmV0dXJuIHRoaXMuc2FmZUVtaXRBc1Byb21pc2UoXG5cdFx0XHRcdFx0J0BuZWVkY3JlYXRldHJhbnNwb3J0JywgdHJhbnNwb3J0TG9jYWxQYXJhbWV0ZXJzKTtcblx0XHRcdH0pXG5cdFx0XHQudGhlbigodHJhbnNwb3J0UmVtb3RlUGFyYW1ldGVycykgPT5cblx0XHRcdHtcblx0XHRcdFx0Ly8gUHJvdmlkZSB0aGUgcmVtb3RlIFNEUCBoYW5kbGVyIHdpdGggdHJhbnNwb3J0IHJlbW90ZSBwYXJhbWV0ZXJzLlxuXHRcdFx0XHR0aGlzLl9yZW1vdGVTZHAuc2V0VHJhbnNwb3J0UmVtb3RlUGFyYW1ldGVycyh0cmFuc3BvcnRSZW1vdGVQYXJhbWV0ZXJzKTtcblxuXHRcdFx0XHR0aGlzLl90cmFuc3BvcnRSZWFkeSA9IHRydWU7XG5cdFx0XHR9KTtcblx0fVxufVxuXG5jbGFzcyBSZWN2SGFuZGxlciBleHRlbmRzIEhhbmRsZXJcbntcblx0Y29uc3RydWN0b3IocnRwUGFyYW1ldGVyc0J5S2luZCwgc2V0dGluZ3MpXG5cdHtcblx0XHRzdXBlcigncmVjdicsIHJ0cFBhcmFtZXRlcnNCeUtpbmQsIHNldHRpbmdzKTtcblxuXHRcdC8vIEdvdCB0cmFuc3BvcnQgcmVtb3RlIHBhcmFtZXRlcnMuXG5cdFx0Ly8gQHR5cGUge0Jvb2xlYW59XG5cdFx0dGhpcy5fdHJhbnNwb3J0Q3JlYXRlZCA9IGZhbHNlO1xuXG5cdFx0Ly8gR290IHRyYW5zcG9ydCBsb2NhbCBwYXJhbWV0ZXJzLlxuXHRcdC8vIEB0eXBlIHtCb29sZWFufVxuXHRcdHRoaXMuX3RyYW5zcG9ydFVwZGF0ZWQgPSBmYWxzZTtcblxuXHRcdC8vIFNlZW4gbWVkaWEga2luZHMuXG5cdFx0Ly8gQHR5cGUge1NldDxTdHJpbmc+fVxuXHRcdHRoaXMuX2tpbmRzID0gbmV3IFNldCgpO1xuXG5cdFx0Ly8gTWFwIG9mIENvbnN1bWVycyBpbmZvcm1hdGlvbiBpbmRleGVkIGJ5IGNvbnN1bWVyLmlkLlxuXHRcdC8vIC0ga2luZCB7U3RyaW5nfVxuXHRcdC8vIC0gdHJhY2tJZCB7U3RyaW5nfVxuXHRcdC8vIC0gc3NyYyB7TnVtYmVyfVxuXHRcdC8vIC0gcnR4U3NyYyB7TnVtYmVyfVxuXHRcdC8vIC0gY25hbWUge1N0cmluZ31cblx0XHQvLyBAdHlwZSB7TWFwPE51bWJlciwgT2JqZWN0Pn1cblx0XHR0aGlzLl9jb25zdW1lckluZm9zID0gbmV3IE1hcCgpO1xuXHR9XG5cblx0YWRkQ29uc3VtZXIoY29uc3VtZXIpXG5cdHtcblx0XHRsb2dnZXIuZGVidWcoXG5cdFx0XHQnYWRkQ29uc3VtZXIoKSBbaWQ6JXMsIGtpbmQ6JXNdJywgY29uc3VtZXIuaWQsIGNvbnN1bWVyLmtpbmQpO1xuXG5cdFx0aWYgKHRoaXMuX2NvbnN1bWVySW5mb3MuaGFzKGNvbnN1bWVyLmlkKSlcblx0XHRcdHJldHVybiBQcm9taXNlLnJlamVjdChuZXcgRXJyb3IoJ0NvbnN1bWVyIGFscmVhZHkgYWRkZWQnKSk7XG5cblx0XHRjb25zdCBlbmNvZGluZyA9IGNvbnN1bWVyLnJ0cFBhcmFtZXRlcnMuZW5jb2RpbmdzWzBdO1xuXHRcdGNvbnN0IGNuYW1lID0gY29uc3VtZXIucnRwUGFyYW1ldGVycy5ydGNwLmNuYW1lO1xuXHRcdGNvbnN0IGNvbnN1bWVySW5mbyA9XG5cdFx0e1xuXHRcdFx0a2luZCAgICAgOiBjb25zdW1lci5raW5kLFxuXHRcdFx0c3RyZWFtSWQgOiBgcmVjdi1zdHJlYW0tJHtjb25zdW1lci5pZH1gLFxuXHRcdFx0dHJhY2tJZCAgOiBgY29uc3VtZXItJHtjb25zdW1lci5raW5kfS0ke2NvbnN1bWVyLmlkfWAsXG5cdFx0XHRzc3JjICAgICA6IGVuY29kaW5nLnNzcmMsXG5cdFx0XHRjbmFtZSAgICA6IGNuYW1lXG5cdFx0fTtcblxuXHRcdGlmIChlbmNvZGluZy5ydHggJiYgZW5jb2RpbmcucnR4LnNzcmMpXG5cdFx0XHRjb25zdW1lckluZm8ucnR4U3NyYyA9IGVuY29kaW5nLnJ0eC5zc3JjO1xuXG5cdFx0dGhpcy5fY29uc3VtZXJJbmZvcy5zZXQoY29uc3VtZXIuaWQsIGNvbnN1bWVySW5mbyk7XG5cdFx0dGhpcy5fa2luZHMuYWRkKGNvbnN1bWVyLmtpbmQpO1xuXG5cdFx0cmV0dXJuIFByb21pc2UucmVzb2x2ZSgpXG5cdFx0XHQudGhlbigoKSA9PlxuXHRcdFx0e1xuXHRcdFx0XHRpZiAoIXRoaXMuX3RyYW5zcG9ydENyZWF0ZWQpXG5cdFx0XHRcdFx0cmV0dXJuIHRoaXMuX3NldHVwVHJhbnNwb3J0KCk7XG5cdFx0XHR9KVxuXHRcdFx0LnRoZW4oKCkgPT5cblx0XHRcdHtcblx0XHRcdFx0Y29uc3QgcmVtb3RlU2RwID0gdGhpcy5fcmVtb3RlU2RwLmNyZWF0ZU9mZmVyU2RwKFxuXHRcdFx0XHRcdEFycmF5LmZyb20odGhpcy5fa2luZHMpLCBBcnJheS5mcm9tKHRoaXMuX2NvbnN1bWVySW5mb3MudmFsdWVzKCkpKTtcblx0XHRcdFx0Y29uc3Qgb2ZmZXIgPSB7IHR5cGU6ICdvZmZlcicsIHNkcDogcmVtb3RlU2RwIH07XG5cblx0XHRcdFx0bG9nZ2VyLmRlYnVnKFxuXHRcdFx0XHRcdCdhZGRDb25zdW1lcigpIHwgY2FsbGluZyBwYy5zZXRSZW1vdGVEZXNjcmlwdGlvbigpIFtvZmZlcjolb10nLFxuXHRcdFx0XHRcdG9mZmVyKTtcblxuXHRcdFx0XHRjb25zdCBvZmZlckRlc2MgPSBuZXcgUlRDU2Vzc2lvbkRlc2NyaXB0aW9uKG9mZmVyKTtcblxuXHRcdFx0XHRyZXR1cm4gdGhpcy5fcGMuc2V0UmVtb3RlRGVzY3JpcHRpb24ob2ZmZXJEZXNjKTtcblx0XHRcdH0pXG5cdFx0XHQudGhlbigoKSA9PlxuXHRcdFx0e1xuXHRcdFx0XHRyZXR1cm4gdGhpcy5fcGMuY3JlYXRlQW5zd2VyKCk7XG5cdFx0XHR9KVxuXHRcdFx0LnRoZW4oKGFuc3dlcikgPT5cblx0XHRcdHtcblx0XHRcdFx0bG9nZ2VyLmRlYnVnKFxuXHRcdFx0XHRcdCdhZGRDb25zdW1lcigpIHwgY2FsbGluZyBwYy5zZXRMb2NhbERlc2NyaXB0aW9uKCkgW2Fuc3dlcjolb10nLFxuXHRcdFx0XHRcdGFuc3dlcik7XG5cblx0XHRcdFx0cmV0dXJuIHRoaXMuX3BjLnNldExvY2FsRGVzY3JpcHRpb24oYW5zd2VyKTtcblx0XHRcdH0pXG5cdFx0XHQudGhlbigoKSA9PlxuXHRcdFx0e1xuXHRcdFx0XHRpZiAoIXRoaXMuX3RyYW5zcG9ydFVwZGF0ZWQpXG5cdFx0XHRcdFx0cmV0dXJuIHRoaXMuX3VwZGF0ZVRyYW5zcG9ydCgpO1xuXHRcdFx0fSlcblx0XHRcdC50aGVuKCgpID0+XG5cdFx0XHR7XG5cdFx0XHRcdGNvbnN0IHN0cmVhbSA9IHRoaXMuX3BjLmdldFJlbW90ZVN0cmVhbXMoKVxuXHRcdFx0XHRcdC5maW5kKChzKSA9PiBzLmlkID09PSBjb25zdW1lckluZm8uc3RyZWFtSWQpO1xuXHRcdFx0XHRjb25zdCB0cmFjayA9IHN0cmVhbS5nZXRUcmFja0J5SWQoY29uc3VtZXJJbmZvLnRyYWNrSWQpO1xuXG5cdFx0XHRcdC8vIEhhY2s6IEFkZCBhIHN0cmVhbVJlYWN0VGFnIHByb3BlcnR5IHdpdGggdGhlIHJlYWN0VGFnIG9mIHRoZSBNZWRpYVN0cmVhbVxuXHRcdFx0XHQvLyBnZW5lcmF0ZWQgYnkgcmVhY3QtbmF0aXZlLXdlYnJ0YyAodGhpcyBpcyBuZWVkZWQgYmVjYXVzZSByZWFjdC1uYXRpdmUtd2VicnRjXG5cdFx0XHRcdC8vIGFzc3VtZXMgdGhhdCB3ZSdyZSBnb25uYSB1c2UgdGhlIHN0cmVhbXMgZ2VuZXJhdGVkIGJ5IGl0KS5cblx0XHRcdFx0dHJhY2suc3RyZWFtUmVhY3RUYWcgPSBzdHJlYW0ucmVhY3RUYWc7XG5cblx0XHRcdFx0aWYgKCF0cmFjaylcblx0XHRcdFx0XHR0aHJvdyBuZXcgRXJyb3IoJ3JlbW90ZSB0cmFjayBub3QgZm91bmQnKTtcblxuXHRcdFx0XHRyZXR1cm4gdHJhY2s7XG5cdFx0XHR9KTtcblx0fVxuXG5cdHJlbW92ZUNvbnN1bWVyKGNvbnN1bWVyKVxuXHR7XG5cdFx0bG9nZ2VyLmRlYnVnKFxuXHRcdFx0J3JlbW92ZUNvbnN1bWVyKCkgW2lkOiVzLCBraW5kOiVzXScsIGNvbnN1bWVyLmlkLCBjb25zdW1lci5raW5kKTtcblxuXHRcdGlmICghdGhpcy5fY29uc3VtZXJJbmZvcy5oYXMoY29uc3VtZXIuaWQpKVxuXHRcdFx0cmV0dXJuIFByb21pc2UucmVqZWN0KG5ldyBFcnJvcignQ29uc3VtZXIgbm90IGZvdW5kJykpO1xuXG5cdFx0dGhpcy5fY29uc3VtZXJJbmZvcy5kZWxldGUoY29uc3VtZXIuaWQpO1xuXG5cdFx0cmV0dXJuIFByb21pc2UucmVzb2x2ZSgpXG5cdFx0XHQudGhlbigoKSA9PlxuXHRcdFx0e1xuXHRcdFx0XHRjb25zdCByZW1vdGVTZHAgPSB0aGlzLl9yZW1vdGVTZHAuY3JlYXRlT2ZmZXJTZHAoXG5cdFx0XHRcdFx0QXJyYXkuZnJvbSh0aGlzLl9raW5kcyksIEFycmF5LmZyb20odGhpcy5fY29uc3VtZXJJbmZvcy52YWx1ZXMoKSkpO1xuXHRcdFx0XHRjb25zdCBvZmZlciA9IHsgdHlwZTogJ29mZmVyJywgc2RwOiByZW1vdGVTZHAgfTtcblxuXHRcdFx0XHRsb2dnZXIuZGVidWcoXG5cdFx0XHRcdFx0J3JlbW92ZUNvbnN1bWVyKCkgfCBjYWxsaW5nIHBjLnNldFJlbW90ZURlc2NyaXB0aW9uKCkgW29mZmVyOiVvXScsXG5cdFx0XHRcdFx0b2ZmZXIpO1xuXG5cdFx0XHRcdGNvbnN0IG9mZmVyRGVzYyA9IG5ldyBSVENTZXNzaW9uRGVzY3JpcHRpb24ob2ZmZXIpO1xuXG5cdFx0XHRcdHJldHVybiB0aGlzLl9wYy5zZXRSZW1vdGVEZXNjcmlwdGlvbihvZmZlckRlc2MpO1xuXHRcdFx0fSlcblx0XHRcdC50aGVuKCgpID0+XG5cdFx0XHR7XG5cdFx0XHRcdHJldHVybiB0aGlzLl9wYy5jcmVhdGVBbnN3ZXIoKTtcblx0XHRcdH0pXG5cdFx0XHQudGhlbigoYW5zd2VyKSA9PlxuXHRcdFx0e1xuXHRcdFx0XHRsb2dnZXIuZGVidWcoXG5cdFx0XHRcdFx0J3JlbW92ZUNvbnN1bWVyKCkgfCBjYWxsaW5nIHBjLnNldExvY2FsRGVzY3JpcHRpb24oKSBbYW5zd2VyOiVvXScsXG5cdFx0XHRcdFx0YW5zd2VyKTtcblxuXHRcdFx0XHRyZXR1cm4gdGhpcy5fcGMuc2V0TG9jYWxEZXNjcmlwdGlvbihhbnN3ZXIpO1xuXHRcdFx0fSk7XG5cdH1cblxuXHRyZXN0YXJ0SWNlKHJlbW90ZUljZVBhcmFtZXRlcnMpXG5cdHtcblx0XHRsb2dnZXIuZGVidWcoJ3Jlc3RhcnRJY2UoKScpO1xuXG5cdFx0Ly8gUHJvdmlkZSB0aGUgcmVtb3RlIFNEUCBoYW5kbGVyIHdpdGggbmV3IHJlbW90ZSBJQ0UgcGFyYW1ldGVycy5cblx0XHR0aGlzLl9yZW1vdGVTZHAudXBkYXRlVHJhbnNwb3J0UmVtb3RlSWNlUGFyYW1ldGVycyhyZW1vdGVJY2VQYXJhbWV0ZXJzKTtcblxuXHRcdHJldHVybiBQcm9taXNlLnJlc29sdmUoKVxuXHRcdFx0LnRoZW4oKCkgPT5cblx0XHRcdHtcblx0XHRcdFx0Y29uc3QgcmVtb3RlU2RwID0gdGhpcy5fcmVtb3RlU2RwLmNyZWF0ZU9mZmVyU2RwKFxuXHRcdFx0XHRcdEFycmF5LmZyb20odGhpcy5fa2luZHMpLCBBcnJheS5mcm9tKHRoaXMuX2NvbnN1bWVySW5mb3MudmFsdWVzKCkpKTtcblx0XHRcdFx0Y29uc3Qgb2ZmZXIgPSB7IHR5cGU6ICdvZmZlcicsIHNkcDogcmVtb3RlU2RwIH07XG5cblx0XHRcdFx0bG9nZ2VyLmRlYnVnKFxuXHRcdFx0XHRcdCdyZXN0YXJ0SWNlKCkgfCBjYWxsaW5nIHBjLnNldFJlbW90ZURlc2NyaXB0aW9uKCkgW29mZmVyOiVvXScsXG5cdFx0XHRcdFx0b2ZmZXIpO1xuXG5cdFx0XHRcdGNvbnN0IG9mZmVyRGVzYyA9IG5ldyBSVENTZXNzaW9uRGVzY3JpcHRpb24ob2ZmZXIpO1xuXG5cdFx0XHRcdHJldHVybiB0aGlzLl9wYy5zZXRSZW1vdGVEZXNjcmlwdGlvbihvZmZlckRlc2MpO1xuXHRcdFx0fSlcblx0XHRcdC50aGVuKCgpID0+XG5cdFx0XHR7XG5cdFx0XHRcdHJldHVybiB0aGlzLl9wYy5jcmVhdGVBbnN3ZXIoKTtcblx0XHRcdH0pXG5cdFx0XHQudGhlbigoYW5zd2VyKSA9PlxuXHRcdFx0e1xuXHRcdFx0XHRsb2dnZXIuZGVidWcoXG5cdFx0XHRcdFx0J3Jlc3RhcnRJY2UoKSB8IGNhbGxpbmcgcGMuc2V0TG9jYWxEZXNjcmlwdGlvbigpIFthbnN3ZXI6JW9dJyxcblx0XHRcdFx0XHRhbnN3ZXIpO1xuXG5cdFx0XHRcdHJldHVybiB0aGlzLl9wYy5zZXRMb2NhbERlc2NyaXB0aW9uKGFuc3dlcik7XG5cdFx0XHR9KTtcblx0fVxuXG5cdF9zZXR1cFRyYW5zcG9ydCgpXG5cdHtcblx0XHRsb2dnZXIuZGVidWcoJ19zZXR1cFRyYW5zcG9ydCgpJyk7XG5cblx0XHRyZXR1cm4gUHJvbWlzZS5yZXNvbHZlKClcblx0XHRcdC50aGVuKCgpID0+XG5cdFx0XHR7XG5cdFx0XHRcdC8vIFdlIG5lZWQgdHJhbnNwb3J0IHJlbW90ZSBwYXJhbWV0ZXJzLlxuXHRcdFx0XHRyZXR1cm4gdGhpcy5zYWZlRW1pdEFzUHJvbWlzZSgnQG5lZWRjcmVhdGV0cmFuc3BvcnQnLCBudWxsKTtcblx0XHRcdH0pXG5cdFx0XHQudGhlbigodHJhbnNwb3J0UmVtb3RlUGFyYW1ldGVycykgPT5cblx0XHRcdHtcblx0XHRcdFx0Ly8gUHJvdmlkZSB0aGUgcmVtb3RlIFNEUCBoYW5kbGVyIHdpdGggdHJhbnNwb3J0IHJlbW90ZSBwYXJhbWV0ZXJzLlxuXHRcdFx0XHR0aGlzLl9yZW1vdGVTZHAuc2V0VHJhbnNwb3J0UmVtb3RlUGFyYW1ldGVycyh0cmFuc3BvcnRSZW1vdGVQYXJhbWV0ZXJzKTtcblxuXHRcdFx0XHR0aGlzLl90cmFuc3BvcnRDcmVhdGVkID0gdHJ1ZTtcblx0XHRcdH0pO1xuXHR9XG5cblx0X3VwZGF0ZVRyYW5zcG9ydCgpXG5cdHtcblx0XHRsb2dnZXIuZGVidWcoJ191cGRhdGVUcmFuc3BvcnQoKScpO1xuXG5cdFx0Ly8gR2V0IG91ciBsb2NhbCBEVExTIHBhcmFtZXRlcnMuXG5cdFx0Ly8gY29uc3QgdHJhbnNwb3J0TG9jYWxQYXJhbWV0ZXJzID0ge307XG5cdFx0Y29uc3Qgc2RwID0gdGhpcy5fcGMubG9jYWxEZXNjcmlwdGlvbi5zZHA7XG5cdFx0Y29uc3Qgc2RwT2JqID0gc2RwVHJhbnNmb3JtLnBhcnNlKHNkcCk7XG5cdFx0Y29uc3QgZHRsc1BhcmFtZXRlcnMgPSBzZHBDb21tb25VdGlscy5leHRyYWN0RHRsc1BhcmFtZXRlcnMoc2RwT2JqKTtcblx0XHRjb25zdCB0cmFuc3BvcnRMb2NhbFBhcmFtZXRlcnMgPSB7IGR0bHNQYXJhbWV0ZXJzIH07XG5cblx0XHQvLyBXZSBuZWVkIHRvIHByb3ZpZGUgdHJhbnNwb3J0IGxvY2FsIHBhcmFtZXRlcnMuXG5cdFx0dGhpcy5zYWZlRW1pdCgnQG5lZWR1cGRhdGV0cmFuc3BvcnQnLCB0cmFuc3BvcnRMb2NhbFBhcmFtZXRlcnMpO1xuXG5cdFx0dGhpcy5fdHJhbnNwb3J0VXBkYXRlZCA9IHRydWU7XG5cdH1cbn1cblxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgUmVhY3ROYXRpdmVcbntcblx0c3RhdGljIGdldCB0YWcoKVxuXHR7XG5cdFx0cmV0dXJuICdSZWFjdE5hdGl2ZSc7XG5cdH1cblxuXHRzdGF0aWMgZ2V0TmF0aXZlUnRwQ2FwYWJpbGl0aWVzKClcblx0e1xuXHRcdGxvZ2dlci5kZWJ1ZygnZ2V0TmF0aXZlUnRwQ2FwYWJpbGl0aWVzKCknKTtcblxuXHRcdGNvbnN0IHBjID0gbmV3IFJUQ1BlZXJDb25uZWN0aW9uKFxuXHRcdFx0e1xuXHRcdFx0XHRpY2VTZXJ2ZXJzICAgICAgICAgOiBbXSxcblx0XHRcdFx0aWNlVHJhbnNwb3J0UG9saWN5IDogJ2FsbCcsXG5cdFx0XHRcdGJ1bmRsZVBvbGljeSAgICAgICA6ICdtYXgtYnVuZGxlJyxcblx0XHRcdFx0cnRjcE11eFBvbGljeSAgICAgIDogJ3JlcXVpcmUnXG5cdFx0XHR9KTtcblxuXHRcdHJldHVybiBwYy5jcmVhdGVPZmZlcihcblx0XHRcdHtcblx0XHRcdFx0b2ZmZXJUb1JlY2VpdmVBdWRpbyA6IHRydWUsXG5cdFx0XHRcdG9mZmVyVG9SZWNlaXZlVmlkZW8gOiB0cnVlXG5cdFx0XHR9KVxuXHRcdFx0LnRoZW4oKG9mZmVyKSA9PlxuXHRcdFx0e1xuXHRcdFx0XHR0cnkgeyBwYy5jbG9zZSgpOyB9XG5cdFx0XHRcdGNhdGNoIChlcnJvcikge31cblxuXHRcdFx0XHRjb25zdCBzZHBPYmogPSBzZHBUcmFuc2Zvcm0ucGFyc2Uob2ZmZXIuc2RwKTtcblx0XHRcdFx0Y29uc3QgbmF0aXZlUnRwQ2FwYWJpbGl0aWVzID0gc2RwQ29tbW9uVXRpbHMuZXh0cmFjdFJ0cENhcGFiaWxpdGllcyhzZHBPYmopO1xuXG5cdFx0XHRcdHJldHVybiBuYXRpdmVSdHBDYXBhYmlsaXRpZXM7XG5cdFx0XHR9KVxuXHRcdFx0LmNhdGNoKChlcnJvcikgPT5cblx0XHRcdHtcblx0XHRcdFx0dHJ5IHsgcGMuY2xvc2UoKTsgfVxuXHRcdFx0XHRjYXRjaCAoZXJyb3IyKSB7fVxuXG5cdFx0XHRcdHRocm93IGVycm9yO1xuXHRcdFx0fSk7XG5cdH1cblxuXHRjb25zdHJ1Y3RvcihkaXJlY3Rpb24sIGV4dGVuZGVkUnRwQ2FwYWJpbGl0aWVzLCBzZXR0aW5ncylcblx0e1xuXHRcdGxvZ2dlci5kZWJ1Zyhcblx0XHRcdCdjb25zdHJ1Y3RvcigpIFtkaXJlY3Rpb246JXMsIGV4dGVuZGVkUnRwQ2FwYWJpbGl0aWVzOiVvXScsXG5cdFx0XHRkaXJlY3Rpb24sIGV4dGVuZGVkUnRwQ2FwYWJpbGl0aWVzKTtcblxuXHRcdGxldCBydHBQYXJhbWV0ZXJzQnlLaW5kO1xuXG5cdFx0c3dpdGNoIChkaXJlY3Rpb24pXG5cdFx0e1xuXHRcdFx0Y2FzZSAnc2VuZCc6XG5cdFx0XHR7XG5cdFx0XHRcdHJ0cFBhcmFtZXRlcnNCeUtpbmQgPVxuXHRcdFx0XHR7XG5cdFx0XHRcdFx0YXVkaW8gOiBvcnRjLmdldFNlbmRpbmdSdHBQYXJhbWV0ZXJzKCdhdWRpbycsIGV4dGVuZGVkUnRwQ2FwYWJpbGl0aWVzKSxcblx0XHRcdFx0XHR2aWRlbyA6IG9ydGMuZ2V0U2VuZGluZ1J0cFBhcmFtZXRlcnMoJ3ZpZGVvJywgZXh0ZW5kZWRSdHBDYXBhYmlsaXRpZXMpXG5cdFx0XHRcdH07XG5cblx0XHRcdFx0cmV0dXJuIG5ldyBTZW5kSGFuZGxlcihydHBQYXJhbWV0ZXJzQnlLaW5kLCBzZXR0aW5ncyk7XG5cdFx0XHR9XG5cdFx0XHRjYXNlICdyZWN2Jzpcblx0XHRcdHtcblx0XHRcdFx0cnRwUGFyYW1ldGVyc0J5S2luZCA9XG5cdFx0XHRcdHtcblx0XHRcdFx0XHRhdWRpbyA6IG9ydGMuZ2V0UmVjZWl2aW5nRnVsbFJ0cFBhcmFtZXRlcnMoJ2F1ZGlvJywgZXh0ZW5kZWRSdHBDYXBhYmlsaXRpZXMpLFxuXHRcdFx0XHRcdHZpZGVvIDogb3J0Yy5nZXRSZWNlaXZpbmdGdWxsUnRwUGFyYW1ldGVycygndmlkZW8nLCBleHRlbmRlZFJ0cENhcGFiaWxpdGllcylcblx0XHRcdFx0fTtcblxuXHRcdFx0XHRyZXR1cm4gbmV3IFJlY3ZIYW5kbGVyKHJ0cFBhcmFtZXRlcnNCeUtpbmQsIHNldHRpbmdzKTtcblx0XHRcdH1cblx0XHR9XG5cdH1cbn1cbiIsImltcG9ydCBzZHBUcmFuc2Zvcm0gZnJvbSAnc2RwLXRyYW5zZm9ybSc7XG5pbXBvcnQgTG9nZ2VyIGZyb20gJy4uL0xvZ2dlcic7XG5pbXBvcnQgRW5oYW5jZWRFdmVudEVtaXR0ZXIgZnJvbSAnLi4vRW5oYW5jZWRFdmVudEVtaXR0ZXInO1xuaW1wb3J0ICogYXMgdXRpbHMgZnJvbSAnLi4vdXRpbHMnO1xuaW1wb3J0ICogYXMgb3J0YyBmcm9tICcuLi9vcnRjJztcbmltcG9ydCAqIGFzIHNkcENvbW1vblV0aWxzIGZyb20gJy4vc2RwL2NvbW1vblV0aWxzJztcbmltcG9ydCAqIGFzIHNkcFBsYW5CVXRpbHMgZnJvbSAnLi9zZHAvcGxhbkJVdGlscyc7XG5pbXBvcnQgUmVtb3RlUGxhbkJTZHAgZnJvbSAnLi9zZHAvUmVtb3RlUGxhbkJTZHAnO1xuXG5jb25zdCBsb2dnZXIgPSBuZXcgTG9nZ2VyKCdTYWZhcmkxMScpO1xuXG5jbGFzcyBIYW5kbGVyIGV4dGVuZHMgRW5oYW5jZWRFdmVudEVtaXR0ZXJcbntcblx0Y29uc3RydWN0b3IoZGlyZWN0aW9uLCBydHBQYXJhbWV0ZXJzQnlLaW5kLCBzZXR0aW5ncylcblx0e1xuXHRcdHN1cGVyKGxvZ2dlcik7XG5cblx0XHQvLyBSVENQZWVyQ29ubmVjdGlvbiBpbnN0YW5jZS5cblx0XHQvLyBAdHlwZSB7UlRDUGVlckNvbm5lY3Rpb259XG5cdFx0dGhpcy5fcGMgPSBuZXcgUlRDUGVlckNvbm5lY3Rpb24oXG5cdFx0XHR7XG5cdFx0XHRcdGljZVNlcnZlcnMgICAgICAgICA6IHNldHRpbmdzLnR1cm5TZXJ2ZXJzIHx8IFtdLFxuXHRcdFx0XHRpY2VUcmFuc3BvcnRQb2xpY3kgOiAnYWxsJyxcblx0XHRcdFx0YnVuZGxlUG9saWN5ICAgICAgIDogJ21heC1idW5kbGUnLFxuXHRcdFx0XHRydGNwTXV4UG9saWN5ICAgICAgOiAncmVxdWlyZSdcblx0XHRcdH0pO1xuXG5cdFx0Ly8gR2VuZXJpYyBzZW5kaW5nIFJUUCBwYXJhbWV0ZXJzIGZvciBhdWRpbyBhbmQgdmlkZW8uXG5cdFx0Ly8gQHR5cGUge09iamVjdH1cblx0XHR0aGlzLl9ydHBQYXJhbWV0ZXJzQnlLaW5kID0gcnRwUGFyYW1ldGVyc0J5S2luZDtcblxuXHRcdC8vIFJlbW90ZSBTRFAgaGFuZGxlci5cblx0XHQvLyBAdHlwZSB7UmVtb3RlUGxhbkJTZHB9XG5cdFx0dGhpcy5fcmVtb3RlU2RwID0gbmV3IFJlbW90ZVBsYW5CU2RwKGRpcmVjdGlvbiwgcnRwUGFyYW1ldGVyc0J5S2luZCk7XG5cblx0XHQvLyBIYW5kbGUgUlRDUGVlckNvbm5lY3Rpb24gY29ubmVjdGlvbiBzdGF0dXMuXG5cdFx0dGhpcy5fcGMuYWRkRXZlbnRMaXN0ZW5lcignaWNlY29ubmVjdGlvbnN0YXRlY2hhbmdlJywgKCkgPT5cblx0XHR7XG5cdFx0XHRzd2l0Y2ggKHRoaXMuX3BjLmljZUNvbm5lY3Rpb25TdGF0ZSlcblx0XHRcdHtcblx0XHRcdFx0Y2FzZSAnY2hlY2tpbmcnOlxuXHRcdFx0XHRcdHRoaXMuZW1pdCgnQGNvbm5lY3Rpb25zdGF0ZWNoYW5nZScsICdjb25uZWN0aW5nJyk7XG5cdFx0XHRcdFx0YnJlYWs7XG5cdFx0XHRcdGNhc2UgJ2Nvbm5lY3RlZCc6XG5cdFx0XHRcdGNhc2UgJ2NvbXBsZXRlZCc6XG5cdFx0XHRcdFx0dGhpcy5lbWl0KCdAY29ubmVjdGlvbnN0YXRlY2hhbmdlJywgJ2Nvbm5lY3RlZCcpO1xuXHRcdFx0XHRcdGJyZWFrO1xuXHRcdFx0XHRjYXNlICdmYWlsZWQnOlxuXHRcdFx0XHRcdHRoaXMuZW1pdCgnQGNvbm5lY3Rpb25zdGF0ZWNoYW5nZScsICdmYWlsZWQnKTtcblx0XHRcdFx0XHRicmVhaztcblx0XHRcdFx0Y2FzZSAnZGlzY29ubmVjdGVkJzpcblx0XHRcdFx0XHR0aGlzLmVtaXQoJ0Bjb25uZWN0aW9uc3RhdGVjaGFuZ2UnLCAnZGlzY29ubmVjdGVkJyk7XG5cdFx0XHRcdFx0YnJlYWs7XG5cdFx0XHRcdGNhc2UgJ2Nsb3NlZCc6XG5cdFx0XHRcdFx0dGhpcy5lbWl0KCdAY29ubmVjdGlvbnN0YXRlY2hhbmdlJywgJ2Nsb3NlZCcpO1xuXHRcdFx0XHRcdGJyZWFrO1xuXHRcdFx0fVxuXHRcdH0pO1xuXHR9XG5cblx0Y2xvc2UoKVxuXHR7XG5cdFx0bG9nZ2VyLmRlYnVnKCdjbG9zZSgpJyk7XG5cblx0XHQvLyBDbG9zZSBSVENQZWVyQ29ubmVjdGlvbi5cblx0XHR0cnkgeyB0aGlzLl9wYy5jbG9zZSgpOyB9XG5cdFx0Y2F0Y2ggKGVycm9yKSB7fVxuXHR9XG59XG5cbmNsYXNzIFNlbmRIYW5kbGVyIGV4dGVuZHMgSGFuZGxlclxue1xuXHRjb25zdHJ1Y3RvcihydHBQYXJhbWV0ZXJzQnlLaW5kLCBzZXR0aW5ncylcblx0e1xuXHRcdHN1cGVyKCdzZW5kJywgcnRwUGFyYW1ldGVyc0J5S2luZCwgc2V0dGluZ3MpO1xuXG5cdFx0Ly8gR290IHRyYW5zcG9ydCBsb2NhbCBhbmQgcmVtb3RlIHBhcmFtZXRlcnMuXG5cdFx0Ly8gQHR5cGUge0Jvb2xlYW59XG5cdFx0dGhpcy5fdHJhbnNwb3J0UmVhZHkgPSBmYWxzZTtcblxuXHRcdC8vIExvY2FsIHN0cmVhbS5cblx0XHQvLyBAdHlwZSB7TWVkaWFTdHJlYW19XG5cdFx0dGhpcy5fc3RyZWFtID0gbmV3IE1lZGlhU3RyZWFtKCk7XG5cdH1cblxuXHRhZGRQcm9kdWNlcihwcm9kdWNlcilcblx0e1xuXHRcdGNvbnN0IHsgdHJhY2sgfSA9IHByb2R1Y2VyO1xuXG5cdFx0bG9nZ2VyLmRlYnVnKFxuXHRcdFx0J2FkZFByb2R1Y2VyKCkgW2lkOiVzLCBraW5kOiVzLCB0cmFja0lkOiVzXScsXG5cdFx0XHRwcm9kdWNlci5pZCwgcHJvZHVjZXIua2luZCwgdHJhY2suaWQpO1xuXG5cdFx0aWYgKHRoaXMuX3N0cmVhbS5nZXRUcmFja0J5SWQodHJhY2suaWQpKVxuXHRcdFx0cmV0dXJuIFByb21pc2UucmVqZWN0KG5ldyBFcnJvcigndHJhY2sgYWxyZWFkeSBhZGRlZCcpKTtcblxuXHRcdGxldCBydHBTZW5kZXI7XG5cdFx0bGV0IGxvY2FsU2RwT2JqO1xuXG5cdFx0cmV0dXJuIFByb21pc2UucmVzb2x2ZSgpXG5cdFx0XHQudGhlbigoKSA9PlxuXHRcdFx0e1xuXHRcdFx0XHR0aGlzLl9zdHJlYW0uYWRkVHJhY2sodHJhY2spO1xuXG5cdFx0XHRcdC8vIEFkZCB0aGUgc3RyZWFtIHRvIHRoZSBQZWVyQ29ubmVjdGlvbi5cblx0XHRcdFx0cnRwU2VuZGVyID0gdGhpcy5fcGMuYWRkVHJhY2sodHJhY2ssIHRoaXMuX3N0cmVhbSk7XG5cblx0XHRcdFx0cmV0dXJuIHRoaXMuX3BjLmNyZWF0ZU9mZmVyKCk7XG5cdFx0XHR9KVxuXHRcdFx0LnRoZW4oKG9mZmVyKSA9PlxuXHRcdFx0e1xuXHRcdFx0XHRsb2dnZXIuZGVidWcoXG5cdFx0XHRcdFx0J2FkZFByb2R1Y2VyKCkgfCBjYWxsaW5nIHBjLnNldExvY2FsRGVzY3JpcHRpb24oKSBbb2ZmZXI6JW9dJyxcblx0XHRcdFx0XHRvZmZlcik7XG5cblx0XHRcdFx0cmV0dXJuIHRoaXMuX3BjLnNldExvY2FsRGVzY3JpcHRpb24ob2ZmZXIpO1xuXHRcdFx0fSlcblx0XHRcdC50aGVuKCgpID0+XG5cdFx0XHR7XG5cdFx0XHRcdGlmICghdGhpcy5fdHJhbnNwb3J0UmVhZHkpXG5cdFx0XHRcdFx0cmV0dXJuIHRoaXMuX3NldHVwVHJhbnNwb3J0KCk7XG5cdFx0XHR9KVxuXHRcdFx0LnRoZW4oKCkgPT5cblx0XHRcdHtcblx0XHRcdFx0bG9jYWxTZHBPYmogPSBzZHBUcmFuc2Zvcm0ucGFyc2UodGhpcy5fcGMubG9jYWxEZXNjcmlwdGlvbi5zZHApO1xuXG5cdFx0XHRcdGNvbnN0IHJlbW90ZVNkcCA9IHRoaXMuX3JlbW90ZVNkcC5jcmVhdGVBbnN3ZXJTZHAobG9jYWxTZHBPYmopO1xuXHRcdFx0XHRjb25zdCBhbnN3ZXIgPSB7IHR5cGU6ICdhbnN3ZXInLCBzZHA6IHJlbW90ZVNkcCB9O1xuXG5cdFx0XHRcdGxvZ2dlci5kZWJ1Zyhcblx0XHRcdFx0XHQnYWRkUHJvZHVjZXIoKSB8IGNhbGxpbmcgcGMuc2V0UmVtb3RlRGVzY3JpcHRpb24oKSBbYW5zd2VyOiVvXScsXG5cdFx0XHRcdFx0YW5zd2VyKTtcblxuXHRcdFx0XHRyZXR1cm4gdGhpcy5fcGMuc2V0UmVtb3RlRGVzY3JpcHRpb24oYW5zd2VyKTtcblx0XHRcdH0pXG5cdFx0XHQudGhlbigoKSA9PlxuXHRcdFx0e1xuXHRcdFx0XHRjb25zdCBydHBQYXJhbWV0ZXJzID0gdXRpbHMuY2xvbmUodGhpcy5fcnRwUGFyYW1ldGVyc0J5S2luZFtwcm9kdWNlci5raW5kXSk7XG5cblx0XHRcdFx0Ly8gRmlsbCB0aGUgUlRQIHBhcmFtZXRlcnMgZm9yIHRoaXMgdHJhY2suXG5cdFx0XHRcdHNkcFBsYW5CVXRpbHMuZmlsbFJ0cFBhcmFtZXRlcnNGb3JUcmFjayhcblx0XHRcdFx0XHRydHBQYXJhbWV0ZXJzLCBsb2NhbFNkcE9iaiwgdHJhY2spO1xuXG5cdFx0XHRcdHJldHVybiBydHBQYXJhbWV0ZXJzO1xuXHRcdFx0fSlcblx0XHRcdC5jYXRjaCgoZXJyb3IpID0+XG5cdFx0XHR7XG5cdFx0XHRcdC8vIFBhbmljIGhlcmUuIFRyeSB0byB1bmRvIHRoaW5ncy5cblxuXHRcdFx0XHR0cnkgeyB0aGlzLl9wYy5yZW1vdmVUcmFjayhydHBTZW5kZXIpOyB9XG5cdFx0XHRcdGNhdGNoIChlcnJvcjIpIHt9XG5cblx0XHRcdFx0dGhpcy5fc3RyZWFtLnJlbW92ZVRyYWNrKHRyYWNrKTtcblxuXHRcdFx0XHR0aHJvdyBlcnJvcjtcblx0XHRcdH0pO1xuXHR9XG5cblx0cmVtb3ZlUHJvZHVjZXIocHJvZHVjZXIpXG5cdHtcblx0XHRjb25zdCB7IHRyYWNrIH0gPSBwcm9kdWNlcjtcblxuXHRcdGxvZ2dlci5kZWJ1Zyhcblx0XHRcdCdyZW1vdmVQcm9kdWNlcigpIFtpZDolcywga2luZDolcywgdHJhY2tJZDolc10nLFxuXHRcdFx0cHJvZHVjZXIuaWQsIHByb2R1Y2VyLmtpbmQsIHRyYWNrLmlkKTtcblxuXHRcdHJldHVybiBQcm9taXNlLnJlc29sdmUoKVxuXHRcdFx0LnRoZW4oKCkgPT5cblx0XHRcdHtcblx0XHRcdFx0Ly8gR2V0IHRoZSBhc3NvY2lhdGVkIFJUQ1J0cFNlbmRlci5cblx0XHRcdFx0Y29uc3QgcnRwU2VuZGVyID0gdGhpcy5fcGMuZ2V0U2VuZGVycygpXG5cdFx0XHRcdFx0LmZpbmQoKHMpID0+IHMudHJhY2sgPT09IHRyYWNrKTtcblxuXHRcdFx0XHRpZiAoIXJ0cFNlbmRlcilcblx0XHRcdFx0XHR0aHJvdyBuZXcgRXJyb3IoJ1JUQ1J0cFNlbmRlciBmb3VuZCcpO1xuXG5cdFx0XHRcdC8vIFJlbW92ZSB0aGUgYXNzb2NpYXRlZCBSdHBTZW5kZXIuXG5cdFx0XHRcdHRoaXMuX3BjLnJlbW92ZVRyYWNrKHJ0cFNlbmRlcik7XG5cblx0XHRcdFx0Ly8gUmVtb3ZlIHRoZSB0cmFjayBmcm9tIHRoZSBsb2NhbCBzdHJlYW0uXG5cdFx0XHRcdHRoaXMuX3N0cmVhbS5yZW1vdmVUcmFjayh0cmFjayk7XG5cblx0XHRcdFx0cmV0dXJuIHRoaXMuX3BjLmNyZWF0ZU9mZmVyKCk7XG5cdFx0XHR9KVxuXHRcdFx0LnRoZW4oKG9mZmVyKSA9PlxuXHRcdFx0e1xuXHRcdFx0XHRsb2dnZXIuZGVidWcoXG5cdFx0XHRcdFx0J3JlbW92ZVByb2R1Y2VyKCkgfCBjYWxsaW5nIHBjLnNldExvY2FsRGVzY3JpcHRpb24oKSBbb2ZmZXI6JW9dJyxcblx0XHRcdFx0XHRvZmZlcik7XG5cblx0XHRcdFx0cmV0dXJuIHRoaXMuX3BjLnNldExvY2FsRGVzY3JpcHRpb24ob2ZmZXIpO1xuXHRcdFx0fSlcblx0XHRcdC5jYXRjaCgoZXJyb3IpID0+XG5cdFx0XHR7XG5cdFx0XHRcdC8vIE5PVEU6IElmIHRoZXJlIGFyZSBubyBzZW5kaW5nIHRyYWNrcywgc2V0TG9jYWxEZXNjcmlwdGlvbigpIHdpbGwgZmFpbCB3aXRoXG5cdFx0XHRcdC8vIFwiRmFpbGVkIHRvIGNyZWF0ZSBjaGFubmVsc1wiLiBJZiBzbywgaWdub3JlIGl0LlxuXHRcdFx0XHRpZiAodGhpcy5fc3RyZWFtLmdldFRyYWNrcygpLmxlbmd0aCA9PT0gMClcblx0XHRcdFx0e1xuXHRcdFx0XHRcdGxvZ2dlci53YXJuKFxuXHRcdFx0XHRcdFx0J3JlbW92ZUxvY2FsVHJhY2soKSB8IGlnbm9yaW5nIGV4cGVjdGVkIGVycm9yIGR1ZSBubyBzZW5kaW5nIHRyYWNrczogJXMnLFxuXHRcdFx0XHRcdFx0ZXJyb3IudG9TdHJpbmcoKSk7XG5cblx0XHRcdFx0XHRyZXR1cm47XG5cdFx0XHRcdH1cblxuXHRcdFx0XHR0aHJvdyBlcnJvcjtcblx0XHRcdH0pXG5cdFx0XHQudGhlbigoKSA9PlxuXHRcdFx0e1xuXHRcdFx0XHRpZiAodGhpcy5fcGMuc2lnbmFsaW5nU3RhdGUgPT09ICdzdGFibGUnKVxuXHRcdFx0XHRcdHJldHVybjtcblxuXHRcdFx0XHRjb25zdCBsb2NhbFNkcE9iaiA9IHNkcFRyYW5zZm9ybS5wYXJzZSh0aGlzLl9wYy5sb2NhbERlc2NyaXB0aW9uLnNkcCk7XG5cdFx0XHRcdGNvbnN0IHJlbW90ZVNkcCA9IHRoaXMuX3JlbW90ZVNkcC5jcmVhdGVBbnN3ZXJTZHAobG9jYWxTZHBPYmopO1xuXHRcdFx0XHRjb25zdCBhbnN3ZXIgPSB7IHR5cGU6ICdhbnN3ZXInLCBzZHA6IHJlbW90ZVNkcCB9O1xuXG5cdFx0XHRcdGxvZ2dlci5kZWJ1Zyhcblx0XHRcdFx0XHQncmVtb3ZlUHJvZHVjZXIoKSB8IGNhbGxpbmcgcGMuc2V0UmVtb3RlRGVzY3JpcHRpb24oKSBbYW5zd2VyOiVvXScsXG5cdFx0XHRcdFx0YW5zd2VyKTtcblxuXHRcdFx0XHRyZXR1cm4gdGhpcy5fcGMuc2V0UmVtb3RlRGVzY3JpcHRpb24oYW5zd2VyKTtcblx0XHRcdH0pO1xuXHR9XG5cblx0cmVwbGFjZVByb2R1Y2VyVHJhY2socHJvZHVjZXIsIHRyYWNrKVxuXHR7XG5cdFx0bG9nZ2VyLmRlYnVnKFxuXHRcdFx0J3JlcGxhY2VQcm9kdWNlclRyYWNrKCkgW2lkOiVzLCBraW5kOiVzLCB0cmFja0lkOiVzXScsXG5cdFx0XHRwcm9kdWNlci5pZCwgcHJvZHVjZXIua2luZCwgdHJhY2suaWQpO1xuXG5cdFx0Y29uc3Qgb2xkVHJhY2sgPSBwcm9kdWNlci50cmFjaztcblxuXHRcdHJldHVybiBQcm9taXNlLnJlc29sdmUoKVxuXHRcdFx0LnRoZW4oKCkgPT5cblx0XHRcdHtcblx0XHRcdFx0Ly8gR2V0IHRoZSBhc3NvY2lhdGVkIFJUQ1J0cFNlbmRlci5cblx0XHRcdFx0Y29uc3QgcnRwU2VuZGVyID0gdGhpcy5fcGMuZ2V0U2VuZGVycygpXG5cdFx0XHRcdFx0LmZpbmQoKHMpID0+IHMudHJhY2sgPT09IG9sZFRyYWNrKTtcblxuXHRcdFx0XHRpZiAoIXJ0cFNlbmRlcilcblx0XHRcdFx0XHR0aHJvdyBuZXcgRXJyb3IoJ2xvY2FsIHRyYWNrIG5vdCBmb3VuZCcpO1xuXG5cdFx0XHRcdHJldHVybiBydHBTZW5kZXIucmVwbGFjZVRyYWNrKHRyYWNrKTtcblx0XHRcdH0pXG5cdFx0XHQudGhlbigoKSA9PlxuXHRcdFx0e1xuXHRcdFx0XHQvLyBSZW1vdmUgdGhlIG9sZCB0cmFjayBmcm9tIHRoZSBsb2NhbCBzdHJlYW0uXG5cdFx0XHRcdHRoaXMuX3N0cmVhbS5yZW1vdmVUcmFjayhvbGRUcmFjayk7XG5cblx0XHRcdFx0Ly8gQWRkIHRoZSBuZXcgdHJhY2sgdG8gdGhlIGxvY2FsIHN0cmVhbS5cblx0XHRcdFx0dGhpcy5fc3RyZWFtLmFkZFRyYWNrKHRyYWNrKTtcblx0XHRcdH0pO1xuXHR9XG5cblx0cmVzdGFydEljZShyZW1vdGVJY2VQYXJhbWV0ZXJzKVxuXHR7XG5cdFx0bG9nZ2VyLmRlYnVnKCdyZXN0YXJ0SWNlKCknKTtcblxuXHRcdC8vIFByb3ZpZGUgdGhlIHJlbW90ZSBTRFAgaGFuZGxlciB3aXRoIG5ldyByZW1vdGUgSUNFIHBhcmFtZXRlcnMuXG5cdFx0dGhpcy5fcmVtb3RlU2RwLnVwZGF0ZVRyYW5zcG9ydFJlbW90ZUljZVBhcmFtZXRlcnMocmVtb3RlSWNlUGFyYW1ldGVycyk7XG5cblx0XHRyZXR1cm4gUHJvbWlzZS5yZXNvbHZlKClcblx0XHRcdC50aGVuKCgpID0+XG5cdFx0XHR7XG5cdFx0XHRcdHJldHVybiB0aGlzLl9wYy5jcmVhdGVPZmZlcih7IGljZVJlc3RhcnQ6IHRydWUgfSk7XG5cdFx0XHR9KVxuXHRcdFx0LnRoZW4oKG9mZmVyKSA9PlxuXHRcdFx0e1xuXHRcdFx0XHRsb2dnZXIuZGVidWcoXG5cdFx0XHRcdFx0J3Jlc3RhcnRJY2UoKSB8IGNhbGxpbmcgcGMuc2V0TG9jYWxEZXNjcmlwdGlvbigpIFtvZmZlcjolb10nLFxuXHRcdFx0XHRcdG9mZmVyKTtcblxuXHRcdFx0XHRyZXR1cm4gdGhpcy5fcGMuc2V0TG9jYWxEZXNjcmlwdGlvbihvZmZlcik7XG5cdFx0XHR9KVxuXHRcdFx0LnRoZW4oKCkgPT5cblx0XHRcdHtcblx0XHRcdFx0Y29uc3QgbG9jYWxTZHBPYmogPSBzZHBUcmFuc2Zvcm0ucGFyc2UodGhpcy5fcGMubG9jYWxEZXNjcmlwdGlvbi5zZHApO1xuXHRcdFx0XHRjb25zdCByZW1vdGVTZHAgPSB0aGlzLl9yZW1vdGVTZHAuY3JlYXRlQW5zd2VyU2RwKGxvY2FsU2RwT2JqKTtcblx0XHRcdFx0Y29uc3QgYW5zd2VyID0geyB0eXBlOiAnYW5zd2VyJywgc2RwOiByZW1vdGVTZHAgfTtcblxuXHRcdFx0XHRsb2dnZXIuZGVidWcoXG5cdFx0XHRcdFx0J3Jlc3RhcnRJY2UoKSB8IGNhbGxpbmcgcGMuc2V0UmVtb3RlRGVzY3JpcHRpb24oKSBbYW5zd2VyOiVvXScsXG5cdFx0XHRcdFx0YW5zd2VyKTtcblxuXHRcdFx0XHRyZXR1cm4gdGhpcy5fcGMuc2V0UmVtb3RlRGVzY3JpcHRpb24oYW5zd2VyKTtcblx0XHRcdH0pO1xuXHR9XG5cblx0X3NldHVwVHJhbnNwb3J0KClcblx0e1xuXHRcdGxvZ2dlci5kZWJ1ZygnX3NldHVwVHJhbnNwb3J0KCknKTtcblxuXHRcdHJldHVybiBQcm9taXNlLnJlc29sdmUoKVxuXHRcdFx0LnRoZW4oKCkgPT5cblx0XHRcdHtcblx0XHRcdFx0Ly8gR2V0IG91ciBsb2NhbCBEVExTIHBhcmFtZXRlcnMuXG5cdFx0XHRcdGNvbnN0IHRyYW5zcG9ydExvY2FsUGFyYW1ldGVycyA9IHt9O1xuXHRcdFx0XHRjb25zdCBzZHAgPSB0aGlzLl9wYy5sb2NhbERlc2NyaXB0aW9uLnNkcDtcblx0XHRcdFx0Y29uc3Qgc2RwT2JqID0gc2RwVHJhbnNmb3JtLnBhcnNlKHNkcCk7XG5cdFx0XHRcdGNvbnN0IGR0bHNQYXJhbWV0ZXJzID0gc2RwQ29tbW9uVXRpbHMuZXh0cmFjdER0bHNQYXJhbWV0ZXJzKHNkcE9iaik7XG5cblx0XHRcdFx0Ly8gTGV0J3MgZGVjaWRlIHRoYXQgd2UnbGwgYmUgRFRMUyBzZXJ2ZXIgKGJlY2F1c2Ugd2UgY2FuKS5cblx0XHRcdFx0ZHRsc1BhcmFtZXRlcnMucm9sZSA9ICdzZXJ2ZXInO1xuXG5cdFx0XHRcdHRyYW5zcG9ydExvY2FsUGFyYW1ldGVycy5kdGxzUGFyYW1ldGVycyA9IGR0bHNQYXJhbWV0ZXJzO1xuXG5cdFx0XHRcdC8vIFByb3ZpZGUgdGhlIHJlbW90ZSBTRFAgaGFuZGxlciB3aXRoIHRyYW5zcG9ydCBsb2NhbCBwYXJhbWV0ZXJzLlxuXHRcdFx0XHR0aGlzLl9yZW1vdGVTZHAuc2V0VHJhbnNwb3J0TG9jYWxQYXJhbWV0ZXJzKHRyYW5zcG9ydExvY2FsUGFyYW1ldGVycyk7XG5cblx0XHRcdFx0Ly8gV2UgbmVlZCB0cmFuc3BvcnQgcmVtb3RlIHBhcmFtZXRlcnMuXG5cdFx0XHRcdHJldHVybiB0aGlzLnNhZmVFbWl0QXNQcm9taXNlKFxuXHRcdFx0XHRcdCdAbmVlZGNyZWF0ZXRyYW5zcG9ydCcsIHRyYW5zcG9ydExvY2FsUGFyYW1ldGVycyk7XG5cdFx0XHR9KVxuXHRcdFx0LnRoZW4oKHRyYW5zcG9ydFJlbW90ZVBhcmFtZXRlcnMpID0+XG5cdFx0XHR7XG5cdFx0XHRcdC8vIFByb3ZpZGUgdGhlIHJlbW90ZSBTRFAgaGFuZGxlciB3aXRoIHRyYW5zcG9ydCByZW1vdGUgcGFyYW1ldGVycy5cblx0XHRcdFx0dGhpcy5fcmVtb3RlU2RwLnNldFRyYW5zcG9ydFJlbW90ZVBhcmFtZXRlcnModHJhbnNwb3J0UmVtb3RlUGFyYW1ldGVycyk7XG5cblx0XHRcdFx0dGhpcy5fdHJhbnNwb3J0UmVhZHkgPSB0cnVlO1xuXHRcdFx0fSk7XG5cdH1cbn1cblxuY2xhc3MgUmVjdkhhbmRsZXIgZXh0ZW5kcyBIYW5kbGVyXG57XG5cdGNvbnN0cnVjdG9yKHJ0cFBhcmFtZXRlcnNCeUtpbmQsIHNldHRpbmdzKVxuXHR7XG5cdFx0c3VwZXIoJ3JlY3YnLCBydHBQYXJhbWV0ZXJzQnlLaW5kLCBzZXR0aW5ncyk7XG5cblx0XHQvLyBHb3QgdHJhbnNwb3J0IHJlbW90ZSBwYXJhbWV0ZXJzLlxuXHRcdC8vIEB0eXBlIHtCb29sZWFufVxuXHRcdHRoaXMuX3RyYW5zcG9ydENyZWF0ZWQgPSBmYWxzZTtcblxuXHRcdC8vIEdvdCB0cmFuc3BvcnQgbG9jYWwgcGFyYW1ldGVycy5cblx0XHQvLyBAdHlwZSB7Qm9vbGVhbn1cblx0XHR0aGlzLl90cmFuc3BvcnRVcGRhdGVkID0gZmFsc2U7XG5cblx0XHQvLyBTZWVuIG1lZGlhIGtpbmRzLlxuXHRcdC8vIEB0eXBlIHtTZXQ8U3RyaW5nPn1cblx0XHR0aGlzLl9raW5kcyA9IG5ldyBTZXQoKTtcblxuXHRcdC8vIE1hcCBvZiBDb25zdW1lcnMgaW5mb3JtYXRpb24gaW5kZXhlZCBieSBjb25zdW1lci5pZC5cblx0XHQvLyAtIGtpbmQge1N0cmluZ31cblx0XHQvLyAtIHRyYWNrSWQge1N0cmluZ31cblx0XHQvLyAtIHNzcmMge051bWJlcn1cblx0XHQvLyAtIHJ0eFNzcmMge051bWJlcn1cblx0XHQvLyAtIGNuYW1lIHtTdHJpbmd9XG5cdFx0Ly8gQHR5cGUge01hcDxOdW1iZXIsIE9iamVjdD59XG5cdFx0dGhpcy5fY29uc3VtZXJJbmZvcyA9IG5ldyBNYXAoKTtcblx0fVxuXG5cdGFkZENvbnN1bWVyKGNvbnN1bWVyKVxuXHR7XG5cdFx0bG9nZ2VyLmRlYnVnKFxuXHRcdFx0J2FkZENvbnN1bWVyKCkgW2lkOiVzLCBraW5kOiVzXScsIGNvbnN1bWVyLmlkLCBjb25zdW1lci5raW5kKTtcblxuXHRcdGlmICh0aGlzLl9jb25zdW1lckluZm9zLmhhcyhjb25zdW1lci5pZCkpXG5cdFx0XHRyZXR1cm4gUHJvbWlzZS5yZWplY3QobmV3IEVycm9yKCdDb25zdW1lciBhbHJlYWR5IGFkZGVkJykpO1xuXG5cdFx0Y29uc3QgZW5jb2RpbmcgPSBjb25zdW1lci5ydHBQYXJhbWV0ZXJzLmVuY29kaW5nc1swXTtcblx0XHRjb25zdCBjbmFtZSA9IGNvbnN1bWVyLnJ0cFBhcmFtZXRlcnMucnRjcC5jbmFtZTtcblx0XHRjb25zdCBjb25zdW1lckluZm8gPVxuXHRcdHtcblx0XHRcdGtpbmQgICAgIDogY29uc3VtZXIua2luZCxcblx0XHRcdHN0cmVhbUlkIDogYHJlY3Ytc3RyZWFtLSR7Y29uc3VtZXIuaWR9YCxcblx0XHRcdHRyYWNrSWQgIDogYGNvbnN1bWVyLSR7Y29uc3VtZXIua2luZH0tJHtjb25zdW1lci5pZH1gLFxuXHRcdFx0c3NyYyAgICAgOiBlbmNvZGluZy5zc3JjLFxuXHRcdFx0Y25hbWUgICAgOiBjbmFtZVxuXHRcdH07XG5cblx0XHRpZiAoZW5jb2RpbmcucnR4ICYmIGVuY29kaW5nLnJ0eC5zc3JjKVxuXHRcdFx0Y29uc3VtZXJJbmZvLnJ0eFNzcmMgPSBlbmNvZGluZy5ydHguc3NyYztcblxuXHRcdHRoaXMuX2NvbnN1bWVySW5mb3Muc2V0KGNvbnN1bWVyLmlkLCBjb25zdW1lckluZm8pO1xuXHRcdHRoaXMuX2tpbmRzLmFkZChjb25zdW1lci5raW5kKTtcblxuXHRcdHJldHVybiBQcm9taXNlLnJlc29sdmUoKVxuXHRcdFx0LnRoZW4oKCkgPT5cblx0XHRcdHtcblx0XHRcdFx0aWYgKCF0aGlzLl90cmFuc3BvcnRDcmVhdGVkKVxuXHRcdFx0XHRcdHJldHVybiB0aGlzLl9zZXR1cFRyYW5zcG9ydCgpO1xuXHRcdFx0fSlcblx0XHRcdC50aGVuKCgpID0+XG5cdFx0XHR7XG5cdFx0XHRcdGNvbnN0IHJlbW90ZVNkcCA9IHRoaXMuX3JlbW90ZVNkcC5jcmVhdGVPZmZlclNkcChcblx0XHRcdFx0XHRBcnJheS5mcm9tKHRoaXMuX2tpbmRzKSwgQXJyYXkuZnJvbSh0aGlzLl9jb25zdW1lckluZm9zLnZhbHVlcygpKSk7XG5cdFx0XHRcdGNvbnN0IG9mZmVyID0geyB0eXBlOiAnb2ZmZXInLCBzZHA6IHJlbW90ZVNkcCB9O1xuXG5cdFx0XHRcdGxvZ2dlci5kZWJ1Zyhcblx0XHRcdFx0XHQnYWRkQ29uc3VtZXIoKSB8IGNhbGxpbmcgcGMuc2V0UmVtb3RlRGVzY3JpcHRpb24oKSBbb2ZmZXI6JW9dJyxcblx0XHRcdFx0XHRvZmZlcik7XG5cblx0XHRcdFx0cmV0dXJuIHRoaXMuX3BjLnNldFJlbW90ZURlc2NyaXB0aW9uKG9mZmVyKTtcblx0XHRcdH0pXG5cdFx0XHQudGhlbigoKSA9PlxuXHRcdFx0e1xuXHRcdFx0XHRyZXR1cm4gdGhpcy5fcGMuY3JlYXRlQW5zd2VyKCk7XG5cdFx0XHR9KVxuXHRcdFx0LnRoZW4oKGFuc3dlcikgPT5cblx0XHRcdHtcblx0XHRcdFx0bG9nZ2VyLmRlYnVnKFxuXHRcdFx0XHRcdCdhZGRDb25zdW1lcigpIHwgY2FsbGluZyBwYy5zZXRMb2NhbERlc2NyaXB0aW9uKCkgW2Fuc3dlcjolb10nLFxuXHRcdFx0XHRcdGFuc3dlcik7XG5cblx0XHRcdFx0cmV0dXJuIHRoaXMuX3BjLnNldExvY2FsRGVzY3JpcHRpb24oYW5zd2VyKTtcblx0XHRcdH0pXG5cdFx0XHQudGhlbigoKSA9PlxuXHRcdFx0e1xuXHRcdFx0XHRpZiAoIXRoaXMuX3RyYW5zcG9ydFVwZGF0ZWQpXG5cdFx0XHRcdFx0cmV0dXJuIHRoaXMuX3VwZGF0ZVRyYW5zcG9ydCgpO1xuXHRcdFx0fSlcblx0XHRcdC50aGVuKCgpID0+XG5cdFx0XHR7XG5cdFx0XHRcdGNvbnN0IG5ld1J0cFJlY2VpdmVyID0gdGhpcy5fcGMuZ2V0UmVjZWl2ZXJzKClcblx0XHRcdFx0XHQuZmluZCgocnRwUmVjZWl2ZXIpID0+XG5cdFx0XHRcdFx0e1xuXHRcdFx0XHRcdFx0Y29uc3QgeyB0cmFjayB9ID0gcnRwUmVjZWl2ZXI7XG5cblx0XHRcdFx0XHRcdGlmICghdHJhY2spXG5cdFx0XHRcdFx0XHRcdHJldHVybiBmYWxzZTtcblxuXHRcdFx0XHRcdFx0cmV0dXJuIHRyYWNrLmlkID09PSBjb25zdW1lckluZm8udHJhY2tJZDtcblx0XHRcdFx0XHR9KTtcblxuXHRcdFx0XHRpZiAoIW5ld1J0cFJlY2VpdmVyKVxuXHRcdFx0XHRcdHRocm93IG5ldyBFcnJvcigncmVtb3RlIHRyYWNrIG5vdCBmb3VuZCcpO1xuXG5cdFx0XHRcdHJldHVybiBuZXdSdHBSZWNlaXZlci50cmFjaztcblx0XHRcdH0pO1xuXHR9XG5cblx0cmVtb3ZlQ29uc3VtZXIoY29uc3VtZXIpXG5cdHtcblx0XHRsb2dnZXIuZGVidWcoXG5cdFx0XHQncmVtb3ZlQ29uc3VtZXIoKSBbaWQ6JXMsIGtpbmQ6JXNdJywgY29uc3VtZXIuaWQsIGNvbnN1bWVyLmtpbmQpO1xuXG5cdFx0aWYgKCF0aGlzLl9jb25zdW1lckluZm9zLmhhcyhjb25zdW1lci5pZCkpXG5cdFx0XHRyZXR1cm4gUHJvbWlzZS5yZWplY3QobmV3IEVycm9yKCdDb25zdW1lciBub3QgZm91bmQnKSk7XG5cblx0XHR0aGlzLl9jb25zdW1lckluZm9zLmRlbGV0ZShjb25zdW1lci5pZCk7XG5cblx0XHRyZXR1cm4gUHJvbWlzZS5yZXNvbHZlKClcblx0XHRcdC50aGVuKCgpID0+XG5cdFx0XHR7XG5cdFx0XHRcdGNvbnN0IHJlbW90ZVNkcCA9IHRoaXMuX3JlbW90ZVNkcC5jcmVhdGVPZmZlclNkcChcblx0XHRcdFx0XHRBcnJheS5mcm9tKHRoaXMuX2tpbmRzKSwgQXJyYXkuZnJvbSh0aGlzLl9jb25zdW1lckluZm9zLnZhbHVlcygpKSk7XG5cdFx0XHRcdGNvbnN0IG9mZmVyID0geyB0eXBlOiAnb2ZmZXInLCBzZHA6IHJlbW90ZVNkcCB9O1xuXG5cdFx0XHRcdGxvZ2dlci5kZWJ1Zyhcblx0XHRcdFx0XHQncmVtb3ZlQ29uc3VtZXIoKSB8IGNhbGxpbmcgcGMuc2V0UmVtb3RlRGVzY3JpcHRpb24oKSBbb2ZmZXI6JW9dJyxcblx0XHRcdFx0XHRvZmZlcik7XG5cblx0XHRcdFx0cmV0dXJuIHRoaXMuX3BjLnNldFJlbW90ZURlc2NyaXB0aW9uKG9mZmVyKTtcblx0XHRcdH0pXG5cdFx0XHQudGhlbigoKSA9PlxuXHRcdFx0e1xuXHRcdFx0XHRyZXR1cm4gdGhpcy5fcGMuY3JlYXRlQW5zd2VyKCk7XG5cdFx0XHR9KVxuXHRcdFx0LnRoZW4oKGFuc3dlcikgPT5cblx0XHRcdHtcblx0XHRcdFx0bG9nZ2VyLmRlYnVnKFxuXHRcdFx0XHRcdCdyZW1vdmVDb25zdW1lcigpIHwgY2FsbGluZyBwYy5zZXRMb2NhbERlc2NyaXB0aW9uKCkgW2Fuc3dlcjolb10nLFxuXHRcdFx0XHRcdGFuc3dlcik7XG5cblx0XHRcdFx0cmV0dXJuIHRoaXMuX3BjLnNldExvY2FsRGVzY3JpcHRpb24oYW5zd2VyKTtcblx0XHRcdH0pO1xuXHR9XG5cblx0cmVzdGFydEljZShyZW1vdGVJY2VQYXJhbWV0ZXJzKVxuXHR7XG5cdFx0bG9nZ2VyLmRlYnVnKCdyZXN0YXJ0SWNlKCknKTtcblxuXHRcdC8vIFByb3ZpZGUgdGhlIHJlbW90ZSBTRFAgaGFuZGxlciB3aXRoIG5ldyByZW1vdGUgSUNFIHBhcmFtZXRlcnMuXG5cdFx0dGhpcy5fcmVtb3RlU2RwLnVwZGF0ZVRyYW5zcG9ydFJlbW90ZUljZVBhcmFtZXRlcnMocmVtb3RlSWNlUGFyYW1ldGVycyk7XG5cblx0XHRyZXR1cm4gUHJvbWlzZS5yZXNvbHZlKClcblx0XHRcdC50aGVuKCgpID0+XG5cdFx0XHR7XG5cdFx0XHRcdGNvbnN0IHJlbW90ZVNkcCA9IHRoaXMuX3JlbW90ZVNkcC5jcmVhdGVPZmZlclNkcChcblx0XHRcdFx0XHRBcnJheS5mcm9tKHRoaXMuX2tpbmRzKSwgQXJyYXkuZnJvbSh0aGlzLl9jb25zdW1lckluZm9zLnZhbHVlcygpKSk7XG5cdFx0XHRcdGNvbnN0IG9mZmVyID0geyB0eXBlOiAnb2ZmZXInLCBzZHA6IHJlbW90ZVNkcCB9O1xuXG5cdFx0XHRcdGxvZ2dlci5kZWJ1Zyhcblx0XHRcdFx0XHQncmVzdGFydEljZSgpIHwgY2FsbGluZyBwYy5zZXRSZW1vdGVEZXNjcmlwdGlvbigpIFtvZmZlcjolb10nLFxuXHRcdFx0XHRcdG9mZmVyKTtcblxuXHRcdFx0XHRyZXR1cm4gdGhpcy5fcGMuc2V0UmVtb3RlRGVzY3JpcHRpb24ob2ZmZXIpO1xuXHRcdFx0fSlcblx0XHRcdC50aGVuKCgpID0+XG5cdFx0XHR7XG5cdFx0XHRcdHJldHVybiB0aGlzLl9wYy5jcmVhdGVBbnN3ZXIoKTtcblx0XHRcdH0pXG5cdFx0XHQudGhlbigoYW5zd2VyKSA9PlxuXHRcdFx0e1xuXHRcdFx0XHRsb2dnZXIuZGVidWcoXG5cdFx0XHRcdFx0J3Jlc3RhcnRJY2UoKSB8IGNhbGxpbmcgcGMuc2V0TG9jYWxEZXNjcmlwdGlvbigpIFthbnN3ZXI6JW9dJyxcblx0XHRcdFx0XHRhbnN3ZXIpO1xuXG5cdFx0XHRcdHJldHVybiB0aGlzLl9wYy5zZXRMb2NhbERlc2NyaXB0aW9uKGFuc3dlcik7XG5cdFx0XHR9KTtcblx0fVxuXG5cdF9zZXR1cFRyYW5zcG9ydCgpXG5cdHtcblx0XHRsb2dnZXIuZGVidWcoJ19zZXR1cFRyYW5zcG9ydCgpJyk7XG5cblx0XHRyZXR1cm4gUHJvbWlzZS5yZXNvbHZlKClcblx0XHRcdC50aGVuKCgpID0+XG5cdFx0XHR7XG5cdFx0XHRcdC8vIFdlIG5lZWQgdHJhbnNwb3J0IHJlbW90ZSBwYXJhbWV0ZXJzLlxuXHRcdFx0XHRyZXR1cm4gdGhpcy5zYWZlRW1pdEFzUHJvbWlzZSgnQG5lZWRjcmVhdGV0cmFuc3BvcnQnLCBudWxsKTtcblx0XHRcdH0pXG5cdFx0XHQudGhlbigodHJhbnNwb3J0UmVtb3RlUGFyYW1ldGVycykgPT5cblx0XHRcdHtcblx0XHRcdFx0Ly8gUHJvdmlkZSB0aGUgcmVtb3RlIFNEUCBoYW5kbGVyIHdpdGggdHJhbnNwb3J0IHJlbW90ZSBwYXJhbWV0ZXJzLlxuXHRcdFx0XHR0aGlzLl9yZW1vdGVTZHAuc2V0VHJhbnNwb3J0UmVtb3RlUGFyYW1ldGVycyh0cmFuc3BvcnRSZW1vdGVQYXJhbWV0ZXJzKTtcblxuXHRcdFx0XHR0aGlzLl90cmFuc3BvcnRDcmVhdGVkID0gdHJ1ZTtcblx0XHRcdH0pO1xuXHR9XG5cblx0X3VwZGF0ZVRyYW5zcG9ydCgpXG5cdHtcblx0XHRsb2dnZXIuZGVidWcoJ191cGRhdGVUcmFuc3BvcnQoKScpO1xuXG5cdFx0Ly8gR2V0IG91ciBsb2NhbCBEVExTIHBhcmFtZXRlcnMuXG5cdFx0Ly8gY29uc3QgdHJhbnNwb3J0TG9jYWxQYXJhbWV0ZXJzID0ge307XG5cdFx0Y29uc3Qgc2RwID0gdGhpcy5fcGMubG9jYWxEZXNjcmlwdGlvbi5zZHA7XG5cdFx0Y29uc3Qgc2RwT2JqID0gc2RwVHJhbnNmb3JtLnBhcnNlKHNkcCk7XG5cdFx0Y29uc3QgZHRsc1BhcmFtZXRlcnMgPSBzZHBDb21tb25VdGlscy5leHRyYWN0RHRsc1BhcmFtZXRlcnMoc2RwT2JqKTtcblx0XHRjb25zdCB0cmFuc3BvcnRMb2NhbFBhcmFtZXRlcnMgPSB7IGR0bHNQYXJhbWV0ZXJzIH07XG5cblx0XHQvLyBXZSBuZWVkIHRvIHByb3ZpZGUgdHJhbnNwb3J0IGxvY2FsIHBhcmFtZXRlcnMuXG5cdFx0dGhpcy5zYWZlRW1pdCgnQG5lZWR1cGRhdGV0cmFuc3BvcnQnLCB0cmFuc3BvcnRMb2NhbFBhcmFtZXRlcnMpO1xuXG5cdFx0dGhpcy5fdHJhbnNwb3J0VXBkYXRlZCA9IHRydWU7XG5cdH1cbn1cblxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgU2FmYXJpMTFcbntcblx0c3RhdGljIGdldCB0YWcoKVxuXHR7XG5cdFx0cmV0dXJuICdTYWZhcmkxMSc7XG5cdH1cblxuXHRzdGF0aWMgZ2V0TmF0aXZlUnRwQ2FwYWJpbGl0aWVzKClcblx0e1xuXHRcdGxvZ2dlci5kZWJ1ZygnZ2V0TmF0aXZlUnRwQ2FwYWJpbGl0aWVzKCknKTtcblxuXHRcdGNvbnN0IHBjID0gbmV3IFJUQ1BlZXJDb25uZWN0aW9uKFxuXHRcdFx0e1xuXHRcdFx0XHRpY2VTZXJ2ZXJzICAgICAgICAgOiBbXSxcblx0XHRcdFx0aWNlVHJhbnNwb3J0UG9saWN5IDogJ2FsbCcsXG5cdFx0XHRcdGJ1bmRsZVBvbGljeSAgICAgICA6ICdtYXgtYnVuZGxlJyxcblx0XHRcdFx0cnRjcE11eFBvbGljeSAgICAgIDogJ3JlcXVpcmUnXG5cdFx0XHR9KTtcblxuXHRcdHBjLmFkZFRyYW5zY2VpdmVyKCdhdWRpbycpO1xuXHRcdHBjLmFkZFRyYW5zY2VpdmVyKCd2aWRlbycpO1xuXG5cdFx0cmV0dXJuIHBjLmNyZWF0ZU9mZmVyKClcblx0XHRcdC50aGVuKChvZmZlcikgPT5cblx0XHRcdHtcblx0XHRcdFx0dHJ5IHsgcGMuY2xvc2UoKTsgfVxuXHRcdFx0XHRjYXRjaCAoZXJyb3IpIHt9XG5cblx0XHRcdFx0Y29uc3Qgc2RwT2JqID0gc2RwVHJhbnNmb3JtLnBhcnNlKG9mZmVyLnNkcCk7XG5cdFx0XHRcdGNvbnN0IG5hdGl2ZVJ0cENhcGFiaWxpdGllcyA9IHNkcENvbW1vblV0aWxzLmV4dHJhY3RSdHBDYXBhYmlsaXRpZXMoc2RwT2JqKTtcblxuXHRcdFx0XHRyZXR1cm4gbmF0aXZlUnRwQ2FwYWJpbGl0aWVzO1xuXHRcdFx0fSlcblx0XHRcdC5jYXRjaCgoZXJyb3IpID0+XG5cdFx0XHR7XG5cdFx0XHRcdHRyeSB7IHBjLmNsb3NlKCk7IH1cblx0XHRcdFx0Y2F0Y2ggKGVycm9yMikge31cblxuXHRcdFx0XHR0aHJvdyBlcnJvcjtcblx0XHRcdH0pO1xuXHR9XG5cblx0Y29uc3RydWN0b3IoZGlyZWN0aW9uLCBleHRlbmRlZFJ0cENhcGFiaWxpdGllcywgc2V0dGluZ3MpXG5cdHtcblx0XHRsb2dnZXIuZGVidWcoXG5cdFx0XHQnY29uc3RydWN0b3IoKSBbZGlyZWN0aW9uOiVzLCBleHRlbmRlZFJ0cENhcGFiaWxpdGllczolb10nLFxuXHRcdFx0ZGlyZWN0aW9uLCBleHRlbmRlZFJ0cENhcGFiaWxpdGllcyk7XG5cblx0XHRsZXQgcnRwUGFyYW1ldGVyc0J5S2luZDtcblxuXHRcdHN3aXRjaCAoZGlyZWN0aW9uKVxuXHRcdHtcblx0XHRcdGNhc2UgJ3NlbmQnOlxuXHRcdFx0e1xuXHRcdFx0XHRydHBQYXJhbWV0ZXJzQnlLaW5kID1cblx0XHRcdFx0e1xuXHRcdFx0XHRcdGF1ZGlvIDogb3J0Yy5nZXRTZW5kaW5nUnRwUGFyYW1ldGVycygnYXVkaW8nLCBleHRlbmRlZFJ0cENhcGFiaWxpdGllcyksXG5cdFx0XHRcdFx0dmlkZW8gOiBvcnRjLmdldFNlbmRpbmdSdHBQYXJhbWV0ZXJzKCd2aWRlbycsIGV4dGVuZGVkUnRwQ2FwYWJpbGl0aWVzKVxuXHRcdFx0XHR9O1xuXG5cdFx0XHRcdHJldHVybiBuZXcgU2VuZEhhbmRsZXIocnRwUGFyYW1ldGVyc0J5S2luZCwgc2V0dGluZ3MpO1xuXHRcdFx0fVxuXHRcdFx0Y2FzZSAncmVjdic6XG5cdFx0XHR7XG5cdFx0XHRcdHJ0cFBhcmFtZXRlcnNCeUtpbmQgPVxuXHRcdFx0XHR7XG5cdFx0XHRcdFx0YXVkaW8gOiBvcnRjLmdldFJlY2VpdmluZ0Z1bGxSdHBQYXJhbWV0ZXJzKCdhdWRpbycsIGV4dGVuZGVkUnRwQ2FwYWJpbGl0aWVzKSxcblx0XHRcdFx0XHR2aWRlbyA6IG9ydGMuZ2V0UmVjZWl2aW5nRnVsbFJ0cFBhcmFtZXRlcnMoJ3ZpZGVvJywgZXh0ZW5kZWRSdHBDYXBhYmlsaXRpZXMpXG5cdFx0XHRcdH07XG5cblx0XHRcdFx0cmV0dXJuIG5ldyBSZWN2SGFuZGxlcihydHBQYXJhbWV0ZXJzQnlLaW5kLCBzZXR0aW5ncyk7XG5cdFx0XHR9XG5cdFx0fVxuXHR9XG59XG4iLCIvKiBnbG9iYWwgUlRDUnRwUmVjZWl2ZXIgKi9cblxuaW1wb3J0ICogYXMgdXRpbHMgZnJvbSAnLi4vLi4vdXRpbHMnO1xuXG4vKipcbiAqIE5vcm1hbGl6ZSBFZGdlJ3MgUlRDUnRwUmVjZWl2ZXIuZ2V0Q2FwYWJpbGl0aWVzKCkgdG8gcHJvZHVjZSBhIGZ1bGxcbiAqIGNvbXBsaWFudCBPUlRDIFJUQ1J0cENhcGFiaWxpdGllcy5cbiAqXG4gKiBAcmV0dXJuIHtSVENSdHBDYXBhYmlsaXRpZXN9XG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBnZXRDYXBhYmlsaXRpZXMoKVxue1xuXHRjb25zdCBuYXRpdmVDYXBzID0gUlRDUnRwUmVjZWl2ZXIuZ2V0Q2FwYWJpbGl0aWVzKCk7XG5cdGNvbnN0IGNhcHMgPSB1dGlscy5jbG9uZShuYXRpdmVDYXBzKTtcblxuXHRmb3IgKGNvbnN0IGNvZGVjIG9mIGNhcHMuY29kZWNzKVxuXHR7XG5cdFx0Ly8gUmVuYW1lIG51bUNoYW5uZWxzIHRvIGNoYW5uZWxzLlxuXHRcdGNvZGVjLmNoYW5uZWxzID0gY29kZWMubnVtQ2hhbm5lbHM7XG5cdFx0ZGVsZXRlIGNvZGVjLm51bUNoYW5uZWxzO1xuXG5cdFx0Ly8gTm9ybWFsaXplIGNoYW5uZWxzLlxuXHRcdGlmIChjb2RlYy5raW5kICE9PSAnYXVkaW8nKVxuXHRcdFx0ZGVsZXRlIGNvZGVjLmNoYW5uZWxzO1xuXHRcdGVsc2UgaWYgKCFjb2RlYy5jaGFubmVscylcblx0XHRcdGNvZGVjLmNoYW5uZWxzID0gMTtcblxuXHRcdC8vIEFkZCBtaW1lVHlwZS5cblx0XHRjb2RlYy5taW1lVHlwZSA9IGAke2NvZGVjLmtpbmR9LyR7Y29kZWMubmFtZX1gO1xuXG5cdFx0Ly8gTk9URTogRWRnZSBzZXRzIHNvbWUgbnVtZXJpYyBwYXJhbWV0ZXJzIGFzIFN0cmluZyByYXRoZXIgdGhhbiBOdW1iZXIuIEZpeCB0aGVtLlxuXHRcdGlmIChjb2RlYy5wYXJhbWV0ZXJzKVxuXHRcdHtcblx0XHRcdGNvbnN0IHBhcmFtZXRlcnMgPSBjb2RlYy5wYXJhbWV0ZXJzO1xuXG5cdFx0XHRpZiAocGFyYW1ldGVycy5hcHQpXG5cdFx0XHRcdHBhcmFtZXRlcnMuYXB0ID0gTnVtYmVyKHBhcmFtZXRlcnMuYXB0KTtcblxuXHRcdFx0aWYgKHBhcmFtZXRlcnNbJ3BhY2tldGl6YXRpb24tbW9kZSddKVxuXHRcdFx0XHRwYXJhbWV0ZXJzWydwYWNrZXRpemF0aW9uLW1vZGUnXSA9IE51bWJlcihwYXJhbWV0ZXJzWydwYWNrZXRpemF0aW9uLW1vZGUnXSk7XG5cdFx0fVxuXG5cdFx0Ly8gRGVsZXRlIGVtdHkgcGFyYW1ldGVyIFN0cmluZyBpbiBydGNwRmVlZGJhY2suXG5cdFx0Zm9yIChjb25zdCBmZWVkYmFjayBvZiBjb2RlYy5ydGNwRmVlZGJhY2sgfHwgW10pXG5cdFx0e1xuXHRcdFx0aWYgKCFmZWVkYmFjay5wYXJhbWV0ZXIpXG5cdFx0XHRcdGRlbGV0ZSBmZWVkYmFjay5wYXJhbWV0ZXI7XG5cdFx0fVxuXHR9XG5cblx0cmV0dXJuIGNhcHM7XG59XG5cbi8qKlxuICogR2VuZXJhdGUgUlRDUnRwUGFyYW1ldGVycyBhcyBFZGdlIGxpa2UgdGhlbS5cbiAqXG4gKiBAcGFyYW0gIHtSVENSdHBQYXJhbWV0ZXJzfSBydHBQYXJhbWV0ZXJzXG4gKiBAcmV0dXJuIHtSVENSdHBQYXJhbWV0ZXJzfVxuICovXG5leHBvcnQgZnVuY3Rpb24gbWFuZ2xlUnRwUGFyYW1ldGVycyhydHBQYXJhbWV0ZXJzKVxue1xuXHRjb25zdCBwYXJhbXMgPSB1dGlscy5jbG9uZShydHBQYXJhbWV0ZXJzKTtcblxuXHRmb3IgKGNvbnN0IGNvZGVjIG9mIHBhcmFtcy5jb2RlY3MpXG5cdHtcblx0XHQvLyBSZW5hbWUgY2hhbm5lbHMgdG8gbnVtQ2hhbm5lbHMuXG5cdFx0aWYgKGNvZGVjLmNoYW5uZWxzKVxuXHRcdHtcblx0XHRcdGNvZGVjLm51bUNoYW5uZWxzID0gY29kZWMuY2hhbm5lbHM7XG5cdFx0XHRkZWxldGUgY29kZWMuY2hhbm5lbHM7XG5cdFx0fVxuXG5cdFx0Ly8gUmVtb3ZlIG1pbWVUeXBlLlxuXHRcdGRlbGV0ZSBjb2RlYy5taW1lVHlwZTtcblx0fVxuXG5cdHJldHVybiBwYXJhbXM7XG59XG4iLCJpbXBvcnQgc2RwVHJhbnNmb3JtIGZyb20gJ3NkcC10cmFuc2Zvcm0nO1xuaW1wb3J0IExvZ2dlciBmcm9tICcuLi8uLi9Mb2dnZXInO1xuaW1wb3J0ICogYXMgdXRpbHMgZnJvbSAnLi4vLi4vdXRpbHMnO1xuXG5jb25zdCBsb2dnZXIgPSBuZXcgTG9nZ2VyKCdSZW1vdGVQbGFuQlNkcCcpO1xuXG5jbGFzcyBSZW1vdGVTZHBcbntcblx0Y29uc3RydWN0b3IocnRwUGFyYW1ldGVyc0J5S2luZClcblx0e1xuXHRcdC8vIEdlbmVyaWMgc2VuZGluZyBSVFAgcGFyYW1ldGVycyBmb3IgYXVkaW8gYW5kIHZpZGVvLlxuXHRcdC8vIEB0eXBlIHtPYmplY3R9XG5cdFx0dGhpcy5fcnRwUGFyYW1ldGVyc0J5S2luZCA9IHJ0cFBhcmFtZXRlcnNCeUtpbmQ7XG5cblx0XHQvLyBUcmFuc3BvcnQgbG9jYWwgcGFyYW1ldGVycywgaW5jbHVkaW5nIERUTFMgcGFyYW1ldGVyZXMuXG5cdFx0Ly8gQHR5cGUge09iamVjdH1cblx0XHR0aGlzLl90cmFuc3BvcnRMb2NhbFBhcmFtZXRlcnMgPSBudWxsO1xuXG5cdFx0Ly8gVHJhbnNwb3J0IHJlbW90ZSBwYXJhbWV0ZXJzLCBpbmNsdWRpbmcgSUNFIHBhcmFtZXRlcnMsIElDRSBjYW5kaWRhdGVzXG5cdFx0Ly8gYW5kIERUTFMgcGFyYW1ldGVyZXMuXG5cdFx0Ly8gQHR5cGUge09iamVjdH1cblx0XHR0aGlzLl90cmFuc3BvcnRSZW1vdGVQYXJhbWV0ZXJzID0gbnVsbDtcblxuXHRcdC8vIFNEUCBnbG9iYWwgZmllbGRzLlxuXHRcdC8vIEB0eXBlIHtPYmplY3R9XG5cdFx0dGhpcy5fc2RwR2xvYmFsRmllbGRzID1cblx0XHR7XG5cdFx0XHRpZCAgICAgIDogdXRpbHMucmFuZG9tTnVtYmVyKCksXG5cdFx0XHR2ZXJzaW9uIDogMFxuXHRcdH07XG5cdH1cblxuXHRzZXRUcmFuc3BvcnRMb2NhbFBhcmFtZXRlcnModHJhbnNwb3J0TG9jYWxQYXJhbWV0ZXJzKVxuXHR7XG5cdFx0bG9nZ2VyLmRlYnVnKFxuXHRcdFx0J3NldFRyYW5zcG9ydExvY2FsUGFyYW1ldGVycygpIFt0cmFuc3BvcnRMb2NhbFBhcmFtZXRlcnM6JW9dJyxcblx0XHRcdHRyYW5zcG9ydExvY2FsUGFyYW1ldGVycyk7XG5cblx0XHR0aGlzLl90cmFuc3BvcnRMb2NhbFBhcmFtZXRlcnMgPSB0cmFuc3BvcnRMb2NhbFBhcmFtZXRlcnM7XG5cdH1cblxuXHRzZXRUcmFuc3BvcnRSZW1vdGVQYXJhbWV0ZXJzKHRyYW5zcG9ydFJlbW90ZVBhcmFtZXRlcnMpXG5cdHtcblx0XHRsb2dnZXIuZGVidWcoXG5cdFx0XHQnc2V0VHJhbnNwb3J0UmVtb3RlUGFyYW1ldGVycygpIFt0cmFuc3BvcnRSZW1vdGVQYXJhbWV0ZXJzOiVvXScsXG5cdFx0XHR0cmFuc3BvcnRSZW1vdGVQYXJhbWV0ZXJzKTtcblxuXHRcdHRoaXMuX3RyYW5zcG9ydFJlbW90ZVBhcmFtZXRlcnMgPSB0cmFuc3BvcnRSZW1vdGVQYXJhbWV0ZXJzO1xuXHR9XG5cblx0dXBkYXRlVHJhbnNwb3J0UmVtb3RlSWNlUGFyYW1ldGVycyhyZW1vdGVJY2VQYXJhbWV0ZXJzKVxuXHR7XG5cdFx0bG9nZ2VyLmRlYnVnKFxuXHRcdFx0J3VwZGF0ZVRyYW5zcG9ydFJlbW90ZUljZVBhcmFtZXRlcnMoKSBbcmVtb3RlSWNlUGFyYW1ldGVyczolb10nLFxuXHRcdFx0cmVtb3RlSWNlUGFyYW1ldGVycyk7XG5cblx0XHR0aGlzLl90cmFuc3BvcnRSZW1vdGVQYXJhbWV0ZXJzLmljZVBhcmFtZXRlcnMgPSByZW1vdGVJY2VQYXJhbWV0ZXJzO1xuXHR9XG59XG5cbmNsYXNzIFNlbmRSZW1vdGVTZHAgZXh0ZW5kcyBSZW1vdGVTZHBcbntcblx0Y29uc3RydWN0b3IocnRwUGFyYW1ldGVyc0J5S2luZClcblx0e1xuXHRcdHN1cGVyKHJ0cFBhcmFtZXRlcnNCeUtpbmQpO1xuXHR9XG5cblx0Y3JlYXRlQW5zd2VyU2RwKGxvY2FsU2RwT2JqKVxuXHR7XG5cdFx0bG9nZ2VyLmRlYnVnKCdjcmVhdGVBbnN3ZXJTZHAoKScpO1xuXG5cdFx0aWYgKCF0aGlzLl90cmFuc3BvcnRMb2NhbFBhcmFtZXRlcnMpXG5cdFx0XHR0aHJvdyBuZXcgRXJyb3IoJ25vIHRyYW5zcG9ydCBsb2NhbCBwYXJhbWV0ZXJzJyk7XG5cdFx0ZWxzZSBpZiAoIXRoaXMuX3RyYW5zcG9ydFJlbW90ZVBhcmFtZXRlcnMpXG5cdFx0XHR0aHJvdyBuZXcgRXJyb3IoJ25vIHRyYW5zcG9ydCByZW1vdGUgcGFyYW1ldGVycycpO1xuXG5cdFx0Y29uc3QgcmVtb3RlSWNlUGFyYW1ldGVycyA9IHRoaXMuX3RyYW5zcG9ydFJlbW90ZVBhcmFtZXRlcnMuaWNlUGFyYW1ldGVycztcblx0XHRjb25zdCByZW1vdGVJY2VDYW5kaWRhdGVzID0gdGhpcy5fdHJhbnNwb3J0UmVtb3RlUGFyYW1ldGVycy5pY2VDYW5kaWRhdGVzO1xuXHRcdGNvbnN0IHJlbW90ZUR0bHNQYXJhbWV0ZXJzID0gdGhpcy5fdHJhbnNwb3J0UmVtb3RlUGFyYW1ldGVycy5kdGxzUGFyYW1ldGVycztcblx0XHRjb25zdCBzZHBPYmogPSB7fTtcblx0XHRjb25zdCBtaWRzID0gKGxvY2FsU2RwT2JqLm1lZGlhIHx8IFtdKVxuXHRcdFx0Lm1hcCgobSkgPT4gbS5taWQpO1xuXG5cdFx0Ly8gSW5jcmVhc2Ugb3VyIFNEUCB2ZXJzaW9uLlxuXHRcdHRoaXMuX3NkcEdsb2JhbEZpZWxkcy52ZXJzaW9uKys7XG5cblx0XHRzZHBPYmoudmVyc2lvbiA9IDA7XG5cdFx0c2RwT2JqLm9yaWdpbiA9XG5cdFx0e1xuXHRcdFx0YWRkcmVzcyAgICAgICAgOiAnMC4wLjAuMCcsXG5cdFx0XHRpcFZlciAgICAgICAgICA6IDQsXG5cdFx0XHRuZXRUeXBlICAgICAgICA6ICdJTicsXG5cdFx0XHRzZXNzaW9uSWQgICAgICA6IHRoaXMuX3NkcEdsb2JhbEZpZWxkcy5pZCxcblx0XHRcdHNlc3Npb25WZXJzaW9uIDogdGhpcy5fc2RwR2xvYmFsRmllbGRzLnZlcnNpb24sXG5cdFx0XHR1c2VybmFtZSAgICAgICA6ICdtZWRpYXNvdXAtY2xpZW50J1xuXHRcdH07XG5cdFx0c2RwT2JqLm5hbWUgPSAnLSc7XG5cdFx0c2RwT2JqLnRpbWluZyA9IHsgc3RhcnQ6IDAsIHN0b3A6IDAgfTtcblx0XHRzZHBPYmouaWNlbGl0ZSA9IHJlbW90ZUljZVBhcmFtZXRlcnMuaWNlTGl0ZSA/ICdpY2UtbGl0ZScgOiBudWxsO1xuXHRcdHNkcE9iai5tc2lkU2VtYW50aWMgPVxuXHRcdHtcblx0XHRcdHNlbWFudGljIDogJ1dNUycsXG5cdFx0XHR0b2tlbiAgICA6ICcqJ1xuXHRcdH07XG5cdFx0c2RwT2JqLmdyb3VwcyA9XG5cdFx0W1xuXHRcdFx0e1xuXHRcdFx0XHR0eXBlIDogJ0JVTkRMRScsXG5cdFx0XHRcdG1pZHMgOiBtaWRzLmpvaW4oJyAnKVxuXHRcdFx0fVxuXHRcdF07XG5cdFx0c2RwT2JqLm1lZGlhID0gW107XG5cblx0XHQvLyBOT1RFOiBXZSB0YWtlIHRoZSBsYXRlc3QgZmluZ2VycHJpbnQuXG5cdFx0Y29uc3QgbnVtRmluZ2VycHJpbnRzID0gcmVtb3RlRHRsc1BhcmFtZXRlcnMuZmluZ2VycHJpbnRzLmxlbmd0aDtcblxuXHRcdHNkcE9iai5maW5nZXJwcmludCA9XG5cdFx0e1xuXHRcdFx0dHlwZSA6IHJlbW90ZUR0bHNQYXJhbWV0ZXJzLmZpbmdlcnByaW50c1tudW1GaW5nZXJwcmludHMgLSAxXS5hbGdvcml0aG0sXG5cdFx0XHRoYXNoIDogcmVtb3RlRHRsc1BhcmFtZXRlcnMuZmluZ2VycHJpbnRzW251bUZpbmdlcnByaW50cyAtIDFdLnZhbHVlXG5cdFx0fTtcblxuXHRcdGZvciAoY29uc3QgbG9jYWxNZWRpYU9iaiBvZiBsb2NhbFNkcE9iai5tZWRpYSB8fCBbXSlcblx0XHR7XG5cdFx0XHRjb25zdCBraW5kID0gbG9jYWxNZWRpYU9iai50eXBlO1xuXHRcdFx0Y29uc3QgY29kZWNzID0gdGhpcy5fcnRwUGFyYW1ldGVyc0J5S2luZFtraW5kXS5jb2RlY3M7XG5cdFx0XHRjb25zdCBoZWFkZXJFeHRlbnNpb25zID0gdGhpcy5fcnRwUGFyYW1ldGVyc0J5S2luZFtraW5kXS5oZWFkZXJFeHRlbnNpb25zO1xuXHRcdFx0Y29uc3QgcmVtb3RlTWVkaWFPYmogPSB7fTtcblxuXHRcdFx0cmVtb3RlTWVkaWFPYmoudHlwZSA9IGxvY2FsTWVkaWFPYmoudHlwZTtcblx0XHRcdHJlbW90ZU1lZGlhT2JqLnBvcnQgPSA3O1xuXHRcdFx0cmVtb3RlTWVkaWFPYmoucHJvdG9jb2wgPSAnUlRQL1NBVlBGJztcblx0XHRcdHJlbW90ZU1lZGlhT2JqLmNvbm5lY3Rpb24gPSB7IGlwOiAnMTI3LjAuMC4xJywgdmVyc2lvbjogNCB9O1xuXHRcdFx0cmVtb3RlTWVkaWFPYmoubWlkID0gbG9jYWxNZWRpYU9iai5taWQ7XG5cblx0XHRcdHJlbW90ZU1lZGlhT2JqLmljZVVmcmFnID0gcmVtb3RlSWNlUGFyYW1ldGVycy51c2VybmFtZUZyYWdtZW50O1xuXHRcdFx0cmVtb3RlTWVkaWFPYmouaWNlUHdkID0gcmVtb3RlSWNlUGFyYW1ldGVycy5wYXNzd29yZDtcblx0XHRcdHJlbW90ZU1lZGlhT2JqLmNhbmRpZGF0ZXMgPSBbXTtcblxuXHRcdFx0Zm9yIChjb25zdCBjYW5kaWRhdGUgb2YgcmVtb3RlSWNlQ2FuZGlkYXRlcylcblx0XHRcdHtcblx0XHRcdFx0Y29uc3QgY2FuZGlkYXRlT2JqID0ge307XG5cblx0XHRcdFx0Ly8gbWVkaWFzb3VwIGRvZXMgbm90IHN1cHBvcnQgbm9uIHJ0Y3AtbXV4IHNvIGNhbmRpZGF0ZXMgY29tcG9uZW50IGlzXG5cdFx0XHRcdC8vIGFsd2F5cyBSVFAgKDEpLlxuXHRcdFx0XHRjYW5kaWRhdGVPYmouY29tcG9uZW50ID0gMTtcblx0XHRcdFx0Y2FuZGlkYXRlT2JqLmZvdW5kYXRpb24gPSBjYW5kaWRhdGUuZm91bmRhdGlvbjtcblx0XHRcdFx0Y2FuZGlkYXRlT2JqLmlwID0gY2FuZGlkYXRlLmlwO1xuXHRcdFx0XHRjYW5kaWRhdGVPYmoucG9ydCA9IGNhbmRpZGF0ZS5wb3J0O1xuXHRcdFx0XHRjYW5kaWRhdGVPYmoucHJpb3JpdHkgPSBjYW5kaWRhdGUucHJpb3JpdHk7XG5cdFx0XHRcdGNhbmRpZGF0ZU9iai50cmFuc3BvcnQgPSBjYW5kaWRhdGUucHJvdG9jb2w7XG5cdFx0XHRcdGNhbmRpZGF0ZU9iai50eXBlID0gY2FuZGlkYXRlLnR5cGU7XG5cdFx0XHRcdGlmIChjYW5kaWRhdGUudGNwVHlwZSlcblx0XHRcdFx0XHRjYW5kaWRhdGVPYmoudGNwdHlwZSA9IGNhbmRpZGF0ZS50Y3BUeXBlO1xuXG5cdFx0XHRcdHJlbW90ZU1lZGlhT2JqLmNhbmRpZGF0ZXMucHVzaChjYW5kaWRhdGVPYmopO1xuXHRcdFx0fVxuXG5cdFx0XHRyZW1vdGVNZWRpYU9iai5lbmRPZkNhbmRpZGF0ZXMgPSAnZW5kLW9mLWNhbmRpZGF0ZXMnO1xuXG5cdFx0XHQvLyBBbm5vdW5jZSBzdXBwb3J0IGZvciBJQ0UgcmVub21pbmF0aW9uLlxuXHRcdFx0Ly8gaHR0cHM6Ly90b29scy5pZXRmLm9yZy9odG1sL2RyYWZ0LXRoYXRjaGVyLWljZS1yZW5vbWluYXRpb25cblx0XHRcdHJlbW90ZU1lZGlhT2JqLmljZU9wdGlvbnMgPSAncmVub21pbmF0aW9uJztcblxuXHRcdFx0c3dpdGNoIChyZW1vdGVEdGxzUGFyYW1ldGVycy5yb2xlKVxuXHRcdFx0e1xuXHRcdFx0XHRjYXNlICdjbGllbnQnOlxuXHRcdFx0XHRcdHJlbW90ZU1lZGlhT2JqLnNldHVwID0gJ2FjdGl2ZSc7XG5cdFx0XHRcdFx0YnJlYWs7XG5cdFx0XHRcdGNhc2UgJ3NlcnZlcic6XG5cdFx0XHRcdFx0cmVtb3RlTWVkaWFPYmouc2V0dXAgPSAncGFzc2l2ZSc7XG5cdFx0XHRcdFx0YnJlYWs7XG5cdFx0XHR9XG5cblx0XHRcdHN3aXRjaCAobG9jYWxNZWRpYU9iai5kaXJlY3Rpb24pXG5cdFx0XHR7XG5cdFx0XHRcdGNhc2UgJ3NlbmRyZWN2Jzpcblx0XHRcdFx0Y2FzZSAnc2VuZG9ubHknOlxuXHRcdFx0XHRcdHJlbW90ZU1lZGlhT2JqLmRpcmVjdGlvbiA9ICdyZWN2b25seSc7XG5cdFx0XHRcdFx0YnJlYWs7XG5cdFx0XHRcdGNhc2UgJ3JlY3Zvbmx5Jzpcblx0XHRcdFx0Y2FzZSAnaW5hY3RpdmUnOlxuXHRcdFx0XHRcdHJlbW90ZU1lZGlhT2JqLmRpcmVjdGlvbiA9ICdpbmFjdGl2ZSc7XG5cdFx0XHRcdFx0YnJlYWs7XG5cdFx0XHR9XG5cblx0XHRcdC8vIElmIHZpZGVvLCBiZSByZWFkeSBmb3Igc2ltdWxjYXN0LlxuXHRcdFx0aWYgKGtpbmQgPT09ICd2aWRlbycpXG5cdFx0XHRcdHJlbW90ZU1lZGlhT2JqLnhHb29nbGVGbGFnID0gJ2NvbmZlcmVuY2UnO1xuXG5cdFx0XHRyZW1vdGVNZWRpYU9iai5ydHAgPSBbXTtcblx0XHRcdHJlbW90ZU1lZGlhT2JqLnJ0Y3BGYiA9IFtdO1xuXHRcdFx0cmVtb3RlTWVkaWFPYmouZm10cCA9IFtdO1xuXG5cdFx0XHRmb3IgKGNvbnN0IGNvZGVjIG9mIGNvZGVjcylcblx0XHRcdHtcblx0XHRcdFx0Y29uc3QgcnRwID1cblx0XHRcdFx0e1xuXHRcdFx0XHRcdHBheWxvYWQgOiBjb2RlYy5wYXlsb2FkVHlwZSxcblx0XHRcdFx0XHRjb2RlYyAgIDogY29kZWMubmFtZSxcblx0XHRcdFx0XHRyYXRlICAgIDogY29kZWMuY2xvY2tSYXRlXG5cdFx0XHRcdH07XG5cblx0XHRcdFx0aWYgKGNvZGVjLmNoYW5uZWxzID4gMSlcblx0XHRcdFx0XHRydHAuZW5jb2RpbmcgPSBjb2RlYy5jaGFubmVscztcblxuXHRcdFx0XHRyZW1vdGVNZWRpYU9iai5ydHAucHVzaChydHApO1xuXG5cdFx0XHRcdGlmIChjb2RlYy5wYXJhbWV0ZXJzKVxuXHRcdFx0XHR7XG5cdFx0XHRcdFx0Y29uc3QgcGFyYW1GbXRwID1cblx0XHRcdFx0XHR7XG5cdFx0XHRcdFx0XHRwYXlsb2FkIDogY29kZWMucGF5bG9hZFR5cGUsXG5cdFx0XHRcdFx0XHRjb25maWcgIDogJydcblx0XHRcdFx0XHR9O1xuXG5cdFx0XHRcdFx0Zm9yIChjb25zdCBrZXkgb2YgT2JqZWN0LmtleXMoY29kZWMucGFyYW1ldGVycykpXG5cdFx0XHRcdFx0e1xuXHRcdFx0XHRcdFx0aWYgKHBhcmFtRm10cC5jb25maWcpXG5cdFx0XHRcdFx0XHRcdHBhcmFtRm10cC5jb25maWcgKz0gJzsnO1xuXG5cdFx0XHRcdFx0XHRwYXJhbUZtdHAuY29uZmlnICs9IGAke2tleX09JHtjb2RlYy5wYXJhbWV0ZXJzW2tleV19YDtcblx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHRpZiAocGFyYW1GbXRwLmNvbmZpZylcblx0XHRcdFx0XHRcdHJlbW90ZU1lZGlhT2JqLmZtdHAucHVzaChwYXJhbUZtdHApO1xuXHRcdFx0XHR9XG5cblx0XHRcdFx0aWYgKGNvZGVjLnJ0Y3BGZWVkYmFjaylcblx0XHRcdFx0e1xuXHRcdFx0XHRcdGZvciAoY29uc3QgZmIgb2YgY29kZWMucnRjcEZlZWRiYWNrKVxuXHRcdFx0XHRcdHtcblx0XHRcdFx0XHRcdHJlbW90ZU1lZGlhT2JqLnJ0Y3BGYi5wdXNoKFxuXHRcdFx0XHRcdFx0XHR7XG5cdFx0XHRcdFx0XHRcdFx0cGF5bG9hZCA6IGNvZGVjLnBheWxvYWRUeXBlLFxuXHRcdFx0XHRcdFx0XHRcdHR5cGUgICAgOiBmYi50eXBlLFxuXHRcdFx0XHRcdFx0XHRcdHN1YnR5cGUgOiBmYi5wYXJhbWV0ZXIgfHwgJydcblx0XHRcdFx0XHRcdFx0fSk7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cdFx0XHR9XG5cblx0XHRcdHJlbW90ZU1lZGlhT2JqLnBheWxvYWRzID0gY29kZWNzXG5cdFx0XHRcdC5tYXAoKGNvZGVjKSA9PiBjb2RlYy5wYXlsb2FkVHlwZSlcblx0XHRcdFx0LmpvaW4oJyAnKTtcblxuXHRcdFx0cmVtb3RlTWVkaWFPYmouZXh0ID0gW107XG5cblx0XHRcdGZvciAoY29uc3QgZXh0IG9mIGhlYWRlckV4dGVuc2lvbnMpXG5cdFx0XHR7XG5cdFx0XHRcdC8vIERvbid0IGFkZCBhIGhlYWRlciBleHRlbnNpb24gaWYgbm90IHByZXNlbnQgaW4gdGhlIG9mZmVyLlxuXHRcdFx0XHRjb25zdCBtYXRjaGVkTG9jYWxFeHQgPSAobG9jYWxNZWRpYU9iai5leHQgfHwgW10pXG5cdFx0XHRcdFx0LmZpbmQoKGxvY2FsRXh0KSA9PiBsb2NhbEV4dC51cmkgPT09IGV4dC51cmkpO1xuXG5cdFx0XHRcdGlmICghbWF0Y2hlZExvY2FsRXh0KVxuXHRcdFx0XHRcdGNvbnRpbnVlO1xuXG5cdFx0XHRcdHJlbW90ZU1lZGlhT2JqLmV4dC5wdXNoKFxuXHRcdFx0XHRcdHtcblx0XHRcdFx0XHRcdHVyaSAgIDogZXh0LnVyaSxcblx0XHRcdFx0XHRcdHZhbHVlIDogZXh0LmlkXG5cdFx0XHRcdFx0fSk7XG5cdFx0XHR9XG5cblx0XHRcdHJlbW90ZU1lZGlhT2JqLnJ0Y3BNdXggPSAncnRjcC1tdXgnO1xuXHRcdFx0cmVtb3RlTWVkaWFPYmoucnRjcFJzaXplID0gJ3J0Y3AtcnNpemUnO1xuXG5cdFx0XHQvLyBQdXNoIGl0LlxuXHRcdFx0c2RwT2JqLm1lZGlhLnB1c2gocmVtb3RlTWVkaWFPYmopO1xuXHRcdH1cblxuXHRcdGNvbnN0IHNkcCA9IHNkcFRyYW5zZm9ybS53cml0ZShzZHBPYmopO1xuXG5cdFx0cmV0dXJuIHNkcDtcblx0fVxufVxuXG5jbGFzcyBSZWN2UmVtb3RlU2RwIGV4dGVuZHMgUmVtb3RlU2RwXG57XG5cdGNvbnN0cnVjdG9yKHJ0cFBhcmFtZXRlcnNCeUtpbmQpXG5cdHtcblx0XHRzdXBlcihydHBQYXJhbWV0ZXJzQnlLaW5kKTtcblx0fVxuXG5cdC8qKlxuXHQgKiBAcGFyYW0ge0FycmF5PFN0cmluZz59IGtpbmRzIC0gTWVkaWEga2luZHMuXG5cdCAqIEBwYXJhbSB7QXJyYXk8T2JqZWN0Pn0gY29uc3VtZXJJbmZvcyAtIENvbnN1bWVyIGluZm9ybWF0aW9ucy5cblx0ICogQHJldHVybiB7U3RyaW5nfVxuXHQgKi9cblx0Y3JlYXRlT2ZmZXJTZHAoa2luZHMsIGNvbnN1bWVySW5mb3MpXG5cdHtcblx0XHRsb2dnZXIuZGVidWcoJ2NyZWF0ZU9mZmVyU2RwKCknKTtcblxuXHRcdGlmICghdGhpcy5fdHJhbnNwb3J0UmVtb3RlUGFyYW1ldGVycylcblx0XHRcdHRocm93IG5ldyBFcnJvcignbm8gdHJhbnNwb3J0IHJlbW90ZSBwYXJhbWV0ZXJzJyk7XG5cblx0XHRjb25zdCByZW1vdGVJY2VQYXJhbWV0ZXJzID0gdGhpcy5fdHJhbnNwb3J0UmVtb3RlUGFyYW1ldGVycy5pY2VQYXJhbWV0ZXJzO1xuXHRcdGNvbnN0IHJlbW90ZUljZUNhbmRpZGF0ZXMgPSB0aGlzLl90cmFuc3BvcnRSZW1vdGVQYXJhbWV0ZXJzLmljZUNhbmRpZGF0ZXM7XG5cdFx0Y29uc3QgcmVtb3RlRHRsc1BhcmFtZXRlcnMgPSB0aGlzLl90cmFuc3BvcnRSZW1vdGVQYXJhbWV0ZXJzLmR0bHNQYXJhbWV0ZXJzO1xuXHRcdGNvbnN0IHNkcE9iaiA9IHt9O1xuXHRcdGNvbnN0IG1pZHMgPSBraW5kcztcblxuXHRcdC8vIEluY3JlYXNlIG91ciBTRFAgdmVyc2lvbi5cblx0XHR0aGlzLl9zZHBHbG9iYWxGaWVsZHMudmVyc2lvbisrO1xuXG5cdFx0c2RwT2JqLnZlcnNpb24gPSAwO1xuXHRcdHNkcE9iai5vcmlnaW4gPVxuXHRcdHtcblx0XHRcdGFkZHJlc3MgICAgICAgIDogJzAuMC4wLjAnLFxuXHRcdFx0aXBWZXIgICAgICAgICAgOiA0LFxuXHRcdFx0bmV0VHlwZSAgICAgICAgOiAnSU4nLFxuXHRcdFx0c2Vzc2lvbklkICAgICAgOiB0aGlzLl9zZHBHbG9iYWxGaWVsZHMuaWQsXG5cdFx0XHRzZXNzaW9uVmVyc2lvbiA6IHRoaXMuX3NkcEdsb2JhbEZpZWxkcy52ZXJzaW9uLFxuXHRcdFx0dXNlcm5hbWUgICAgICAgOiAnbWVkaWFzb3VwLWNsaWVudCdcblx0XHR9O1xuXHRcdHNkcE9iai5uYW1lID0gJy0nO1xuXHRcdHNkcE9iai50aW1pbmcgPSB7IHN0YXJ0OiAwLCBzdG9wOiAwIH07XG5cdFx0c2RwT2JqLmljZWxpdGUgPSByZW1vdGVJY2VQYXJhbWV0ZXJzLmljZUxpdGUgPyAnaWNlLWxpdGUnIDogbnVsbDtcblx0XHRzZHBPYmoubXNpZFNlbWFudGljID1cblx0XHR7XG5cdFx0XHRzZW1hbnRpYyA6ICdXTVMnLFxuXHRcdFx0dG9rZW4gICAgOiAnKidcblx0XHR9O1xuXHRcdHNkcE9iai5ncm91cHMgPVxuXHRcdFtcblx0XHRcdHtcblx0XHRcdFx0dHlwZSA6ICdCVU5ETEUnLFxuXHRcdFx0XHRtaWRzIDogbWlkcy5qb2luKCcgJylcblx0XHRcdH1cblx0XHRdO1xuXHRcdHNkcE9iai5tZWRpYSA9IFtdO1xuXG5cdFx0Ly8gTk9URTogV2UgdGFrZSB0aGUgbGF0ZXN0IGZpbmdlcnByaW50LlxuXHRcdGNvbnN0IG51bUZpbmdlcnByaW50cyA9IHJlbW90ZUR0bHNQYXJhbWV0ZXJzLmZpbmdlcnByaW50cy5sZW5ndGg7XG5cblx0XHRzZHBPYmouZmluZ2VycHJpbnQgPVxuXHRcdHtcblx0XHRcdHR5cGUgOiByZW1vdGVEdGxzUGFyYW1ldGVycy5maW5nZXJwcmludHNbbnVtRmluZ2VycHJpbnRzIC0gMV0uYWxnb3JpdGhtLFxuXHRcdFx0aGFzaCA6IHJlbW90ZUR0bHNQYXJhbWV0ZXJzLmZpbmdlcnByaW50c1tudW1GaW5nZXJwcmludHMgLSAxXS52YWx1ZVxuXHRcdH07XG5cblx0XHRmb3IgKGNvbnN0IGtpbmQgb2Yga2luZHMpXG5cdFx0e1xuXHRcdFx0Y29uc3QgY29kZWNzID0gdGhpcy5fcnRwUGFyYW1ldGVyc0J5S2luZFtraW5kXS5jb2RlY3M7XG5cdFx0XHRjb25zdCBoZWFkZXJFeHRlbnNpb25zID0gdGhpcy5fcnRwUGFyYW1ldGVyc0J5S2luZFtraW5kXS5oZWFkZXJFeHRlbnNpb25zO1xuXHRcdFx0Y29uc3QgcmVtb3RlTWVkaWFPYmogPSB7fTtcblxuXHRcdFx0cmVtb3RlTWVkaWFPYmoudHlwZSA9IGtpbmQ7XG5cdFx0XHRyZW1vdGVNZWRpYU9iai5wb3J0ID0gNztcblx0XHRcdHJlbW90ZU1lZGlhT2JqLnByb3RvY29sID0gJ1JUUC9TQVZQRic7XG5cdFx0XHRyZW1vdGVNZWRpYU9iai5jb25uZWN0aW9uID0geyBpcDogJzEyNy4wLjAuMScsIHZlcnNpb246IDQgfTtcblx0XHRcdHJlbW90ZU1lZGlhT2JqLm1pZCA9IGtpbmQ7XG5cblx0XHRcdHJlbW90ZU1lZGlhT2JqLmljZVVmcmFnID0gcmVtb3RlSWNlUGFyYW1ldGVycy51c2VybmFtZUZyYWdtZW50O1xuXHRcdFx0cmVtb3RlTWVkaWFPYmouaWNlUHdkID0gcmVtb3RlSWNlUGFyYW1ldGVycy5wYXNzd29yZDtcblx0XHRcdHJlbW90ZU1lZGlhT2JqLmNhbmRpZGF0ZXMgPSBbXTtcblxuXHRcdFx0Zm9yIChjb25zdCBjYW5kaWRhdGUgb2YgcmVtb3RlSWNlQ2FuZGlkYXRlcylcblx0XHRcdHtcblx0XHRcdFx0Y29uc3QgY2FuZGlkYXRlT2JqID0ge307XG5cblx0XHRcdFx0Ly8gbWVkaWFzb3VwIGRvZXMgbm90IHN1cHBvcnQgbm9uIHJ0Y3AtbXV4IHNvIGNhbmRpZGF0ZXMgY29tcG9uZW50IGlzXG5cdFx0XHRcdC8vIGFsd2F5cyBSVFAgKDEpLlxuXHRcdFx0XHRjYW5kaWRhdGVPYmouY29tcG9uZW50ID0gMTtcblx0XHRcdFx0Y2FuZGlkYXRlT2JqLmZvdW5kYXRpb24gPSBjYW5kaWRhdGUuZm91bmRhdGlvbjtcblx0XHRcdFx0Y2FuZGlkYXRlT2JqLmlwID0gY2FuZGlkYXRlLmlwO1xuXHRcdFx0XHRjYW5kaWRhdGVPYmoucG9ydCA9IGNhbmRpZGF0ZS5wb3J0O1xuXHRcdFx0XHRjYW5kaWRhdGVPYmoucHJpb3JpdHkgPSBjYW5kaWRhdGUucHJpb3JpdHk7XG5cdFx0XHRcdGNhbmRpZGF0ZU9iai50cmFuc3BvcnQgPSBjYW5kaWRhdGUucHJvdG9jb2w7XG5cdFx0XHRcdGNhbmRpZGF0ZU9iai50eXBlID0gY2FuZGlkYXRlLnR5cGU7XG5cdFx0XHRcdGlmIChjYW5kaWRhdGUudGNwVHlwZSlcblx0XHRcdFx0XHRjYW5kaWRhdGVPYmoudGNwdHlwZSA9IGNhbmRpZGF0ZS50Y3BUeXBlO1xuXG5cdFx0XHRcdHJlbW90ZU1lZGlhT2JqLmNhbmRpZGF0ZXMucHVzaChjYW5kaWRhdGVPYmopO1xuXHRcdFx0fVxuXG5cdFx0XHRyZW1vdGVNZWRpYU9iai5lbmRPZkNhbmRpZGF0ZXMgPSAnZW5kLW9mLWNhbmRpZGF0ZXMnO1xuXG5cdFx0XHQvLyBBbm5vdW5jZSBzdXBwb3J0IGZvciBJQ0UgcmVub21pbmF0aW9uLlxuXHRcdFx0Ly8gaHR0cHM6Ly90b29scy5pZXRmLm9yZy9odG1sL2RyYWZ0LXRoYXRjaGVyLWljZS1yZW5vbWluYXRpb25cblx0XHRcdHJlbW90ZU1lZGlhT2JqLmljZU9wdGlvbnMgPSAncmVub21pbmF0aW9uJztcblxuXHRcdFx0cmVtb3RlTWVkaWFPYmouc2V0dXAgPSAnYWN0cGFzcyc7XG5cblx0XHRcdGlmIChjb25zdW1lckluZm9zLnNvbWUoKGluZm8pID0+IGluZm8ua2luZCA9PT0ga2luZCkpXG5cdFx0XHRcdHJlbW90ZU1lZGlhT2JqLmRpcmVjdGlvbiA9ICdzZW5kb25seSc7XG5cdFx0XHRlbHNlXG5cdFx0XHRcdHJlbW90ZU1lZGlhT2JqLmRpcmVjdGlvbiA9ICdpbmFjdGl2ZSc7XG5cblx0XHRcdHJlbW90ZU1lZGlhT2JqLnJ0cCA9IFtdO1xuXHRcdFx0cmVtb3RlTWVkaWFPYmoucnRjcEZiID0gW107XG5cdFx0XHRyZW1vdGVNZWRpYU9iai5mbXRwID0gW107XG5cblx0XHRcdGZvciAoY29uc3QgY29kZWMgb2YgY29kZWNzKVxuXHRcdFx0e1xuXHRcdFx0XHRjb25zdCBydHAgPVxuXHRcdFx0XHR7XG5cdFx0XHRcdFx0cGF5bG9hZCA6IGNvZGVjLnBheWxvYWRUeXBlLFxuXHRcdFx0XHRcdGNvZGVjICAgOiBjb2RlYy5uYW1lLFxuXHRcdFx0XHRcdHJhdGUgICAgOiBjb2RlYy5jbG9ja1JhdGVcblx0XHRcdFx0fTtcblxuXHRcdFx0XHRpZiAoY29kZWMuY2hhbm5lbHMgPiAxKVxuXHRcdFx0XHRcdHJ0cC5lbmNvZGluZyA9IGNvZGVjLmNoYW5uZWxzO1xuXG5cdFx0XHRcdHJlbW90ZU1lZGlhT2JqLnJ0cC5wdXNoKHJ0cCk7XG5cblx0XHRcdFx0aWYgKGNvZGVjLnBhcmFtZXRlcnMpXG5cdFx0XHRcdHtcblx0XHRcdFx0XHRjb25zdCBwYXJhbUZtdHAgPVxuXHRcdFx0XHRcdHtcblx0XHRcdFx0XHRcdHBheWxvYWQgOiBjb2RlYy5wYXlsb2FkVHlwZSxcblx0XHRcdFx0XHRcdGNvbmZpZyAgOiAnJ1xuXHRcdFx0XHRcdH07XG5cblx0XHRcdFx0XHRmb3IgKGNvbnN0IGtleSBvZiBPYmplY3Qua2V5cyhjb2RlYy5wYXJhbWV0ZXJzKSlcblx0XHRcdFx0XHR7XG5cdFx0XHRcdFx0XHRpZiAocGFyYW1GbXRwLmNvbmZpZylcblx0XHRcdFx0XHRcdFx0cGFyYW1GbXRwLmNvbmZpZyArPSAnOyc7XG5cblx0XHRcdFx0XHRcdHBhcmFtRm10cC5jb25maWcgKz0gYCR7a2V5fT0ke2NvZGVjLnBhcmFtZXRlcnNba2V5XX1gO1xuXHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdGlmIChwYXJhbUZtdHAuY29uZmlnKVxuXHRcdFx0XHRcdFx0cmVtb3RlTWVkaWFPYmouZm10cC5wdXNoKHBhcmFtRm10cCk7XG5cdFx0XHRcdH1cblxuXHRcdFx0XHRpZiAoY29kZWMucnRjcEZlZWRiYWNrKVxuXHRcdFx0XHR7XG5cdFx0XHRcdFx0Zm9yIChjb25zdCBmYiBvZiBjb2RlYy5ydGNwRmVlZGJhY2spXG5cdFx0XHRcdFx0e1xuXHRcdFx0XHRcdFx0cmVtb3RlTWVkaWFPYmoucnRjcEZiLnB1c2goXG5cdFx0XHRcdFx0XHRcdHtcblx0XHRcdFx0XHRcdFx0XHRwYXlsb2FkIDogY29kZWMucGF5bG9hZFR5cGUsXG5cdFx0XHRcdFx0XHRcdFx0dHlwZSAgICA6IGZiLnR5cGUsXG5cdFx0XHRcdFx0XHRcdFx0c3VidHlwZSA6IGZiLnBhcmFtZXRlciB8fCAnJ1xuXHRcdFx0XHRcdFx0XHR9KTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblx0XHRcdH1cblxuXHRcdFx0cmVtb3RlTWVkaWFPYmoucGF5bG9hZHMgPSBjb2RlY3Ncblx0XHRcdFx0Lm1hcCgoY29kZWMpID0+IGNvZGVjLnBheWxvYWRUeXBlKVxuXHRcdFx0XHQuam9pbignICcpO1xuXG5cdFx0XHRyZW1vdGVNZWRpYU9iai5leHQgPSBbXTtcblxuXHRcdFx0Zm9yIChjb25zdCBleHQgb2YgaGVhZGVyRXh0ZW5zaW9ucylcblx0XHRcdHtcblx0XHRcdFx0cmVtb3RlTWVkaWFPYmouZXh0LnB1c2goXG5cdFx0XHRcdFx0e1xuXHRcdFx0XHRcdFx0dXJpICAgOiBleHQudXJpLFxuXHRcdFx0XHRcdFx0dmFsdWUgOiBleHQuaWRcblx0XHRcdFx0XHR9KTtcblx0XHRcdH1cblxuXHRcdFx0cmVtb3RlTWVkaWFPYmoucnRjcE11eCA9ICdydGNwLW11eCc7XG5cdFx0XHRyZW1vdGVNZWRpYU9iai5ydGNwUnNpemUgPSAncnRjcC1yc2l6ZSc7XG5cblx0XHRcdHJlbW90ZU1lZGlhT2JqLnNzcmNzID0gW107XG5cdFx0XHRyZW1vdGVNZWRpYU9iai5zc3JjR3JvdXBzID0gW107XG5cblx0XHRcdGZvciAoY29uc3QgaW5mbyBvZiBjb25zdW1lckluZm9zKVxuXHRcdFx0e1xuXHRcdFx0XHRpZiAoaW5mby5raW5kICE9PSBraW5kKVxuXHRcdFx0XHRcdGNvbnRpbnVlO1xuXG5cdFx0XHRcdHJlbW90ZU1lZGlhT2JqLnNzcmNzLnB1c2goXG5cdFx0XHRcdFx0e1xuXHRcdFx0XHRcdFx0aWQgICAgICAgIDogaW5mby5zc3JjLFxuXHRcdFx0XHRcdFx0YXR0cmlidXRlIDogJ21zaWQnLFxuXHRcdFx0XHRcdFx0dmFsdWUgICAgIDogYCR7aW5mby5zdHJlYW1JZH0gJHtpbmZvLnRyYWNrSWR9YFxuXHRcdFx0XHRcdH0pO1xuXG5cdFx0XHRcdHJlbW90ZU1lZGlhT2JqLnNzcmNzLnB1c2goXG5cdFx0XHRcdFx0e1xuXHRcdFx0XHRcdFx0aWQgICAgICAgIDogaW5mby5zc3JjLFxuXHRcdFx0XHRcdFx0YXR0cmlidXRlIDogJ21zbGFiZWwnLFxuXHRcdFx0XHRcdFx0dmFsdWUgICAgIDogaW5mby5zdHJlYW1JZFxuXHRcdFx0XHRcdH0pO1xuXG5cdFx0XHRcdHJlbW90ZU1lZGlhT2JqLnNzcmNzLnB1c2goXG5cdFx0XHRcdFx0e1xuXHRcdFx0XHRcdFx0aWQgICAgICAgIDogaW5mby5zc3JjLFxuXHRcdFx0XHRcdFx0YXR0cmlidXRlIDogJ2xhYmVsJyxcblx0XHRcdFx0XHRcdHZhbHVlICAgICA6IGluZm8udHJhY2tJZFxuXHRcdFx0XHRcdH0pO1xuXG5cdFx0XHRcdHJlbW90ZU1lZGlhT2JqLnNzcmNzLnB1c2goXG5cdFx0XHRcdFx0e1xuXHRcdFx0XHRcdFx0aWQgICAgICAgIDogaW5mby5zc3JjLFxuXHRcdFx0XHRcdFx0YXR0cmlidXRlIDogJ2NuYW1lJyxcblx0XHRcdFx0XHRcdHZhbHVlICAgICA6IGluZm8uY25hbWVcblx0XHRcdFx0XHR9KTtcblxuXHRcdFx0XHRpZiAoaW5mby5ydHhTc3JjKVxuXHRcdFx0XHR7XG5cdFx0XHRcdFx0cmVtb3RlTWVkaWFPYmouc3NyY3MucHVzaChcblx0XHRcdFx0XHRcdHtcblx0XHRcdFx0XHRcdFx0aWQgICAgICAgIDogaW5mby5ydHhTc3JjLFxuXHRcdFx0XHRcdFx0XHRhdHRyaWJ1dGUgOiAnbXNpZCcsXG5cdFx0XHRcdFx0XHRcdHZhbHVlICAgICA6IGAke2luZm8uc3RyZWFtSWR9ICR7aW5mby50cmFja0lkfWBcblx0XHRcdFx0XHRcdH0pO1xuXG5cdFx0XHRcdFx0cmVtb3RlTWVkaWFPYmouc3NyY3MucHVzaChcblx0XHRcdFx0XHRcdHtcblx0XHRcdFx0XHRcdFx0aWQgICAgICAgIDogaW5mby5ydHhTc3JjLFxuXHRcdFx0XHRcdFx0XHRhdHRyaWJ1dGUgOiAnbXNsYWJlbCcsXG5cdFx0XHRcdFx0XHRcdHZhbHVlICAgICA6IGluZm8uc3RyZWFtSWRcblx0XHRcdFx0XHRcdH0pO1xuXG5cdFx0XHRcdFx0cmVtb3RlTWVkaWFPYmouc3NyY3MucHVzaChcblx0XHRcdFx0XHRcdHtcblx0XHRcdFx0XHRcdFx0aWQgICAgICAgIDogaW5mby5ydHhTc3JjLFxuXHRcdFx0XHRcdFx0XHRhdHRyaWJ1dGUgOiAnbGFiZWwnLFxuXHRcdFx0XHRcdFx0XHR2YWx1ZSAgICAgOiBpbmZvLnRyYWNrSWRcblx0XHRcdFx0XHRcdH0pO1xuXG5cdFx0XHRcdFx0cmVtb3RlTWVkaWFPYmouc3NyY3MucHVzaChcblx0XHRcdFx0XHRcdHtcblx0XHRcdFx0XHRcdFx0aWQgICAgICAgIDogaW5mby5ydHhTc3JjLFxuXHRcdFx0XHRcdFx0XHRhdHRyaWJ1dGUgOiAnY25hbWUnLFxuXHRcdFx0XHRcdFx0XHR2YWx1ZSAgICAgOiBpbmZvLmNuYW1lXG5cdFx0XHRcdFx0XHR9KTtcblxuXHRcdFx0XHRcdC8vIEFzc29jaWF0ZSBvcmlnaW5hbCBhbmQgcmV0cmFuc21pc3Npb24gU1NSQy5cblx0XHRcdFx0XHRyZW1vdGVNZWRpYU9iai5zc3JjR3JvdXBzLnB1c2goXG5cdFx0XHRcdFx0XHR7XG5cdFx0XHRcdFx0XHRcdHNlbWFudGljcyA6ICdGSUQnLFxuXHRcdFx0XHRcdFx0XHRzc3JjcyAgICAgOiBgJHtpbmZvLnNzcmN9ICR7aW5mby5ydHhTc3JjfWBcblx0XHRcdFx0XHRcdH0pO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cblx0XHRcdC8vIFB1c2ggaXQuXG5cdFx0XHRzZHBPYmoubWVkaWEucHVzaChyZW1vdGVNZWRpYU9iaik7XG5cdFx0fVxuXG5cdFx0Y29uc3Qgc2RwID0gc2RwVHJhbnNmb3JtLndyaXRlKHNkcE9iaik7XG5cblx0XHRyZXR1cm4gc2RwO1xuXHR9XG59XG5cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIFJlbW90ZVBsYW5CU2RwXG57XG5cdGNvbnN0cnVjdG9yKGRpcmVjdGlvbiwgcnRwUGFyYW1ldGVyc0J5S2luZClcblx0e1xuXHRcdGxvZ2dlci5kZWJ1Zyhcblx0XHRcdCdjb25zdHJ1Y3RvcigpIFtkaXJlY3Rpb246JXMsIHJ0cFBhcmFtZXRlcnNCeUtpbmQ6JW9dJyxcblx0XHRcdGRpcmVjdGlvbiwgcnRwUGFyYW1ldGVyc0J5S2luZCk7XG5cblx0XHRzd2l0Y2ggKGRpcmVjdGlvbilcblx0XHR7XG5cdFx0XHRjYXNlICdzZW5kJzpcblx0XHRcdFx0cmV0dXJuIG5ldyBTZW5kUmVtb3RlU2RwKHJ0cFBhcmFtZXRlcnNCeUtpbmQpO1xuXHRcdFx0Y2FzZSAncmVjdic6XG5cdFx0XHRcdHJldHVybiBuZXcgUmVjdlJlbW90ZVNkcChydHBQYXJhbWV0ZXJzQnlLaW5kKTtcblx0XHR9XG5cdH1cbn1cbiIsImltcG9ydCBzZHBUcmFuc2Zvcm0gZnJvbSAnc2RwLXRyYW5zZm9ybSc7XG5pbXBvcnQgTG9nZ2VyIGZyb20gJy4uLy4uL0xvZ2dlcic7XG5pbXBvcnQgKiBhcyB1dGlscyBmcm9tICcuLi8uLi91dGlscyc7XG5cbmNvbnN0IGxvZ2dlciA9IG5ldyBMb2dnZXIoJ1JlbW90ZVVuaWZpZWRQbGFuU2RwJyk7XG5cbmNsYXNzIFJlbW90ZVNkcFxue1xuXHRjb25zdHJ1Y3RvcihydHBQYXJhbWV0ZXJzQnlLaW5kKVxuXHR7XG5cdFx0Ly8gR2VuZXJpYyBzZW5kaW5nIFJUUCBwYXJhbWV0ZXJzIGZvciBhdWRpbyBhbmQgdmlkZW8uXG5cdFx0Ly8gQHR5cGUge09iamVjdH1cblx0XHR0aGlzLl9ydHBQYXJhbWV0ZXJzQnlLaW5kID0gcnRwUGFyYW1ldGVyc0J5S2luZDtcblxuXHRcdC8vIFRyYW5zcG9ydCBsb2NhbCBwYXJhbWV0ZXJzLCBpbmNsdWRpbmcgRFRMUyBwYXJhbWV0ZXJlcy5cblx0XHQvLyBAdHlwZSB7T2JqZWN0fVxuXHRcdHRoaXMuX3RyYW5zcG9ydExvY2FsUGFyYW1ldGVycyA9IG51bGw7XG5cblx0XHQvLyBUcmFuc3BvcnQgcmVtb3RlIHBhcmFtZXRlcnMsIGluY2x1ZGluZyBJQ0UgcGFyYW1ldGVycywgSUNFIGNhbmRpZGF0ZXNcblx0XHQvLyBhbmQgRFRMUyBwYXJhbWV0ZXJlcy5cblx0XHQvLyBAdHlwZSB7T2JqZWN0fVxuXHRcdHRoaXMuX3RyYW5zcG9ydFJlbW90ZVBhcmFtZXRlcnMgPSBudWxsO1xuXG5cdFx0Ly8gU0RQIGdsb2JhbCBmaWVsZHMuXG5cdFx0Ly8gQHR5cGUge09iamVjdH1cblx0XHR0aGlzLl9zZHBHbG9iYWxGaWVsZHMgPVxuXHRcdHtcblx0XHRcdGlkICAgICAgOiB1dGlscy5yYW5kb21OdW1iZXIoKSxcblx0XHRcdHZlcnNpb24gOiAwXG5cdFx0fTtcblx0fVxuXG5cdHNldFRyYW5zcG9ydExvY2FsUGFyYW1ldGVycyh0cmFuc3BvcnRMb2NhbFBhcmFtZXRlcnMpXG5cdHtcblx0XHRsb2dnZXIuZGVidWcoXG5cdFx0XHQnc2V0VHJhbnNwb3J0TG9jYWxQYXJhbWV0ZXJzKCkgW3RyYW5zcG9ydExvY2FsUGFyYW1ldGVyczolb10nLFxuXHRcdFx0dHJhbnNwb3J0TG9jYWxQYXJhbWV0ZXJzKTtcblxuXHRcdHRoaXMuX3RyYW5zcG9ydExvY2FsUGFyYW1ldGVycyA9IHRyYW5zcG9ydExvY2FsUGFyYW1ldGVycztcblx0fVxuXG5cdHNldFRyYW5zcG9ydFJlbW90ZVBhcmFtZXRlcnModHJhbnNwb3J0UmVtb3RlUGFyYW1ldGVycylcblx0e1xuXHRcdGxvZ2dlci5kZWJ1Zyhcblx0XHRcdCdzZXRUcmFuc3BvcnRSZW1vdGVQYXJhbWV0ZXJzKCkgW3RyYW5zcG9ydFJlbW90ZVBhcmFtZXRlcnM6JW9dJyxcblx0XHRcdHRyYW5zcG9ydFJlbW90ZVBhcmFtZXRlcnMpO1xuXG5cdFx0dGhpcy5fdHJhbnNwb3J0UmVtb3RlUGFyYW1ldGVycyA9IHRyYW5zcG9ydFJlbW90ZVBhcmFtZXRlcnM7XG5cdH1cblxuXHR1cGRhdGVUcmFuc3BvcnRSZW1vdGVJY2VQYXJhbWV0ZXJzKHJlbW90ZUljZVBhcmFtZXRlcnMpXG5cdHtcblx0XHRsb2dnZXIuZGVidWcoXG5cdFx0XHQndXBkYXRlVHJhbnNwb3J0UmVtb3RlSWNlUGFyYW1ldGVycygpIFtyZW1vdGVJY2VQYXJhbWV0ZXJzOiVvXScsXG5cdFx0XHRyZW1vdGVJY2VQYXJhbWV0ZXJzKTtcblxuXHRcdHRoaXMuX3RyYW5zcG9ydFJlbW90ZVBhcmFtZXRlcnMuaWNlUGFyYW1ldGVycyA9IHJlbW90ZUljZVBhcmFtZXRlcnM7XG5cdH1cbn1cblxuY2xhc3MgU2VuZFJlbW90ZVNkcCBleHRlbmRzIFJlbW90ZVNkcFxue1xuXHRjb25zdHJ1Y3RvcihydHBQYXJhbWV0ZXJzQnlLaW5kKVxuXHR7XG5cdFx0c3VwZXIocnRwUGFyYW1ldGVyc0J5S2luZCk7XG5cdH1cblxuXHRjcmVhdGVBbnN3ZXJTZHAobG9jYWxTZHBPYmopXG5cdHtcblx0XHRsb2dnZXIuZGVidWcoJ2NyZWF0ZUFuc3dlclNkcCgpJyk7XG5cblx0XHRpZiAoIXRoaXMuX3RyYW5zcG9ydExvY2FsUGFyYW1ldGVycylcblx0XHRcdHRocm93IG5ldyBFcnJvcignbm8gdHJhbnNwb3J0IGxvY2FsIHBhcmFtZXRlcnMnKTtcblx0XHRlbHNlIGlmICghdGhpcy5fdHJhbnNwb3J0UmVtb3RlUGFyYW1ldGVycylcblx0XHRcdHRocm93IG5ldyBFcnJvcignbm8gdHJhbnNwb3J0IHJlbW90ZSBwYXJhbWV0ZXJzJyk7XG5cblx0XHRjb25zdCByZW1vdGVJY2VQYXJhbWV0ZXJzID0gdGhpcy5fdHJhbnNwb3J0UmVtb3RlUGFyYW1ldGVycy5pY2VQYXJhbWV0ZXJzO1xuXHRcdGNvbnN0IHJlbW90ZUljZUNhbmRpZGF0ZXMgPSB0aGlzLl90cmFuc3BvcnRSZW1vdGVQYXJhbWV0ZXJzLmljZUNhbmRpZGF0ZXM7XG5cdFx0Y29uc3QgcmVtb3RlRHRsc1BhcmFtZXRlcnMgPSB0aGlzLl90cmFuc3BvcnRSZW1vdGVQYXJhbWV0ZXJzLmR0bHNQYXJhbWV0ZXJzO1xuXHRcdGNvbnN0IHNkcE9iaiA9IHt9O1xuXHRcdGNvbnN0IG1pZHMgPSAobG9jYWxTZHBPYmoubWVkaWEgfHwgW10pXG5cdFx0XHQuZmlsdGVyKChtKSA9PiBtLm1pZClcblx0XHRcdC5tYXAoKG0pID0+IG0ubWlkKTtcblxuXHRcdC8vIEluY3JlYXNlIG91ciBTRFAgdmVyc2lvbi5cblx0XHR0aGlzLl9zZHBHbG9iYWxGaWVsZHMudmVyc2lvbisrO1xuXG5cdFx0c2RwT2JqLnZlcnNpb24gPSAwO1xuXHRcdHNkcE9iai5vcmlnaW4gPVxuXHRcdHtcblx0XHRcdGFkZHJlc3MgICAgICAgIDogJzAuMC4wLjAnLFxuXHRcdFx0aXBWZXIgICAgICAgICAgOiA0LFxuXHRcdFx0bmV0VHlwZSAgICAgICAgOiAnSU4nLFxuXHRcdFx0c2Vzc2lvbklkICAgICAgOiB0aGlzLl9zZHBHbG9iYWxGaWVsZHMuaWQsXG5cdFx0XHRzZXNzaW9uVmVyc2lvbiA6IHRoaXMuX3NkcEdsb2JhbEZpZWxkcy52ZXJzaW9uLFxuXHRcdFx0dXNlcm5hbWUgICAgICAgOiAnbWVkaWFzb3VwLWNsaWVudCdcblx0XHR9O1xuXHRcdHNkcE9iai5uYW1lID0gJy0nO1xuXHRcdHNkcE9iai50aW1pbmcgPSB7IHN0YXJ0OiAwLCBzdG9wOiAwIH07XG5cdFx0c2RwT2JqLmljZWxpdGUgPSByZW1vdGVJY2VQYXJhbWV0ZXJzLmljZUxpdGUgPyAnaWNlLWxpdGUnIDogbnVsbDtcblx0XHRzZHBPYmoubXNpZFNlbWFudGljID1cblx0XHR7XG5cdFx0XHRzZW1hbnRpYyA6ICdXTVMnLFxuXHRcdFx0dG9rZW4gICAgOiAnKidcblx0XHR9O1xuXG5cdFx0aWYgKG1pZHMubGVuZ3RoID4gMClcblx0XHR7XG5cdFx0XHRzZHBPYmouZ3JvdXBzID1cblx0XHRcdFtcblx0XHRcdFx0e1xuXHRcdFx0XHRcdHR5cGUgOiAnQlVORExFJyxcblx0XHRcdFx0XHRtaWRzIDogbWlkcy5qb2luKCcgJylcblx0XHRcdFx0fVxuXHRcdFx0XTtcblx0XHR9XG5cblx0XHRzZHBPYmoubWVkaWEgPSBbXTtcblxuXHRcdC8vIE5PVEU6IFdlIHRha2UgdGhlIGxhdGVzdCBmaW5nZXJwcmludC5cblx0XHRjb25zdCBudW1GaW5nZXJwcmludHMgPSByZW1vdGVEdGxzUGFyYW1ldGVycy5maW5nZXJwcmludHMubGVuZ3RoO1xuXG5cdFx0c2RwT2JqLmZpbmdlcnByaW50ID1cblx0XHR7XG5cdFx0XHR0eXBlIDogcmVtb3RlRHRsc1BhcmFtZXRlcnMuZmluZ2VycHJpbnRzW251bUZpbmdlcnByaW50cyAtIDFdLmFsZ29yaXRobSxcblx0XHRcdGhhc2ggOiByZW1vdGVEdGxzUGFyYW1ldGVycy5maW5nZXJwcmludHNbbnVtRmluZ2VycHJpbnRzIC0gMV0udmFsdWVcblx0XHR9O1xuXG5cdFx0Zm9yIChjb25zdCBsb2NhbE1lZGlhT2JqIG9mIGxvY2FsU2RwT2JqLm1lZGlhIHx8IFtdKVxuXHRcdHtcblx0XHRcdGNvbnN0IGNsb3NlZCA9IGxvY2FsTWVkaWFPYmouZGlyZWN0aW9uID09PSAnaW5hY3RpdmUnO1xuXHRcdFx0Y29uc3Qga2luZCA9IGxvY2FsTWVkaWFPYmoudHlwZTtcblx0XHRcdGNvbnN0IGNvZGVjcyA9IHRoaXMuX3J0cFBhcmFtZXRlcnNCeUtpbmRba2luZF0uY29kZWNzO1xuXHRcdFx0Y29uc3QgaGVhZGVyRXh0ZW5zaW9ucyA9IHRoaXMuX3J0cFBhcmFtZXRlcnNCeUtpbmRba2luZF0uaGVhZGVyRXh0ZW5zaW9ucztcblx0XHRcdGNvbnN0IHJlbW90ZU1lZGlhT2JqID0ge307XG5cblx0XHRcdHJlbW90ZU1lZGlhT2JqLnR5cGUgPSBsb2NhbE1lZGlhT2JqLnR5cGU7XG5cdFx0XHRyZW1vdGVNZWRpYU9iai5wb3J0ID0gNztcblx0XHRcdHJlbW90ZU1lZGlhT2JqLnByb3RvY29sID0gJ1JUUC9TQVZQRic7XG5cdFx0XHRyZW1vdGVNZWRpYU9iai5jb25uZWN0aW9uID0geyBpcDogJzEyNy4wLjAuMScsIHZlcnNpb246IDQgfTtcblx0XHRcdHJlbW90ZU1lZGlhT2JqLm1pZCA9IGxvY2FsTWVkaWFPYmoubWlkO1xuXG5cdFx0XHRyZW1vdGVNZWRpYU9iai5pY2VVZnJhZyA9IHJlbW90ZUljZVBhcmFtZXRlcnMudXNlcm5hbWVGcmFnbWVudDtcblx0XHRcdHJlbW90ZU1lZGlhT2JqLmljZVB3ZCA9IHJlbW90ZUljZVBhcmFtZXRlcnMucGFzc3dvcmQ7XG5cdFx0XHRyZW1vdGVNZWRpYU9iai5jYW5kaWRhdGVzID0gW107XG5cblx0XHRcdGZvciAoY29uc3QgY2FuZGlkYXRlIG9mIHJlbW90ZUljZUNhbmRpZGF0ZXMpXG5cdFx0XHR7XG5cdFx0XHRcdGNvbnN0IGNhbmRpZGF0ZU9iaiA9IHt9O1xuXG5cdFx0XHRcdC8vIG1lZGlhc291cCBkb2VzIG5vdCBzdXBwb3J0IG5vbiBydGNwLW11eCBzbyBjYW5kaWRhdGVzIGNvbXBvbmVudCBpc1xuXHRcdFx0XHQvLyBhbHdheXMgUlRQICgxKS5cblx0XHRcdFx0Y2FuZGlkYXRlT2JqLmNvbXBvbmVudCA9IDE7XG5cdFx0XHRcdGNhbmRpZGF0ZU9iai5mb3VuZGF0aW9uID0gY2FuZGlkYXRlLmZvdW5kYXRpb247XG5cdFx0XHRcdGNhbmRpZGF0ZU9iai5pcCA9IGNhbmRpZGF0ZS5pcDtcblx0XHRcdFx0Y2FuZGlkYXRlT2JqLnBvcnQgPSBjYW5kaWRhdGUucG9ydDtcblx0XHRcdFx0Y2FuZGlkYXRlT2JqLnByaW9yaXR5ID0gY2FuZGlkYXRlLnByaW9yaXR5O1xuXHRcdFx0XHRjYW5kaWRhdGVPYmoudHJhbnNwb3J0ID0gY2FuZGlkYXRlLnByb3RvY29sO1xuXHRcdFx0XHRjYW5kaWRhdGVPYmoudHlwZSA9IGNhbmRpZGF0ZS50eXBlO1xuXHRcdFx0XHRpZiAoY2FuZGlkYXRlLnRjcFR5cGUpXG5cdFx0XHRcdFx0Y2FuZGlkYXRlT2JqLnRjcHR5cGUgPSBjYW5kaWRhdGUudGNwVHlwZTtcblxuXHRcdFx0XHRyZW1vdGVNZWRpYU9iai5jYW5kaWRhdGVzLnB1c2goY2FuZGlkYXRlT2JqKTtcblx0XHRcdH1cblxuXHRcdFx0cmVtb3RlTWVkaWFPYmouZW5kT2ZDYW5kaWRhdGVzID0gJ2VuZC1vZi1jYW5kaWRhdGVzJztcblxuXHRcdFx0Ly8gQW5ub3VuY2Ugc3VwcG9ydCBmb3IgSUNFIHJlbm9taW5hdGlvbi5cblx0XHRcdC8vIGh0dHBzOi8vdG9vbHMuaWV0Zi5vcmcvaHRtbC9kcmFmdC10aGF0Y2hlci1pY2UtcmVub21pbmF0aW9uXG5cdFx0XHRyZW1vdGVNZWRpYU9iai5pY2VPcHRpb25zID0gJ3Jlbm9taW5hdGlvbic7XG5cblx0XHRcdHN3aXRjaCAocmVtb3RlRHRsc1BhcmFtZXRlcnMucm9sZSlcblx0XHRcdHtcblx0XHRcdFx0Y2FzZSAnY2xpZW50Jzpcblx0XHRcdFx0XHRyZW1vdGVNZWRpYU9iai5zZXR1cCA9ICdhY3RpdmUnO1xuXHRcdFx0XHRcdGJyZWFrO1xuXHRcdFx0XHRjYXNlICdzZXJ2ZXInOlxuXHRcdFx0XHRcdHJlbW90ZU1lZGlhT2JqLnNldHVwID0gJ3Bhc3NpdmUnO1xuXHRcdFx0XHRcdGJyZWFrO1xuXHRcdFx0fVxuXG5cdFx0XHRzd2l0Y2ggKGxvY2FsTWVkaWFPYmouZGlyZWN0aW9uKVxuXHRcdFx0e1xuXHRcdFx0XHRjYXNlICdzZW5kcmVjdic6XG5cdFx0XHRcdGNhc2UgJ3NlbmRvbmx5Jzpcblx0XHRcdFx0XHRyZW1vdGVNZWRpYU9iai5kaXJlY3Rpb24gPSAncmVjdm9ubHknO1xuXHRcdFx0XHRcdGJyZWFrO1xuXHRcdFx0XHRjYXNlICdyZWN2b25seSc6XG5cdFx0XHRcdGNhc2UgJ2luYWN0aXZlJzpcblx0XHRcdFx0XHRyZW1vdGVNZWRpYU9iai5kaXJlY3Rpb24gPSAnaW5hY3RpdmUnO1xuXHRcdFx0XHRcdGJyZWFrO1xuXHRcdFx0fVxuXG5cdFx0XHRyZW1vdGVNZWRpYU9iai5ydHAgPSBbXTtcblx0XHRcdHJlbW90ZU1lZGlhT2JqLnJ0Y3BGYiA9IFtdO1xuXHRcdFx0cmVtb3RlTWVkaWFPYmouZm10cCA9IFtdO1xuXG5cdFx0XHRmb3IgKGNvbnN0IGNvZGVjIG9mIGNvZGVjcylcblx0XHRcdHtcblx0XHRcdFx0Y29uc3QgcnRwID1cblx0XHRcdFx0e1xuXHRcdFx0XHRcdHBheWxvYWQgOiBjb2RlYy5wYXlsb2FkVHlwZSxcblx0XHRcdFx0XHRjb2RlYyAgIDogY29kZWMubmFtZSxcblx0XHRcdFx0XHRyYXRlICAgIDogY29kZWMuY2xvY2tSYXRlXG5cdFx0XHRcdH07XG5cblx0XHRcdFx0aWYgKGNvZGVjLmNoYW5uZWxzID4gMSlcblx0XHRcdFx0XHRydHAuZW5jb2RpbmcgPSBjb2RlYy5jaGFubmVscztcblxuXHRcdFx0XHRyZW1vdGVNZWRpYU9iai5ydHAucHVzaChydHApO1xuXG5cdFx0XHRcdGlmIChjb2RlYy5wYXJhbWV0ZXJzKVxuXHRcdFx0XHR7XG5cdFx0XHRcdFx0Y29uc3QgcGFyYW1GbXRwID1cblx0XHRcdFx0XHR7XG5cdFx0XHRcdFx0XHRwYXlsb2FkIDogY29kZWMucGF5bG9hZFR5cGUsXG5cdFx0XHRcdFx0XHRjb25maWcgIDogJydcblx0XHRcdFx0XHR9O1xuXG5cdFx0XHRcdFx0Zm9yIChjb25zdCBrZXkgb2YgT2JqZWN0LmtleXMoY29kZWMucGFyYW1ldGVycykpXG5cdFx0XHRcdFx0e1xuXHRcdFx0XHRcdFx0aWYgKHBhcmFtRm10cC5jb25maWcpXG5cdFx0XHRcdFx0XHRcdHBhcmFtRm10cC5jb25maWcgKz0gJzsnO1xuXG5cdFx0XHRcdFx0XHRwYXJhbUZtdHAuY29uZmlnICs9IGAke2tleX09JHtjb2RlYy5wYXJhbWV0ZXJzW2tleV19YDtcblx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHRpZiAocGFyYW1GbXRwLmNvbmZpZylcblx0XHRcdFx0XHRcdHJlbW90ZU1lZGlhT2JqLmZtdHAucHVzaChwYXJhbUZtdHApO1xuXHRcdFx0XHR9XG5cblx0XHRcdFx0aWYgKGNvZGVjLnJ0Y3BGZWVkYmFjaylcblx0XHRcdFx0e1xuXHRcdFx0XHRcdGZvciAoY29uc3QgZmIgb2YgY29kZWMucnRjcEZlZWRiYWNrKVxuXHRcdFx0XHRcdHtcblx0XHRcdFx0XHRcdHJlbW90ZU1lZGlhT2JqLnJ0Y3BGYi5wdXNoKFxuXHRcdFx0XHRcdFx0XHR7XG5cdFx0XHRcdFx0XHRcdFx0cGF5bG9hZCA6IGNvZGVjLnBheWxvYWRUeXBlLFxuXHRcdFx0XHRcdFx0XHRcdHR5cGUgICAgOiBmYi50eXBlLFxuXHRcdFx0XHRcdFx0XHRcdHN1YnR5cGUgOiBmYi5wYXJhbWV0ZXIgfHwgJydcblx0XHRcdFx0XHRcdFx0fSk7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cdFx0XHR9XG5cblx0XHRcdHJlbW90ZU1lZGlhT2JqLnBheWxvYWRzID0gY29kZWNzXG5cdFx0XHRcdC5tYXAoKGNvZGVjKSA9PiBjb2RlYy5wYXlsb2FkVHlwZSlcblx0XHRcdFx0LmpvaW4oJyAnKTtcblxuXHRcdFx0Ly8gTk9URTogRmlyZWZveCBkb2VzIG5vdCBsaWtlIGE9ZXh0bWFwIGxpbmVzIGlmIGE9aW5hY3RpdmUuXG5cdFx0XHRpZiAoIWNsb3NlZClcblx0XHRcdHtcblx0XHRcdFx0cmVtb3RlTWVkaWFPYmouZXh0ID0gW107XG5cblx0XHRcdFx0Zm9yIChjb25zdCBleHQgb2YgaGVhZGVyRXh0ZW5zaW9ucylcblx0XHRcdFx0e1xuXHRcdFx0XHRcdC8vIERvbid0IGFkZCBhIGhlYWRlciBleHRlbnNpb24gaWYgbm90IHByZXNlbnQgaW4gdGhlIG9mZmVyLlxuXHRcdFx0XHRcdGNvbnN0IG1hdGNoZWRMb2NhbEV4dCA9IChsb2NhbE1lZGlhT2JqLmV4dCB8fCBbXSlcblx0XHRcdFx0XHRcdC5maW5kKChsb2NhbEV4dCkgPT4gbG9jYWxFeHQudXJpID09PSBleHQudXJpKTtcblxuXHRcdFx0XHRcdGlmICghbWF0Y2hlZExvY2FsRXh0KVxuXHRcdFx0XHRcdFx0Y29udGludWU7XG5cblx0XHRcdFx0XHRyZW1vdGVNZWRpYU9iai5leHQucHVzaChcblx0XHRcdFx0XHRcdHtcblx0XHRcdFx0XHRcdFx0dXJpICAgOiBleHQudXJpLFxuXHRcdFx0XHRcdFx0XHR2YWx1ZSA6IGV4dC5pZFxuXHRcdFx0XHRcdFx0fSk7XG5cdFx0XHRcdH1cblx0XHRcdH1cblxuXHRcdFx0Ly8gU2ltdWxjYXN0LlxuXHRcdFx0aWYgKGxvY2FsTWVkaWFPYmouc2ltdWxjYXN0XzAzKVxuXHRcdFx0e1xuXHRcdFx0XHQvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgY2FtZWxjYXNlXG5cdFx0XHRcdHJlbW90ZU1lZGlhT2JqLnNpbXVsY2FzdF8wMyA9XG5cdFx0XHRcdHtcblx0XHRcdFx0XHR2YWx1ZSA6IGxvY2FsTWVkaWFPYmouc2ltdWxjYXN0XzAzLnZhbHVlLnJlcGxhY2UoL3NlbmQvZywgJ3JlY3YnKVxuXHRcdFx0XHR9O1xuXG5cdFx0XHRcdHJlbW90ZU1lZGlhT2JqLnJpZHMgPSBbXTtcblxuXHRcdFx0XHRmb3IgKGNvbnN0IHJpZCBvZiBsb2NhbE1lZGlhT2JqLnJpZHMgfHwgW10pXG5cdFx0XHRcdHtcblx0XHRcdFx0XHRpZiAocmlkLmRpcmVjdGlvbiAhPT0gJ3NlbmQnKVxuXHRcdFx0XHRcdFx0Y29udGludWU7XG5cblx0XHRcdFx0XHRyZW1vdGVNZWRpYU9iai5yaWRzLnB1c2goXG5cdFx0XHRcdFx0XHR7XG5cdFx0XHRcdFx0XHRcdGlkICAgICAgICA6IHJpZC5pZCxcblx0XHRcdFx0XHRcdFx0ZGlyZWN0aW9uIDogJ3JlY3YnXG5cdFx0XHRcdFx0XHR9KTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXG5cdFx0XHRyZW1vdGVNZWRpYU9iai5ydGNwTXV4ID0gJ3J0Y3AtbXV4Jztcblx0XHRcdHJlbW90ZU1lZGlhT2JqLnJ0Y3BSc2l6ZSA9ICdydGNwLXJzaXplJztcblxuXHRcdFx0Ly8gUHVzaCBpdC5cblx0XHRcdHNkcE9iai5tZWRpYS5wdXNoKHJlbW90ZU1lZGlhT2JqKTtcblx0XHR9XG5cblx0XHRjb25zdCBzZHAgPSBzZHBUcmFuc2Zvcm0ud3JpdGUoc2RwT2JqKTtcblxuXHRcdHJldHVybiBzZHA7XG5cdH1cbn1cblxuY2xhc3MgUmVjdlJlbW90ZVNkcCBleHRlbmRzIFJlbW90ZVNkcFxue1xuXHRjb25zdHJ1Y3RvcihydHBQYXJhbWV0ZXJzQnlLaW5kKVxuXHR7XG5cdFx0c3VwZXIocnRwUGFyYW1ldGVyc0J5S2luZCk7XG5cdH1cblxuXHQvKipcblx0ICogQHBhcmFtIHtBcnJheTxPYmplY3Q+fSBjb25zdW1lckluZm9zIC0gQ29uc3VtZXIgaW5mb3JtYXRpb25zLlxuXHQgKiBAcmV0dXJuIHtTdHJpbmd9XG5cdCAqL1xuXHRjcmVhdGVPZmZlclNkcChjb25zdW1lckluZm9zKVxuXHR7XG5cdFx0bG9nZ2VyLmRlYnVnKCdjcmVhdGVPZmZlclNkcCgpJyk7XG5cblx0XHRpZiAoIXRoaXMuX3RyYW5zcG9ydFJlbW90ZVBhcmFtZXRlcnMpXG5cdFx0XHR0aHJvdyBuZXcgRXJyb3IoJ25vIHRyYW5zcG9ydCByZW1vdGUgcGFyYW1ldGVycycpO1xuXG5cdFx0Y29uc3QgcmVtb3RlSWNlUGFyYW1ldGVycyA9IHRoaXMuX3RyYW5zcG9ydFJlbW90ZVBhcmFtZXRlcnMuaWNlUGFyYW1ldGVycztcblx0XHRjb25zdCByZW1vdGVJY2VDYW5kaWRhdGVzID0gdGhpcy5fdHJhbnNwb3J0UmVtb3RlUGFyYW1ldGVycy5pY2VDYW5kaWRhdGVzO1xuXHRcdGNvbnN0IHJlbW90ZUR0bHNQYXJhbWV0ZXJzID0gdGhpcy5fdHJhbnNwb3J0UmVtb3RlUGFyYW1ldGVycy5kdGxzUGFyYW1ldGVycztcblx0XHRjb25zdCBzZHBPYmogPSB7fTtcblx0XHRjb25zdCBtaWRzID0gY29uc3VtZXJJbmZvc1xuXHRcdFx0Lm1hcCgoaW5mbykgPT4gaW5mby5taWQpO1xuXG5cdFx0Ly8gSW5jcmVhc2Ugb3VyIFNEUCB2ZXJzaW9uLlxuXHRcdHRoaXMuX3NkcEdsb2JhbEZpZWxkcy52ZXJzaW9uKys7XG5cblx0XHRzZHBPYmoudmVyc2lvbiA9IDA7XG5cdFx0c2RwT2JqLm9yaWdpbiA9XG5cdFx0e1xuXHRcdFx0YWRkcmVzcyAgICAgICAgOiAnMC4wLjAuMCcsXG5cdFx0XHRpcFZlciAgICAgICAgICA6IDQsXG5cdFx0XHRuZXRUeXBlICAgICAgICA6ICdJTicsXG5cdFx0XHRzZXNzaW9uSWQgICAgICA6IHRoaXMuX3NkcEdsb2JhbEZpZWxkcy5pZCxcblx0XHRcdHNlc3Npb25WZXJzaW9uIDogdGhpcy5fc2RwR2xvYmFsRmllbGRzLnZlcnNpb24sXG5cdFx0XHR1c2VybmFtZSAgICAgICA6ICdtZWRpYXNvdXAtY2xpZW50J1xuXHRcdH07XG5cdFx0c2RwT2JqLm5hbWUgPSAnLSc7XG5cdFx0c2RwT2JqLnRpbWluZyA9IHsgc3RhcnQ6IDAsIHN0b3A6IDAgfTtcblx0XHRzZHBPYmouaWNlbGl0ZSA9IHJlbW90ZUljZVBhcmFtZXRlcnMuaWNlTGl0ZSA/ICdpY2UtbGl0ZScgOiBudWxsO1xuXHRcdHNkcE9iai5tc2lkU2VtYW50aWMgPVxuXHRcdHtcblx0XHRcdHNlbWFudGljIDogJ1dNUycsXG5cdFx0XHR0b2tlbiAgICA6ICcqJ1xuXHRcdH07XG5cblx0XHRpZiAobWlkcy5sZW5ndGggPiAwKVxuXHRcdHtcblx0XHRcdHNkcE9iai5ncm91cHMgPVxuXHRcdFx0W1xuXHRcdFx0XHR7XG5cdFx0XHRcdFx0dHlwZSA6ICdCVU5ETEUnLFxuXHRcdFx0XHRcdG1pZHMgOiBtaWRzLmpvaW4oJyAnKVxuXHRcdFx0XHR9XG5cdFx0XHRdO1xuXHRcdH1cblxuXHRcdHNkcE9iai5tZWRpYSA9IFtdO1xuXG5cdFx0Ly8gTk9URTogV2UgdGFrZSB0aGUgbGF0ZXN0IGZpbmdlcnByaW50LlxuXHRcdGNvbnN0IG51bUZpbmdlcnByaW50cyA9IHJlbW90ZUR0bHNQYXJhbWV0ZXJzLmZpbmdlcnByaW50cy5sZW5ndGg7XG5cblx0XHRzZHBPYmouZmluZ2VycHJpbnQgPVxuXHRcdHtcblx0XHRcdHR5cGUgOiByZW1vdGVEdGxzUGFyYW1ldGVycy5maW5nZXJwcmludHNbbnVtRmluZ2VycHJpbnRzIC0gMV0uYWxnb3JpdGhtLFxuXHRcdFx0aGFzaCA6IHJlbW90ZUR0bHNQYXJhbWV0ZXJzLmZpbmdlcnByaW50c1tudW1GaW5nZXJwcmludHMgLSAxXS52YWx1ZVxuXHRcdH07XG5cblx0XHRmb3IgKGNvbnN0IGluZm8gb2YgY29uc3VtZXJJbmZvcylcblx0XHR7XG5cdFx0XHRjb25zdCBjbG9zZWQgPSBpbmZvLmNsb3NlZDtcblx0XHRcdGNvbnN0IGtpbmQgPSBpbmZvLmtpbmQ7XG5cdFx0XHRsZXQgY29kZWNzO1xuXHRcdFx0bGV0IGhlYWRlckV4dGVuc2lvbnM7XG5cblx0XHRcdGlmIChpbmZvLmtpbmQgIT09ICdhcHBsaWNhdGlvbicpXG5cdFx0XHR7XG5cdFx0XHRcdGNvZGVjcyA9IHRoaXMuX3J0cFBhcmFtZXRlcnNCeUtpbmRba2luZF0uY29kZWNzO1xuXHRcdFx0XHRoZWFkZXJFeHRlbnNpb25zID0gdGhpcy5fcnRwUGFyYW1ldGVyc0J5S2luZFtraW5kXS5oZWFkZXJFeHRlbnNpb25zO1xuXHRcdFx0fVxuXG5cdFx0XHRjb25zdCByZW1vdGVNZWRpYU9iaiA9IHt9O1xuXG5cdFx0XHRpZiAoaW5mby5raW5kICE9PSAnYXBwbGljYXRpb24nKVxuXHRcdFx0e1xuXHRcdFx0XHRyZW1vdGVNZWRpYU9iai50eXBlID0ga2luZDtcblx0XHRcdFx0cmVtb3RlTWVkaWFPYmoucG9ydCA9IDc7XG5cdFx0XHRcdHJlbW90ZU1lZGlhT2JqLnByb3RvY29sID0gJ1JUUC9TQVZQRic7XG5cdFx0XHRcdHJlbW90ZU1lZGlhT2JqLmNvbm5lY3Rpb24gPSB7IGlwOiAnMTI3LjAuMC4xJywgdmVyc2lvbjogNCB9O1xuXHRcdFx0XHRyZW1vdGVNZWRpYU9iai5taWQgPSBpbmZvLm1pZDtcblx0XHRcdFx0cmVtb3RlTWVkaWFPYmoubXNpZCA9IGAke2luZm8uc3RyZWFtSWR9ICR7aW5mby50cmFja0lkfWA7XG5cdFx0XHR9XG5cdFx0XHRlbHNlXG5cdFx0XHR7XG5cdFx0XHRcdHJlbW90ZU1lZGlhT2JqLnR5cGUgPSBraW5kO1xuXHRcdFx0XHRyZW1vdGVNZWRpYU9iai5wb3J0ID0gOTtcblx0XHRcdFx0cmVtb3RlTWVkaWFPYmoucHJvdG9jb2wgPSAnRFRMUy9TQ1RQJztcblx0XHRcdFx0cmVtb3RlTWVkaWFPYmouY29ubmVjdGlvbiA9IHsgaXA6ICcxMjcuMC4wLjEnLCB2ZXJzaW9uOiA0IH07XG5cdFx0XHRcdHJlbW90ZU1lZGlhT2JqLm1pZCA9IGluZm8ubWlkO1xuXHRcdFx0fVxuXG5cdFx0XHRyZW1vdGVNZWRpYU9iai5pY2VVZnJhZyA9IHJlbW90ZUljZVBhcmFtZXRlcnMudXNlcm5hbWVGcmFnbWVudDtcblx0XHRcdHJlbW90ZU1lZGlhT2JqLmljZVB3ZCA9IHJlbW90ZUljZVBhcmFtZXRlcnMucGFzc3dvcmQ7XG5cdFx0XHRyZW1vdGVNZWRpYU9iai5jYW5kaWRhdGVzID0gW107XG5cblx0XHRcdGZvciAoY29uc3QgY2FuZGlkYXRlIG9mIHJlbW90ZUljZUNhbmRpZGF0ZXMpXG5cdFx0XHR7XG5cdFx0XHRcdGNvbnN0IGNhbmRpZGF0ZU9iaiA9IHt9O1xuXG5cdFx0XHRcdC8vIG1lZGlhc291cCBkb2VzIG5vdCBzdXBwb3J0IG5vbiBydGNwLW11eCBzbyBjYW5kaWRhdGVzIGNvbXBvbmVudCBpc1xuXHRcdFx0XHQvLyBhbHdheXMgUlRQICgxKS5cblx0XHRcdFx0Y2FuZGlkYXRlT2JqLmNvbXBvbmVudCA9IDE7XG5cdFx0XHRcdGNhbmRpZGF0ZU9iai5mb3VuZGF0aW9uID0gY2FuZGlkYXRlLmZvdW5kYXRpb247XG5cdFx0XHRcdGNhbmRpZGF0ZU9iai5pcCA9IGNhbmRpZGF0ZS5pcDtcblx0XHRcdFx0Y2FuZGlkYXRlT2JqLnBvcnQgPSBjYW5kaWRhdGUucG9ydDtcblx0XHRcdFx0Y2FuZGlkYXRlT2JqLnByaW9yaXR5ID0gY2FuZGlkYXRlLnByaW9yaXR5O1xuXHRcdFx0XHRjYW5kaWRhdGVPYmoudHJhbnNwb3J0ID0gY2FuZGlkYXRlLnByb3RvY29sO1xuXHRcdFx0XHRjYW5kaWRhdGVPYmoudHlwZSA9IGNhbmRpZGF0ZS50eXBlO1xuXHRcdFx0XHRpZiAoY2FuZGlkYXRlLnRjcFR5cGUpXG5cdFx0XHRcdFx0Y2FuZGlkYXRlT2JqLnRjcHR5cGUgPSBjYW5kaWRhdGUudGNwVHlwZTtcblxuXHRcdFx0XHRyZW1vdGVNZWRpYU9iai5jYW5kaWRhdGVzLnB1c2goY2FuZGlkYXRlT2JqKTtcblx0XHRcdH1cblxuXHRcdFx0cmVtb3RlTWVkaWFPYmouZW5kT2ZDYW5kaWRhdGVzID0gJ2VuZC1vZi1jYW5kaWRhdGVzJztcblxuXHRcdFx0Ly8gQW5ub3VuY2Ugc3VwcG9ydCBmb3IgSUNFIHJlbm9taW5hdGlvbi5cblx0XHRcdC8vIGh0dHBzOi8vdG9vbHMuaWV0Zi5vcmcvaHRtbC9kcmFmdC10aGF0Y2hlci1pY2UtcmVub21pbmF0aW9uXG5cdFx0XHRyZW1vdGVNZWRpYU9iai5pY2VPcHRpb25zID0gJ3Jlbm9taW5hdGlvbic7XG5cblx0XHRcdHJlbW90ZU1lZGlhT2JqLnNldHVwID0gJ2FjdHBhc3MnO1xuXG5cdFx0XHRpZiAoaW5mby5raW5kICE9PSAnYXBwbGljYXRpb24nKVxuXHRcdFx0e1xuXHRcdFx0XHRpZiAoIWNsb3NlZClcblx0XHRcdFx0XHRyZW1vdGVNZWRpYU9iai5kaXJlY3Rpb24gPSAnc2VuZG9ubHknO1xuXHRcdFx0XHRlbHNlXG5cdFx0XHRcdFx0cmVtb3RlTWVkaWFPYmouZGlyZWN0aW9uID0gJ2luYWN0aXZlJztcblxuXHRcdFx0XHRyZW1vdGVNZWRpYU9iai5ydHAgPSBbXTtcblx0XHRcdFx0cmVtb3RlTWVkaWFPYmoucnRjcEZiID0gW107XG5cdFx0XHRcdHJlbW90ZU1lZGlhT2JqLmZtdHAgPSBbXTtcblxuXHRcdFx0XHRmb3IgKGNvbnN0IGNvZGVjIG9mIGNvZGVjcylcblx0XHRcdFx0e1xuXHRcdFx0XHRcdGNvbnN0IHJ0cCA9XG5cdFx0XHRcdFx0e1xuXHRcdFx0XHRcdFx0cGF5bG9hZCA6IGNvZGVjLnBheWxvYWRUeXBlLFxuXHRcdFx0XHRcdFx0Y29kZWMgICA6IGNvZGVjLm5hbWUsXG5cdFx0XHRcdFx0XHRyYXRlICAgIDogY29kZWMuY2xvY2tSYXRlXG5cdFx0XHRcdFx0fTtcblxuXHRcdFx0XHRcdGlmIChjb2RlYy5jaGFubmVscyA+IDEpXG5cdFx0XHRcdFx0XHRydHAuZW5jb2RpbmcgPSBjb2RlYy5jaGFubmVscztcblxuXHRcdFx0XHRcdHJlbW90ZU1lZGlhT2JqLnJ0cC5wdXNoKHJ0cCk7XG5cblx0XHRcdFx0XHRpZiAoY29kZWMucGFyYW1ldGVycylcblx0XHRcdFx0XHR7XG5cdFx0XHRcdFx0XHRjb25zdCBwYXJhbUZtdHAgPVxuXHRcdFx0XHRcdFx0e1xuXHRcdFx0XHRcdFx0XHRwYXlsb2FkIDogY29kZWMucGF5bG9hZFR5cGUsXG5cdFx0XHRcdFx0XHRcdGNvbmZpZyAgOiAnJ1xuXHRcdFx0XHRcdFx0fTtcblxuXHRcdFx0XHRcdFx0Zm9yIChjb25zdCBrZXkgb2YgT2JqZWN0LmtleXMoY29kZWMucGFyYW1ldGVycykpXG5cdFx0XHRcdFx0XHR7XG5cdFx0XHRcdFx0XHRcdGlmIChwYXJhbUZtdHAuY29uZmlnKVxuXHRcdFx0XHRcdFx0XHRcdHBhcmFtRm10cC5jb25maWcgKz0gJzsnO1xuXG5cdFx0XHRcdFx0XHRcdHBhcmFtRm10cC5jb25maWcgKz0gYCR7a2V5fT0ke2NvZGVjLnBhcmFtZXRlcnNba2V5XX1gO1xuXHRcdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0XHRpZiAocGFyYW1GbXRwLmNvbmZpZylcblx0XHRcdFx0XHRcdFx0cmVtb3RlTWVkaWFPYmouZm10cC5wdXNoKHBhcmFtRm10cCk7XG5cdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0aWYgKGNvZGVjLnJ0Y3BGZWVkYmFjaylcblx0XHRcdFx0XHR7XG5cdFx0XHRcdFx0XHRmb3IgKGNvbnN0IGZiIG9mIGNvZGVjLnJ0Y3BGZWVkYmFjaylcblx0XHRcdFx0XHRcdHtcblx0XHRcdFx0XHRcdFx0cmVtb3RlTWVkaWFPYmoucnRjcEZiLnB1c2goXG5cdFx0XHRcdFx0XHRcdFx0e1xuXHRcdFx0XHRcdFx0XHRcdFx0cGF5bG9hZCA6IGNvZGVjLnBheWxvYWRUeXBlLFxuXHRcdFx0XHRcdFx0XHRcdFx0dHlwZSAgICA6IGZiLnR5cGUsXG5cdFx0XHRcdFx0XHRcdFx0XHRzdWJ0eXBlIDogZmIucGFyYW1ldGVyIHx8ICcnXG5cdFx0XHRcdFx0XHRcdFx0fSk7XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cblx0XHRcdFx0cmVtb3RlTWVkaWFPYmoucGF5bG9hZHMgPSBjb2RlY3Ncblx0XHRcdFx0XHQubWFwKChjb2RlYykgPT4gY29kZWMucGF5bG9hZFR5cGUpXG5cdFx0XHRcdFx0LmpvaW4oJyAnKTtcblxuXHRcdFx0XHQvLyBOT1RFOiBGaXJlZm94IGRvZXMgbm90IGxpa2UgYT1leHRtYXAgbGluZXMgaWYgYT1pbmFjdGl2ZS5cblx0XHRcdFx0aWYgKCFjbG9zZWQpXG5cdFx0XHRcdHtcblx0XHRcdFx0XHRyZW1vdGVNZWRpYU9iai5leHQgPSBbXTtcblxuXHRcdFx0XHRcdGZvciAoY29uc3QgZXh0IG9mIGhlYWRlckV4dGVuc2lvbnMpXG5cdFx0XHRcdFx0e1xuXHRcdFx0XHRcdFx0cmVtb3RlTWVkaWFPYmouZXh0LnB1c2goXG5cdFx0XHRcdFx0XHRcdHtcblx0XHRcdFx0XHRcdFx0XHR1cmkgICA6IGV4dC51cmksXG5cdFx0XHRcdFx0XHRcdFx0dmFsdWUgOiBleHQuaWRcblx0XHRcdFx0XHRcdFx0fSk7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cblx0XHRcdFx0cmVtb3RlTWVkaWFPYmoucnRjcE11eCA9ICdydGNwLW11eCc7XG5cdFx0XHRcdHJlbW90ZU1lZGlhT2JqLnJ0Y3BSc2l6ZSA9ICdydGNwLXJzaXplJztcblxuXHRcdFx0XHRpZiAoIWNsb3NlZClcblx0XHRcdFx0e1xuXHRcdFx0XHRcdHJlbW90ZU1lZGlhT2JqLnNzcmNzID0gW107XG5cdFx0XHRcdFx0cmVtb3RlTWVkaWFPYmouc3NyY0dyb3VwcyA9IFtdO1xuXG5cdFx0XHRcdFx0cmVtb3RlTWVkaWFPYmouc3NyY3MucHVzaChcblx0XHRcdFx0XHRcdHtcblx0XHRcdFx0XHRcdFx0aWQgICAgICAgIDogaW5mby5zc3JjLFxuXHRcdFx0XHRcdFx0XHRhdHRyaWJ1dGUgOiAnY25hbWUnLFxuXHRcdFx0XHRcdFx0XHR2YWx1ZSAgICAgOiBpbmZvLmNuYW1lXG5cdFx0XHRcdFx0XHR9KTtcblxuXHRcdFx0XHRcdGlmIChpbmZvLnJ0eFNzcmMpXG5cdFx0XHRcdFx0e1xuXHRcdFx0XHRcdFx0cmVtb3RlTWVkaWFPYmouc3NyY3MucHVzaChcblx0XHRcdFx0XHRcdFx0e1xuXHRcdFx0XHRcdFx0XHRcdGlkICAgICAgICA6IGluZm8ucnR4U3NyYyxcblx0XHRcdFx0XHRcdFx0XHRhdHRyaWJ1dGUgOiAnY25hbWUnLFxuXHRcdFx0XHRcdFx0XHRcdHZhbHVlICAgICA6IGluZm8uY25hbWVcblx0XHRcdFx0XHRcdFx0fSk7XG5cblx0XHRcdFx0XHRcdC8vIEFzc29jaWF0ZSBvcmlnaW5hbCBhbmQgcmV0cmFuc21pc3Npb24gU1NSQy5cblx0XHRcdFx0XHRcdHJlbW90ZU1lZGlhT2JqLnNzcmNHcm91cHMucHVzaChcblx0XHRcdFx0XHRcdFx0e1xuXHRcdFx0XHRcdFx0XHRcdHNlbWFudGljcyA6ICdGSUQnLFxuXHRcdFx0XHRcdFx0XHRcdHNzcmNzICAgICA6IGAke2luZm8uc3NyY30gJHtpbmZvLnJ0eFNzcmN9YFxuXHRcdFx0XHRcdFx0XHR9KTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHRcdGVsc2Vcblx0XHRcdHtcblx0XHRcdFx0cmVtb3RlTWVkaWFPYmoucGF5bG9hZHMgPSA1MDAwO1xuXHRcdFx0XHRyZW1vdGVNZWRpYU9iai5zY3RwbWFwID1cblx0XHRcdFx0e1xuXHRcdFx0XHRcdGFwcCAgICAgICAgICAgIDogJ3dlYnJ0Yy1kYXRhY2hhbm5lbCcsXG5cdFx0XHRcdFx0bWF4TWVzc2FnZVNpemUgOiAyNTYsXG5cdFx0XHRcdFx0c2N0cG1hcE51bWJlciAgOiA1MDAwXG5cdFx0XHRcdH07XG5cdFx0XHR9XG5cblx0XHRcdC8vIFB1c2ggaXQuXG5cdFx0XHRzZHBPYmoubWVkaWEucHVzaChyZW1vdGVNZWRpYU9iaik7XG5cdFx0fVxuXG5cdFx0Y29uc3Qgc2RwID0gc2RwVHJhbnNmb3JtLndyaXRlKHNkcE9iaik7XG5cblx0XHRyZXR1cm4gc2RwO1xuXHR9XG59XG5cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIFJlbW90ZVVuaWZpZWRQbGFuU2RwXG57XG5cdGNvbnN0cnVjdG9yKGRpcmVjdGlvbiwgcnRwUGFyYW1ldGVyc0J5S2luZClcblx0e1xuXHRcdGxvZ2dlci5kZWJ1Zyhcblx0XHRcdCdjb25zdHJ1Y3RvcigpIFtkaXJlY3Rpb246JXMsIHJ0cFBhcmFtZXRlcnNCeUtpbmQ6JW9dJyxcblx0XHRcdGRpcmVjdGlvbiwgcnRwUGFyYW1ldGVyc0J5S2luZCk7XG5cblx0XHRzd2l0Y2ggKGRpcmVjdGlvbilcblx0XHR7XG5cdFx0XHRjYXNlICdzZW5kJzpcblx0XHRcdFx0cmV0dXJuIG5ldyBTZW5kUmVtb3RlU2RwKHJ0cFBhcmFtZXRlcnNCeUtpbmQpO1xuXHRcdFx0Y2FzZSAncmVjdic6XG5cdFx0XHRcdHJldHVybiBuZXcgUmVjdlJlbW90ZVNkcChydHBQYXJhbWV0ZXJzQnlLaW5kKTtcblx0XHR9XG5cdH1cbn1cbiIsImltcG9ydCBzZHBUcmFuc2Zvcm0gZnJvbSAnc2RwLXRyYW5zZm9ybSc7XG5cbi8qKlxuICogRXh0cmFjdCBSVFAgY2FwYWJpbGl0aWVzIGZyb20gYSBTRFAuXG4gKlxuICogQHBhcmFtIHtPYmplY3R9IHNkcE9iaiAtIFNEUCBPYmplY3QgZ2VuZXJhdGVkIGJ5IHNkcC10cmFuc2Zvcm0uXG4gKiBAcmV0dXJuIHtSVENSdHBDYXBhYmlsaXRpZXN9XG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBleHRyYWN0UnRwQ2FwYWJpbGl0aWVzKHNkcE9iailcbntcblx0Ly8gTWFwIG9mIFJ0cENvZGVjUGFyYW1ldGVycyBpbmRleGVkIGJ5IHBheWxvYWQgdHlwZS5cblx0Y29uc3QgY29kZWNzTWFwID0gbmV3IE1hcCgpO1xuXG5cdC8vIEFycmF5IG9mIFJ0cEhlYWRlckV4dGVuc2lvbnMuXG5cdGNvbnN0IGhlYWRlckV4dGVuc2lvbnMgPSBbXTtcblxuXHQvLyBXaGV0aGVyIGEgbT1hdWRpby92aWRlbyBzZWN0aW9uIGhhcyBiZWVuIGFscmVhZHkgZm91bmQuXG5cdGxldCBnb3RBdWRpbyA9IGZhbHNlO1xuXHRsZXQgZ290VmlkZW8gPSBmYWxzZTtcblxuXHRmb3IgKGNvbnN0IG0gb2Ygc2RwT2JqLm1lZGlhKVxuXHR7XG5cdFx0Y29uc3Qga2luZCA9IG0udHlwZTtcblxuXHRcdHN3aXRjaCAoa2luZClcblx0XHR7XG5cdFx0XHRjYXNlICdhdWRpbyc6XG5cdFx0XHR7XG5cdFx0XHRcdGlmIChnb3RBdWRpbylcblx0XHRcdFx0XHRjb250aW51ZTtcblxuXHRcdFx0XHRnb3RBdWRpbyA9IHRydWU7XG5cdFx0XHRcdGJyZWFrO1xuXHRcdFx0fVxuXHRcdFx0Y2FzZSAndmlkZW8nOlxuXHRcdFx0e1xuXHRcdFx0XHRpZiAoZ290VmlkZW8pXG5cdFx0XHRcdFx0Y29udGludWU7XG5cblx0XHRcdFx0Z290VmlkZW8gPSB0cnVlO1xuXHRcdFx0XHRicmVhaztcblx0XHRcdH1cblx0XHRcdGRlZmF1bHQ6XG5cdFx0XHR7XG5cdFx0XHRcdGNvbnRpbnVlO1xuXHRcdFx0fVxuXHRcdH1cblxuXHRcdC8vIEdldCBjb2RlY3MuXG5cdFx0Zm9yIChjb25zdCBydHAgb2YgbS5ydHApXG5cdFx0e1xuXHRcdFx0Y29uc3QgY29kZWMgPVxuXHRcdFx0e1xuXHRcdFx0XHRuYW1lICAgICAgICAgICAgICAgICA6IHJ0cC5jb2RlYyxcblx0XHRcdFx0bWltZVR5cGUgICAgICAgICAgICAgOiBgJHtraW5kfS8ke3J0cC5jb2RlY31gLFxuXHRcdFx0XHRraW5kICAgICAgICAgICAgICAgICA6IGtpbmQsXG5cdFx0XHRcdGNsb2NrUmF0ZSAgICAgICAgICAgIDogcnRwLnJhdGUsXG5cdFx0XHRcdHByZWZlcnJlZFBheWxvYWRUeXBlIDogcnRwLnBheWxvYWQsXG5cdFx0XHRcdGNoYW5uZWxzICAgICAgICAgICAgIDogcnRwLmVuY29kaW5nLFxuXHRcdFx0XHRydGNwRmVlZGJhY2sgICAgICAgICA6IFtdLFxuXHRcdFx0XHRwYXJhbWV0ZXJzICAgICAgICAgICA6IHt9XG5cdFx0XHR9O1xuXG5cdFx0XHRpZiAoY29kZWMua2luZCAhPT0gJ2F1ZGlvJylcblx0XHRcdFx0ZGVsZXRlIGNvZGVjLmNoYW5uZWxzO1xuXHRcdFx0ZWxzZSBpZiAoIWNvZGVjLmNoYW5uZWxzKVxuXHRcdFx0XHRjb2RlYy5jaGFubmVscyA9IDE7XG5cblx0XHRcdGNvZGVjc01hcC5zZXQoY29kZWMucHJlZmVycmVkUGF5bG9hZFR5cGUsIGNvZGVjKTtcblx0XHR9XG5cblx0XHQvLyBHZXQgY29kZWMgcGFyYW1ldGVycy5cblx0XHRmb3IgKGNvbnN0IGZtdHAgb2YgbS5mbXRwIHx8IFtdKVxuXHRcdHtcblx0XHRcdGNvbnN0IHBhcmFtZXRlcnMgPSBzZHBUcmFuc2Zvcm0ucGFyc2VGbXRwQ29uZmlnKGZtdHAuY29uZmlnKTtcblx0XHRcdGNvbnN0IGNvZGVjID0gY29kZWNzTWFwLmdldChmbXRwLnBheWxvYWQpO1xuXG5cdFx0XHRpZiAoIWNvZGVjKVxuXHRcdFx0XHRjb250aW51ZTtcblxuXHRcdFx0Y29kZWMucGFyYW1ldGVycyA9IHBhcmFtZXRlcnM7XG5cdFx0fVxuXG5cdFx0Ly8gR2V0IFJUQ1AgZmVlZGJhY2sgZm9yIGVhY2ggY29kZWMuXG5cdFx0Zm9yIChjb25zdCBmYiBvZiBtLnJ0Y3BGYiB8fCBbXSlcblx0XHR7XG5cdFx0XHRjb25zdCBjb2RlYyA9IGNvZGVjc01hcC5nZXQoZmIucGF5bG9hZCk7XG5cblx0XHRcdGlmICghY29kZWMpXG5cdFx0XHRcdGNvbnRpbnVlO1xuXG5cdFx0XHRjb25zdCBmZWVkYmFjayA9XG5cdFx0XHR7XG5cdFx0XHRcdHR5cGUgICAgICA6IGZiLnR5cGUsXG5cdFx0XHRcdHBhcmFtZXRlciA6IGZiLnN1YnR5cGVcblx0XHRcdH07XG5cblx0XHRcdGlmICghZmVlZGJhY2sucGFyYW1ldGVyKVxuXHRcdFx0XHRkZWxldGUgZmVlZGJhY2sucGFyYW1ldGVyO1xuXG5cdFx0XHRjb2RlYy5ydGNwRmVlZGJhY2sucHVzaChmZWVkYmFjayk7XG5cdFx0fVxuXG5cdFx0Ly8gR2V0IFJUUCBoZWFkZXIgZXh0ZW5zaW9ucy5cblx0XHRmb3IgKGNvbnN0IGV4dCBvZiBtLmV4dCB8fCBbXSlcblx0XHR7XG5cdFx0XHRjb25zdCBoZWFkZXJFeHRlbnNpb24gPVxuXHRcdFx0e1xuXHRcdFx0XHRraW5kICAgICAgICA6IGtpbmQsXG5cdFx0XHRcdHVyaSAgICAgICAgIDogZXh0LnVyaSxcblx0XHRcdFx0cHJlZmVycmVkSWQgOiBleHQudmFsdWVcblx0XHRcdH07XG5cblx0XHRcdGhlYWRlckV4dGVuc2lvbnMucHVzaChoZWFkZXJFeHRlbnNpb24pO1xuXHRcdH1cblx0fVxuXG5cdGNvbnN0IHJ0cENhcGFiaWxpdGllcyA9XG5cdHtcblx0XHRjb2RlY3MgICAgICAgICAgIDogQXJyYXkuZnJvbShjb2RlY3NNYXAudmFsdWVzKCkpLFxuXHRcdGhlYWRlckV4dGVuc2lvbnMgOiBoZWFkZXJFeHRlbnNpb25zLFxuXHRcdGZlY01lY2hhbmlzbXMgICAgOiBbXSAvLyBUT0RPXG5cdH07XG5cblx0cmV0dXJuIHJ0cENhcGFiaWxpdGllcztcbn1cblxuLyoqXG4gKiBFeHRyYWN0IERUTFMgcGFyYW1ldGVycyBmcm9tIGEgU0RQLlxuICpcbiAqIEBwYXJhbSB7T2JqZWN0fSBzZHBPYmogLSBTRFAgT2JqZWN0IGdlbmVyYXRlZCBieSBzZHAtdHJhbnNmb3JtLlxuICogQHJldHVybiB7UlRDRHRsc1BhcmFtZXRlcnN9XG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBleHRyYWN0RHRsc1BhcmFtZXRlcnMoc2RwT2JqKVxue1xuXHRjb25zdCBtZWRpYSA9IGdldEZpcnN0QWN0aXZlTWVkaWFTZWN0aW9uKHNkcE9iaik7XG5cdGNvbnN0IGZpbmdlcnByaW50ID0gbWVkaWEuZmluZ2VycHJpbnQgfHwgc2RwT2JqLmZpbmdlcnByaW50O1xuXHRsZXQgcm9sZTtcblxuXHRzd2l0Y2ggKG1lZGlhLnNldHVwKVxuXHR7XG5cdFx0Y2FzZSAnYWN0aXZlJzpcblx0XHRcdHJvbGUgPSAnY2xpZW50Jztcblx0XHRcdGJyZWFrO1xuXHRcdGNhc2UgJ3Bhc3NpdmUnOlxuXHRcdFx0cm9sZSA9ICdzZXJ2ZXInO1xuXHRcdFx0YnJlYWs7XG5cdFx0Y2FzZSAnYWN0cGFzcyc6XG5cdFx0XHRyb2xlID0gJ2F1dG8nO1xuXHRcdFx0YnJlYWs7XG5cdH1cblxuXHRjb25zdCBkdGxzUGFyYW1ldGVycyA9XG5cdHtcblx0XHRyb2xlICAgICAgICAgOiByb2xlLFxuXHRcdGZpbmdlcnByaW50cyA6XG5cdFx0W1xuXHRcdFx0e1xuXHRcdFx0XHRhbGdvcml0aG0gOiBmaW5nZXJwcmludC50eXBlLFxuXHRcdFx0XHR2YWx1ZSAgICAgOiBmaW5nZXJwcmludC5oYXNoXG5cdFx0XHR9XG5cdFx0XVxuXHR9O1xuXG5cdHJldHVybiBkdGxzUGFyYW1ldGVycztcbn1cblxuLyoqXG4gKiBHZXQgdGhlIGZpcnN0IGFjaXZlIG1lZGlhIHNlY3Rpb24uXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7T2JqZWN0fSBzZHBPYmogLSBTRFAgT2JqZWN0IGdlbmVyYXRlZCBieSBzZHAtdHJhbnNmb3JtLlxuICogQHJldHVybiB7T2JqZWN0fSBTRFAgbWVkaWEgc2VjdGlvbiBhcyBwYXJzZWQgYnkgc2RwLXRyYW5zZm9ybS5cbiAqL1xuZnVuY3Rpb24gZ2V0Rmlyc3RBY3RpdmVNZWRpYVNlY3Rpb24oc2RwT2JqKVxue1xuXHRyZXR1cm4gKHNkcE9iai5tZWRpYSB8fCBbXSlcblx0XHQuZmluZCgobSkgPT4gbS5pY2VVZnJhZyAmJiBtLnBvcnQgIT09IDApO1xufVxuIiwiLyoqXG4gKiBGaWxsIHRoZSBnaXZlbiBSVFAgcGFyYW1ldGVycyBmb3IgdGhlIGdpdmVuIHRyYWNrLlxuICpcbiAqIEBwYXJhbSB7UlRDUnRwUGFyYW1ldGVyc30gcnRwUGFyYW1ldGVycyAtICBSVFAgcGFyYW1ldGVycyB0byBiZSBmaWxsZWQuXG4gKiBAcGFyYW0ge09iamVjdH0gc2RwT2JqIC0gTG9jYWwgU0RQIE9iamVjdCBnZW5lcmF0ZWQgYnkgc2RwLXRyYW5zZm9ybS5cbiAqIEBwYXJhbSB7TWVkaWFTdHJlYW1UcmFja30gdHJhY2tcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGZpbGxSdHBQYXJhbWV0ZXJzRm9yVHJhY2socnRwUGFyYW1ldGVycywgc2RwT2JqLCB0cmFjaylcbntcblx0Y29uc3Qga2luZCA9IHRyYWNrLmtpbmQ7XG5cdGNvbnN0IHJ0Y3AgPVxuXHR7XG5cdFx0Y25hbWUgICAgICAgOiBudWxsLFxuXHRcdHJlZHVjZWRTaXplIDogdHJ1ZSxcblx0XHRtdXggICAgICAgICA6IHRydWVcblx0fTtcblxuXHRjb25zdCBtU2VjdGlvbiA9IChzZHBPYmoubWVkaWEgfHwgW10pXG5cdFx0LmZpbmQoKG0pID0+IG0udHlwZSA9PT0ga2luZCk7XG5cblx0aWYgKCFtU2VjdGlvbilcblx0XHR0aHJvdyBuZXcgRXJyb3IoYG09JHtraW5kfSBzZWN0aW9uIG5vdCBmb3VuZGApO1xuXG5cdC8vIEZpcnN0IG1lZGlhIFNTUkMgKG9yIHRoZSBvbmx5IG9uZSkuXG5cdGxldCBmaXJzdFNzcmM7XG5cblx0Ly8gR2V0IGFsbCB0aGUgU1NSQ3MuXG5cblx0Y29uc3Qgc3NyY3MgPSBuZXcgU2V0KCk7XG5cblx0Zm9yIChjb25zdCBsaW5lIG9mIG1TZWN0aW9uLnNzcmNzIHx8IFtdKVxuXHR7XG5cdFx0aWYgKGxpbmUuYXR0cmlidXRlICE9PSAnbXNpZCcpXG5cdFx0XHRjb250aW51ZTtcblxuXHRcdGNvbnN0IHRyYWNrSWQgPSBsaW5lLnZhbHVlLnNwbGl0KCcgJylbMV07XG5cblx0XHRpZiAodHJhY2tJZCA9PT0gdHJhY2suaWQpXG5cdFx0e1xuXHRcdFx0Y29uc3Qgc3NyYyA9IGxpbmUuaWQ7XG5cblx0XHRcdHNzcmNzLmFkZChzc3JjKTtcblxuXHRcdFx0aWYgKCFmaXJzdFNzcmMpXG5cdFx0XHRcdGZpcnN0U3NyYyA9IHNzcmM7XG5cdFx0fVxuXHR9XG5cblx0aWYgKHNzcmNzLnNpemUgPT09IDApXG5cdFx0dGhyb3cgbmV3IEVycm9yKGBhPXNzcmMgbGluZSBub3QgZm91bmQgZm9yIGxvY2FsIHRyYWNrIFt0cmFjay5pZDoke3RyYWNrLmlkfV1gKTtcblxuXHQvLyBHZXQgbWVkaWEgYW5kIFJUWCBTU1JDcy5cblxuXHRjb25zdCBzc3JjVG9SdHhTc3JjID0gbmV3IE1hcCgpO1xuXG5cdC8vIEZpcnN0IGFzc3VtZSBSVFggaXMgdXNlZC5cblx0Zm9yIChjb25zdCBsaW5lIG9mIG1TZWN0aW9uLnNzcmNHcm91cHMgfHwgW10pXG5cdHtcblx0XHRpZiAobGluZS5zZW1hbnRpY3MgIT09ICdGSUQnKVxuXHRcdFx0Y29udGludWU7XG5cblx0XHRsZXQgWyBzc3JjLCBydHhTc3JjIF0gPSBsaW5lLnNzcmNzLnNwbGl0KC9cXHMrLyk7XG5cblx0XHRzc3JjID0gTnVtYmVyKHNzcmMpO1xuXHRcdHJ0eFNzcmMgPSBOdW1iZXIocnR4U3NyYyk7XG5cblx0XHRpZiAoc3NyY3MuaGFzKHNzcmMpKVxuXHRcdHtcblx0XHRcdC8vIFJlbW92ZSBib3RoIHRoZSBTU1JDIGFuZCBSVFggU1NSQyBmcm9tIHRoZSBTZXQgc28gbGF0ZXIgd2Uga25vdyB0aGF0IHRoZXlcblx0XHRcdC8vIGFyZSBhbHJlYWR5IGhhbmRsZWQuXG5cdFx0XHRzc3Jjcy5kZWxldGUoc3NyYyk7XG5cdFx0XHRzc3Jjcy5kZWxldGUocnR4U3NyYyk7XG5cblx0XHRcdC8vIEFkZCB0byB0aGUgbWFwLlxuXHRcdFx0c3NyY1RvUnR4U3NyYy5zZXQoc3NyYywgcnR4U3NyYyk7XG5cdFx0fVxuXHR9XG5cblx0Ly8gSWYgdGhlIFNldCBvZiBTU1JDcyBpcyBub3QgZW1wdHkgaXQgbWVhbnMgdGhhdCBSVFggaXMgbm90IGJlaW5nIHVzZWQsIHNvIHRha2Vcblx0Ly8gbWVkaWEgU1NSQ3MgZnJvbSB0aGVyZS5cblx0Zm9yIChjb25zdCBzc3JjIG9mIHNzcmNzKVxuXHR7XG5cdFx0Ly8gQWRkIHRvIHRoZSBtYXAuXG5cdFx0c3NyY1RvUnR4U3NyYy5zZXQoc3NyYywgbnVsbCk7XG5cdH1cblxuXHQvLyBHZXQgUlRDUCBpbmZvLlxuXG5cdGNvbnN0IHNzcmNDbmFtZUxpbmUgPSBtU2VjdGlvbi5zc3Jjc1xuXHRcdC5maW5kKChsaW5lKSA9PlxuXHRcdHtcblx0XHRcdHJldHVybiAobGluZS5hdHRyaWJ1dGUgPT09ICdjbmFtZScgJiYgbGluZS5pZCA9PT0gZmlyc3RTc3JjKTtcblx0XHR9KTtcblxuXHRpZiAoc3NyY0NuYW1lTGluZSlcblx0XHRydGNwLmNuYW1lID0gc3NyY0NuYW1lTGluZS52YWx1ZTtcblxuXHQvLyBGaWxsIFJUUCBwYXJhbWV0ZXJzLlxuXG5cdHJ0cFBhcmFtZXRlcnMucnRjcCA9IHJ0Y3A7XG5cdHJ0cFBhcmFtZXRlcnMuZW5jb2RpbmdzID0gW107XG5cblx0Y29uc3Qgc2ltdWxjYXN0ID0gc3NyY1RvUnR4U3NyYy5zaXplID4gMTtcblx0Y29uc3Qgc2ltdWxjYXN0UHJvZmlsZXMgPSBbICdsb3cnLCAnbWVkaXVtJywgJ2hpZ2gnIF07XG5cblx0Zm9yIChjb25zdCBbIHNzcmMsIHJ0eFNzcmMgXSBvZiBzc3JjVG9SdHhTc3JjKVxuXHR7XG5cdFx0Y29uc3QgZW5jb2RpbmcgPSB7IHNzcmMgfTtcblxuXHRcdGlmIChydHhTc3JjKVxuXHRcdFx0ZW5jb2RpbmcucnR4ID0geyBzc3JjOiBydHhTc3JjIH07XG5cblx0XHRpZiAoc2ltdWxjYXN0KVxuXHRcdFx0ZW5jb2RpbmcucHJvZmlsZSA9IHNpbXVsY2FzdFByb2ZpbGVzLnNoaWZ0KCk7XG5cblx0XHRydHBQYXJhbWV0ZXJzLmVuY29kaW5ncy5wdXNoKGVuY29kaW5nKTtcblx0fVxufVxuXG4vKipcbiAqIEFkZHMgc2ltdWxjYXN0IGludG8gdGhlIGdpdmVuIFNEUCBmb3IgdGhlIGdpdmVuIHRyYWNrLlxuICpcbiAqIEBwYXJhbSB7T2JqZWN0fSBzZHBPYmogLSBMb2NhbCBTRFAgT2JqZWN0IGdlbmVyYXRlZCBieSBzZHAtdHJhbnNmb3JtLlxuICogQHBhcmFtIHtNZWRpYVN0cmVhbVRyYWNrfSB0cmFja1xuICovXG5leHBvcnQgZnVuY3Rpb24gYWRkU2ltdWxjYXN0Rm9yVHJhY2soc2RwT2JqLCB0cmFjaylcbntcblx0Y29uc3Qga2luZCA9IHRyYWNrLmtpbmQ7XG5cblx0Y29uc3QgbVNlY3Rpb24gPSAoc2RwT2JqLm1lZGlhIHx8IFtdKVxuXHRcdC5maW5kKChtKSA9PiBtLnR5cGUgPT09IGtpbmQpO1xuXG5cdGlmICghbVNlY3Rpb24pXG5cdFx0dGhyb3cgbmV3IEVycm9yKGBtPSR7a2luZH0gc2VjdGlvbiBub3QgZm91bmRgKTtcblxuXHRsZXQgc3NyYztcblx0bGV0IHJ0eFNzcmM7XG5cdGxldCBtc2lkO1xuXG5cdC8vIEdldCB0aGUgU1NSQy5cblxuXHRjb25zdCBzc3JjTXNpZExpbmUgPSAobVNlY3Rpb24uc3NyY3MgfHwgW10pXG5cdFx0LmZpbmQoKGxpbmUpID0+XG5cdFx0e1xuXHRcdFx0aWYgKGxpbmUuYXR0cmlidXRlICE9PSAnbXNpZCcpXG5cdFx0XHRcdHJldHVybiBmYWxzZTtcblxuXHRcdFx0Y29uc3QgdHJhY2tJZCA9IGxpbmUudmFsdWUuc3BsaXQoJyAnKVsxXTtcblxuXHRcdFx0aWYgKHRyYWNrSWQgPT09IHRyYWNrLmlkKVxuXHRcdFx0e1xuXHRcdFx0XHRzc3JjID0gbGluZS5pZDtcblx0XHRcdFx0bXNpZCA9IGxpbmUudmFsdWUuc3BsaXQoJyAnKVswXTtcblxuXHRcdFx0XHRyZXR1cm4gdHJ1ZTtcblx0XHRcdH1cblx0XHR9KTtcblxuXHRpZiAoIXNzcmNNc2lkTGluZSlcblx0XHR0aHJvdyBuZXcgRXJyb3IoYGE9c3NyYyBsaW5lIG5vdCBmb3VuZCBmb3IgbG9jYWwgdHJhY2sgW3RyYWNrLmlkOiR7dHJhY2suaWR9XWApO1xuXG5cdC8vIEdldCB0aGUgU1NSQyBmb3IgUlRYLlxuXG5cdChtU2VjdGlvbi5zc3JjR3JvdXBzIHx8IFtdKVxuXHRcdC5zb21lKChsaW5lKSA9PlxuXHRcdHtcblx0XHRcdGlmIChsaW5lLnNlbWFudGljcyAhPT0gJ0ZJRCcpXG5cdFx0XHRcdHJldHVybjtcblxuXHRcdFx0Y29uc3Qgc3NyY3MgPSBsaW5lLnNzcmNzLnNwbGl0KC9cXHMrLyk7XG5cblx0XHRcdGlmIChOdW1iZXIoc3NyY3NbMF0pID09PSBzc3JjKVxuXHRcdFx0e1xuXHRcdFx0XHRydHhTc3JjID0gTnVtYmVyKHNzcmNzWzFdKTtcblxuXHRcdFx0XHRyZXR1cm4gdHJ1ZTtcblx0XHRcdH1cblx0XHR9KTtcblxuXHRjb25zdCBzc3JjQ25hbWVMaW5lID0gbVNlY3Rpb24uc3NyY3Ncblx0XHQuZmluZCgobGluZSkgPT5cblx0XHR7XG5cdFx0XHRyZXR1cm4gKGxpbmUuYXR0cmlidXRlID09PSAnY25hbWUnICYmIGxpbmUuaWQgPT09IHNzcmMpO1xuXHRcdH0pO1xuXG5cdGlmICghc3NyY0NuYW1lTGluZSlcblx0XHR0aHJvdyBuZXcgRXJyb3IoYENOQU1FIGxpbmUgbm90IGZvdW5kIGZvciBsb2NhbCB0cmFjayBbdHJhY2suaWQ6JHt0cmFjay5pZH1dYCk7XG5cblx0Y29uc3QgY25hbWUgPSBzc3JjQ25hbWVMaW5lLnZhbHVlO1xuXHRjb25zdCBzc3JjMiA9IHNzcmMgKyAxO1xuXHRjb25zdCBzc3JjMyA9IHNzcmMgKyAyO1xuXG5cdG1TZWN0aW9uLnNzcmNHcm91cHMgPSBtU2VjdGlvbi5zc3JjR3JvdXBzIHx8IFtdO1xuXG5cdG1TZWN0aW9uLnNzcmNHcm91cHMucHVzaChcblx0XHR7XG5cdFx0XHRzZW1hbnRpY3MgOiAnU0lNJyxcblx0XHRcdHNzcmNzICAgICA6IGAke3NzcmN9ICR7c3NyYzJ9ICR7c3NyYzN9YFxuXHRcdH0pO1xuXG5cdG1TZWN0aW9uLnNzcmNzLnB1c2goXG5cdFx0e1xuXHRcdFx0aWQgICAgICAgIDogc3NyYzIsXG5cdFx0XHRhdHRyaWJ1dGUgOiAnY25hbWUnLFxuXHRcdFx0dmFsdWUgICAgIDogY25hbWVcblx0XHR9KTtcblxuXHRtU2VjdGlvbi5zc3Jjcy5wdXNoKFxuXHRcdHtcblx0XHRcdGlkICAgICAgICA6IHNzcmMyLFxuXHRcdFx0YXR0cmlidXRlIDogJ21zaWQnLFxuXHRcdFx0dmFsdWUgICAgIDogYCR7bXNpZH0gJHt0cmFjay5pZH1gXG5cdFx0fSk7XG5cblx0bVNlY3Rpb24uc3NyY3MucHVzaChcblx0XHR7XG5cdFx0XHRpZCAgICAgICAgOiBzc3JjMyxcblx0XHRcdGF0dHJpYnV0ZSA6ICdjbmFtZScsXG5cdFx0XHR2YWx1ZSAgICAgOiBjbmFtZVxuXHRcdH0pO1xuXG5cdG1TZWN0aW9uLnNzcmNzLnB1c2goXG5cdFx0e1xuXHRcdFx0aWQgICAgICAgIDogc3NyYzMsXG5cdFx0XHRhdHRyaWJ1dGUgOiAnbXNpZCcsXG5cdFx0XHR2YWx1ZSAgICAgOiBgJHttc2lkfSAke3RyYWNrLmlkfWBcblx0XHR9KTtcblxuXHRpZiAocnR4U3NyYylcblx0e1xuXHRcdGNvbnN0IHJ0eFNzcmMyID0gcnR4U3NyYyArIDE7XG5cdFx0Y29uc3QgcnR4U3NyYzMgPSBydHhTc3JjICsgMjtcblxuXHRcdG1TZWN0aW9uLnNzcmNHcm91cHMucHVzaChcblx0XHRcdHtcblx0XHRcdFx0c2VtYW50aWNzIDogJ0ZJRCcsXG5cdFx0XHRcdHNzcmNzICAgICA6IGAke3NzcmMyfSAke3J0eFNzcmMyfWBcblx0XHRcdH0pO1xuXG5cdFx0bVNlY3Rpb24uc3NyY3MucHVzaChcblx0XHRcdHtcblx0XHRcdFx0aWQgICAgICAgIDogcnR4U3NyYzIsXG5cdFx0XHRcdGF0dHJpYnV0ZSA6ICdjbmFtZScsXG5cdFx0XHRcdHZhbHVlICAgICA6IGNuYW1lXG5cdFx0XHR9KTtcblxuXHRcdG1TZWN0aW9uLnNzcmNzLnB1c2goXG5cdFx0XHR7XG5cdFx0XHRcdGlkICAgICAgICA6IHJ0eFNzcmMyLFxuXHRcdFx0XHRhdHRyaWJ1dGUgOiAnbXNpZCcsXG5cdFx0XHRcdHZhbHVlICAgICA6IGAke21zaWR9ICR7dHJhY2suaWR9YFxuXHRcdFx0fSk7XG5cblx0XHRtU2VjdGlvbi5zc3JjR3JvdXBzLnB1c2goXG5cdFx0XHR7XG5cdFx0XHRcdHNlbWFudGljcyA6ICdGSUQnLFxuXHRcdFx0XHRzc3JjcyAgICAgOiBgJHtzc3JjM30gJHtydHhTc3JjM31gXG5cdFx0XHR9KTtcblxuXHRcdG1TZWN0aW9uLnNzcmNzLnB1c2goXG5cdFx0XHR7XG5cdFx0XHRcdGlkICAgICAgICA6IHJ0eFNzcmMzLFxuXHRcdFx0XHRhdHRyaWJ1dGUgOiAnY25hbWUnLFxuXHRcdFx0XHR2YWx1ZSAgICAgOiBjbmFtZVxuXHRcdFx0fSk7XG5cblx0XHRtU2VjdGlvbi5zc3Jjcy5wdXNoKFxuXHRcdFx0e1xuXHRcdFx0XHRpZCAgICAgICAgOiBydHhTc3JjMyxcblx0XHRcdFx0YXR0cmlidXRlIDogJ21zaWQnLFxuXHRcdFx0XHR2YWx1ZSAgICAgOiBgJHttc2lkfSAke3RyYWNrLmlkfWBcblx0XHRcdH0pO1xuXHR9XG59XG4iLCIvKipcbiAqIEZpbGwgdGhlIGdpdmVuIFJUUCBwYXJhbWV0ZXJzIGZvciB0aGUgZ2l2ZW4gdHJhY2suXG4gKlxuICogQHBhcmFtIHtSVENSdHBQYXJhbWV0ZXJzfSBydHBQYXJhbWV0ZXJzIC0gIFJUUCBwYXJhbWV0ZXJzIHRvIGJlIGZpbGxlZC5cbiAqIEBwYXJhbSB7T2JqZWN0fSBzZHBPYmogLSBMb2NhbCBTRFAgT2JqZWN0IGdlbmVyYXRlZCBieSBzZHAtdHJhbnNmb3JtLlxuICogQHBhcmFtIHtNZWRpYVN0cmVhbVRyYWNrfSB0cmFja1xuICovXG5leHBvcnQgZnVuY3Rpb24gZmlsbFJ0cFBhcmFtZXRlcnNGb3JUcmFjayhydHBQYXJhbWV0ZXJzLCBzZHBPYmosIHRyYWNrKVxue1xuXHRjb25zdCBraW5kID0gdHJhY2sua2luZDtcblx0Y29uc3QgcnRjcCA9XG5cdHtcblx0XHRjbmFtZSAgICAgICA6IG51bGwsXG5cdFx0cmVkdWNlZFNpemUgOiB0cnVlLFxuXHRcdG11eCAgICAgICAgIDogdHJ1ZVxuXHR9O1xuXG5cdGNvbnN0IG1TZWN0aW9uID0gKHNkcE9iai5tZWRpYSB8fCBbXSlcblx0XHQuZmluZCgobSkgPT5cblx0XHR7XG5cdFx0XHRpZiAobS50eXBlICE9PSBraW5kKVxuXHRcdFx0XHRyZXR1cm47XG5cblx0XHRcdGNvbnN0IG1zaWRMaW5lID0gbS5tc2lkO1xuXG5cdFx0XHRpZiAoIW1zaWRMaW5lKVxuXHRcdFx0XHRyZXR1cm47XG5cblx0XHRcdGNvbnN0IHRyYWNrSWQgPSBtc2lkTGluZS5zcGxpdCgnICcpWzFdO1xuXG5cdFx0XHRpZiAodHJhY2tJZCA9PT0gdHJhY2suaWQpXG5cdFx0XHRcdHJldHVybiB0cnVlO1xuXHRcdH0pO1xuXG5cdGlmICghbVNlY3Rpb24pXG5cdFx0dGhyb3cgbmV3IEVycm9yKGBtPSR7a2luZH0gc2VjdGlvbiBub3QgZm91bmRgKTtcblxuXHQvLyBHZXQgdGhlIFNTUkMgYW5kIENOQU1FLlxuXG5cdGNvbnN0IHNzcmNDbmFtZUxpbmUgPSAobVNlY3Rpb24uc3NyY3MgfHwgW10pXG5cdFx0LmZpbmQoKGxpbmUpID0+IGxpbmUuYXR0cmlidXRlID09PSAnY25hbWUnKTtcblxuXHRsZXQgc3NyYztcblxuXHRpZiAoc3NyY0NuYW1lTGluZSlcblx0e1xuXHRcdHNzcmMgPSBzc3JjQ25hbWVMaW5lLmlkO1xuXHRcdHJ0Y3AuY25hbWUgPSBzc3JjQ25hbWVMaW5lLnZhbHVlO1xuXHR9XG5cblx0Ly8gR2V0IGE9cmlkIGxpbmVzLlxuXG5cdC8vIEFycmF5IG9mIE9iamVjdHMgd2l0aCByaWQgYW5kIHByb2ZpbGUga2V5cy5cblx0Y29uc3Qgc2ltdWxjYXN0U3RyZWFtcyA9IFtdO1xuXG5cdGZvciAoY29uc3QgcmlkIG9mIG1TZWN0aW9uLnJpZHMgfHwgW10pXG5cdHtcblx0XHRpZiAocmlkLmRpcmVjdGlvbiAhPT0gJ3NlbmQnKVxuXHRcdFx0Y29udGludWU7XG5cblx0XHRpZiAoL15sb3cvLnRlc3QocmlkLmlkKSlcblx0XHRcdHNpbXVsY2FzdFN0cmVhbXMucHVzaCh7IHJpZDogcmlkLmlkLCBwcm9maWxlOiAnbG93JyB9KTtcblx0XHRlbHNlIGlmICgvXm1lZGl1bS8udGVzdChyaWQuaWQpKVxuXHRcdFx0c2ltdWxjYXN0U3RyZWFtcy5wdXNoKHsgcmlkOiByaWQuaWQsIHByb2ZpbGU6ICdtZWRpdW0nIH0pO1xuXHRcdGlmICgvXmhpZ2gvLnRlc3QocmlkLmlkKSlcblx0XHRcdHNpbXVsY2FzdFN0cmVhbXMucHVzaCh7IHJpZDogcmlkLmlkLCBwcm9maWxlOiAnaGlnaCcgfSk7XG5cdH1cblxuXHQvLyBGaWxsIFJUUCBwYXJhbWV0ZXJzLlxuXG5cdHJ0cFBhcmFtZXRlcnMucnRjcCA9IHJ0Y3A7XG5cdHJ0cFBhcmFtZXRlcnMuZW5jb2RpbmdzID0gW107XG5cblx0aWYgKHNpbXVsY2FzdFN0cmVhbXMubGVuZ3RoID09PSAwKVxuXHR7XG5cdFx0Y29uc3QgZW5jb2RpbmcgPSB7IHNzcmMgfTtcblxuXHRcdHJ0cFBhcmFtZXRlcnMuZW5jb2RpbmdzLnB1c2goZW5jb2RpbmcpO1xuXHR9XG5cdGVsc2Vcblx0e1xuXHRcdGZvciAoY29uc3Qgc2ltdWxjYXN0U3RyZWFtIG9mIHNpbXVsY2FzdFN0cmVhbXMpXG5cdFx0e1xuXHRcdFx0Y29uc3QgZW5jb2RpbmcgPVxuXHRcdFx0e1xuXHRcdFx0XHRlbmNvZGluZ0lkIDogc2ltdWxjYXN0U3RyZWFtLnJpZCxcblx0XHRcdFx0cHJvZmlsZSAgICA6IHNpbXVsY2FzdFN0cmVhbS5wcm9maWxlXG5cdFx0XHR9O1xuXG5cdFx0XHRydHBQYXJhbWV0ZXJzLmVuY29kaW5ncy5wdXNoKGVuY29kaW5nKTtcblx0XHR9XG5cdH1cbn1cbiIsImltcG9ydCAqIGFzIG9ydGMgZnJvbSAnLi9vcnRjJztcbmltcG9ydCBEZXZpY2UgZnJvbSAnLi9EZXZpY2UnO1xuaW1wb3J0IFJvb20gZnJvbSAnLi9Sb29tJztcblxuLyoqXG4gKiBXaGV0aGVyIHRoZSBjdXJyZW50IGJyb3dzZXIgb3IgZGV2aWNlIGlzIHN1cHBvcnRlZC5cbiAqXG4gKiBAcmV0dXJuIHtCb29sZWFufVxuICpcbiAqIEBleGFtcGxlXG4gKiBpc0RldmljZVN1cHBvcnRlZCgpXG4gKiAvLyA9PiB0cnVlXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBpc0RldmljZVN1cHBvcnRlZCgpXG57XG5cdHJldHVybiBEZXZpY2UuaXNTdXBwb3J0ZWQoKTtcbn1cblxuLyoqXG4gKiBHZXQgaW5mb3JtYXRpb24gcmVnYXJkaW5nIHRoZSBjdXJyZW50IGJyb3dzZXIgb3IgZGV2aWNlLlxuICpcbiAqIEByZXR1cm4ge09iamVjdH0gLSBPYmplY3Qgd2l0aCBgbmFtZWAgKFN0cmluZykgYW5kIHZlcnNpb24ge1N0cmluZ30uXG4gKlxuICogQGV4YW1wbGVcbiAqIGdldERldmljZUluZm8oKVxuICogLy8gPT4geyBmbGFnOiAnY2hyb21lJywgbmFtZTogJ0Nocm9tZScsIHZlcnNpb246ICc1OS4wJywgYm93c2VyOiB7fSB9XG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBnZXREZXZpY2VJbmZvKClcbntcblx0cmV0dXJuIHtcblx0XHRmbGFnICAgIDogRGV2aWNlLmdldEZsYWcoKSxcblx0XHRuYW1lICAgIDogRGV2aWNlLmdldE5hbWUoKSxcblx0XHR2ZXJzaW9uIDogRGV2aWNlLmdldFZlcnNpb24oKSxcblx0XHRib3dzZXIgIDogRGV2aWNlLmdldEJvd3NlcigpXG5cdH07XG59XG5cbi8qKlxuICogQ2hlY2sgd2hldGhlciB0aGlzIGRldmljZS9icm93c2VyIGNhbiBzZW5kL3JlY2VpdmUgYXVkaW8vdmlkZW8gaW4gYSByb29tXG4gKiB3aG9zZSBSVFAgY2FwYWJpbGl0aWVzIGFyZSBnaXZlbi5cbiAqXG4gKiBAcGFyYW0ge09iamVjdH0gUm9vbSBSVFAgY2FwYWJpbGl0aWVzLlxuICpcbiAqIEByZXR1cm4ge1Byb21pc2V9IFJlc29sdmVzIHRvIGFuIE9iamVjdCB3aXRoICdhdWRpbycgYW5kICd2aWRlbycgQm9vbGVhbnMuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBjaGVja0NhcGFiaWxpdGllc0ZvclJvb20ocm9vbVJ0cENhcGFiaWxpdGllcylcbntcblx0aWYgKCFEZXZpY2UuaXNTdXBwb3J0ZWQoKSlcblx0XHRyZXR1cm4gUHJvbWlzZS5yZWplY3QobmV3IEVycm9yKCdjdXJyZW50IGJyb3dzZXIvZGV2aWNlIG5vdCBzdXBwb3J0ZWQnKSk7XG5cblx0cmV0dXJuIERldmljZS5IYW5kbGVyLmdldE5hdGl2ZVJ0cENhcGFiaWxpdGllcygpXG5cdFx0LnRoZW4oKG5hdGl2ZVJ0cENhcGFiaWxpdGllcykgPT5cblx0XHR7XG5cdFx0XHRjb25zdCBleHRlbmRlZFJ0cENhcGFiaWxpdGllcyA9IG9ydGMuZ2V0RXh0ZW5kZWRSdHBDYXBhYmlsaXRpZXMoXG5cdFx0XHRcdG5hdGl2ZVJ0cENhcGFiaWxpdGllcywgcm9vbVJ0cENhcGFiaWxpdGllcyk7XG5cblx0XHRcdHJldHVybiB7XG5cdFx0XHRcdGF1ZGlvIDogb3J0Yy5jYW5TZW5kKCdhdWRpbycsIGV4dGVuZGVkUnRwQ2FwYWJpbGl0aWVzKSxcblx0XHRcdFx0dmlkZW8gOiBvcnRjLmNhblNlbmQoJ3ZpZGVvJywgZXh0ZW5kZWRSdHBDYXBhYmlsaXRpZXMpXG5cdFx0XHR9O1xuXHRcdH0pO1xufVxuXG4vKipcbiAqIEV4cG9zZSB0aGUgUm9vbSBjbGFzcy5cbiAqXG4gKiBAZXhhbXBsZVxuICogY29uc3Qgcm9vbSA9IG5ldyBSb29tKCk7YFxuICovXG5leHBvcnQgeyBSb29tIH07XG4iLCIvKipcbiAqIEdlbmVyYXRlIGV4dGVuZGVkIFJUUCBjYXBhYmlsaXRpZXMgZm9yIHNlbmRpbmcgYW5kIHJlY2VpdmluZy5cbiAqXG4gKiBAcGFyYW0ge1JUQ1J0cENhcGFiaWxpdGllc30gbG9jYWxDYXBzIC0gTG9jYWwgY2FwYWJpbGl0aWVzLlxuICogQHBhcmFtIHtSVENSdHBDYXBhYmlsaXRpZXN9IHJlbW90ZUNhcHMgLSBSZW1vdGUgY2FwYWJpbGl0aWVzLlxuICpcbiAqIEByZXR1cm4ge1JUQ0V4dGVuZGVkUnRwQ2FwYWJpbGl0aWVzfVxuICovXG5leHBvcnQgZnVuY3Rpb24gZ2V0RXh0ZW5kZWRSdHBDYXBhYmlsaXRpZXMobG9jYWxDYXBzLCByZW1vdGVDYXBzKVxue1xuXHRjb25zdCBleHRlbmRlZENhcHMgPVxuXHR7XG5cdFx0Y29kZWNzICAgICAgICAgICA6IFtdLFxuXHRcdGhlYWRlckV4dGVuc2lvbnMgOiBbXSxcblx0XHRmZWNNZWNoYW5pc21zICAgIDogW11cblx0fTtcblxuXHQvLyBNYXRjaCBtZWRpYSBjb2RlY3MgYW5kIGtlZXAgdGhlIG9yZGVyIHByZWZlcnJlZCBieSByZW1vdGVDYXBzLlxuXHRmb3IgKGNvbnN0IHJlbW90ZUNvZGVjIG9mIHJlbW90ZUNhcHMuY29kZWNzIHx8IFtdKVxuXHR7XG5cdFx0Ly8gVE9ETzogSWdub3JlIHBzZXVkby1jb2RlY3MgYW5kIGZlYXR1cmUgY29kZWNzLlxuXHRcdGlmIChyZW1vdGVDb2RlYy5uYW1lID09PSAncnR4Jylcblx0XHRcdGNvbnRpbnVlO1xuXG5cdFx0Y29uc3QgbWF0Y2hpbmdMb2NhbENvZGVjID0gKGxvY2FsQ2Fwcy5jb2RlY3MgfHwgW10pXG5cdFx0XHQuZmluZCgobG9jYWxDb2RlYykgPT4gbWF0Y2hDYXBDb2RlY3MobG9jYWxDb2RlYywgcmVtb3RlQ29kZWMpKTtcblxuXHRcdGlmIChtYXRjaGluZ0xvY2FsQ29kZWMpXG5cdFx0e1xuXHRcdFx0Y29uc3QgZXh0ZW5kZWRDb2RlYyA9XG5cdFx0XHR7XG5cdFx0XHRcdG5hbWUgICAgICAgICAgICAgICA6IHJlbW90ZUNvZGVjLm5hbWUsXG5cdFx0XHRcdG1pbWVUeXBlICAgICAgICAgICA6IHJlbW90ZUNvZGVjLm1pbWVUeXBlLFxuXHRcdFx0XHRraW5kICAgICAgICAgICAgICAgOiByZW1vdGVDb2RlYy5raW5kLFxuXHRcdFx0XHRjbG9ja1JhdGUgICAgICAgICAgOiByZW1vdGVDb2RlYy5jbG9ja1JhdGUsXG5cdFx0XHRcdHNlbmRQYXlsb2FkVHlwZSAgICA6IG1hdGNoaW5nTG9jYWxDb2RlYy5wcmVmZXJyZWRQYXlsb2FkVHlwZSxcblx0XHRcdFx0c2VuZFJ0eFBheWxvYWRUeXBlIDogbnVsbCxcblx0XHRcdFx0cmVjdlBheWxvYWRUeXBlICAgIDogcmVtb3RlQ29kZWMucHJlZmVycmVkUGF5bG9hZFR5cGUsXG5cdFx0XHRcdHJlY3ZSdHhQYXlsb2FkVHlwZSA6IG51bGwsXG5cdFx0XHRcdGNoYW5uZWxzICAgICAgICAgICA6IHJlbW90ZUNvZGVjLmNoYW5uZWxzLFxuXHRcdFx0XHRydGNwRmVlZGJhY2sgICAgICAgOiByZWR1Y2VSdGNwRmVlZGJhY2sobWF0Y2hpbmdMb2NhbENvZGVjLCByZW1vdGVDb2RlYyksXG5cdFx0XHRcdHBhcmFtZXRlcnMgICAgICAgICA6IHJlbW90ZUNvZGVjLnBhcmFtZXRlcnNcblx0XHRcdH07XG5cblx0XHRcdGlmICghZXh0ZW5kZWRDb2RlYy5jaGFubmVscylcblx0XHRcdFx0ZGVsZXRlIGV4dGVuZGVkQ29kZWMuY2hhbm5lbHM7XG5cblx0XHRcdGV4dGVuZGVkQ2Fwcy5jb2RlY3MucHVzaChleHRlbmRlZENvZGVjKTtcblx0XHR9XG5cdH1cblxuXHQvLyBNYXRjaCBSVFggY29kZWNzLlxuXHRmb3IgKGNvbnN0IGV4dGVuZGVkQ29kZWMgb2YgZXh0ZW5kZWRDYXBzLmNvZGVjcyB8fCBbXSlcblx0e1xuXHRcdGNvbnN0IG1hdGNoaW5nTG9jYWxSdHhDb2RlYyA9IChsb2NhbENhcHMuY29kZWNzIHx8IFtdKVxuXHRcdFx0LmZpbmQoKGxvY2FsQ29kZWMpID0+XG5cdFx0XHR7XG5cdFx0XHRcdHJldHVybiAoXG5cdFx0XHRcdFx0bG9jYWxDb2RlYy5uYW1lID09PSAncnR4JyAmJlxuXHRcdFx0XHRcdGxvY2FsQ29kZWMucGFyYW1ldGVycy5hcHQgPT09IGV4dGVuZGVkQ29kZWMuc2VuZFBheWxvYWRUeXBlXG5cdFx0XHRcdCk7XG5cdFx0XHR9KTtcblxuXHRcdGNvbnN0IG1hdGNoaW5nUmVtb3RlUnR4Q29kZWMgPSAocmVtb3RlQ2Fwcy5jb2RlY3MgfHwgW10pXG5cdFx0XHQuZmluZCgocmVtb3RlQ29kZWMpID0+XG5cdFx0XHR7XG5cdFx0XHRcdHJldHVybiAoXG5cdFx0XHRcdFx0cmVtb3RlQ29kZWMubmFtZSA9PT0gJ3J0eCcgJiZcblx0XHRcdFx0XHRyZW1vdGVDb2RlYy5wYXJhbWV0ZXJzLmFwdCA9PT0gZXh0ZW5kZWRDb2RlYy5yZWN2UGF5bG9hZFR5cGVcblx0XHRcdFx0KTtcblx0XHRcdH0pO1xuXG5cdFx0aWYgKG1hdGNoaW5nTG9jYWxSdHhDb2RlYyAmJiBtYXRjaGluZ1JlbW90ZVJ0eENvZGVjKVxuXHRcdHtcblx0XHRcdGV4dGVuZGVkQ29kZWMuc2VuZFJ0eFBheWxvYWRUeXBlID0gbWF0Y2hpbmdMb2NhbFJ0eENvZGVjLnByZWZlcnJlZFBheWxvYWRUeXBlO1xuXHRcdFx0ZXh0ZW5kZWRDb2RlYy5yZWN2UnR4UGF5bG9hZFR5cGUgPSBtYXRjaGluZ1JlbW90ZVJ0eENvZGVjLnByZWZlcnJlZFBheWxvYWRUeXBlO1xuXHRcdH1cblx0fVxuXG5cdC8vIE1hdGNoIGhlYWRlciBleHRlbnNpb25zLlxuXHRmb3IgKGNvbnN0IHJlbW90ZUV4dCBvZiByZW1vdGVDYXBzLmhlYWRlckV4dGVuc2lvbnMgfHwgW10pXG5cdHtcblx0XHRjb25zdCBtYXRjaGluZ0xvY2FsRXh0ID0gKGxvY2FsQ2Fwcy5oZWFkZXJFeHRlbnNpb25zIHx8IFtdKVxuXHRcdFx0LmZpbmQoKGxvY2FsRXh0KSA9PiBtYXRjaENhcEhlYWRlckV4dGVuc2lvbnMobG9jYWxFeHQsIHJlbW90ZUV4dCkpO1xuXG5cdFx0aWYgKG1hdGNoaW5nTG9jYWxFeHQpXG5cdFx0e1xuXHRcdFx0Y29uc3QgZXh0ZW5kZWRFeHQgPVxuXHRcdFx0e1xuXHRcdFx0XHRraW5kICAgOiByZW1vdGVFeHQua2luZCxcblx0XHRcdFx0dXJpICAgIDogcmVtb3RlRXh0LnVyaSxcblx0XHRcdFx0c2VuZElkIDogbWF0Y2hpbmdMb2NhbEV4dC5wcmVmZXJyZWRJZCxcblx0XHRcdFx0cmVjdklkIDogcmVtb3RlRXh0LnByZWZlcnJlZElkXG5cdFx0XHR9O1xuXG5cdFx0XHRleHRlbmRlZENhcHMuaGVhZGVyRXh0ZW5zaW9ucy5wdXNoKGV4dGVuZGVkRXh0KTtcblx0XHR9XG5cdH1cblxuXHRyZXR1cm4gZXh0ZW5kZWRDYXBzO1xufVxuXG4vKipcbiAqIEdlbmVyYXRlIFJUUCBjYXBhYmlsaXRpZXMgZm9yIHJlY2VpdmluZyBtZWRpYSBiYXNlZCBvbiB0aGUgZ2l2ZW4gZXh0ZW5kZWRcbiAqIFJUUCBjYXBhYmlsaXRpZXMuXG4gKlxuICogQHBhcmFtIHtSVENFeHRlbmRlZFJ0cENhcGFiaWxpdGllc30gZXh0ZW5kZWRSdHBDYXBhYmlsaXRpZXNcbiAqXG4gKiBAcmV0dXJuIHtSVENSdHBDYXBhYmlsaXRpZXN9XG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBnZXRSdHBDYXBhYmlsaXRpZXMoZXh0ZW5kZWRSdHBDYXBhYmlsaXRpZXMpXG57XG5cdGNvbnN0IGNhcHMgPVxuXHR7XG5cdFx0Y29kZWNzICAgICAgICAgICA6IFtdLFxuXHRcdGhlYWRlckV4dGVuc2lvbnMgOiBbXSxcblx0XHRmZWNNZWNoYW5pc21zICAgIDogW11cblx0fTtcblxuXHRmb3IgKGNvbnN0IGNhcENvZGVjIG9mIGV4dGVuZGVkUnRwQ2FwYWJpbGl0aWVzLmNvZGVjcylcblx0e1xuXHRcdGNvbnN0IGNvZGVjID1cblx0XHR7XG5cdFx0XHRuYW1lICAgICAgICAgICAgICAgICA6IGNhcENvZGVjLm5hbWUsXG5cdFx0XHRtaW1lVHlwZSAgICAgICAgICAgICA6IGNhcENvZGVjLm1pbWVUeXBlLFxuXHRcdFx0a2luZCAgICAgICAgICAgICAgICAgOiBjYXBDb2RlYy5raW5kLFxuXHRcdFx0Y2xvY2tSYXRlICAgICAgICAgICAgOiBjYXBDb2RlYy5jbG9ja1JhdGUsXG5cdFx0XHRwcmVmZXJyZWRQYXlsb2FkVHlwZSA6IGNhcENvZGVjLnJlY3ZQYXlsb2FkVHlwZSxcblx0XHRcdGNoYW5uZWxzICAgICAgICAgICAgIDogY2FwQ29kZWMuY2hhbm5lbHMsXG5cdFx0XHRydGNwRmVlZGJhY2sgICAgICAgICA6IGNhcENvZGVjLnJ0Y3BGZWVkYmFjayxcblx0XHRcdHBhcmFtZXRlcnMgICAgICAgICAgIDogY2FwQ29kZWMucGFyYW1ldGVyc1xuXHRcdH07XG5cblx0XHRpZiAoIWNvZGVjLmNoYW5uZWxzKVxuXHRcdFx0ZGVsZXRlIGNvZGVjLmNoYW5uZWxzO1xuXG5cdFx0Y2Fwcy5jb2RlY3MucHVzaChjb2RlYyk7XG5cblx0XHQvLyBBZGQgUlRYIGNvZGVjLlxuXHRcdGlmIChjYXBDb2RlYy5yZWN2UnR4UGF5bG9hZFR5cGUpXG5cdFx0e1xuXHRcdFx0Y29uc3QgcnR4Q2FwQ29kZWMgPVxuXHRcdFx0e1xuXHRcdFx0XHRuYW1lICAgICAgICAgICAgICAgICA6ICdydHgnLFxuXHRcdFx0XHRtaW1lVHlwZSAgICAgICAgICAgICA6IGAke2NhcENvZGVjLmtpbmR9L3J0eGAsXG5cdFx0XHRcdGtpbmQgICAgICAgICAgICAgICAgIDogY2FwQ29kZWMua2luZCxcblx0XHRcdFx0Y2xvY2tSYXRlICAgICAgICAgICAgOiBjYXBDb2RlYy5jbG9ja1JhdGUsXG5cdFx0XHRcdHByZWZlcnJlZFBheWxvYWRUeXBlIDogY2FwQ29kZWMucmVjdlJ0eFBheWxvYWRUeXBlLFxuXHRcdFx0XHRwYXJhbWV0ZXJzICAgICAgICAgICA6XG5cdFx0XHRcdHtcblx0XHRcdFx0XHRhcHQgOiBjYXBDb2RlYy5yZWN2UGF5bG9hZFR5cGVcblx0XHRcdFx0fVxuXHRcdFx0fTtcblxuXHRcdFx0Y2Fwcy5jb2RlY3MucHVzaChydHhDYXBDb2RlYyk7XG5cdFx0fVxuXG5cdFx0Ly8gVE9ETzogSW4gdGhlIGZ1dHVyZSwgd2UgbmVlZCB0byBhZGQgRkVDLCBDTiwgZXRjLCBjb2RlY3MuXG5cdH1cblxuXHRmb3IgKGNvbnN0IGNhcEV4dCBvZiBleHRlbmRlZFJ0cENhcGFiaWxpdGllcy5oZWFkZXJFeHRlbnNpb25zKVxuXHR7XG5cdFx0Y29uc3QgZXh0ID1cblx0XHR7XG5cdFx0XHRraW5kICAgICAgICA6IGNhcEV4dC5raW5kLFxuXHRcdFx0dXJpICAgICAgICAgOiBjYXBFeHQudXJpLFxuXHRcdFx0cHJlZmVycmVkSWQgOiBjYXBFeHQucmVjdklkXG5cdFx0fTtcblxuXHRcdGNhcHMuaGVhZGVyRXh0ZW5zaW9ucy5wdXNoKGV4dCk7XG5cdH1cblxuXHRjYXBzLmZlY01lY2hhbmlzbXMgPSBleHRlbmRlZFJ0cENhcGFiaWxpdGllcy5mZWNNZWNoYW5pc21zO1xuXG5cdHJldHVybiBjYXBzO1xufVxuXG4vKipcbiAqIEdldCB1bnN1cHBvcnRlZCByZW1vdGUgY29kZWNzLlxuICpcbiAqIEBwYXJhbSB7UlRDUnRwQ2FwYWJpbGl0aWVzfSByZW1vdGVDYXBzIC0gUmVtb3RlIGNhcGFiaWxpdGllcy5cbiAqIEBwYXJhbSB7QXJyYXk8TnVtYmVyPn0gbWFuZGF0b3J5Q29kZWNQYXlsb2FkVHlwZXMgLSBMaXN0IG9mIGNvZGVjIFBUIHZhbHVlcy5cbiAqIEBwYXJhbSB7UlRDRXh0ZW5kZWRSdHBDYXBhYmlsaXRpZXN9IGV4dGVuZGVkUnRwQ2FwYWJpbGl0aWVzXG4gKlxuICogQHJldHVybiB7Qm9vbGVhbn1cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGdldFVuc3VwcG9ydGVkQ29kZWNzKFxuXHRyZW1vdGVDYXBzLCBtYW5kYXRvcnlDb2RlY1BheWxvYWRUeXBlcywgZXh0ZW5kZWRSdHBDYXBhYmlsaXRpZXMpXG57XG5cdC8vIElmIG5vdCBnaXZlbiBqdXN0IGlnbm9yZS5cblx0aWYgKCFBcnJheS5pc0FycmF5KG1hbmRhdG9yeUNvZGVjUGF5bG9hZFR5cGVzKSlcblx0XHRyZXR1cm4gW107XG5cblx0Y29uc3QgdW5zdXBwb3J0ZWRDb2RlY3MgPSBbXTtcblx0Y29uc3QgcmVtb3RlQ29kZWNzID0gcmVtb3RlQ2Fwcy5jb2RlY3M7XG5cdGNvbnN0IHN1cHBvcnRlZENvZGVjcyA9IGV4dGVuZGVkUnRwQ2FwYWJpbGl0aWVzLmNvZGVjcztcblxuXHRmb3IgKGNvbnN0IHB0IG9mIG1hbmRhdG9yeUNvZGVjUGF5bG9hZFR5cGVzKVxuXHR7XG5cdFx0aWYgKCFzdXBwb3J0ZWRDb2RlY3Muc29tZSgoY29kZWMpID0+IGNvZGVjLnJlY3ZQYXlsb2FkVHlwZSA9PT0gcHQpKVxuXHRcdHtcblx0XHRcdGNvbnN0IHVuc3VwcG9ydGVkQ29kZWMgPSByZW1vdGVDb2RlY3Ncblx0XHRcdFx0LmZpbmQoKGNvZGVjKSA9PiBjb2RlYy5wcmVmZXJyZWRQYXlsb2FkVHlwZSA9PT0gcHQpO1xuXG5cdFx0XHRpZiAoIXVuc3VwcG9ydGVkQ29kZWMpXG5cdFx0XHRcdHRocm93IG5ldyBFcnJvcihgbWFuZGF0b3J5IGNvZGVjIFBUICR7cHR9IG5vdCBmb3VuZCBpbiByZW1vdGUgY29kZWNzYCk7XG5cblx0XHRcdHVuc3VwcG9ydGVkQ29kZWNzLnB1c2godW5zdXBwb3J0ZWRDb2RlYyk7XG5cdFx0fVxuXHR9XG5cblx0cmV0dXJuIHVuc3VwcG9ydGVkQ29kZWNzO1xufVxuXG4vKipcbiAqIFdoZXRoZXIgbWVkaWEgY2FuIGJlIHNlbnQgYmFzZWQgb24gdGhlIGdpdmVuIFJUUCBjYXBhYmlsaXRpZXMuXG4gKlxuICogQHBhcmFtIHtTdHJpbmd9IGtpbmRcbiAqIEBwYXJhbSB7UlRDRXh0ZW5kZWRSdHBDYXBhYmlsaXRpZXN9IGV4dGVuZGVkUnRwQ2FwYWJpbGl0aWVzXG4gKlxuICogQHJldHVybiB7Qm9vbGVhbn1cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGNhblNlbmQoa2luZCwgZXh0ZW5kZWRSdHBDYXBhYmlsaXRpZXMpXG57XG5cdHJldHVybiBleHRlbmRlZFJ0cENhcGFiaWxpdGllcy5jb2RlY3MuXG5cdFx0c29tZSgoY29kZWMpID0+IGNvZGVjLmtpbmQgPT09IGtpbmQpO1xufVxuXG4vKipcbiAqIFdoZXRoZXIgdGhlIGdpdmVuIFJUUCBwYXJhbWV0ZXJzIGNhbiBiZSByZWNlaXZlZCB3aXRoIHRoZSBnaXZlbiBSVFBcbiAqIGNhcGFiaWxpdGllcy5cbiAqXG4gKiBAcGFyYW0ge1JUQ1J0cFBhcmFtZXRlcnN9IHJ0cFBhcmFtZXRlcnNcbiAqIEBwYXJhbSB7UlRDRXh0ZW5kZWRSdHBDYXBhYmlsaXRpZXN9IGV4dGVuZGVkUnRwQ2FwYWJpbGl0aWVzXG4gKlxuICogQHJldHVybiB7Qm9vbGVhbn1cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGNhblJlY2VpdmUocnRwUGFyYW1ldGVycywgZXh0ZW5kZWRSdHBDYXBhYmlsaXRpZXMpXG57XG5cdGlmIChydHBQYXJhbWV0ZXJzLmNvZGVjcy5sZW5ndGggPT09IDApXG5cdFx0cmV0dXJuIGZhbHNlO1xuXG5cdGNvbnN0IGZpcnN0TWVkaWFDb2RlYyA9IHJ0cFBhcmFtZXRlcnMuY29kZWNzWzBdO1xuXG5cdHJldHVybiBleHRlbmRlZFJ0cENhcGFiaWxpdGllcy5jb2RlY3Ncblx0XHQuc29tZSgoY29kZWMpID0+IGNvZGVjLnJlY3ZQYXlsb2FkVHlwZSA9PT0gZmlyc3RNZWRpYUNvZGVjLnBheWxvYWRUeXBlKTtcbn1cblxuLyoqXG4gKiBHZW5lcmF0ZSBSVFAgcGFyYW1ldGVycyBvZiB0aGUgZ2l2ZW4ga2luZCBmb3Igc2VuZGluZyBtZWRpYS5cbiAqIEp1c3QgdGhlIGZpcnN0IG1lZGlhIGNvZGVjIHBlciBraW5kIGlzIGNvbnNpZGVyZWQuXG4gKiBOT1RFOiBtdXhJZCwgZW5jb2RpbmdzIGFuZCBydGNwIGZpZWxkcyBhcmUgbGVmdCBlbXB0eS5cbiAqXG4gKiBAcGFyYW0ge2tpbmR9IGtpbmRcbiAqIEBwYXJhbSB7UlRDRXh0ZW5kZWRSdHBDYXBhYmlsaXRpZXN9IGV4dGVuZGVkUnRwQ2FwYWJpbGl0aWVzXG4gKlxuICogQHJldHVybiB7UlRDUnRwUGFyYW1ldGVyc31cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGdldFNlbmRpbmdSdHBQYXJhbWV0ZXJzKGtpbmQsIGV4dGVuZGVkUnRwQ2FwYWJpbGl0aWVzKVxue1xuXHRjb25zdCBwYXJhbXMgPVxuXHR7XG5cdFx0bXV4SWQgICAgICAgICAgICA6IG51bGwsXG5cdFx0Y29kZWNzICAgICAgICAgICA6IFtdLFxuXHRcdGhlYWRlckV4dGVuc2lvbnMgOiBbXSxcblx0XHRlbmNvZGluZ3MgICAgICAgIDogW10sXG5cdFx0cnRjcCAgICAgICAgICAgICA6IHt9XG5cdH07XG5cblx0Zm9yIChjb25zdCBjYXBDb2RlYyBvZiBleHRlbmRlZFJ0cENhcGFiaWxpdGllcy5jb2RlY3MpXG5cdHtcblx0XHRpZiAoY2FwQ29kZWMua2luZCAhPT0ga2luZClcblx0XHRcdGNvbnRpbnVlO1xuXG5cdFx0Y29uc3QgY29kZWMgPVxuXHRcdHtcblx0XHRcdG5hbWUgICAgICAgICA6IGNhcENvZGVjLm5hbWUsXG5cdFx0XHRtaW1lVHlwZSAgICAgOiBjYXBDb2RlYy5taW1lVHlwZSxcblx0XHRcdGNsb2NrUmF0ZSAgICA6IGNhcENvZGVjLmNsb2NrUmF0ZSxcblx0XHRcdHBheWxvYWRUeXBlICA6IGNhcENvZGVjLnNlbmRQYXlsb2FkVHlwZSxcblx0XHRcdGNoYW5uZWxzICAgICA6IGNhcENvZGVjLmNoYW5uZWxzLFxuXHRcdFx0cnRjcEZlZWRiYWNrIDogY2FwQ29kZWMucnRjcEZlZWRiYWNrLFxuXHRcdFx0cGFyYW1ldGVycyAgIDogY2FwQ29kZWMucGFyYW1ldGVyc1xuXHRcdH07XG5cblx0XHRpZiAoIWNvZGVjLmNoYW5uZWxzKVxuXHRcdFx0ZGVsZXRlIGNvZGVjLmNoYW5uZWxzO1xuXG5cdFx0cGFyYW1zLmNvZGVjcy5wdXNoKGNvZGVjKTtcblxuXHRcdC8vIEFkZCBSVFggY29kZWMuXG5cdFx0aWYgKGNhcENvZGVjLnNlbmRSdHhQYXlsb2FkVHlwZSlcblx0XHR7XG5cdFx0XHRjb25zdCBydHhDb2RlYyA9XG5cdFx0XHR7XG5cdFx0XHRcdG5hbWUgICAgICAgIDogJ3J0eCcsXG5cdFx0XHRcdG1pbWVUeXBlICAgIDogYCR7Y2FwQ29kZWMua2luZH0vcnR4YCxcblx0XHRcdFx0Y2xvY2tSYXRlICAgOiBjYXBDb2RlYy5jbG9ja1JhdGUsXG5cdFx0XHRcdHBheWxvYWRUeXBlIDogY2FwQ29kZWMuc2VuZFJ0eFBheWxvYWRUeXBlLFxuXHRcdFx0XHRwYXJhbWV0ZXJzICA6XG5cdFx0XHRcdHtcblx0XHRcdFx0XHRhcHQgOiBjYXBDb2RlYy5zZW5kUGF5bG9hZFR5cGVcblx0XHRcdFx0fVxuXHRcdFx0fTtcblxuXHRcdFx0cGFyYW1zLmNvZGVjcy5wdXNoKHJ0eENvZGVjKTtcblx0XHR9XG5cblx0XHQvLyBOT1RFOiBXZSBhc3N1bWUgYSBzaW5nbGUgbWVkaWEgY29kZWMgcGx1cyBhbiBvcHRpb25hbCBSVFggY29kZWMgZm9yIG5vdy5cblx0XHQvLyBUT0RPOiBJbiB0aGUgZnV0dXJlLCB3ZSBuZWVkIHRvIGFkZCBGRUMsIENOLCBldGMsIGNvZGVjcy5cblx0XHRicmVhaztcblx0fVxuXG5cdGZvciAoY29uc3QgY2FwRXh0IG9mIGV4dGVuZGVkUnRwQ2FwYWJpbGl0aWVzLmhlYWRlckV4dGVuc2lvbnMpXG5cdHtcblx0XHRpZiAoY2FwRXh0LmtpbmQgJiYgY2FwRXh0LmtpbmQgIT09IGtpbmQpXG5cdFx0XHRjb250aW51ZTtcblxuXHRcdGNvbnN0IGV4dCA9XG5cdFx0e1xuXHRcdFx0dXJpIDogY2FwRXh0LnVyaSxcblx0XHRcdGlkICA6IGNhcEV4dC5zZW5kSWRcblx0XHR9O1xuXG5cdFx0cGFyYW1zLmhlYWRlckV4dGVuc2lvbnMucHVzaChleHQpO1xuXHR9XG5cblx0cmV0dXJuIHBhcmFtcztcbn1cblxuLyoqXG4gKiBHZW5lcmF0ZSBSVFAgcGFyYW1ldGVycyBvZiB0aGUgZ2l2ZW4ga2luZCBmb3IgcmVjZWl2aW5nIG1lZGlhLlxuICogQWxsIHRoZSBtZWRpYSBjb2RlY3MgcGVyIGtpbmQgYXJlIGNvbnNpZGVyZWQuIFRoaXMgaXMgdXNlZnVsIGZvciBnZW5lcmF0aW5nXG4gKiBhIFNEUCByZW1vdGUgb2ZmZXIuXG4gKiBOT1RFOiBtdXhJZCwgZW5jb2RpbmdzIGFuZCBydGNwIGZpZWxkcyBhcmUgbGVmdCBlbXB0eS5cbiAqXG4gKiBAcGFyYW0ge1N0cmluZ30ga2luZFxuICogQHBhcmFtIHtSVENFeHRlbmRlZFJ0cENhcGFiaWxpdGllc30gZXh0ZW5kZWRSdHBDYXBhYmlsaXRpZXNcbiAqXG4gKiBAcmV0dXJuIHtSVENSdHBQYXJhbWV0ZXJzfVxuICovXG5leHBvcnQgZnVuY3Rpb24gZ2V0UmVjZWl2aW5nRnVsbFJ0cFBhcmFtZXRlcnMoa2luZCwgZXh0ZW5kZWRSdHBDYXBhYmlsaXRpZXMpXG57XG5cdGNvbnN0IHBhcmFtcyA9XG5cdHtcblx0XHRtdXhJZCAgICAgICAgICAgIDogbnVsbCxcblx0XHRjb2RlY3MgICAgICAgICAgIDogW10sXG5cdFx0aGVhZGVyRXh0ZW5zaW9ucyA6IFtdLFxuXHRcdGVuY29kaW5ncyAgICAgICAgOiBbXSxcblx0XHRydGNwICAgICAgICAgICAgIDoge31cblx0fTtcblxuXHRmb3IgKGNvbnN0IGNhcENvZGVjIG9mIGV4dGVuZGVkUnRwQ2FwYWJpbGl0aWVzLmNvZGVjcylcblx0e1xuXHRcdGlmIChjYXBDb2RlYy5raW5kICE9PSBraW5kKVxuXHRcdFx0Y29udGludWU7XG5cblx0XHRjb25zdCBjb2RlYyA9XG5cdFx0e1xuXHRcdFx0bmFtZSAgICAgICAgIDogY2FwQ29kZWMubmFtZSxcblx0XHRcdG1pbWVUeXBlICAgICA6IGNhcENvZGVjLm1pbWVUeXBlLFxuXHRcdFx0Y2xvY2tSYXRlICAgIDogY2FwQ29kZWMuY2xvY2tSYXRlLFxuXHRcdFx0cGF5bG9hZFR5cGUgIDogY2FwQ29kZWMucmVjdlBheWxvYWRUeXBlLFxuXHRcdFx0Y2hhbm5lbHMgICAgIDogY2FwQ29kZWMuY2hhbm5lbHMsXG5cdFx0XHRydGNwRmVlZGJhY2sgOiBjYXBDb2RlYy5ydGNwRmVlZGJhY2ssXG5cdFx0XHRwYXJhbWV0ZXJzICAgOiBjYXBDb2RlYy5wYXJhbWV0ZXJzXG5cdFx0fTtcblxuXHRcdGlmICghY29kZWMuY2hhbm5lbHMpXG5cdFx0XHRkZWxldGUgY29kZWMuY2hhbm5lbHM7XG5cblx0XHRwYXJhbXMuY29kZWNzLnB1c2goY29kZWMpO1xuXG5cdFx0Ly8gQWRkIFJUWCBjb2RlYy5cblx0XHRpZiAoY2FwQ29kZWMucmVjdlJ0eFBheWxvYWRUeXBlKVxuXHRcdHtcblx0XHRcdGNvbnN0IHJ0eENvZGVjID1cblx0XHRcdHtcblx0XHRcdFx0bmFtZSAgICAgICAgOiAncnR4Jyxcblx0XHRcdFx0bWltZVR5cGUgICAgOiBgJHtjYXBDb2RlYy5raW5kfS9ydHhgLFxuXHRcdFx0XHRjbG9ja1JhdGUgICA6IGNhcENvZGVjLmNsb2NrUmF0ZSxcblx0XHRcdFx0cGF5bG9hZFR5cGUgOiBjYXBDb2RlYy5yZWN2UnR4UGF5bG9hZFR5cGUsXG5cdFx0XHRcdHBhcmFtZXRlcnMgIDpcblx0XHRcdFx0e1xuXHRcdFx0XHRcdGFwdCA6IGNhcENvZGVjLnJlY3ZQYXlsb2FkVHlwZVxuXHRcdFx0XHR9XG5cdFx0XHR9O1xuXG5cdFx0XHRwYXJhbXMuY29kZWNzLnB1c2gocnR4Q29kZWMpO1xuXHRcdH1cblxuXHRcdC8vIFRPRE86IEluIHRoZSBmdXR1cmUsIHdlIG5lZWQgdG8gYWRkIEZFQywgQ04sIGV0YywgY29kZWNzLlxuXHR9XG5cblx0Zm9yIChjb25zdCBjYXBFeHQgb2YgZXh0ZW5kZWRSdHBDYXBhYmlsaXRpZXMuaGVhZGVyRXh0ZW5zaW9ucylcblx0e1xuXHRcdGlmIChjYXBFeHQua2luZCAmJiBjYXBFeHQua2luZCAhPT0ga2luZClcblx0XHRcdGNvbnRpbnVlO1xuXG5cdFx0Y29uc3QgZXh0ID1cblx0XHR7XG5cdFx0XHR1cmkgOiBjYXBFeHQudXJpLFxuXHRcdFx0aWQgIDogY2FwRXh0LnJlY3ZJZFxuXHRcdH07XG5cblx0XHRwYXJhbXMuaGVhZGVyRXh0ZW5zaW9ucy5wdXNoKGV4dCk7XG5cdH1cblxuXHRyZXR1cm4gcGFyYW1zO1xufVxuXG5mdW5jdGlvbiBtYXRjaENhcENvZGVjcyhhQ29kZWMsIGJDb2RlYylcbntcblx0Y29uc3QgYU1pbWVUeXBlID0gYUNvZGVjLm1pbWVUeXBlLnRvTG93ZXJDYXNlKCk7XG5cdGNvbnN0IGJNaW1lVHlwZSA9IGJDb2RlYy5taW1lVHlwZS50b0xvd2VyQ2FzZSgpO1xuXG5cdGlmIChhTWltZVR5cGUgIT09IGJNaW1lVHlwZSlcblx0XHRyZXR1cm4gZmFsc2U7XG5cblx0aWYgKGFDb2RlYy5jbG9ja1JhdGUgIT09IGJDb2RlYy5jbG9ja1JhdGUpXG5cdFx0cmV0dXJuIGZhbHNlO1xuXG5cdGlmIChhQ29kZWMuY2hhbm5lbHMgIT09IGJDb2RlYy5jaGFubmVscylcblx0XHRyZXR1cm4gZmFsc2U7XG5cblx0Ly8gTWF0Y2ggSDI2NCBwYXJhbWV0ZXJzLlxuXHRpZiAoYU1pbWVUeXBlID09PSAndmlkZW8vaDI2NCcpXG5cdHtcblx0XHRjb25zdCBhUGFja2V0aXphdGlvbk1vZGUgPSAoYUNvZGVjLnBhcmFtZXRlcnMgfHwge30pWydwYWNrZXRpemF0aW9uLW1vZGUnXSB8fCAwO1xuXHRcdGNvbnN0IGJQYWNrZXRpemF0aW9uTW9kZSA9IChiQ29kZWMucGFyYW1ldGVycyB8fCB7fSlbJ3BhY2tldGl6YXRpb24tbW9kZSddIHx8IDA7XG5cblx0XHRpZiAoYVBhY2tldGl6YXRpb25Nb2RlICE9PSBiUGFja2V0aXphdGlvbk1vZGUpXG5cdFx0XHRyZXR1cm4gZmFsc2U7XG5cdH1cblxuXHRyZXR1cm4gdHJ1ZTtcbn1cblxuZnVuY3Rpb24gbWF0Y2hDYXBIZWFkZXJFeHRlbnNpb25zKGFFeHQsIGJFeHQpXG57XG5cdGlmIChhRXh0LmtpbmQgJiYgYkV4dC5raW5kICYmIGFFeHQua2luZCAhPT0gYkV4dC5raW5kKVxuXHRcdHJldHVybiBmYWxzZTtcblxuXHRpZiAoYUV4dC51cmkgIT09IGJFeHQudXJpKVxuXHRcdHJldHVybiBmYWxzZTtcblxuXHRyZXR1cm4gdHJ1ZTtcbn1cblxuZnVuY3Rpb24gcmVkdWNlUnRjcEZlZWRiYWNrKGNvZGVjQSwgY29kZWNCKVxue1xuXHRjb25zdCByZWR1Y2VkUnRjcEZlZWRiYWNrID0gW107XG5cblx0Zm9yIChjb25zdCBhRmIgb2YgY29kZWNBLnJ0Y3BGZWVkYmFjayB8fCBbXSlcblx0e1xuXHRcdGNvbnN0IG1hdGNoaW5nQkZiID0gKGNvZGVjQi5ydGNwRmVlZGJhY2sgfHwgW10pXG5cdFx0XHQuZmluZCgoYkZiKSA9PlxuXHRcdFx0e1xuXHRcdFx0XHRyZXR1cm4gKFxuXHRcdFx0XHRcdGJGYi50eXBlID09PSBhRmIudHlwZSAmJlxuXHRcdFx0XHRcdGJGYi5wYXJhbWV0ZXIgPT09IGFGYi5wYXJhbWV0ZXJcblx0XHRcdFx0KTtcblx0XHRcdH0pO1xuXG5cdFx0aWYgKG1hdGNoaW5nQkZiKVxuXHRcdFx0cmVkdWNlZFJ0Y3BGZWVkYmFjay5wdXNoKG1hdGNoaW5nQkZiKTtcblx0fVxuXG5cdHJldHVybiByZWR1Y2VkUnRjcEZlZWRiYWNrO1xufVxuIiwiaW1wb3J0IHJhbmRvbU51bWJlckxpYiBmcm9tICdyYW5kb20tbnVtYmVyJztcblxuY29uc3QgcmFuZG9tTnVtYmVyR2VuZXJhdG9yID0gcmFuZG9tTnVtYmVyTGliLmdlbmVyYXRvcihcblx0e1xuXHRcdG1pbiAgICAgOiAxMDAwMDAwMCxcblx0XHRtYXggICAgIDogOTk5OTk5OTksXG5cdFx0aW50ZWdlciA6IHRydWVcblx0fSk7XG5cbi8qKlxuICogR2VuZXJhdGVzIGEgcmFuZG9tIHBvc2l0aXZlIG51bWJlciBiZXR3ZWVuIDEwMDAwMDAwIGFuZCA5OTk5OTk5OS5cbiAqXG4gKiBAcmV0dXJuIHtOdW1iZXJ9XG4gKi9cbmV4cG9ydCBmdW5jdGlvbiByYW5kb21OdW1iZXIoKVxue1xuXHRyZXR1cm4gcmFuZG9tTnVtYmVyR2VuZXJhdG9yKCk7XG59XG5cbi8qKlxuICogQ2xvbmVzIHRoZSBnaXZlbiBPYmplY3QvQXJyYXkuXG4gKlxuICogQHBhcmFtIHtPYmplY3R8QXJyYXl9IG9ialxuICpcbiAqIEByZXR1cm4ge09iamVjdHxBcnJheX1cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGNsb25lKG9iailcbntcblx0cmV0dXJuIEpTT04ucGFyc2UoSlNPTi5zdHJpbmdpZnkob2JqKSk7XG59XG4iLCJtb2R1bGUuZXhwb3J0cyA9IHsgXCJkZWZhdWx0XCI6IHJlcXVpcmUoXCJjb3JlLWpzL2xpYnJhcnkvZm4vYXJyYXkvZnJvbVwiKSwgX19lc01vZHVsZTogdHJ1ZSB9OyIsIm1vZHVsZS5leHBvcnRzID0geyBcImRlZmF1bHRcIjogcmVxdWlyZShcImNvcmUtanMvbGlicmFyeS9mbi9nZXQtaXRlcmF0b3JcIiksIF9fZXNNb2R1bGU6IHRydWUgfTsiLCJtb2R1bGUuZXhwb3J0cyA9IHsgXCJkZWZhdWx0XCI6IHJlcXVpcmUoXCJjb3JlLWpzL2xpYnJhcnkvZm4vaXMtaXRlcmFibGVcIiksIF9fZXNNb2R1bGU6IHRydWUgfTsiLCJtb2R1bGUuZXhwb3J0cyA9IHsgXCJkZWZhdWx0XCI6IHJlcXVpcmUoXCJjb3JlLWpzL2xpYnJhcnkvZm4vanNvbi9zdHJpbmdpZnlcIiksIF9fZXNNb2R1bGU6IHRydWUgfTsiLCJtb2R1bGUuZXhwb3J0cyA9IHsgXCJkZWZhdWx0XCI6IHJlcXVpcmUoXCJjb3JlLWpzL2xpYnJhcnkvZm4vbWFwXCIpLCBfX2VzTW9kdWxlOiB0cnVlIH07IiwibW9kdWxlLmV4cG9ydHMgPSB7IFwiZGVmYXVsdFwiOiByZXF1aXJlKFwiY29yZS1qcy9saWJyYXJ5L2ZuL29iamVjdC9hc3NpZ25cIiksIF9fZXNNb2R1bGU6IHRydWUgfTsiLCJtb2R1bGUuZXhwb3J0cyA9IHsgXCJkZWZhdWx0XCI6IHJlcXVpcmUoXCJjb3JlLWpzL2xpYnJhcnkvZm4vb2JqZWN0L2NyZWF0ZVwiKSwgX19lc01vZHVsZTogdHJ1ZSB9OyIsIm1vZHVsZS5leHBvcnRzID0geyBcImRlZmF1bHRcIjogcmVxdWlyZShcImNvcmUtanMvbGlicmFyeS9mbi9vYmplY3QvZGVmaW5lLXByb3BlcnR5XCIpLCBfX2VzTW9kdWxlOiB0cnVlIH07IiwibW9kdWxlLmV4cG9ydHMgPSB7IFwiZGVmYXVsdFwiOiByZXF1aXJlKFwiY29yZS1qcy9saWJyYXJ5L2ZuL29iamVjdC9nZXQtcHJvdG90eXBlLW9mXCIpLCBfX2VzTW9kdWxlOiB0cnVlIH07IiwibW9kdWxlLmV4cG9ydHMgPSB7IFwiZGVmYXVsdFwiOiByZXF1aXJlKFwiY29yZS1qcy9saWJyYXJ5L2ZuL29iamVjdC9rZXlzXCIpLCBfX2VzTW9kdWxlOiB0cnVlIH07IiwibW9kdWxlLmV4cG9ydHMgPSB7IFwiZGVmYXVsdFwiOiByZXF1aXJlKFwiY29yZS1qcy9saWJyYXJ5L2ZuL29iamVjdC9zZXQtcHJvdG90eXBlLW9mXCIpLCBfX2VzTW9kdWxlOiB0cnVlIH07IiwibW9kdWxlLmV4cG9ydHMgPSB7IFwiZGVmYXVsdFwiOiByZXF1aXJlKFwiY29yZS1qcy9saWJyYXJ5L2ZuL29iamVjdC92YWx1ZXNcIiksIF9fZXNNb2R1bGU6IHRydWUgfTsiLCJtb2R1bGUuZXhwb3J0cyA9IHsgXCJkZWZhdWx0XCI6IHJlcXVpcmUoXCJjb3JlLWpzL2xpYnJhcnkvZm4vcHJvbWlzZVwiKSwgX19lc01vZHVsZTogdHJ1ZSB9OyIsIm1vZHVsZS5leHBvcnRzID0geyBcImRlZmF1bHRcIjogcmVxdWlyZShcImNvcmUtanMvbGlicmFyeS9mbi9zZXRcIiksIF9fZXNNb2R1bGU6IHRydWUgfTsiLCJtb2R1bGUuZXhwb3J0cyA9IHsgXCJkZWZhdWx0XCI6IHJlcXVpcmUoXCJjb3JlLWpzL2xpYnJhcnkvZm4vc3ltYm9sXCIpLCBfX2VzTW9kdWxlOiB0cnVlIH07IiwibW9kdWxlLmV4cG9ydHMgPSB7IFwiZGVmYXVsdFwiOiByZXF1aXJlKFwiY29yZS1qcy9saWJyYXJ5L2ZuL3N5bWJvbC9pdGVyYXRvclwiKSwgX19lc01vZHVsZTogdHJ1ZSB9OyIsIlwidXNlIHN0cmljdFwiO1xuXG5leHBvcnRzLl9fZXNNb2R1bGUgPSB0cnVlO1xuXG5leHBvcnRzLmRlZmF1bHQgPSBmdW5jdGlvbiAoaW5zdGFuY2UsIENvbnN0cnVjdG9yKSB7XG4gIGlmICghKGluc3RhbmNlIGluc3RhbmNlb2YgQ29uc3RydWN0b3IpKSB7XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkNhbm5vdCBjYWxsIGEgY2xhc3MgYXMgYSBmdW5jdGlvblwiKTtcbiAgfVxufTsiLCJcInVzZSBzdHJpY3RcIjtcblxuZXhwb3J0cy5fX2VzTW9kdWxlID0gdHJ1ZTtcblxudmFyIF9kZWZpbmVQcm9wZXJ0eSA9IHJlcXVpcmUoXCIuLi9jb3JlLWpzL29iamVjdC9kZWZpbmUtcHJvcGVydHlcIik7XG5cbnZhciBfZGVmaW5lUHJvcGVydHkyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfZGVmaW5lUHJvcGVydHkpO1xuXG5mdW5jdGlvbiBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KG9iaikgeyByZXR1cm4gb2JqICYmIG9iai5fX2VzTW9kdWxlID8gb2JqIDogeyBkZWZhdWx0OiBvYmogfTsgfVxuXG5leHBvcnRzLmRlZmF1bHQgPSBmdW5jdGlvbiAoKSB7XG4gIGZ1bmN0aW9uIGRlZmluZVByb3BlcnRpZXModGFyZ2V0LCBwcm9wcykge1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgcHJvcHMubGVuZ3RoOyBpKyspIHtcbiAgICAgIHZhciBkZXNjcmlwdG9yID0gcHJvcHNbaV07XG4gICAgICBkZXNjcmlwdG9yLmVudW1lcmFibGUgPSBkZXNjcmlwdG9yLmVudW1lcmFibGUgfHwgZmFsc2U7XG4gICAgICBkZXNjcmlwdG9yLmNvbmZpZ3VyYWJsZSA9IHRydWU7XG4gICAgICBpZiAoXCJ2YWx1ZVwiIGluIGRlc2NyaXB0b3IpIGRlc2NyaXB0b3Iud3JpdGFibGUgPSB0cnVlO1xuICAgICAgKDAsIF9kZWZpbmVQcm9wZXJ0eTIuZGVmYXVsdCkodGFyZ2V0LCBkZXNjcmlwdG9yLmtleSwgZGVzY3JpcHRvcik7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIGZ1bmN0aW9uIChDb25zdHJ1Y3RvciwgcHJvdG9Qcm9wcywgc3RhdGljUHJvcHMpIHtcbiAgICBpZiAocHJvdG9Qcm9wcykgZGVmaW5lUHJvcGVydGllcyhDb25zdHJ1Y3Rvci5wcm90b3R5cGUsIHByb3RvUHJvcHMpO1xuICAgIGlmIChzdGF0aWNQcm9wcykgZGVmaW5lUHJvcGVydGllcyhDb25zdHJ1Y3Rvciwgc3RhdGljUHJvcHMpO1xuICAgIHJldHVybiBDb25zdHJ1Y3RvcjtcbiAgfTtcbn0oKTsiLCJcInVzZSBzdHJpY3RcIjtcblxuZXhwb3J0cy5fX2VzTW9kdWxlID0gdHJ1ZTtcblxudmFyIF9hc3NpZ24gPSByZXF1aXJlKFwiLi4vY29yZS1qcy9vYmplY3QvYXNzaWduXCIpO1xuXG52YXIgX2Fzc2lnbjIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9hc3NpZ24pO1xuXG5mdW5jdGlvbiBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KG9iaikgeyByZXR1cm4gb2JqICYmIG9iai5fX2VzTW9kdWxlID8gb2JqIDogeyBkZWZhdWx0OiBvYmogfTsgfVxuXG5leHBvcnRzLmRlZmF1bHQgPSBfYXNzaWduMi5kZWZhdWx0IHx8IGZ1bmN0aW9uICh0YXJnZXQpIHtcbiAgZm9yICh2YXIgaSA9IDE7IGkgPCBhcmd1bWVudHMubGVuZ3RoOyBpKyspIHtcbiAgICB2YXIgc291cmNlID0gYXJndW1lbnRzW2ldO1xuXG4gICAgZm9yICh2YXIga2V5IGluIHNvdXJjZSkge1xuICAgICAgaWYgKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChzb3VyY2UsIGtleSkpIHtcbiAgICAgICAgdGFyZ2V0W2tleV0gPSBzb3VyY2Vba2V5XTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICByZXR1cm4gdGFyZ2V0O1xufTsiLCJcInVzZSBzdHJpY3RcIjtcblxuZXhwb3J0cy5fX2VzTW9kdWxlID0gdHJ1ZTtcblxudmFyIF9zZXRQcm90b3R5cGVPZiA9IHJlcXVpcmUoXCIuLi9jb3JlLWpzL29iamVjdC9zZXQtcHJvdG90eXBlLW9mXCIpO1xuXG52YXIgX3NldFByb3RvdHlwZU9mMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX3NldFByb3RvdHlwZU9mKTtcblxudmFyIF9jcmVhdGUgPSByZXF1aXJlKFwiLi4vY29yZS1qcy9vYmplY3QvY3JlYXRlXCIpO1xuXG52YXIgX2NyZWF0ZTIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9jcmVhdGUpO1xuXG52YXIgX3R5cGVvZjIgPSByZXF1aXJlKFwiLi4vaGVscGVycy90eXBlb2ZcIik7XG5cbnZhciBfdHlwZW9mMyA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX3R5cGVvZjIpO1xuXG5mdW5jdGlvbiBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KG9iaikgeyByZXR1cm4gb2JqICYmIG9iai5fX2VzTW9kdWxlID8gb2JqIDogeyBkZWZhdWx0OiBvYmogfTsgfVxuXG5leHBvcnRzLmRlZmF1bHQgPSBmdW5jdGlvbiAoc3ViQ2xhc3MsIHN1cGVyQ2xhc3MpIHtcbiAgaWYgKHR5cGVvZiBzdXBlckNsYXNzICE9PSBcImZ1bmN0aW9uXCIgJiYgc3VwZXJDbGFzcyAhPT0gbnVsbCkge1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXCJTdXBlciBleHByZXNzaW9uIG11c3QgZWl0aGVyIGJlIG51bGwgb3IgYSBmdW5jdGlvbiwgbm90IFwiICsgKHR5cGVvZiBzdXBlckNsYXNzID09PSBcInVuZGVmaW5lZFwiID8gXCJ1bmRlZmluZWRcIiA6ICgwLCBfdHlwZW9mMy5kZWZhdWx0KShzdXBlckNsYXNzKSkpO1xuICB9XG5cbiAgc3ViQ2xhc3MucHJvdG90eXBlID0gKDAsIF9jcmVhdGUyLmRlZmF1bHQpKHN1cGVyQ2xhc3MgJiYgc3VwZXJDbGFzcy5wcm90b3R5cGUsIHtcbiAgICBjb25zdHJ1Y3Rvcjoge1xuICAgICAgdmFsdWU6IHN1YkNsYXNzLFxuICAgICAgZW51bWVyYWJsZTogZmFsc2UsXG4gICAgICB3cml0YWJsZTogdHJ1ZSxcbiAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgIH1cbiAgfSk7XG4gIGlmIChzdXBlckNsYXNzKSBfc2V0UHJvdG90eXBlT2YyLmRlZmF1bHQgPyAoMCwgX3NldFByb3RvdHlwZU9mMi5kZWZhdWx0KShzdWJDbGFzcywgc3VwZXJDbGFzcykgOiBzdWJDbGFzcy5fX3Byb3RvX18gPSBzdXBlckNsYXNzO1xufTsiLCJcInVzZSBzdHJpY3RcIjtcblxuZXhwb3J0cy5fX2VzTW9kdWxlID0gdHJ1ZTtcblxudmFyIF90eXBlb2YyID0gcmVxdWlyZShcIi4uL2hlbHBlcnMvdHlwZW9mXCIpO1xuXG52YXIgX3R5cGVvZjMgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF90eXBlb2YyKTtcblxuZnVuY3Rpb24gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChvYmopIHsgcmV0dXJuIG9iaiAmJiBvYmouX19lc01vZHVsZSA/IG9iaiA6IHsgZGVmYXVsdDogb2JqIH07IH1cblxuZXhwb3J0cy5kZWZhdWx0ID0gZnVuY3Rpb24gKHNlbGYsIGNhbGwpIHtcbiAgaWYgKCFzZWxmKSB7XG4gICAgdGhyb3cgbmV3IFJlZmVyZW5jZUVycm9yKFwidGhpcyBoYXNuJ3QgYmVlbiBpbml0aWFsaXNlZCAtIHN1cGVyKCkgaGFzbid0IGJlZW4gY2FsbGVkXCIpO1xuICB9XG5cbiAgcmV0dXJuIGNhbGwgJiYgKCh0eXBlb2YgY2FsbCA9PT0gXCJ1bmRlZmluZWRcIiA/IFwidW5kZWZpbmVkXCIgOiAoMCwgX3R5cGVvZjMuZGVmYXVsdCkoY2FsbCkpID09PSBcIm9iamVjdFwiIHx8IHR5cGVvZiBjYWxsID09PSBcImZ1bmN0aW9uXCIpID8gY2FsbCA6IHNlbGY7XG59OyIsIlwidXNlIHN0cmljdFwiO1xuXG5leHBvcnRzLl9fZXNNb2R1bGUgPSB0cnVlO1xuXG52YXIgX2lzSXRlcmFibGUyID0gcmVxdWlyZShcIi4uL2NvcmUtanMvaXMtaXRlcmFibGVcIik7XG5cbnZhciBfaXNJdGVyYWJsZTMgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9pc0l0ZXJhYmxlMik7XG5cbnZhciBfZ2V0SXRlcmF0b3IyID0gcmVxdWlyZShcIi4uL2NvcmUtanMvZ2V0LWl0ZXJhdG9yXCIpO1xuXG52YXIgX2dldEl0ZXJhdG9yMyA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX2dldEl0ZXJhdG9yMik7XG5cbmZ1bmN0aW9uIF9pbnRlcm9wUmVxdWlyZURlZmF1bHQob2JqKSB7IHJldHVybiBvYmogJiYgb2JqLl9fZXNNb2R1bGUgPyBvYmogOiB7IGRlZmF1bHQ6IG9iaiB9OyB9XG5cbmV4cG9ydHMuZGVmYXVsdCA9IGZ1bmN0aW9uICgpIHtcbiAgZnVuY3Rpb24gc2xpY2VJdGVyYXRvcihhcnIsIGkpIHtcbiAgICB2YXIgX2FyciA9IFtdO1xuICAgIHZhciBfbiA9IHRydWU7XG4gICAgdmFyIF9kID0gZmFsc2U7XG4gICAgdmFyIF9lID0gdW5kZWZpbmVkO1xuXG4gICAgdHJ5IHtcbiAgICAgIGZvciAodmFyIF9pID0gKDAsIF9nZXRJdGVyYXRvcjMuZGVmYXVsdCkoYXJyKSwgX3M7ICEoX24gPSAoX3MgPSBfaS5uZXh0KCkpLmRvbmUpOyBfbiA9IHRydWUpIHtcbiAgICAgICAgX2Fyci5wdXNoKF9zLnZhbHVlKTtcblxuICAgICAgICBpZiAoaSAmJiBfYXJyLmxlbmd0aCA9PT0gaSkgYnJlYWs7XG4gICAgICB9XG4gICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICBfZCA9IHRydWU7XG4gICAgICBfZSA9IGVycjtcbiAgICB9IGZpbmFsbHkge1xuICAgICAgdHJ5IHtcbiAgICAgICAgaWYgKCFfbiAmJiBfaVtcInJldHVyblwiXSkgX2lbXCJyZXR1cm5cIl0oKTtcbiAgICAgIH0gZmluYWxseSB7XG4gICAgICAgIGlmIChfZCkgdGhyb3cgX2U7XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIF9hcnI7XG4gIH1cblxuICByZXR1cm4gZnVuY3Rpb24gKGFyciwgaSkge1xuICAgIGlmIChBcnJheS5pc0FycmF5KGFycikpIHtcbiAgICAgIHJldHVybiBhcnI7XG4gICAgfSBlbHNlIGlmICgoMCwgX2lzSXRlcmFibGUzLmRlZmF1bHQpKE9iamVjdChhcnIpKSkge1xuICAgICAgcmV0dXJuIHNsaWNlSXRlcmF0b3IoYXJyLCBpKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkludmFsaWQgYXR0ZW1wdCB0byBkZXN0cnVjdHVyZSBub24taXRlcmFibGUgaW5zdGFuY2VcIik7XG4gICAgfVxuICB9O1xufSgpOyIsIlwidXNlIHN0cmljdFwiO1xuXG5leHBvcnRzLl9fZXNNb2R1bGUgPSB0cnVlO1xuXG52YXIgX2Zyb20gPSByZXF1aXJlKFwiLi4vY29yZS1qcy9hcnJheS9mcm9tXCIpO1xuXG52YXIgX2Zyb20yID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfZnJvbSk7XG5cbmZ1bmN0aW9uIF9pbnRlcm9wUmVxdWlyZURlZmF1bHQob2JqKSB7IHJldHVybiBvYmogJiYgb2JqLl9fZXNNb2R1bGUgPyBvYmogOiB7IGRlZmF1bHQ6IG9iaiB9OyB9XG5cbmV4cG9ydHMuZGVmYXVsdCA9IGZ1bmN0aW9uIChhcnIpIHtcbiAgaWYgKEFycmF5LmlzQXJyYXkoYXJyKSkge1xuICAgIGZvciAodmFyIGkgPSAwLCBhcnIyID0gQXJyYXkoYXJyLmxlbmd0aCk7IGkgPCBhcnIubGVuZ3RoOyBpKyspIHtcbiAgICAgIGFycjJbaV0gPSBhcnJbaV07XG4gICAgfVxuXG4gICAgcmV0dXJuIGFycjI7XG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuICgwLCBfZnJvbTIuZGVmYXVsdCkoYXJyKTtcbiAgfVxufTsiLCJcInVzZSBzdHJpY3RcIjtcblxuZXhwb3J0cy5fX2VzTW9kdWxlID0gdHJ1ZTtcblxudmFyIF9pdGVyYXRvciA9IHJlcXVpcmUoXCIuLi9jb3JlLWpzL3N5bWJvbC9pdGVyYXRvclwiKTtcblxudmFyIF9pdGVyYXRvcjIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9pdGVyYXRvcik7XG5cbnZhciBfc3ltYm9sID0gcmVxdWlyZShcIi4uL2NvcmUtanMvc3ltYm9sXCIpO1xuXG52YXIgX3N5bWJvbDIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9zeW1ib2wpO1xuXG52YXIgX3R5cGVvZiA9IHR5cGVvZiBfc3ltYm9sMi5kZWZhdWx0ID09PSBcImZ1bmN0aW9uXCIgJiYgdHlwZW9mIF9pdGVyYXRvcjIuZGVmYXVsdCA9PT0gXCJzeW1ib2xcIiA/IGZ1bmN0aW9uIChvYmopIHsgcmV0dXJuIHR5cGVvZiBvYmo7IH0gOiBmdW5jdGlvbiAob2JqKSB7IHJldHVybiBvYmogJiYgdHlwZW9mIF9zeW1ib2wyLmRlZmF1bHQgPT09IFwiZnVuY3Rpb25cIiAmJiBvYmouY29uc3RydWN0b3IgPT09IF9zeW1ib2wyLmRlZmF1bHQgJiYgb2JqICE9PSBfc3ltYm9sMi5kZWZhdWx0LnByb3RvdHlwZSA/IFwic3ltYm9sXCIgOiB0eXBlb2Ygb2JqOyB9O1xuXG5mdW5jdGlvbiBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KG9iaikgeyByZXR1cm4gb2JqICYmIG9iai5fX2VzTW9kdWxlID8gb2JqIDogeyBkZWZhdWx0OiBvYmogfTsgfVxuXG5leHBvcnRzLmRlZmF1bHQgPSB0eXBlb2YgX3N5bWJvbDIuZGVmYXVsdCA9PT0gXCJmdW5jdGlvblwiICYmIF90eXBlb2YoX2l0ZXJhdG9yMi5kZWZhdWx0KSA9PT0gXCJzeW1ib2xcIiA/IGZ1bmN0aW9uIChvYmopIHtcbiAgcmV0dXJuIHR5cGVvZiBvYmogPT09IFwidW5kZWZpbmVkXCIgPyBcInVuZGVmaW5lZFwiIDogX3R5cGVvZihvYmopO1xufSA6IGZ1bmN0aW9uIChvYmopIHtcbiAgcmV0dXJuIG9iaiAmJiB0eXBlb2YgX3N5bWJvbDIuZGVmYXVsdCA9PT0gXCJmdW5jdGlvblwiICYmIG9iai5jb25zdHJ1Y3RvciA9PT0gX3N5bWJvbDIuZGVmYXVsdCAmJiBvYmogIT09IF9zeW1ib2wyLmRlZmF1bHQucHJvdG90eXBlID8gXCJzeW1ib2xcIiA6IHR5cGVvZiBvYmogPT09IFwidW5kZWZpbmVkXCIgPyBcInVuZGVmaW5lZFwiIDogX3R5cGVvZihvYmopO1xufTsiLCIvKiFcbiAqIEJvd3NlciAtIGEgYnJvd3NlciBkZXRlY3RvclxuICogaHR0cHM6Ly9naXRodWIuY29tL2RlZC9ib3dzZXJcbiAqIE1JVCBMaWNlbnNlIHwgKGMpIER1c3RpbiBEaWF6IDIwMTVcbiAqL1xuXG4hZnVuY3Rpb24gKHJvb3QsIG5hbWUsIGRlZmluaXRpb24pIHtcbiAgaWYgKHR5cGVvZiBtb2R1bGUgIT0gJ3VuZGVmaW5lZCcgJiYgbW9kdWxlLmV4cG9ydHMpIG1vZHVsZS5leHBvcnRzID0gZGVmaW5pdGlvbigpXG4gIGVsc2UgaWYgKHR5cGVvZiBkZWZpbmUgPT0gJ2Z1bmN0aW9uJyAmJiBkZWZpbmUuYW1kKSBkZWZpbmUobmFtZSwgZGVmaW5pdGlvbilcbiAgZWxzZSByb290W25hbWVdID0gZGVmaW5pdGlvbigpXG59KHRoaXMsICdib3dzZXInLCBmdW5jdGlvbiAoKSB7XG4gIC8qKlxuICAgICogU2VlIHVzZXJhZ2VudHMuanMgZm9yIGV4YW1wbGVzIG9mIG5hdmlnYXRvci51c2VyQWdlbnRcbiAgICAqL1xuXG4gIHZhciB0ID0gdHJ1ZVxuXG4gIGZ1bmN0aW9uIGRldGVjdCh1YSkge1xuXG4gICAgZnVuY3Rpb24gZ2V0Rmlyc3RNYXRjaChyZWdleCkge1xuICAgICAgdmFyIG1hdGNoID0gdWEubWF0Y2gocmVnZXgpO1xuICAgICAgcmV0dXJuIChtYXRjaCAmJiBtYXRjaC5sZW5ndGggPiAxICYmIG1hdGNoWzFdKSB8fCAnJztcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBnZXRTZWNvbmRNYXRjaChyZWdleCkge1xuICAgICAgdmFyIG1hdGNoID0gdWEubWF0Y2gocmVnZXgpO1xuICAgICAgcmV0dXJuIChtYXRjaCAmJiBtYXRjaC5sZW5ndGggPiAxICYmIG1hdGNoWzJdKSB8fCAnJztcbiAgICB9XG5cbiAgICB2YXIgaW9zZGV2aWNlID0gZ2V0Rmlyc3RNYXRjaCgvKGlwb2R8aXBob25lfGlwYWQpL2kpLnRvTG93ZXJDYXNlKClcbiAgICAgICwgbGlrZUFuZHJvaWQgPSAvbGlrZSBhbmRyb2lkL2kudGVzdCh1YSlcbiAgICAgICwgYW5kcm9pZCA9ICFsaWtlQW5kcm9pZCAmJiAvYW5kcm9pZC9pLnRlc3QodWEpXG4gICAgICAsIG5leHVzTW9iaWxlID0gL25leHVzXFxzKlswLTZdXFxzKi9pLnRlc3QodWEpXG4gICAgICAsIG5leHVzVGFibGV0ID0gIW5leHVzTW9iaWxlICYmIC9uZXh1c1xccypbMC05XSsvaS50ZXN0KHVhKVxuICAgICAgLCBjaHJvbWVvcyA9IC9Dck9TLy50ZXN0KHVhKVxuICAgICAgLCBzaWxrID0gL3NpbGsvaS50ZXN0KHVhKVxuICAgICAgLCBzYWlsZmlzaCA9IC9zYWlsZmlzaC9pLnRlc3QodWEpXG4gICAgICAsIHRpemVuID0gL3RpemVuL2kudGVzdCh1YSlcbiAgICAgICwgd2Vib3MgPSAvKHdlYnxocHcpb3MvaS50ZXN0KHVhKVxuICAgICAgLCB3aW5kb3dzcGhvbmUgPSAvd2luZG93cyBwaG9uZS9pLnRlc3QodWEpXG4gICAgICAsIHNhbXN1bmdCcm93c2VyID0gL1NhbXN1bmdCcm93c2VyL2kudGVzdCh1YSlcbiAgICAgICwgd2luZG93cyA9ICF3aW5kb3dzcGhvbmUgJiYgL3dpbmRvd3MvaS50ZXN0KHVhKVxuICAgICAgLCBtYWMgPSAhaW9zZGV2aWNlICYmICFzaWxrICYmIC9tYWNpbnRvc2gvaS50ZXN0KHVhKVxuICAgICAgLCBsaW51eCA9ICFhbmRyb2lkICYmICFzYWlsZmlzaCAmJiAhdGl6ZW4gJiYgIXdlYm9zICYmIC9saW51eC9pLnRlc3QodWEpXG4gICAgICAsIGVkZ2VWZXJzaW9uID0gZ2V0U2Vjb25kTWF0Y2goL2VkZyhbZWFdfGlvcylcXC8oXFxkKyhcXC5cXGQrKT8pL2kpXG4gICAgICAsIHZlcnNpb25JZGVudGlmaWVyID0gZ2V0Rmlyc3RNYXRjaCgvdmVyc2lvblxcLyhcXGQrKFxcLlxcZCspPykvaSlcbiAgICAgICwgdGFibGV0ID0gL3RhYmxldC9pLnRlc3QodWEpICYmICEvdGFibGV0IHBjL2kudGVzdCh1YSlcbiAgICAgICwgbW9iaWxlID0gIXRhYmxldCAmJiAvW14tXW1vYmkvaS50ZXN0KHVhKVxuICAgICAgLCB4Ym94ID0gL3hib3gvaS50ZXN0KHVhKVxuICAgICAgLCByZXN1bHRcblxuICAgIGlmICgvb3BlcmEvaS50ZXN0KHVhKSkge1xuICAgICAgLy8gIGFuIG9sZCBPcGVyYVxuICAgICAgcmVzdWx0ID0ge1xuICAgICAgICBuYW1lOiAnT3BlcmEnXG4gICAgICAsIG9wZXJhOiB0XG4gICAgICAsIHZlcnNpb246IHZlcnNpb25JZGVudGlmaWVyIHx8IGdldEZpcnN0TWF0Y2goLyg/Om9wZXJhfG9wcnxvcGlvcylbXFxzXFwvXShcXGQrKFxcLlxcZCspPykvaSlcbiAgICAgIH1cbiAgICB9IGVsc2UgaWYgKC9vcHJcXC98b3Bpb3MvaS50ZXN0KHVhKSkge1xuICAgICAgLy8gYSBuZXcgT3BlcmFcbiAgICAgIHJlc3VsdCA9IHtcbiAgICAgICAgbmFtZTogJ09wZXJhJ1xuICAgICAgICAsIG9wZXJhOiB0XG4gICAgICAgICwgdmVyc2lvbjogZ2V0Rmlyc3RNYXRjaCgvKD86b3ByfG9waW9zKVtcXHNcXC9dKFxcZCsoXFwuXFxkKyk/KS9pKSB8fCB2ZXJzaW9uSWRlbnRpZmllclxuICAgICAgfVxuICAgIH1cbiAgICBlbHNlIGlmICgvU2Ftc3VuZ0Jyb3dzZXIvaS50ZXN0KHVhKSkge1xuICAgICAgcmVzdWx0ID0ge1xuICAgICAgICBuYW1lOiAnU2Ftc3VuZyBJbnRlcm5ldCBmb3IgQW5kcm9pZCdcbiAgICAgICAgLCBzYW1zdW5nQnJvd3NlcjogdFxuICAgICAgICAsIHZlcnNpb246IHZlcnNpb25JZGVudGlmaWVyIHx8IGdldEZpcnN0TWF0Y2goLyg/OlNhbXN1bmdCcm93c2VyKVtcXHNcXC9dKFxcZCsoXFwuXFxkKyk/KS9pKVxuICAgICAgfVxuICAgIH1cbiAgICBlbHNlIGlmICgvY29hc3QvaS50ZXN0KHVhKSkge1xuICAgICAgcmVzdWx0ID0ge1xuICAgICAgICBuYW1lOiAnT3BlcmEgQ29hc3QnXG4gICAgICAgICwgY29hc3Q6IHRcbiAgICAgICAgLCB2ZXJzaW9uOiB2ZXJzaW9uSWRlbnRpZmllciB8fCBnZXRGaXJzdE1hdGNoKC8oPzpjb2FzdClbXFxzXFwvXShcXGQrKFxcLlxcZCspPykvaSlcbiAgICAgIH1cbiAgICB9XG4gICAgZWxzZSBpZiAoL3lhYnJvd3Nlci9pLnRlc3QodWEpKSB7XG4gICAgICByZXN1bHQgPSB7XG4gICAgICAgIG5hbWU6ICdZYW5kZXggQnJvd3NlcidcbiAgICAgICwgeWFuZGV4YnJvd3NlcjogdFxuICAgICAgLCB2ZXJzaW9uOiB2ZXJzaW9uSWRlbnRpZmllciB8fCBnZXRGaXJzdE1hdGNoKC8oPzp5YWJyb3dzZXIpW1xcc1xcL10oXFxkKyhcXC5cXGQrKT8pL2kpXG4gICAgICB9XG4gICAgfVxuICAgIGVsc2UgaWYgKC91Y2Jyb3dzZXIvaS50ZXN0KHVhKSkge1xuICAgICAgcmVzdWx0ID0ge1xuICAgICAgICAgIG5hbWU6ICdVQyBCcm93c2VyJ1xuICAgICAgICAsIHVjYnJvd3NlcjogdFxuICAgICAgICAsIHZlcnNpb246IGdldEZpcnN0TWF0Y2goLyg/OnVjYnJvd3NlcilbXFxzXFwvXShcXGQrKD86XFwuXFxkKykrKS9pKVxuICAgICAgfVxuICAgIH1cbiAgICBlbHNlIGlmICgvbXhpb3MvaS50ZXN0KHVhKSkge1xuICAgICAgcmVzdWx0ID0ge1xuICAgICAgICBuYW1lOiAnTWF4dGhvbidcbiAgICAgICAgLCBtYXh0aG9uOiB0XG4gICAgICAgICwgdmVyc2lvbjogZ2V0Rmlyc3RNYXRjaCgvKD86bXhpb3MpW1xcc1xcL10oXFxkKyg/OlxcLlxcZCspKykvaSlcbiAgICAgIH1cbiAgICB9XG4gICAgZWxzZSBpZiAoL2VwaXBoYW55L2kudGVzdCh1YSkpIHtcbiAgICAgIHJlc3VsdCA9IHtcbiAgICAgICAgbmFtZTogJ0VwaXBoYW55J1xuICAgICAgICAsIGVwaXBoYW55OiB0XG4gICAgICAgICwgdmVyc2lvbjogZ2V0Rmlyc3RNYXRjaCgvKD86ZXBpcGhhbnkpW1xcc1xcL10oXFxkKyg/OlxcLlxcZCspKykvaSlcbiAgICAgIH1cbiAgICB9XG4gICAgZWxzZSBpZiAoL3B1ZmZpbi9pLnRlc3QodWEpKSB7XG4gICAgICByZXN1bHQgPSB7XG4gICAgICAgIG5hbWU6ICdQdWZmaW4nXG4gICAgICAgICwgcHVmZmluOiB0XG4gICAgICAgICwgdmVyc2lvbjogZ2V0Rmlyc3RNYXRjaCgvKD86cHVmZmluKVtcXHNcXC9dKFxcZCsoPzpcXC5cXGQrKT8pL2kpXG4gICAgICB9XG4gICAgfVxuICAgIGVsc2UgaWYgKC9zbGVpcG5pci9pLnRlc3QodWEpKSB7XG4gICAgICByZXN1bHQgPSB7XG4gICAgICAgIG5hbWU6ICdTbGVpcG5pcidcbiAgICAgICAgLCBzbGVpcG5pcjogdFxuICAgICAgICAsIHZlcnNpb246IGdldEZpcnN0TWF0Y2goLyg/OnNsZWlwbmlyKVtcXHNcXC9dKFxcZCsoPzpcXC5cXGQrKSspL2kpXG4gICAgICB9XG4gICAgfVxuICAgIGVsc2UgaWYgKC9rLW1lbGVvbi9pLnRlc3QodWEpKSB7XG4gICAgICByZXN1bHQgPSB7XG4gICAgICAgIG5hbWU6ICdLLU1lbGVvbidcbiAgICAgICAgLCBrTWVsZW9uOiB0XG4gICAgICAgICwgdmVyc2lvbjogZ2V0Rmlyc3RNYXRjaCgvKD86ay1tZWxlb24pW1xcc1xcL10oXFxkKyg/OlxcLlxcZCspKykvaSlcbiAgICAgIH1cbiAgICB9XG4gICAgZWxzZSBpZiAod2luZG93c3Bob25lKSB7XG4gICAgICByZXN1bHQgPSB7XG4gICAgICAgIG5hbWU6ICdXaW5kb3dzIFBob25lJ1xuICAgICAgLCBvc25hbWU6ICdXaW5kb3dzIFBob25lJ1xuICAgICAgLCB3aW5kb3dzcGhvbmU6IHRcbiAgICAgIH1cbiAgICAgIGlmIChlZGdlVmVyc2lvbikge1xuICAgICAgICByZXN1bHQubXNlZGdlID0gdFxuICAgICAgICByZXN1bHQudmVyc2lvbiA9IGVkZ2VWZXJzaW9uXG4gICAgICB9XG4gICAgICBlbHNlIHtcbiAgICAgICAgcmVzdWx0Lm1zaWUgPSB0XG4gICAgICAgIHJlc3VsdC52ZXJzaW9uID0gZ2V0Rmlyc3RNYXRjaCgvaWVtb2JpbGVcXC8oXFxkKyhcXC5cXGQrKT8pL2kpXG4gICAgICB9XG4gICAgfVxuICAgIGVsc2UgaWYgKC9tc2llfHRyaWRlbnQvaS50ZXN0KHVhKSkge1xuICAgICAgcmVzdWx0ID0ge1xuICAgICAgICBuYW1lOiAnSW50ZXJuZXQgRXhwbG9yZXInXG4gICAgICAsIG1zaWU6IHRcbiAgICAgICwgdmVyc2lvbjogZ2V0Rmlyc3RNYXRjaCgvKD86bXNpZSB8cnY6KShcXGQrKFxcLlxcZCspPykvaSlcbiAgICAgIH1cbiAgICB9IGVsc2UgaWYgKGNocm9tZW9zKSB7XG4gICAgICByZXN1bHQgPSB7XG4gICAgICAgIG5hbWU6ICdDaHJvbWUnXG4gICAgICAsIG9zbmFtZTogJ0Nocm9tZSBPUydcbiAgICAgICwgY2hyb21lb3M6IHRcbiAgICAgICwgY2hyb21lQm9vazogdFxuICAgICAgLCBjaHJvbWU6IHRcbiAgICAgICwgdmVyc2lvbjogZ2V0Rmlyc3RNYXRjaCgvKD86Y2hyb21lfGNyaW9zfGNybW8pXFwvKFxcZCsoXFwuXFxkKyk/KS9pKVxuICAgICAgfVxuICAgIH0gZWxzZSBpZiAoL2VkZyhbZWFdfGlvcykvaS50ZXN0KHVhKSkge1xuICAgICAgcmVzdWx0ID0ge1xuICAgICAgICBuYW1lOiAnTWljcm9zb2Z0IEVkZ2UnXG4gICAgICAsIG1zZWRnZTogdFxuICAgICAgLCB2ZXJzaW9uOiBlZGdlVmVyc2lvblxuICAgICAgfVxuICAgIH1cbiAgICBlbHNlIGlmICgvdml2YWxkaS9pLnRlc3QodWEpKSB7XG4gICAgICByZXN1bHQgPSB7XG4gICAgICAgIG5hbWU6ICdWaXZhbGRpJ1xuICAgICAgICAsIHZpdmFsZGk6IHRcbiAgICAgICAgLCB2ZXJzaW9uOiBnZXRGaXJzdE1hdGNoKC92aXZhbGRpXFwvKFxcZCsoXFwuXFxkKyk/KS9pKSB8fCB2ZXJzaW9uSWRlbnRpZmllclxuICAgICAgfVxuICAgIH1cbiAgICBlbHNlIGlmIChzYWlsZmlzaCkge1xuICAgICAgcmVzdWx0ID0ge1xuICAgICAgICBuYW1lOiAnU2FpbGZpc2gnXG4gICAgICAsIG9zbmFtZTogJ1NhaWxmaXNoIE9TJ1xuICAgICAgLCBzYWlsZmlzaDogdFxuICAgICAgLCB2ZXJzaW9uOiBnZXRGaXJzdE1hdGNoKC9zYWlsZmlzaFxccz9icm93c2VyXFwvKFxcZCsoXFwuXFxkKyk/KS9pKVxuICAgICAgfVxuICAgIH1cbiAgICBlbHNlIGlmICgvc2VhbW9ua2V5XFwvL2kudGVzdCh1YSkpIHtcbiAgICAgIHJlc3VsdCA9IHtcbiAgICAgICAgbmFtZTogJ1NlYU1vbmtleSdcbiAgICAgICwgc2VhbW9ua2V5OiB0XG4gICAgICAsIHZlcnNpb246IGdldEZpcnN0TWF0Y2goL3NlYW1vbmtleVxcLyhcXGQrKFxcLlxcZCspPykvaSlcbiAgICAgIH1cbiAgICB9XG4gICAgZWxzZSBpZiAoL2ZpcmVmb3h8aWNld2Vhc2VsfGZ4aW9zL2kudGVzdCh1YSkpIHtcbiAgICAgIHJlc3VsdCA9IHtcbiAgICAgICAgbmFtZTogJ0ZpcmVmb3gnXG4gICAgICAsIGZpcmVmb3g6IHRcbiAgICAgICwgdmVyc2lvbjogZ2V0Rmlyc3RNYXRjaCgvKD86ZmlyZWZveHxpY2V3ZWFzZWx8Znhpb3MpWyBcXC9dKFxcZCsoXFwuXFxkKyk/KS9pKVxuICAgICAgfVxuICAgICAgaWYgKC9cXCgobW9iaWxlfHRhYmxldCk7W15cXCldKnJ2OltcXGRcXC5dK1xcKS9pLnRlc3QodWEpKSB7XG4gICAgICAgIHJlc3VsdC5maXJlZm94b3MgPSB0XG4gICAgICAgIHJlc3VsdC5vc25hbWUgPSAnRmlyZWZveCBPUydcbiAgICAgIH1cbiAgICB9XG4gICAgZWxzZSBpZiAoc2lsaykge1xuICAgICAgcmVzdWx0ID0gIHtcbiAgICAgICAgbmFtZTogJ0FtYXpvbiBTaWxrJ1xuICAgICAgLCBzaWxrOiB0XG4gICAgICAsIHZlcnNpb24gOiBnZXRGaXJzdE1hdGNoKC9zaWxrXFwvKFxcZCsoXFwuXFxkKyk/KS9pKVxuICAgICAgfVxuICAgIH1cbiAgICBlbHNlIGlmICgvcGhhbnRvbS9pLnRlc3QodWEpKSB7XG4gICAgICByZXN1bHQgPSB7XG4gICAgICAgIG5hbWU6ICdQaGFudG9tSlMnXG4gICAgICAsIHBoYW50b206IHRcbiAgICAgICwgdmVyc2lvbjogZ2V0Rmlyc3RNYXRjaCgvcGhhbnRvbWpzXFwvKFxcZCsoXFwuXFxkKyk/KS9pKVxuICAgICAgfVxuICAgIH1cbiAgICBlbHNlIGlmICgvc2xpbWVyanMvaS50ZXN0KHVhKSkge1xuICAgICAgcmVzdWx0ID0ge1xuICAgICAgICBuYW1lOiAnU2xpbWVySlMnXG4gICAgICAgICwgc2xpbWVyOiB0XG4gICAgICAgICwgdmVyc2lvbjogZ2V0Rmlyc3RNYXRjaCgvc2xpbWVyanNcXC8oXFxkKyhcXC5cXGQrKT8pL2kpXG4gICAgICB9XG4gICAgfVxuICAgIGVsc2UgaWYgKC9ibGFja2JlcnJ5fFxcYmJiXFxkKy9pLnRlc3QodWEpIHx8IC9yaW1cXHN0YWJsZXQvaS50ZXN0KHVhKSkge1xuICAgICAgcmVzdWx0ID0ge1xuICAgICAgICBuYW1lOiAnQmxhY2tCZXJyeSdcbiAgICAgICwgb3NuYW1lOiAnQmxhY2tCZXJyeSBPUydcbiAgICAgICwgYmxhY2tiZXJyeTogdFxuICAgICAgLCB2ZXJzaW9uOiB2ZXJzaW9uSWRlbnRpZmllciB8fCBnZXRGaXJzdE1hdGNoKC9ibGFja2JlcnJ5W1xcZF0rXFwvKFxcZCsoXFwuXFxkKyk/KS9pKVxuICAgICAgfVxuICAgIH1cbiAgICBlbHNlIGlmICh3ZWJvcykge1xuICAgICAgcmVzdWx0ID0ge1xuICAgICAgICBuYW1lOiAnV2ViT1MnXG4gICAgICAsIG9zbmFtZTogJ1dlYk9TJ1xuICAgICAgLCB3ZWJvczogdFxuICAgICAgLCB2ZXJzaW9uOiB2ZXJzaW9uSWRlbnRpZmllciB8fCBnZXRGaXJzdE1hdGNoKC93KD86ZWIpP29zYnJvd3NlclxcLyhcXGQrKFxcLlxcZCspPykvaSlcbiAgICAgIH07XG4gICAgICAvdG91Y2hwYWRcXC8vaS50ZXN0KHVhKSAmJiAocmVzdWx0LnRvdWNocGFkID0gdClcbiAgICB9XG4gICAgZWxzZSBpZiAoL2JhZGEvaS50ZXN0KHVhKSkge1xuICAgICAgcmVzdWx0ID0ge1xuICAgICAgICBuYW1lOiAnQmFkYSdcbiAgICAgICwgb3NuYW1lOiAnQmFkYSdcbiAgICAgICwgYmFkYTogdFxuICAgICAgLCB2ZXJzaW9uOiBnZXRGaXJzdE1hdGNoKC9kb2xmaW5cXC8oXFxkKyhcXC5cXGQrKT8pL2kpXG4gICAgICB9O1xuICAgIH1cbiAgICBlbHNlIGlmICh0aXplbikge1xuICAgICAgcmVzdWx0ID0ge1xuICAgICAgICBuYW1lOiAnVGl6ZW4nXG4gICAgICAsIG9zbmFtZTogJ1RpemVuJ1xuICAgICAgLCB0aXplbjogdFxuICAgICAgLCB2ZXJzaW9uOiBnZXRGaXJzdE1hdGNoKC8oPzp0aXplblxccz8pP2Jyb3dzZXJcXC8oXFxkKyhcXC5cXGQrKT8pL2kpIHx8IHZlcnNpb25JZGVudGlmaWVyXG4gICAgICB9O1xuICAgIH1cbiAgICBlbHNlIGlmICgvcXVwemlsbGEvaS50ZXN0KHVhKSkge1xuICAgICAgcmVzdWx0ID0ge1xuICAgICAgICBuYW1lOiAnUXVwWmlsbGEnXG4gICAgICAgICwgcXVwemlsbGE6IHRcbiAgICAgICAgLCB2ZXJzaW9uOiBnZXRGaXJzdE1hdGNoKC8oPzpxdXB6aWxsYSlbXFxzXFwvXShcXGQrKD86XFwuXFxkKykrKS9pKSB8fCB2ZXJzaW9uSWRlbnRpZmllclxuICAgICAgfVxuICAgIH1cbiAgICBlbHNlIGlmICgvY2hyb21pdW0vaS50ZXN0KHVhKSkge1xuICAgICAgcmVzdWx0ID0ge1xuICAgICAgICBuYW1lOiAnQ2hyb21pdW0nXG4gICAgICAgICwgY2hyb21pdW06IHRcbiAgICAgICAgLCB2ZXJzaW9uOiBnZXRGaXJzdE1hdGNoKC8oPzpjaHJvbWl1bSlbXFxzXFwvXShcXGQrKD86XFwuXFxkKyk/KS9pKSB8fCB2ZXJzaW9uSWRlbnRpZmllclxuICAgICAgfVxuICAgIH1cbiAgICBlbHNlIGlmICgvY2hyb21lfGNyaW9zfGNybW8vaS50ZXN0KHVhKSkge1xuICAgICAgcmVzdWx0ID0ge1xuICAgICAgICBuYW1lOiAnQ2hyb21lJ1xuICAgICAgICAsIGNocm9tZTogdFxuICAgICAgICAsIHZlcnNpb246IGdldEZpcnN0TWF0Y2goLyg/OmNocm9tZXxjcmlvc3xjcm1vKVxcLyhcXGQrKFxcLlxcZCspPykvaSlcbiAgICAgIH1cbiAgICB9XG4gICAgZWxzZSBpZiAoYW5kcm9pZCkge1xuICAgICAgcmVzdWx0ID0ge1xuICAgICAgICBuYW1lOiAnQW5kcm9pZCdcbiAgICAgICAgLCB2ZXJzaW9uOiB2ZXJzaW9uSWRlbnRpZmllclxuICAgICAgfVxuICAgIH1cbiAgICBlbHNlIGlmICgvc2FmYXJpfGFwcGxld2Via2l0L2kudGVzdCh1YSkpIHtcbiAgICAgIHJlc3VsdCA9IHtcbiAgICAgICAgbmFtZTogJ1NhZmFyaSdcbiAgICAgICwgc2FmYXJpOiB0XG4gICAgICB9XG4gICAgICBpZiAodmVyc2lvbklkZW50aWZpZXIpIHtcbiAgICAgICAgcmVzdWx0LnZlcnNpb24gPSB2ZXJzaW9uSWRlbnRpZmllclxuICAgICAgfVxuICAgIH1cbiAgICBlbHNlIGlmIChpb3NkZXZpY2UpIHtcbiAgICAgIHJlc3VsdCA9IHtcbiAgICAgICAgbmFtZSA6IGlvc2RldmljZSA9PSAnaXBob25lJyA/ICdpUGhvbmUnIDogaW9zZGV2aWNlID09ICdpcGFkJyA/ICdpUGFkJyA6ICdpUG9kJ1xuICAgICAgfVxuICAgICAgLy8gV1RGOiB2ZXJzaW9uIGlzIG5vdCBwYXJ0IG9mIHVzZXIgYWdlbnQgaW4gd2ViIGFwcHNcbiAgICAgIGlmICh2ZXJzaW9uSWRlbnRpZmllcikge1xuICAgICAgICByZXN1bHQudmVyc2lvbiA9IHZlcnNpb25JZGVudGlmaWVyXG4gICAgICB9XG4gICAgfVxuICAgIGVsc2UgaWYoL2dvb2dsZWJvdC9pLnRlc3QodWEpKSB7XG4gICAgICByZXN1bHQgPSB7XG4gICAgICAgIG5hbWU6ICdHb29nbGVib3QnXG4gICAgICAsIGdvb2dsZWJvdDogdFxuICAgICAgLCB2ZXJzaW9uOiBnZXRGaXJzdE1hdGNoKC9nb29nbGVib3RcXC8oXFxkKyhcXC5cXGQrKSkvaSkgfHwgdmVyc2lvbklkZW50aWZpZXJcbiAgICAgIH1cbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICByZXN1bHQgPSB7XG4gICAgICAgIG5hbWU6IGdldEZpcnN0TWF0Y2goL14oLiopXFwvKC4qKSAvKSxcbiAgICAgICAgdmVyc2lvbjogZ2V0U2Vjb25kTWF0Y2goL14oLiopXFwvKC4qKSAvKVxuICAgICB9O1xuICAgfVxuXG4gICAgLy8gc2V0IHdlYmtpdCBvciBnZWNrbyBmbGFnIGZvciBicm93c2VycyBiYXNlZCBvbiB0aGVzZSBlbmdpbmVzXG4gICAgaWYgKCFyZXN1bHQubXNlZGdlICYmIC8oYXBwbGUpP3dlYmtpdC9pLnRlc3QodWEpKSB7XG4gICAgICBpZiAoLyhhcHBsZSk/d2Via2l0XFwvNTM3XFwuMzYvaS50ZXN0KHVhKSkge1xuICAgICAgICByZXN1bHQubmFtZSA9IHJlc3VsdC5uYW1lIHx8IFwiQmxpbmtcIlxuICAgICAgICByZXN1bHQuYmxpbmsgPSB0XG4gICAgICB9IGVsc2Uge1xuICAgICAgICByZXN1bHQubmFtZSA9IHJlc3VsdC5uYW1lIHx8IFwiV2Via2l0XCJcbiAgICAgICAgcmVzdWx0LndlYmtpdCA9IHRcbiAgICAgIH1cbiAgICAgIGlmICghcmVzdWx0LnZlcnNpb24gJiYgdmVyc2lvbklkZW50aWZpZXIpIHtcbiAgICAgICAgcmVzdWx0LnZlcnNpb24gPSB2ZXJzaW9uSWRlbnRpZmllclxuICAgICAgfVxuICAgIH0gZWxzZSBpZiAoIXJlc3VsdC5vcGVyYSAmJiAvZ2Vja29cXC8vaS50ZXN0KHVhKSkge1xuICAgICAgcmVzdWx0Lm5hbWUgPSByZXN1bHQubmFtZSB8fCBcIkdlY2tvXCJcbiAgICAgIHJlc3VsdC5nZWNrbyA9IHRcbiAgICAgIHJlc3VsdC52ZXJzaW9uID0gcmVzdWx0LnZlcnNpb24gfHwgZ2V0Rmlyc3RNYXRjaCgvZ2Vja29cXC8oXFxkKyhcXC5cXGQrKT8pL2kpXG4gICAgfVxuXG4gICAgLy8gc2V0IE9TIGZsYWdzIGZvciBwbGF0Zm9ybXMgdGhhdCBoYXZlIG11bHRpcGxlIGJyb3dzZXJzXG4gICAgaWYgKCFyZXN1bHQud2luZG93c3Bob25lICYmIChhbmRyb2lkIHx8IHJlc3VsdC5zaWxrKSkge1xuICAgICAgcmVzdWx0LmFuZHJvaWQgPSB0XG4gICAgICByZXN1bHQub3NuYW1lID0gJ0FuZHJvaWQnXG4gICAgfSBlbHNlIGlmICghcmVzdWx0LndpbmRvd3NwaG9uZSAmJiBpb3NkZXZpY2UpIHtcbiAgICAgIHJlc3VsdFtpb3NkZXZpY2VdID0gdFxuICAgICAgcmVzdWx0LmlvcyA9IHRcbiAgICAgIHJlc3VsdC5vc25hbWUgPSAnaU9TJ1xuICAgIH0gZWxzZSBpZiAobWFjKSB7XG4gICAgICByZXN1bHQubWFjID0gdFxuICAgICAgcmVzdWx0Lm9zbmFtZSA9ICdtYWNPUydcbiAgICB9IGVsc2UgaWYgKHhib3gpIHtcbiAgICAgIHJlc3VsdC54Ym94ID0gdFxuICAgICAgcmVzdWx0Lm9zbmFtZSA9ICdYYm94J1xuICAgIH0gZWxzZSBpZiAod2luZG93cykge1xuICAgICAgcmVzdWx0LndpbmRvd3MgPSB0XG4gICAgICByZXN1bHQub3NuYW1lID0gJ1dpbmRvd3MnXG4gICAgfSBlbHNlIGlmIChsaW51eCkge1xuICAgICAgcmVzdWx0LmxpbnV4ID0gdFxuICAgICAgcmVzdWx0Lm9zbmFtZSA9ICdMaW51eCdcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBnZXRXaW5kb3dzVmVyc2lvbiAocykge1xuICAgICAgc3dpdGNoIChzKSB7XG4gICAgICAgIGNhc2UgJ05UJzogcmV0dXJuICdOVCdcbiAgICAgICAgY2FzZSAnWFAnOiByZXR1cm4gJ1hQJ1xuICAgICAgICBjYXNlICdOVCA1LjAnOiByZXR1cm4gJzIwMDAnXG4gICAgICAgIGNhc2UgJ05UIDUuMSc6IHJldHVybiAnWFAnXG4gICAgICAgIGNhc2UgJ05UIDUuMic6IHJldHVybiAnMjAwMydcbiAgICAgICAgY2FzZSAnTlQgNi4wJzogcmV0dXJuICdWaXN0YSdcbiAgICAgICAgY2FzZSAnTlQgNi4xJzogcmV0dXJuICc3J1xuICAgICAgICBjYXNlICdOVCA2LjInOiByZXR1cm4gJzgnXG4gICAgICAgIGNhc2UgJ05UIDYuMyc6IHJldHVybiAnOC4xJ1xuICAgICAgICBjYXNlICdOVCAxMC4wJzogcmV0dXJuICcxMCdcbiAgICAgICAgZGVmYXVsdDogcmV0dXJuIHVuZGVmaW5lZFxuICAgICAgfVxuICAgIH1cblxuICAgIC8vIE9TIHZlcnNpb24gZXh0cmFjdGlvblxuICAgIHZhciBvc1ZlcnNpb24gPSAnJztcbiAgICBpZiAocmVzdWx0LndpbmRvd3MpIHtcbiAgICAgIG9zVmVyc2lvbiA9IGdldFdpbmRvd3NWZXJzaW9uKGdldEZpcnN0TWF0Y2goL1dpbmRvd3MgKChOVHxYUCkoIFxcZFxcZD8uXFxkKT8pL2kpKVxuICAgIH0gZWxzZSBpZiAocmVzdWx0LndpbmRvd3NwaG9uZSkge1xuICAgICAgb3NWZXJzaW9uID0gZ2V0Rmlyc3RNYXRjaCgvd2luZG93cyBwaG9uZSAoPzpvcyk/XFxzPyhcXGQrKFxcLlxcZCspKikvaSk7XG4gICAgfSBlbHNlIGlmIChyZXN1bHQubWFjKSB7XG4gICAgICBvc1ZlcnNpb24gPSBnZXRGaXJzdE1hdGNoKC9NYWMgT1MgWCAoXFxkKyhbX1xcLlxcc11cXGQrKSopL2kpO1xuICAgICAgb3NWZXJzaW9uID0gb3NWZXJzaW9uLnJlcGxhY2UoL1tfXFxzXS9nLCAnLicpO1xuICAgIH0gZWxzZSBpZiAoaW9zZGV2aWNlKSB7XG4gICAgICBvc1ZlcnNpb24gPSBnZXRGaXJzdE1hdGNoKC9vcyAoXFxkKyhbX1xcc11cXGQrKSopIGxpa2UgbWFjIG9zIHgvaSk7XG4gICAgICBvc1ZlcnNpb24gPSBvc1ZlcnNpb24ucmVwbGFjZSgvW19cXHNdL2csICcuJyk7XG4gICAgfSBlbHNlIGlmIChhbmRyb2lkKSB7XG4gICAgICBvc1ZlcnNpb24gPSBnZXRGaXJzdE1hdGNoKC9hbmRyb2lkWyBcXC8tXShcXGQrKFxcLlxcZCspKikvaSk7XG4gICAgfSBlbHNlIGlmIChyZXN1bHQud2Vib3MpIHtcbiAgICAgIG9zVmVyc2lvbiA9IGdldEZpcnN0TWF0Y2goLyg/OndlYnxocHcpb3NcXC8oXFxkKyhcXC5cXGQrKSopL2kpO1xuICAgIH0gZWxzZSBpZiAocmVzdWx0LmJsYWNrYmVycnkpIHtcbiAgICAgIG9zVmVyc2lvbiA9IGdldEZpcnN0TWF0Y2goL3JpbVxcc3RhYmxldFxcc29zXFxzKFxcZCsoXFwuXFxkKykqKS9pKTtcbiAgICB9IGVsc2UgaWYgKHJlc3VsdC5iYWRhKSB7XG4gICAgICBvc1ZlcnNpb24gPSBnZXRGaXJzdE1hdGNoKC9iYWRhXFwvKFxcZCsoXFwuXFxkKykqKS9pKTtcbiAgICB9IGVsc2UgaWYgKHJlc3VsdC50aXplbikge1xuICAgICAgb3NWZXJzaW9uID0gZ2V0Rmlyc3RNYXRjaCgvdGl6ZW5bXFwvXFxzXShcXGQrKFxcLlxcZCspKikvaSk7XG4gICAgfVxuICAgIGlmIChvc1ZlcnNpb24pIHtcbiAgICAgIHJlc3VsdC5vc3ZlcnNpb24gPSBvc1ZlcnNpb247XG4gICAgfVxuXG4gICAgLy8gZGV2aWNlIHR5cGUgZXh0cmFjdGlvblxuICAgIHZhciBvc01ham9yVmVyc2lvbiA9ICFyZXN1bHQud2luZG93cyAmJiBvc1ZlcnNpb24uc3BsaXQoJy4nKVswXTtcbiAgICBpZiAoXG4gICAgICAgICB0YWJsZXRcbiAgICAgIHx8IG5leHVzVGFibGV0XG4gICAgICB8fCBpb3NkZXZpY2UgPT0gJ2lwYWQnXG4gICAgICB8fCAoYW5kcm9pZCAmJiAob3NNYWpvclZlcnNpb24gPT0gMyB8fCAob3NNYWpvclZlcnNpb24gPj0gNCAmJiAhbW9iaWxlKSkpXG4gICAgICB8fCByZXN1bHQuc2lsa1xuICAgICkge1xuICAgICAgcmVzdWx0LnRhYmxldCA9IHRcbiAgICB9IGVsc2UgaWYgKFxuICAgICAgICAgbW9iaWxlXG4gICAgICB8fCBpb3NkZXZpY2UgPT0gJ2lwaG9uZSdcbiAgICAgIHx8IGlvc2RldmljZSA9PSAnaXBvZCdcbiAgICAgIHx8IGFuZHJvaWRcbiAgICAgIHx8IG5leHVzTW9iaWxlXG4gICAgICB8fCByZXN1bHQuYmxhY2tiZXJyeVxuICAgICAgfHwgcmVzdWx0LndlYm9zXG4gICAgICB8fCByZXN1bHQuYmFkYVxuICAgICkge1xuICAgICAgcmVzdWx0Lm1vYmlsZSA9IHRcbiAgICB9XG5cbiAgICAvLyBHcmFkZWQgQnJvd3NlciBTdXBwb3J0XG4gICAgLy8gaHR0cDovL2RldmVsb3Blci55YWhvby5jb20veXVpL2FydGljbGVzL2dic1xuICAgIGlmIChyZXN1bHQubXNlZGdlIHx8XG4gICAgICAgIChyZXN1bHQubXNpZSAmJiByZXN1bHQudmVyc2lvbiA+PSAxMCkgfHxcbiAgICAgICAgKHJlc3VsdC55YW5kZXhicm93c2VyICYmIHJlc3VsdC52ZXJzaW9uID49IDE1KSB8fFxuXHRcdCAgICAocmVzdWx0LnZpdmFsZGkgJiYgcmVzdWx0LnZlcnNpb24gPj0gMS4wKSB8fFxuICAgICAgICAocmVzdWx0LmNocm9tZSAmJiByZXN1bHQudmVyc2lvbiA+PSAyMCkgfHxcbiAgICAgICAgKHJlc3VsdC5zYW1zdW5nQnJvd3NlciAmJiByZXN1bHQudmVyc2lvbiA+PSA0KSB8fFxuICAgICAgICAocmVzdWx0LmZpcmVmb3ggJiYgcmVzdWx0LnZlcnNpb24gPj0gMjAuMCkgfHxcbiAgICAgICAgKHJlc3VsdC5zYWZhcmkgJiYgcmVzdWx0LnZlcnNpb24gPj0gNikgfHxcbiAgICAgICAgKHJlc3VsdC5vcGVyYSAmJiByZXN1bHQudmVyc2lvbiA+PSAxMC4wKSB8fFxuICAgICAgICAocmVzdWx0LmlvcyAmJiByZXN1bHQub3N2ZXJzaW9uICYmIHJlc3VsdC5vc3ZlcnNpb24uc3BsaXQoXCIuXCIpWzBdID49IDYpIHx8XG4gICAgICAgIChyZXN1bHQuYmxhY2tiZXJyeSAmJiByZXN1bHQudmVyc2lvbiA+PSAxMC4xKVxuICAgICAgICB8fCAocmVzdWx0LmNocm9taXVtICYmIHJlc3VsdC52ZXJzaW9uID49IDIwKVxuICAgICAgICApIHtcbiAgICAgIHJlc3VsdC5hID0gdDtcbiAgICB9XG4gICAgZWxzZSBpZiAoKHJlc3VsdC5tc2llICYmIHJlc3VsdC52ZXJzaW9uIDwgMTApIHx8XG4gICAgICAgIChyZXN1bHQuY2hyb21lICYmIHJlc3VsdC52ZXJzaW9uIDwgMjApIHx8XG4gICAgICAgIChyZXN1bHQuZmlyZWZveCAmJiByZXN1bHQudmVyc2lvbiA8IDIwLjApIHx8XG4gICAgICAgIChyZXN1bHQuc2FmYXJpICYmIHJlc3VsdC52ZXJzaW9uIDwgNikgfHxcbiAgICAgICAgKHJlc3VsdC5vcGVyYSAmJiByZXN1bHQudmVyc2lvbiA8IDEwLjApIHx8XG4gICAgICAgIChyZXN1bHQuaW9zICYmIHJlc3VsdC5vc3ZlcnNpb24gJiYgcmVzdWx0Lm9zdmVyc2lvbi5zcGxpdChcIi5cIilbMF0gPCA2KVxuICAgICAgICB8fCAocmVzdWx0LmNocm9taXVtICYmIHJlc3VsdC52ZXJzaW9uIDwgMjApXG4gICAgICAgICkge1xuICAgICAgcmVzdWx0LmMgPSB0XG4gICAgfSBlbHNlIHJlc3VsdC54ID0gdFxuXG4gICAgcmV0dXJuIHJlc3VsdFxuICB9XG5cbiAgdmFyIGJvd3NlciA9IGRldGVjdCh0eXBlb2YgbmF2aWdhdG9yICE9PSAndW5kZWZpbmVkJyA/IG5hdmlnYXRvci51c2VyQWdlbnQgfHwgJycgOiAnJylcblxuICBib3dzZXIudGVzdCA9IGZ1bmN0aW9uIChicm93c2VyTGlzdCkge1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgYnJvd3Nlckxpc3QubGVuZ3RoOyArK2kpIHtcbiAgICAgIHZhciBicm93c2VySXRlbSA9IGJyb3dzZXJMaXN0W2ldO1xuICAgICAgaWYgKHR5cGVvZiBicm93c2VySXRlbT09PSAnc3RyaW5nJykge1xuICAgICAgICBpZiAoYnJvd3Nlckl0ZW0gaW4gYm93c2VyKSB7XG4gICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG5cbiAgLyoqXG4gICAqIEdldCB2ZXJzaW9uIHByZWNpc2lvbnMgY291bnRcbiAgICpcbiAgICogQGV4YW1wbGVcbiAgICogICBnZXRWZXJzaW9uUHJlY2lzaW9uKFwiMS4xMC4zXCIpIC8vIDNcbiAgICpcbiAgICogQHBhcmFtICB7c3RyaW5nfSB2ZXJzaW9uXG4gICAqIEByZXR1cm4ge251bWJlcn1cbiAgICovXG4gIGZ1bmN0aW9uIGdldFZlcnNpb25QcmVjaXNpb24odmVyc2lvbikge1xuICAgIHJldHVybiB2ZXJzaW9uLnNwbGl0KFwiLlwiKS5sZW5ndGg7XG4gIH1cblxuICAvKipcbiAgICogQXJyYXk6Om1hcCBwb2x5ZmlsbFxuICAgKlxuICAgKiBAcGFyYW0gIHtBcnJheX0gYXJyXG4gICAqIEBwYXJhbSAge0Z1bmN0aW9ufSBpdGVyYXRvclxuICAgKiBAcmV0dXJuIHtBcnJheX1cbiAgICovXG4gIGZ1bmN0aW9uIG1hcChhcnIsIGl0ZXJhdG9yKSB7XG4gICAgdmFyIHJlc3VsdCA9IFtdLCBpO1xuICAgIGlmIChBcnJheS5wcm90b3R5cGUubWFwKSB7XG4gICAgICByZXR1cm4gQXJyYXkucHJvdG90eXBlLm1hcC5jYWxsKGFyciwgaXRlcmF0b3IpO1xuICAgIH1cbiAgICBmb3IgKGkgPSAwOyBpIDwgYXJyLmxlbmd0aDsgaSsrKSB7XG4gICAgICByZXN1bHQucHVzaChpdGVyYXRvcihhcnJbaV0pKTtcbiAgICB9XG4gICAgcmV0dXJuIHJlc3VsdDtcbiAgfVxuXG4gIC8qKlxuICAgKiBDYWxjdWxhdGUgYnJvd3NlciB2ZXJzaW9uIHdlaWdodFxuICAgKlxuICAgKiBAZXhhbXBsZVxuICAgKiAgIGNvbXBhcmVWZXJzaW9ucyhbJzEuMTAuMi4xJywgICcxLjguMi4xLjkwJ10pICAgIC8vIDFcbiAgICogICBjb21wYXJlVmVyc2lvbnMoWycxLjAxMC4yLjEnLCAnMS4wOS4yLjEuOTAnXSk7ICAvLyAxXG4gICAqICAgY29tcGFyZVZlcnNpb25zKFsnMS4xMC4yLjEnLCAgJzEuMTAuMi4xJ10pOyAgICAgLy8gMFxuICAgKiAgIGNvbXBhcmVWZXJzaW9ucyhbJzEuMTAuMi4xJywgICcxLjA4MDAuMiddKTsgICAgIC8vIC0xXG4gICAqXG4gICAqIEBwYXJhbSAge0FycmF5PFN0cmluZz59IHZlcnNpb25zIHZlcnNpb25zIHRvIGNvbXBhcmVcbiAgICogQHJldHVybiB7TnVtYmVyfSBjb21wYXJpc29uIHJlc3VsdFxuICAgKi9cbiAgZnVuY3Rpb24gY29tcGFyZVZlcnNpb25zKHZlcnNpb25zKSB7XG4gICAgLy8gMSkgZ2V0IGNvbW1vbiBwcmVjaXNpb24gZm9yIGJvdGggdmVyc2lvbnMsIGZvciBleGFtcGxlIGZvciBcIjEwLjBcIiBhbmQgXCI5XCIgaXQgc2hvdWxkIGJlIDJcbiAgICB2YXIgcHJlY2lzaW9uID0gTWF0aC5tYXgoZ2V0VmVyc2lvblByZWNpc2lvbih2ZXJzaW9uc1swXSksIGdldFZlcnNpb25QcmVjaXNpb24odmVyc2lvbnNbMV0pKTtcbiAgICB2YXIgY2h1bmtzID0gbWFwKHZlcnNpb25zLCBmdW5jdGlvbiAodmVyc2lvbikge1xuICAgICAgdmFyIGRlbHRhID0gcHJlY2lzaW9uIC0gZ2V0VmVyc2lvblByZWNpc2lvbih2ZXJzaW9uKTtcblxuICAgICAgLy8gMikgXCI5XCIgLT4gXCI5LjBcIiAoZm9yIHByZWNpc2lvbiA9IDIpXG4gICAgICB2ZXJzaW9uID0gdmVyc2lvbiArIG5ldyBBcnJheShkZWx0YSArIDEpLmpvaW4oXCIuMFwiKTtcblxuICAgICAgLy8gMykgXCI5LjBcIiAtPiBbXCIwMDAwMDAwMDBcIlwiLCBcIjAwMDAwMDAwOVwiXVxuICAgICAgcmV0dXJuIG1hcCh2ZXJzaW9uLnNwbGl0KFwiLlwiKSwgZnVuY3Rpb24gKGNodW5rKSB7XG4gICAgICAgIHJldHVybiBuZXcgQXJyYXkoMjAgLSBjaHVuay5sZW5ndGgpLmpvaW4oXCIwXCIpICsgY2h1bms7XG4gICAgICB9KS5yZXZlcnNlKCk7XG4gICAgfSk7XG5cbiAgICAvLyBpdGVyYXRlIGluIHJldmVyc2Ugb3JkZXIgYnkgcmV2ZXJzZWQgY2h1bmtzIGFycmF5XG4gICAgd2hpbGUgKC0tcHJlY2lzaW9uID49IDApIHtcbiAgICAgIC8vIDQpIGNvbXBhcmU6IFwiMDAwMDAwMDA5XCIgPiBcIjAwMDAwMDAxMFwiID0gZmFsc2UgKGJ1dCBcIjlcIiA+IFwiMTBcIiA9IHRydWUpXG4gICAgICBpZiAoY2h1bmtzWzBdW3ByZWNpc2lvbl0gPiBjaHVua3NbMV1bcHJlY2lzaW9uXSkge1xuICAgICAgICByZXR1cm4gMTtcbiAgICAgIH1cbiAgICAgIGVsc2UgaWYgKGNodW5rc1swXVtwcmVjaXNpb25dID09PSBjaHVua3NbMV1bcHJlY2lzaW9uXSkge1xuICAgICAgICBpZiAocHJlY2lzaW9uID09PSAwKSB7XG4gICAgICAgICAgLy8gYWxsIHZlcnNpb24gY2h1bmtzIGFyZSBzYW1lXG4gICAgICAgICAgcmV0dXJuIDA7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGVsc2Uge1xuICAgICAgICByZXR1cm4gLTE7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIENoZWNrIGlmIGJyb3dzZXIgaXMgdW5zdXBwb3J0ZWRcbiAgICpcbiAgICogQGV4YW1wbGVcbiAgICogICBib3dzZXIuaXNVbnN1cHBvcnRlZEJyb3dzZXIoe1xuICAgKiAgICAgbXNpZTogXCIxMFwiLFxuICAgKiAgICAgZmlyZWZveDogXCIyM1wiLFxuICAgKiAgICAgY2hyb21lOiBcIjI5XCIsXG4gICAqICAgICBzYWZhcmk6IFwiNS4xXCIsXG4gICAqICAgICBvcGVyYTogXCIxNlwiLFxuICAgKiAgICAgcGhhbnRvbTogXCI1MzRcIlxuICAgKiAgIH0pO1xuICAgKlxuICAgKiBAcGFyYW0gIHtPYmplY3R9ICBtaW5WZXJzaW9ucyBtYXAgb2YgbWluaW1hbCB2ZXJzaW9uIHRvIGJyb3dzZXJcbiAgICogQHBhcmFtICB7Qm9vbGVhbn0gW3N0cmljdE1vZGUgPSBmYWxzZV0gZmxhZyB0byByZXR1cm4gZmFsc2UgaWYgYnJvd3NlciB3YXNuJ3QgZm91bmQgaW4gbWFwXG4gICAqIEBwYXJhbSAge1N0cmluZ30gIFt1YV0gdXNlciBhZ2VudCBzdHJpbmdcbiAgICogQHJldHVybiB7Qm9vbGVhbn1cbiAgICovXG4gIGZ1bmN0aW9uIGlzVW5zdXBwb3J0ZWRCcm93c2VyKG1pblZlcnNpb25zLCBzdHJpY3RNb2RlLCB1YSkge1xuICAgIHZhciBfYm93c2VyID0gYm93c2VyO1xuXG4gICAgLy8gbWFrZSBzdHJpY3RNb2RlIHBhcmFtIG9wdGlvbmFsIHdpdGggdWEgcGFyYW0gdXNhZ2VcbiAgICBpZiAodHlwZW9mIHN0cmljdE1vZGUgPT09ICdzdHJpbmcnKSB7XG4gICAgICB1YSA9IHN0cmljdE1vZGU7XG4gICAgICBzdHJpY3RNb2RlID0gdm9pZCgwKTtcbiAgICB9XG5cbiAgICBpZiAoc3RyaWN0TW9kZSA9PT0gdm9pZCgwKSkge1xuICAgICAgc3RyaWN0TW9kZSA9IGZhbHNlO1xuICAgIH1cbiAgICBpZiAodWEpIHtcbiAgICAgIF9ib3dzZXIgPSBkZXRlY3QodWEpO1xuICAgIH1cblxuICAgIHZhciB2ZXJzaW9uID0gXCJcIiArIF9ib3dzZXIudmVyc2lvbjtcbiAgICBmb3IgKHZhciBicm93c2VyIGluIG1pblZlcnNpb25zKSB7XG4gICAgICBpZiAobWluVmVyc2lvbnMuaGFzT3duUHJvcGVydHkoYnJvd3NlcikpIHtcbiAgICAgICAgaWYgKF9ib3dzZXJbYnJvd3Nlcl0pIHtcbiAgICAgICAgICBpZiAodHlwZW9mIG1pblZlcnNpb25zW2Jyb3dzZXJdICE9PSAnc3RyaW5nJykge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdCcm93c2VyIHZlcnNpb24gaW4gdGhlIG1pblZlcnNpb24gbWFwIHNob3VsZCBiZSBhIHN0cmluZzogJyArIGJyb3dzZXIgKyAnOiAnICsgU3RyaW5nKG1pblZlcnNpb25zKSk7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgLy8gYnJvd3NlciB2ZXJzaW9uIGFuZCBtaW4gc3VwcG9ydGVkIHZlcnNpb24uXG4gICAgICAgICAgcmV0dXJuIGNvbXBhcmVWZXJzaW9ucyhbdmVyc2lvbiwgbWluVmVyc2lvbnNbYnJvd3Nlcl1dKSA8IDA7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gc3RyaWN0TW9kZTsgLy8gbm90IGZvdW5kXG4gIH1cblxuICAvKipcbiAgICogQ2hlY2sgaWYgYnJvd3NlciBpcyBzdXBwb3J0ZWRcbiAgICpcbiAgICogQHBhcmFtICB7T2JqZWN0fSBtaW5WZXJzaW9ucyBtYXAgb2YgbWluaW1hbCB2ZXJzaW9uIHRvIGJyb3dzZXJcbiAgICogQHBhcmFtICB7Qm9vbGVhbn0gW3N0cmljdE1vZGUgPSBmYWxzZV0gZmxhZyB0byByZXR1cm4gZmFsc2UgaWYgYnJvd3NlciB3YXNuJ3QgZm91bmQgaW4gbWFwXG4gICAqIEBwYXJhbSAge1N0cmluZ30gIFt1YV0gdXNlciBhZ2VudCBzdHJpbmdcbiAgICogQHJldHVybiB7Qm9vbGVhbn1cbiAgICovXG4gIGZ1bmN0aW9uIGNoZWNrKG1pblZlcnNpb25zLCBzdHJpY3RNb2RlLCB1YSkge1xuICAgIHJldHVybiAhaXNVbnN1cHBvcnRlZEJyb3dzZXIobWluVmVyc2lvbnMsIHN0cmljdE1vZGUsIHVhKTtcbiAgfVxuXG4gIGJvd3Nlci5pc1Vuc3VwcG9ydGVkQnJvd3NlciA9IGlzVW5zdXBwb3J0ZWRCcm93c2VyO1xuICBib3dzZXIuY29tcGFyZVZlcnNpb25zID0gY29tcGFyZVZlcnNpb25zO1xuICBib3dzZXIuY2hlY2sgPSBjaGVjaztcblxuICAvKlxuICAgKiBTZXQgb3VyIGRldGVjdCBtZXRob2QgdG8gdGhlIG1haW4gYm93c2VyIG9iamVjdCBzbyB3ZSBjYW5cbiAgICogcmV1c2UgaXQgdG8gdGVzdCBvdGhlciB1c2VyIGFnZW50cy5cbiAgICogVGhpcyBpcyBuZWVkZWQgdG8gaW1wbGVtZW50IGZ1dHVyZSB0ZXN0cy5cbiAgICovXG4gIGJvd3Nlci5fZGV0ZWN0ID0gZGV0ZWN0O1xuXG4gIC8qXG4gICAqIFNldCBvdXIgZGV0ZWN0IHB1YmxpYyBtZXRob2QgdG8gdGhlIG1haW4gYm93c2VyIG9iamVjdFxuICAgKiBUaGlzIGlzIG5lZWRlZCB0byBpbXBsZW1lbnQgYm93c2VyIGluIHNlcnZlciBzaWRlXG4gICAqL1xuICBib3dzZXIuZGV0ZWN0ID0gZGV0ZWN0O1xuICByZXR1cm4gYm93c2VyXG59KTtcbiIsIi8vIENvcHlyaWdodCBKb3llbnQsIEluYy4gYW5kIG90aGVyIE5vZGUgY29udHJpYnV0b3JzLlxuLy9cbi8vIFBlcm1pc3Npb24gaXMgaGVyZWJ5IGdyYW50ZWQsIGZyZWUgb2YgY2hhcmdlLCB0byBhbnkgcGVyc29uIG9idGFpbmluZyBhXG4vLyBjb3B5IG9mIHRoaXMgc29mdHdhcmUgYW5kIGFzc29jaWF0ZWQgZG9jdW1lbnRhdGlvbiBmaWxlcyAodGhlXG4vLyBcIlNvZnR3YXJlXCIpLCB0byBkZWFsIGluIHRoZSBTb2Z0d2FyZSB3aXRob3V0IHJlc3RyaWN0aW9uLCBpbmNsdWRpbmdcbi8vIHdpdGhvdXQgbGltaXRhdGlvbiB0aGUgcmlnaHRzIHRvIHVzZSwgY29weSwgbW9kaWZ5LCBtZXJnZSwgcHVibGlzaCxcbi8vIGRpc3RyaWJ1dGUsIHN1YmxpY2Vuc2UsIGFuZC9vciBzZWxsIGNvcGllcyBvZiB0aGUgU29mdHdhcmUsIGFuZCB0byBwZXJtaXRcbi8vIHBlcnNvbnMgdG8gd2hvbSB0aGUgU29mdHdhcmUgaXMgZnVybmlzaGVkIHRvIGRvIHNvLCBzdWJqZWN0IHRvIHRoZVxuLy8gZm9sbG93aW5nIGNvbmRpdGlvbnM6XG4vL1xuLy8gVGhlIGFib3ZlIGNvcHlyaWdodCBub3RpY2UgYW5kIHRoaXMgcGVybWlzc2lvbiBub3RpY2Ugc2hhbGwgYmUgaW5jbHVkZWRcbi8vIGluIGFsbCBjb3BpZXMgb3Igc3Vic3RhbnRpYWwgcG9ydGlvbnMgb2YgdGhlIFNvZnR3YXJlLlxuLy9cbi8vIFRIRSBTT0ZUV0FSRSBJUyBQUk9WSURFRCBcIkFTIElTXCIsIFdJVEhPVVQgV0FSUkFOVFkgT0YgQU5ZIEtJTkQsIEVYUFJFU1Ncbi8vIE9SIElNUExJRUQsIElOQ0xVRElORyBCVVQgTk9UIExJTUlURUQgVE8gVEhFIFdBUlJBTlRJRVMgT0Zcbi8vIE1FUkNIQU5UQUJJTElUWSwgRklUTkVTUyBGT1IgQSBQQVJUSUNVTEFSIFBVUlBPU0UgQU5EIE5PTklORlJJTkdFTUVOVC4gSU5cbi8vIE5PIEVWRU5UIFNIQUxMIFRIRSBBVVRIT1JTIE9SIENPUFlSSUdIVCBIT0xERVJTIEJFIExJQUJMRSBGT1IgQU5ZIENMQUlNLFxuLy8gREFNQUdFUyBPUiBPVEhFUiBMSUFCSUxJVFksIFdIRVRIRVIgSU4gQU4gQUNUSU9OIE9GIENPTlRSQUNULCBUT1JUIE9SXG4vLyBPVEhFUldJU0UsIEFSSVNJTkcgRlJPTSwgT1VUIE9GIE9SIElOIENPTk5FQ1RJT04gV0lUSCBUSEUgU09GVFdBUkUgT1IgVEhFXG4vLyBVU0UgT1IgT1RIRVIgREVBTElOR1MgSU4gVEhFIFNPRlRXQVJFLlxuXG52YXIgb2JqZWN0Q3JlYXRlID0gT2JqZWN0LmNyZWF0ZSB8fCBvYmplY3RDcmVhdGVQb2x5ZmlsbFxudmFyIG9iamVjdEtleXMgPSBPYmplY3Qua2V5cyB8fCBvYmplY3RLZXlzUG9seWZpbGxcbnZhciBiaW5kID0gRnVuY3Rpb24ucHJvdG90eXBlLmJpbmQgfHwgZnVuY3Rpb25CaW5kUG9seWZpbGxcblxuZnVuY3Rpb24gRXZlbnRFbWl0dGVyKCkge1xuICBpZiAoIXRoaXMuX2V2ZW50cyB8fCAhT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKHRoaXMsICdfZXZlbnRzJykpIHtcbiAgICB0aGlzLl9ldmVudHMgPSBvYmplY3RDcmVhdGUobnVsbCk7XG4gICAgdGhpcy5fZXZlbnRzQ291bnQgPSAwO1xuICB9XG5cbiAgdGhpcy5fbWF4TGlzdGVuZXJzID0gdGhpcy5fbWF4TGlzdGVuZXJzIHx8IHVuZGVmaW5lZDtcbn1cbm1vZHVsZS5leHBvcnRzID0gRXZlbnRFbWl0dGVyO1xuXG4vLyBCYWNrd2FyZHMtY29tcGF0IHdpdGggbm9kZSAwLjEwLnhcbkV2ZW50RW1pdHRlci5FdmVudEVtaXR0ZXIgPSBFdmVudEVtaXR0ZXI7XG5cbkV2ZW50RW1pdHRlci5wcm90b3R5cGUuX2V2ZW50cyA9IHVuZGVmaW5lZDtcbkV2ZW50RW1pdHRlci5wcm90b3R5cGUuX21heExpc3RlbmVycyA9IHVuZGVmaW5lZDtcblxuLy8gQnkgZGVmYXVsdCBFdmVudEVtaXR0ZXJzIHdpbGwgcHJpbnQgYSB3YXJuaW5nIGlmIG1vcmUgdGhhbiAxMCBsaXN0ZW5lcnMgYXJlXG4vLyBhZGRlZCB0byBpdC4gVGhpcyBpcyBhIHVzZWZ1bCBkZWZhdWx0IHdoaWNoIGhlbHBzIGZpbmRpbmcgbWVtb3J5IGxlYWtzLlxudmFyIGRlZmF1bHRNYXhMaXN0ZW5lcnMgPSAxMDtcblxudmFyIGhhc0RlZmluZVByb3BlcnR5O1xudHJ5IHtcbiAgdmFyIG8gPSB7fTtcbiAgaWYgKE9iamVjdC5kZWZpbmVQcm9wZXJ0eSkgT2JqZWN0LmRlZmluZVByb3BlcnR5KG8sICd4JywgeyB2YWx1ZTogMCB9KTtcbiAgaGFzRGVmaW5lUHJvcGVydHkgPSBvLnggPT09IDA7XG59IGNhdGNoIChlcnIpIHsgaGFzRGVmaW5lUHJvcGVydHkgPSBmYWxzZSB9XG5pZiAoaGFzRGVmaW5lUHJvcGVydHkpIHtcbiAgT2JqZWN0LmRlZmluZVByb3BlcnR5KEV2ZW50RW1pdHRlciwgJ2RlZmF1bHRNYXhMaXN0ZW5lcnMnLCB7XG4gICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICBnZXQ6IGZ1bmN0aW9uKCkge1xuICAgICAgcmV0dXJuIGRlZmF1bHRNYXhMaXN0ZW5lcnM7XG4gICAgfSxcbiAgICBzZXQ6IGZ1bmN0aW9uKGFyZykge1xuICAgICAgLy8gY2hlY2sgd2hldGhlciB0aGUgaW5wdXQgaXMgYSBwb3NpdGl2ZSBudW1iZXIgKHdob3NlIHZhbHVlIGlzIHplcm8gb3JcbiAgICAgIC8vIGdyZWF0ZXIgYW5kIG5vdCBhIE5hTikuXG4gICAgICBpZiAodHlwZW9mIGFyZyAhPT0gJ251bWJlcicgfHwgYXJnIDwgMCB8fCBhcmcgIT09IGFyZylcbiAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignXCJkZWZhdWx0TWF4TGlzdGVuZXJzXCIgbXVzdCBiZSBhIHBvc2l0aXZlIG51bWJlcicpO1xuICAgICAgZGVmYXVsdE1heExpc3RlbmVycyA9IGFyZztcbiAgICB9XG4gIH0pO1xufSBlbHNlIHtcbiAgRXZlbnRFbWl0dGVyLmRlZmF1bHRNYXhMaXN0ZW5lcnMgPSBkZWZhdWx0TWF4TGlzdGVuZXJzO1xufVxuXG4vLyBPYnZpb3VzbHkgbm90IGFsbCBFbWl0dGVycyBzaG91bGQgYmUgbGltaXRlZCB0byAxMC4gVGhpcyBmdW5jdGlvbiBhbGxvd3Ncbi8vIHRoYXQgdG8gYmUgaW5jcmVhc2VkLiBTZXQgdG8gemVybyBmb3IgdW5saW1pdGVkLlxuRXZlbnRFbWl0dGVyLnByb3RvdHlwZS5zZXRNYXhMaXN0ZW5lcnMgPSBmdW5jdGlvbiBzZXRNYXhMaXN0ZW5lcnMobikge1xuICBpZiAodHlwZW9mIG4gIT09ICdudW1iZXInIHx8IG4gPCAwIHx8IGlzTmFOKG4pKVxuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ1wiblwiIGFyZ3VtZW50IG11c3QgYmUgYSBwb3NpdGl2ZSBudW1iZXInKTtcbiAgdGhpcy5fbWF4TGlzdGVuZXJzID0gbjtcbiAgcmV0dXJuIHRoaXM7XG59O1xuXG5mdW5jdGlvbiAkZ2V0TWF4TGlzdGVuZXJzKHRoYXQpIHtcbiAgaWYgKHRoYXQuX21heExpc3RlbmVycyA9PT0gdW5kZWZpbmVkKVxuICAgIHJldHVybiBFdmVudEVtaXR0ZXIuZGVmYXVsdE1heExpc3RlbmVycztcbiAgcmV0dXJuIHRoYXQuX21heExpc3RlbmVycztcbn1cblxuRXZlbnRFbWl0dGVyLnByb3RvdHlwZS5nZXRNYXhMaXN0ZW5lcnMgPSBmdW5jdGlvbiBnZXRNYXhMaXN0ZW5lcnMoKSB7XG4gIHJldHVybiAkZ2V0TWF4TGlzdGVuZXJzKHRoaXMpO1xufTtcblxuLy8gVGhlc2Ugc3RhbmRhbG9uZSBlbWl0KiBmdW5jdGlvbnMgYXJlIHVzZWQgdG8gb3B0aW1pemUgY2FsbGluZyBvZiBldmVudFxuLy8gaGFuZGxlcnMgZm9yIGZhc3QgY2FzZXMgYmVjYXVzZSBlbWl0KCkgaXRzZWxmIG9mdGVuIGhhcyBhIHZhcmlhYmxlIG51bWJlciBvZlxuLy8gYXJndW1lbnRzIGFuZCBjYW4gYmUgZGVvcHRpbWl6ZWQgYmVjYXVzZSBvZiB0aGF0LiBUaGVzZSBmdW5jdGlvbnMgYWx3YXlzIGhhdmVcbi8vIHRoZSBzYW1lIG51bWJlciBvZiBhcmd1bWVudHMgYW5kIHRodXMgZG8gbm90IGdldCBkZW9wdGltaXplZCwgc28gdGhlIGNvZGVcbi8vIGluc2lkZSB0aGVtIGNhbiBleGVjdXRlIGZhc3Rlci5cbmZ1bmN0aW9uIGVtaXROb25lKGhhbmRsZXIsIGlzRm4sIHNlbGYpIHtcbiAgaWYgKGlzRm4pXG4gICAgaGFuZGxlci5jYWxsKHNlbGYpO1xuICBlbHNlIHtcbiAgICB2YXIgbGVuID0gaGFuZGxlci5sZW5ndGg7XG4gICAgdmFyIGxpc3RlbmVycyA9IGFycmF5Q2xvbmUoaGFuZGxlciwgbGVuKTtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGxlbjsgKytpKVxuICAgICAgbGlzdGVuZXJzW2ldLmNhbGwoc2VsZik7XG4gIH1cbn1cbmZ1bmN0aW9uIGVtaXRPbmUoaGFuZGxlciwgaXNGbiwgc2VsZiwgYXJnMSkge1xuICBpZiAoaXNGbilcbiAgICBoYW5kbGVyLmNhbGwoc2VsZiwgYXJnMSk7XG4gIGVsc2Uge1xuICAgIHZhciBsZW4gPSBoYW5kbGVyLmxlbmd0aDtcbiAgICB2YXIgbGlzdGVuZXJzID0gYXJyYXlDbG9uZShoYW5kbGVyLCBsZW4pO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuOyArK2kpXG4gICAgICBsaXN0ZW5lcnNbaV0uY2FsbChzZWxmLCBhcmcxKTtcbiAgfVxufVxuZnVuY3Rpb24gZW1pdFR3byhoYW5kbGVyLCBpc0ZuLCBzZWxmLCBhcmcxLCBhcmcyKSB7XG4gIGlmIChpc0ZuKVxuICAgIGhhbmRsZXIuY2FsbChzZWxmLCBhcmcxLCBhcmcyKTtcbiAgZWxzZSB7XG4gICAgdmFyIGxlbiA9IGhhbmRsZXIubGVuZ3RoO1xuICAgIHZhciBsaXN0ZW5lcnMgPSBhcnJheUNsb25lKGhhbmRsZXIsIGxlbik7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW47ICsraSlcbiAgICAgIGxpc3RlbmVyc1tpXS5jYWxsKHNlbGYsIGFyZzEsIGFyZzIpO1xuICB9XG59XG5mdW5jdGlvbiBlbWl0VGhyZWUoaGFuZGxlciwgaXNGbiwgc2VsZiwgYXJnMSwgYXJnMiwgYXJnMykge1xuICBpZiAoaXNGbilcbiAgICBoYW5kbGVyLmNhbGwoc2VsZiwgYXJnMSwgYXJnMiwgYXJnMyk7XG4gIGVsc2Uge1xuICAgIHZhciBsZW4gPSBoYW5kbGVyLmxlbmd0aDtcbiAgICB2YXIgbGlzdGVuZXJzID0gYXJyYXlDbG9uZShoYW5kbGVyLCBsZW4pO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuOyArK2kpXG4gICAgICBsaXN0ZW5lcnNbaV0uY2FsbChzZWxmLCBhcmcxLCBhcmcyLCBhcmczKTtcbiAgfVxufVxuXG5mdW5jdGlvbiBlbWl0TWFueShoYW5kbGVyLCBpc0ZuLCBzZWxmLCBhcmdzKSB7XG4gIGlmIChpc0ZuKVxuICAgIGhhbmRsZXIuYXBwbHkoc2VsZiwgYXJncyk7XG4gIGVsc2Uge1xuICAgIHZhciBsZW4gPSBoYW5kbGVyLmxlbmd0aDtcbiAgICB2YXIgbGlzdGVuZXJzID0gYXJyYXlDbG9uZShoYW5kbGVyLCBsZW4pO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuOyArK2kpXG4gICAgICBsaXN0ZW5lcnNbaV0uYXBwbHkoc2VsZiwgYXJncyk7XG4gIH1cbn1cblxuRXZlbnRFbWl0dGVyLnByb3RvdHlwZS5lbWl0ID0gZnVuY3Rpb24gZW1pdCh0eXBlKSB7XG4gIHZhciBlciwgaGFuZGxlciwgbGVuLCBhcmdzLCBpLCBldmVudHM7XG4gIHZhciBkb0Vycm9yID0gKHR5cGUgPT09ICdlcnJvcicpO1xuXG4gIGV2ZW50cyA9IHRoaXMuX2V2ZW50cztcbiAgaWYgKGV2ZW50cylcbiAgICBkb0Vycm9yID0gKGRvRXJyb3IgJiYgZXZlbnRzLmVycm9yID09IG51bGwpO1xuICBlbHNlIGlmICghZG9FcnJvcilcbiAgICByZXR1cm4gZmFsc2U7XG5cbiAgLy8gSWYgdGhlcmUgaXMgbm8gJ2Vycm9yJyBldmVudCBsaXN0ZW5lciB0aGVuIHRocm93LlxuICBpZiAoZG9FcnJvcikge1xuICAgIGlmIChhcmd1bWVudHMubGVuZ3RoID4gMSlcbiAgICAgIGVyID0gYXJndW1lbnRzWzFdO1xuICAgIGlmIChlciBpbnN0YW5jZW9mIEVycm9yKSB7XG4gICAgICB0aHJvdyBlcjsgLy8gVW5oYW5kbGVkICdlcnJvcicgZXZlbnRcbiAgICB9IGVsc2Uge1xuICAgICAgLy8gQXQgbGVhc3QgZ2l2ZSBzb21lIGtpbmQgb2YgY29udGV4dCB0byB0aGUgdXNlclxuICAgICAgdmFyIGVyciA9IG5ldyBFcnJvcignVW5oYW5kbGVkIFwiZXJyb3JcIiBldmVudC4gKCcgKyBlciArICcpJyk7XG4gICAgICBlcnIuY29udGV4dCA9IGVyO1xuICAgICAgdGhyb3cgZXJyO1xuICAgIH1cbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cblxuICBoYW5kbGVyID0gZXZlbnRzW3R5cGVdO1xuXG4gIGlmICghaGFuZGxlcilcbiAgICByZXR1cm4gZmFsc2U7XG5cbiAgdmFyIGlzRm4gPSB0eXBlb2YgaGFuZGxlciA9PT0gJ2Z1bmN0aW9uJztcbiAgbGVuID0gYXJndW1lbnRzLmxlbmd0aDtcbiAgc3dpdGNoIChsZW4pIHtcbiAgICAgIC8vIGZhc3QgY2FzZXNcbiAgICBjYXNlIDE6XG4gICAgICBlbWl0Tm9uZShoYW5kbGVyLCBpc0ZuLCB0aGlzKTtcbiAgICAgIGJyZWFrO1xuICAgIGNhc2UgMjpcbiAgICAgIGVtaXRPbmUoaGFuZGxlciwgaXNGbiwgdGhpcywgYXJndW1lbnRzWzFdKTtcbiAgICAgIGJyZWFrO1xuICAgIGNhc2UgMzpcbiAgICAgIGVtaXRUd28oaGFuZGxlciwgaXNGbiwgdGhpcywgYXJndW1lbnRzWzFdLCBhcmd1bWVudHNbMl0pO1xuICAgICAgYnJlYWs7XG4gICAgY2FzZSA0OlxuICAgICAgZW1pdFRocmVlKGhhbmRsZXIsIGlzRm4sIHRoaXMsIGFyZ3VtZW50c1sxXSwgYXJndW1lbnRzWzJdLCBhcmd1bWVudHNbM10pO1xuICAgICAgYnJlYWs7XG4gICAgICAvLyBzbG93ZXJcbiAgICBkZWZhdWx0OlxuICAgICAgYXJncyA9IG5ldyBBcnJheShsZW4gLSAxKTtcbiAgICAgIGZvciAoaSA9IDE7IGkgPCBsZW47IGkrKylcbiAgICAgICAgYXJnc1tpIC0gMV0gPSBhcmd1bWVudHNbaV07XG4gICAgICBlbWl0TWFueShoYW5kbGVyLCBpc0ZuLCB0aGlzLCBhcmdzKTtcbiAgfVxuXG4gIHJldHVybiB0cnVlO1xufTtcblxuZnVuY3Rpb24gX2FkZExpc3RlbmVyKHRhcmdldCwgdHlwZSwgbGlzdGVuZXIsIHByZXBlbmQpIHtcbiAgdmFyIG07XG4gIHZhciBldmVudHM7XG4gIHZhciBleGlzdGluZztcblxuICBpZiAodHlwZW9mIGxpc3RlbmVyICE9PSAnZnVuY3Rpb24nKVxuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ1wibGlzdGVuZXJcIiBhcmd1bWVudCBtdXN0IGJlIGEgZnVuY3Rpb24nKTtcblxuICBldmVudHMgPSB0YXJnZXQuX2V2ZW50cztcbiAgaWYgKCFldmVudHMpIHtcbiAgICBldmVudHMgPSB0YXJnZXQuX2V2ZW50cyA9IG9iamVjdENyZWF0ZShudWxsKTtcbiAgICB0YXJnZXQuX2V2ZW50c0NvdW50ID0gMDtcbiAgfSBlbHNlIHtcbiAgICAvLyBUbyBhdm9pZCByZWN1cnNpb24gaW4gdGhlIGNhc2UgdGhhdCB0eXBlID09PSBcIm5ld0xpc3RlbmVyXCIhIEJlZm9yZVxuICAgIC8vIGFkZGluZyBpdCB0byB0aGUgbGlzdGVuZXJzLCBmaXJzdCBlbWl0IFwibmV3TGlzdGVuZXJcIi5cbiAgICBpZiAoZXZlbnRzLm5ld0xpc3RlbmVyKSB7XG4gICAgICB0YXJnZXQuZW1pdCgnbmV3TGlzdGVuZXInLCB0eXBlLFxuICAgICAgICAgIGxpc3RlbmVyLmxpc3RlbmVyID8gbGlzdGVuZXIubGlzdGVuZXIgOiBsaXN0ZW5lcik7XG5cbiAgICAgIC8vIFJlLWFzc2lnbiBgZXZlbnRzYCBiZWNhdXNlIGEgbmV3TGlzdGVuZXIgaGFuZGxlciBjb3VsZCBoYXZlIGNhdXNlZCB0aGVcbiAgICAgIC8vIHRoaXMuX2V2ZW50cyB0byBiZSBhc3NpZ25lZCB0byBhIG5ldyBvYmplY3RcbiAgICAgIGV2ZW50cyA9IHRhcmdldC5fZXZlbnRzO1xuICAgIH1cbiAgICBleGlzdGluZyA9IGV2ZW50c1t0eXBlXTtcbiAgfVxuXG4gIGlmICghZXhpc3RpbmcpIHtcbiAgICAvLyBPcHRpbWl6ZSB0aGUgY2FzZSBvZiBvbmUgbGlzdGVuZXIuIERvbid0IG5lZWQgdGhlIGV4dHJhIGFycmF5IG9iamVjdC5cbiAgICBleGlzdGluZyA9IGV2ZW50c1t0eXBlXSA9IGxpc3RlbmVyO1xuICAgICsrdGFyZ2V0Ll9ldmVudHNDb3VudDtcbiAgfSBlbHNlIHtcbiAgICBpZiAodHlwZW9mIGV4aXN0aW5nID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAvLyBBZGRpbmcgdGhlIHNlY29uZCBlbGVtZW50LCBuZWVkIHRvIGNoYW5nZSB0byBhcnJheS5cbiAgICAgIGV4aXN0aW5nID0gZXZlbnRzW3R5cGVdID1cbiAgICAgICAgICBwcmVwZW5kID8gW2xpc3RlbmVyLCBleGlzdGluZ10gOiBbZXhpc3RpbmcsIGxpc3RlbmVyXTtcbiAgICB9IGVsc2Uge1xuICAgICAgLy8gSWYgd2UndmUgYWxyZWFkeSBnb3QgYW4gYXJyYXksIGp1c3QgYXBwZW5kLlxuICAgICAgaWYgKHByZXBlbmQpIHtcbiAgICAgICAgZXhpc3RpbmcudW5zaGlmdChsaXN0ZW5lcik7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBleGlzdGluZy5wdXNoKGxpc3RlbmVyKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICAvLyBDaGVjayBmb3IgbGlzdGVuZXIgbGVha1xuICAgIGlmICghZXhpc3Rpbmcud2FybmVkKSB7XG4gICAgICBtID0gJGdldE1heExpc3RlbmVycyh0YXJnZXQpO1xuICAgICAgaWYgKG0gJiYgbSA+IDAgJiYgZXhpc3RpbmcubGVuZ3RoID4gbSkge1xuICAgICAgICBleGlzdGluZy53YXJuZWQgPSB0cnVlO1xuICAgICAgICB2YXIgdyA9IG5ldyBFcnJvcignUG9zc2libGUgRXZlbnRFbWl0dGVyIG1lbW9yeSBsZWFrIGRldGVjdGVkLiAnICtcbiAgICAgICAgICAgIGV4aXN0aW5nLmxlbmd0aCArICcgXCInICsgU3RyaW5nKHR5cGUpICsgJ1wiIGxpc3RlbmVycyAnICtcbiAgICAgICAgICAgICdhZGRlZC4gVXNlIGVtaXR0ZXIuc2V0TWF4TGlzdGVuZXJzKCkgdG8gJyArXG4gICAgICAgICAgICAnaW5jcmVhc2UgbGltaXQuJyk7XG4gICAgICAgIHcubmFtZSA9ICdNYXhMaXN0ZW5lcnNFeGNlZWRlZFdhcm5pbmcnO1xuICAgICAgICB3LmVtaXR0ZXIgPSB0YXJnZXQ7XG4gICAgICAgIHcudHlwZSA9IHR5cGU7XG4gICAgICAgIHcuY291bnQgPSBleGlzdGluZy5sZW5ndGg7XG4gICAgICAgIGlmICh0eXBlb2YgY29uc29sZSA9PT0gJ29iamVjdCcgJiYgY29uc29sZS53YXJuKSB7XG4gICAgICAgICAgY29uc29sZS53YXJuKCclczogJXMnLCB3Lm5hbWUsIHcubWVzc2FnZSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICByZXR1cm4gdGFyZ2V0O1xufVxuXG5FdmVudEVtaXR0ZXIucHJvdG90eXBlLmFkZExpc3RlbmVyID0gZnVuY3Rpb24gYWRkTGlzdGVuZXIodHlwZSwgbGlzdGVuZXIpIHtcbiAgcmV0dXJuIF9hZGRMaXN0ZW5lcih0aGlzLCB0eXBlLCBsaXN0ZW5lciwgZmFsc2UpO1xufTtcblxuRXZlbnRFbWl0dGVyLnByb3RvdHlwZS5vbiA9IEV2ZW50RW1pdHRlci5wcm90b3R5cGUuYWRkTGlzdGVuZXI7XG5cbkV2ZW50RW1pdHRlci5wcm90b3R5cGUucHJlcGVuZExpc3RlbmVyID1cbiAgICBmdW5jdGlvbiBwcmVwZW5kTGlzdGVuZXIodHlwZSwgbGlzdGVuZXIpIHtcbiAgICAgIHJldHVybiBfYWRkTGlzdGVuZXIodGhpcywgdHlwZSwgbGlzdGVuZXIsIHRydWUpO1xuICAgIH07XG5cbmZ1bmN0aW9uIG9uY2VXcmFwcGVyKCkge1xuICBpZiAoIXRoaXMuZmlyZWQpIHtcbiAgICB0aGlzLnRhcmdldC5yZW1vdmVMaXN0ZW5lcih0aGlzLnR5cGUsIHRoaXMud3JhcEZuKTtcbiAgICB0aGlzLmZpcmVkID0gdHJ1ZTtcbiAgICBzd2l0Y2ggKGFyZ3VtZW50cy5sZW5ndGgpIHtcbiAgICAgIGNhc2UgMDpcbiAgICAgICAgcmV0dXJuIHRoaXMubGlzdGVuZXIuY2FsbCh0aGlzLnRhcmdldCk7XG4gICAgICBjYXNlIDE6XG4gICAgICAgIHJldHVybiB0aGlzLmxpc3RlbmVyLmNhbGwodGhpcy50YXJnZXQsIGFyZ3VtZW50c1swXSk7XG4gICAgICBjYXNlIDI6XG4gICAgICAgIHJldHVybiB0aGlzLmxpc3RlbmVyLmNhbGwodGhpcy50YXJnZXQsIGFyZ3VtZW50c1swXSwgYXJndW1lbnRzWzFdKTtcbiAgICAgIGNhc2UgMzpcbiAgICAgICAgcmV0dXJuIHRoaXMubGlzdGVuZXIuY2FsbCh0aGlzLnRhcmdldCwgYXJndW1lbnRzWzBdLCBhcmd1bWVudHNbMV0sXG4gICAgICAgICAgICBhcmd1bWVudHNbMl0pO1xuICAgICAgZGVmYXVsdDpcbiAgICAgICAgdmFyIGFyZ3MgPSBuZXcgQXJyYXkoYXJndW1lbnRzLmxlbmd0aCk7XG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgYXJncy5sZW5ndGg7ICsraSlcbiAgICAgICAgICBhcmdzW2ldID0gYXJndW1lbnRzW2ldO1xuICAgICAgICB0aGlzLmxpc3RlbmVyLmFwcGx5KHRoaXMudGFyZ2V0LCBhcmdzKTtcbiAgICB9XG4gIH1cbn1cblxuZnVuY3Rpb24gX29uY2VXcmFwKHRhcmdldCwgdHlwZSwgbGlzdGVuZXIpIHtcbiAgdmFyIHN0YXRlID0geyBmaXJlZDogZmFsc2UsIHdyYXBGbjogdW5kZWZpbmVkLCB0YXJnZXQ6IHRhcmdldCwgdHlwZTogdHlwZSwgbGlzdGVuZXI6IGxpc3RlbmVyIH07XG4gIHZhciB3cmFwcGVkID0gYmluZC5jYWxsKG9uY2VXcmFwcGVyLCBzdGF0ZSk7XG4gIHdyYXBwZWQubGlzdGVuZXIgPSBsaXN0ZW5lcjtcbiAgc3RhdGUud3JhcEZuID0gd3JhcHBlZDtcbiAgcmV0dXJuIHdyYXBwZWQ7XG59XG5cbkV2ZW50RW1pdHRlci5wcm90b3R5cGUub25jZSA9IGZ1bmN0aW9uIG9uY2UodHlwZSwgbGlzdGVuZXIpIHtcbiAgaWYgKHR5cGVvZiBsaXN0ZW5lciAhPT0gJ2Z1bmN0aW9uJylcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdcImxpc3RlbmVyXCIgYXJndW1lbnQgbXVzdCBiZSBhIGZ1bmN0aW9uJyk7XG4gIHRoaXMub24odHlwZSwgX29uY2VXcmFwKHRoaXMsIHR5cGUsIGxpc3RlbmVyKSk7XG4gIHJldHVybiB0aGlzO1xufTtcblxuRXZlbnRFbWl0dGVyLnByb3RvdHlwZS5wcmVwZW5kT25jZUxpc3RlbmVyID1cbiAgICBmdW5jdGlvbiBwcmVwZW5kT25jZUxpc3RlbmVyKHR5cGUsIGxpc3RlbmVyKSB7XG4gICAgICBpZiAodHlwZW9mIGxpc3RlbmVyICE9PSAnZnVuY3Rpb24nKVxuICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdcImxpc3RlbmVyXCIgYXJndW1lbnQgbXVzdCBiZSBhIGZ1bmN0aW9uJyk7XG4gICAgICB0aGlzLnByZXBlbmRMaXN0ZW5lcih0eXBlLCBfb25jZVdyYXAodGhpcywgdHlwZSwgbGlzdGVuZXIpKTtcbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH07XG5cbi8vIEVtaXRzIGEgJ3JlbW92ZUxpc3RlbmVyJyBldmVudCBpZiBhbmQgb25seSBpZiB0aGUgbGlzdGVuZXIgd2FzIHJlbW92ZWQuXG5FdmVudEVtaXR0ZXIucHJvdG90eXBlLnJlbW92ZUxpc3RlbmVyID1cbiAgICBmdW5jdGlvbiByZW1vdmVMaXN0ZW5lcih0eXBlLCBsaXN0ZW5lcikge1xuICAgICAgdmFyIGxpc3QsIGV2ZW50cywgcG9zaXRpb24sIGksIG9yaWdpbmFsTGlzdGVuZXI7XG5cbiAgICAgIGlmICh0eXBlb2YgbGlzdGVuZXIgIT09ICdmdW5jdGlvbicpXG4gICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ1wibGlzdGVuZXJcIiBhcmd1bWVudCBtdXN0IGJlIGEgZnVuY3Rpb24nKTtcblxuICAgICAgZXZlbnRzID0gdGhpcy5fZXZlbnRzO1xuICAgICAgaWYgKCFldmVudHMpXG4gICAgICAgIHJldHVybiB0aGlzO1xuXG4gICAgICBsaXN0ID0gZXZlbnRzW3R5cGVdO1xuICAgICAgaWYgKCFsaXN0KVxuICAgICAgICByZXR1cm4gdGhpcztcblxuICAgICAgaWYgKGxpc3QgPT09IGxpc3RlbmVyIHx8IGxpc3QubGlzdGVuZXIgPT09IGxpc3RlbmVyKSB7XG4gICAgICAgIGlmICgtLXRoaXMuX2V2ZW50c0NvdW50ID09PSAwKVxuICAgICAgICAgIHRoaXMuX2V2ZW50cyA9IG9iamVjdENyZWF0ZShudWxsKTtcbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgZGVsZXRlIGV2ZW50c1t0eXBlXTtcbiAgICAgICAgICBpZiAoZXZlbnRzLnJlbW92ZUxpc3RlbmVyKVxuICAgICAgICAgICAgdGhpcy5lbWl0KCdyZW1vdmVMaXN0ZW5lcicsIHR5cGUsIGxpc3QubGlzdGVuZXIgfHwgbGlzdGVuZXIpO1xuICAgICAgICB9XG4gICAgICB9IGVsc2UgaWYgKHR5cGVvZiBsaXN0ICE9PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgIHBvc2l0aW9uID0gLTE7XG5cbiAgICAgICAgZm9yIChpID0gbGlzdC5sZW5ndGggLSAxOyBpID49IDA7IGktLSkge1xuICAgICAgICAgIGlmIChsaXN0W2ldID09PSBsaXN0ZW5lciB8fCBsaXN0W2ldLmxpc3RlbmVyID09PSBsaXN0ZW5lcikge1xuICAgICAgICAgICAgb3JpZ2luYWxMaXN0ZW5lciA9IGxpc3RbaV0ubGlzdGVuZXI7XG4gICAgICAgICAgICBwb3NpdGlvbiA9IGk7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBpZiAocG9zaXRpb24gPCAwKVxuICAgICAgICAgIHJldHVybiB0aGlzO1xuXG4gICAgICAgIGlmIChwb3NpdGlvbiA9PT0gMClcbiAgICAgICAgICBsaXN0LnNoaWZ0KCk7XG4gICAgICAgIGVsc2VcbiAgICAgICAgICBzcGxpY2VPbmUobGlzdCwgcG9zaXRpb24pO1xuXG4gICAgICAgIGlmIChsaXN0Lmxlbmd0aCA9PT0gMSlcbiAgICAgICAgICBldmVudHNbdHlwZV0gPSBsaXN0WzBdO1xuXG4gICAgICAgIGlmIChldmVudHMucmVtb3ZlTGlzdGVuZXIpXG4gICAgICAgICAgdGhpcy5lbWl0KCdyZW1vdmVMaXN0ZW5lcicsIHR5cGUsIG9yaWdpbmFsTGlzdGVuZXIgfHwgbGlzdGVuZXIpO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9O1xuXG5FdmVudEVtaXR0ZXIucHJvdG90eXBlLnJlbW92ZUFsbExpc3RlbmVycyA9XG4gICAgZnVuY3Rpb24gcmVtb3ZlQWxsTGlzdGVuZXJzKHR5cGUpIHtcbiAgICAgIHZhciBsaXN0ZW5lcnMsIGV2ZW50cywgaTtcblxuICAgICAgZXZlbnRzID0gdGhpcy5fZXZlbnRzO1xuICAgICAgaWYgKCFldmVudHMpXG4gICAgICAgIHJldHVybiB0aGlzO1xuXG4gICAgICAvLyBub3QgbGlzdGVuaW5nIGZvciByZW1vdmVMaXN0ZW5lciwgbm8gbmVlZCB0byBlbWl0XG4gICAgICBpZiAoIWV2ZW50cy5yZW1vdmVMaXN0ZW5lcikge1xuICAgICAgICBpZiAoYXJndW1lbnRzLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICAgIHRoaXMuX2V2ZW50cyA9IG9iamVjdENyZWF0ZShudWxsKTtcbiAgICAgICAgICB0aGlzLl9ldmVudHNDb3VudCA9IDA7XG4gICAgICAgIH0gZWxzZSBpZiAoZXZlbnRzW3R5cGVdKSB7XG4gICAgICAgICAgaWYgKC0tdGhpcy5fZXZlbnRzQ291bnQgPT09IDApXG4gICAgICAgICAgICB0aGlzLl9ldmVudHMgPSBvYmplY3RDcmVhdGUobnVsbCk7XG4gICAgICAgICAgZWxzZVxuICAgICAgICAgICAgZGVsZXRlIGV2ZW50c1t0eXBlXTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgIH1cblxuICAgICAgLy8gZW1pdCByZW1vdmVMaXN0ZW5lciBmb3IgYWxsIGxpc3RlbmVycyBvbiBhbGwgZXZlbnRzXG4gICAgICBpZiAoYXJndW1lbnRzLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICB2YXIga2V5cyA9IG9iamVjdEtleXMoZXZlbnRzKTtcbiAgICAgICAgdmFyIGtleTtcbiAgICAgICAgZm9yIChpID0gMDsgaSA8IGtleXMubGVuZ3RoOyArK2kpIHtcbiAgICAgICAgICBrZXkgPSBrZXlzW2ldO1xuICAgICAgICAgIGlmIChrZXkgPT09ICdyZW1vdmVMaXN0ZW5lcicpIGNvbnRpbnVlO1xuICAgICAgICAgIHRoaXMucmVtb3ZlQWxsTGlzdGVuZXJzKGtleSk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5yZW1vdmVBbGxMaXN0ZW5lcnMoJ3JlbW92ZUxpc3RlbmVyJyk7XG4gICAgICAgIHRoaXMuX2V2ZW50cyA9IG9iamVjdENyZWF0ZShudWxsKTtcbiAgICAgICAgdGhpcy5fZXZlbnRzQ291bnQgPSAwO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgIH1cblxuICAgICAgbGlzdGVuZXJzID0gZXZlbnRzW3R5cGVdO1xuXG4gICAgICBpZiAodHlwZW9mIGxpc3RlbmVycyA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICB0aGlzLnJlbW92ZUxpc3RlbmVyKHR5cGUsIGxpc3RlbmVycyk7XG4gICAgICB9IGVsc2UgaWYgKGxpc3RlbmVycykge1xuICAgICAgICAvLyBMSUZPIG9yZGVyXG4gICAgICAgIGZvciAoaSA9IGxpc3RlbmVycy5sZW5ndGggLSAxOyBpID49IDA7IGktLSkge1xuICAgICAgICAgIHRoaXMucmVtb3ZlTGlzdGVuZXIodHlwZSwgbGlzdGVuZXJzW2ldKTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9O1xuXG5FdmVudEVtaXR0ZXIucHJvdG90eXBlLmxpc3RlbmVycyA9IGZ1bmN0aW9uIGxpc3RlbmVycyh0eXBlKSB7XG4gIHZhciBldmxpc3RlbmVyO1xuICB2YXIgcmV0O1xuICB2YXIgZXZlbnRzID0gdGhpcy5fZXZlbnRzO1xuXG4gIGlmICghZXZlbnRzKVxuICAgIHJldCA9IFtdO1xuICBlbHNlIHtcbiAgICBldmxpc3RlbmVyID0gZXZlbnRzW3R5cGVdO1xuICAgIGlmICghZXZsaXN0ZW5lcilcbiAgICAgIHJldCA9IFtdO1xuICAgIGVsc2UgaWYgKHR5cGVvZiBldmxpc3RlbmVyID09PSAnZnVuY3Rpb24nKVxuICAgICAgcmV0ID0gW2V2bGlzdGVuZXIubGlzdGVuZXIgfHwgZXZsaXN0ZW5lcl07XG4gICAgZWxzZVxuICAgICAgcmV0ID0gdW53cmFwTGlzdGVuZXJzKGV2bGlzdGVuZXIpO1xuICB9XG5cbiAgcmV0dXJuIHJldDtcbn07XG5cbkV2ZW50RW1pdHRlci5saXN0ZW5lckNvdW50ID0gZnVuY3Rpb24oZW1pdHRlciwgdHlwZSkge1xuICBpZiAodHlwZW9mIGVtaXR0ZXIubGlzdGVuZXJDb3VudCA9PT0gJ2Z1bmN0aW9uJykge1xuICAgIHJldHVybiBlbWl0dGVyLmxpc3RlbmVyQ291bnQodHlwZSk7XG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuIGxpc3RlbmVyQ291bnQuY2FsbChlbWl0dGVyLCB0eXBlKTtcbiAgfVxufTtcblxuRXZlbnRFbWl0dGVyLnByb3RvdHlwZS5saXN0ZW5lckNvdW50ID0gbGlzdGVuZXJDb3VudDtcbmZ1bmN0aW9uIGxpc3RlbmVyQ291bnQodHlwZSkge1xuICB2YXIgZXZlbnRzID0gdGhpcy5fZXZlbnRzO1xuXG4gIGlmIChldmVudHMpIHtcbiAgICB2YXIgZXZsaXN0ZW5lciA9IGV2ZW50c1t0eXBlXTtcblxuICAgIGlmICh0eXBlb2YgZXZsaXN0ZW5lciA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgcmV0dXJuIDE7XG4gICAgfSBlbHNlIGlmIChldmxpc3RlbmVyKSB7XG4gICAgICByZXR1cm4gZXZsaXN0ZW5lci5sZW5ndGg7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIDA7XG59XG5cbkV2ZW50RW1pdHRlci5wcm90b3R5cGUuZXZlbnROYW1lcyA9IGZ1bmN0aW9uIGV2ZW50TmFtZXMoKSB7XG4gIHJldHVybiB0aGlzLl9ldmVudHNDb3VudCA+IDAgPyBSZWZsZWN0Lm93bktleXModGhpcy5fZXZlbnRzKSA6IFtdO1xufTtcblxuLy8gQWJvdXQgMS41eCBmYXN0ZXIgdGhhbiB0aGUgdHdvLWFyZyB2ZXJzaW9uIG9mIEFycmF5I3NwbGljZSgpLlxuZnVuY3Rpb24gc3BsaWNlT25lKGxpc3QsIGluZGV4KSB7XG4gIGZvciAodmFyIGkgPSBpbmRleCwgayA9IGkgKyAxLCBuID0gbGlzdC5sZW5ndGg7IGsgPCBuOyBpICs9IDEsIGsgKz0gMSlcbiAgICBsaXN0W2ldID0gbGlzdFtrXTtcbiAgbGlzdC5wb3AoKTtcbn1cblxuZnVuY3Rpb24gYXJyYXlDbG9uZShhcnIsIG4pIHtcbiAgdmFyIGNvcHkgPSBuZXcgQXJyYXkobik7XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgbjsgKytpKVxuICAgIGNvcHlbaV0gPSBhcnJbaV07XG4gIHJldHVybiBjb3B5O1xufVxuXG5mdW5jdGlvbiB1bndyYXBMaXN0ZW5lcnMoYXJyKSB7XG4gIHZhciByZXQgPSBuZXcgQXJyYXkoYXJyLmxlbmd0aCk7XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgcmV0Lmxlbmd0aDsgKytpKSB7XG4gICAgcmV0W2ldID0gYXJyW2ldLmxpc3RlbmVyIHx8IGFycltpXTtcbiAgfVxuICByZXR1cm4gcmV0O1xufVxuXG5mdW5jdGlvbiBvYmplY3RDcmVhdGVQb2x5ZmlsbChwcm90bykge1xuICB2YXIgRiA9IGZ1bmN0aW9uKCkge307XG4gIEYucHJvdG90eXBlID0gcHJvdG87XG4gIHJldHVybiBuZXcgRjtcbn1cbmZ1bmN0aW9uIG9iamVjdEtleXNQb2x5ZmlsbChvYmopIHtcbiAgdmFyIGtleXMgPSBbXTtcbiAgZm9yICh2YXIgayBpbiBvYmopIGlmIChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwob2JqLCBrKSkge1xuICAgIGtleXMucHVzaChrKTtcbiAgfVxuICByZXR1cm4gaztcbn1cbmZ1bmN0aW9uIGZ1bmN0aW9uQmluZFBvbHlmaWxsKGNvbnRleHQpIHtcbiAgdmFyIGZuID0gdGhpcztcbiAgcmV0dXJuIGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gZm4uYXBwbHkoY29udGV4dCwgYXJndW1lbnRzKTtcbiAgfTtcbn1cbiIsInJlcXVpcmUoJy4uLy4uL21vZHVsZXMvZXM2LnN0cmluZy5pdGVyYXRvcicpO1xucmVxdWlyZSgnLi4vLi4vbW9kdWxlcy9lczYuYXJyYXkuZnJvbScpO1xubW9kdWxlLmV4cG9ydHMgPSByZXF1aXJlKCcuLi8uLi9tb2R1bGVzL19jb3JlJykuQXJyYXkuZnJvbTtcbiIsInJlcXVpcmUoJy4uL21vZHVsZXMvd2ViLmRvbS5pdGVyYWJsZScpO1xucmVxdWlyZSgnLi4vbW9kdWxlcy9lczYuc3RyaW5nLml0ZXJhdG9yJyk7XG5tb2R1bGUuZXhwb3J0cyA9IHJlcXVpcmUoJy4uL21vZHVsZXMvY29yZS5nZXQtaXRlcmF0b3InKTtcbiIsInJlcXVpcmUoJy4uL21vZHVsZXMvd2ViLmRvbS5pdGVyYWJsZScpO1xucmVxdWlyZSgnLi4vbW9kdWxlcy9lczYuc3RyaW5nLml0ZXJhdG9yJyk7XG5tb2R1bGUuZXhwb3J0cyA9IHJlcXVpcmUoJy4uL21vZHVsZXMvY29yZS5pcy1pdGVyYWJsZScpO1xuIiwidmFyIGNvcmUgPSByZXF1aXJlKCcuLi8uLi9tb2R1bGVzL19jb3JlJyk7XG52YXIgJEpTT04gPSBjb3JlLkpTT04gfHwgKGNvcmUuSlNPTiA9IHsgc3RyaW5naWZ5OiBKU09OLnN0cmluZ2lmeSB9KTtcbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gc3RyaW5naWZ5KGl0KSB7IC8vIGVzbGludC1kaXNhYmxlLWxpbmUgbm8tdW51c2VkLXZhcnNcbiAgcmV0dXJuICRKU09OLnN0cmluZ2lmeS5hcHBseSgkSlNPTiwgYXJndW1lbnRzKTtcbn07XG4iLCJyZXF1aXJlKCcuLi9tb2R1bGVzL2VzNi5vYmplY3QudG8tc3RyaW5nJyk7XG5yZXF1aXJlKCcuLi9tb2R1bGVzL2VzNi5zdHJpbmcuaXRlcmF0b3InKTtcbnJlcXVpcmUoJy4uL21vZHVsZXMvd2ViLmRvbS5pdGVyYWJsZScpO1xucmVxdWlyZSgnLi4vbW9kdWxlcy9lczYubWFwJyk7XG5yZXF1aXJlKCcuLi9tb2R1bGVzL2VzNy5tYXAudG8tanNvbicpO1xucmVxdWlyZSgnLi4vbW9kdWxlcy9lczcubWFwLm9mJyk7XG5yZXF1aXJlKCcuLi9tb2R1bGVzL2VzNy5tYXAuZnJvbScpO1xubW9kdWxlLmV4cG9ydHMgPSByZXF1aXJlKCcuLi9tb2R1bGVzL19jb3JlJykuTWFwO1xuIiwicmVxdWlyZSgnLi4vLi4vbW9kdWxlcy9lczYub2JqZWN0LmFzc2lnbicpO1xubW9kdWxlLmV4cG9ydHMgPSByZXF1aXJlKCcuLi8uLi9tb2R1bGVzL19jb3JlJykuT2JqZWN0LmFzc2lnbjtcbiIsInJlcXVpcmUoJy4uLy4uL21vZHVsZXMvZXM2Lm9iamVjdC5jcmVhdGUnKTtcbnZhciAkT2JqZWN0ID0gcmVxdWlyZSgnLi4vLi4vbW9kdWxlcy9fY29yZScpLk9iamVjdDtcbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gY3JlYXRlKFAsIEQpIHtcbiAgcmV0dXJuICRPYmplY3QuY3JlYXRlKFAsIEQpO1xufTtcbiIsInJlcXVpcmUoJy4uLy4uL21vZHVsZXMvZXM2Lm9iamVjdC5kZWZpbmUtcHJvcGVydHknKTtcbnZhciAkT2JqZWN0ID0gcmVxdWlyZSgnLi4vLi4vbW9kdWxlcy9fY29yZScpLk9iamVjdDtcbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gZGVmaW5lUHJvcGVydHkoaXQsIGtleSwgZGVzYykge1xuICByZXR1cm4gJE9iamVjdC5kZWZpbmVQcm9wZXJ0eShpdCwga2V5LCBkZXNjKTtcbn07XG4iLCJyZXF1aXJlKCcuLi8uLi9tb2R1bGVzL2VzNi5vYmplY3QuZ2V0LXByb3RvdHlwZS1vZicpO1xubW9kdWxlLmV4cG9ydHMgPSByZXF1aXJlKCcuLi8uLi9tb2R1bGVzL19jb3JlJykuT2JqZWN0LmdldFByb3RvdHlwZU9mO1xuIiwicmVxdWlyZSgnLi4vLi4vbW9kdWxlcy9lczYub2JqZWN0LmtleXMnKTtcbm1vZHVsZS5leHBvcnRzID0gcmVxdWlyZSgnLi4vLi4vbW9kdWxlcy9fY29yZScpLk9iamVjdC5rZXlzO1xuIiwicmVxdWlyZSgnLi4vLi4vbW9kdWxlcy9lczYub2JqZWN0LnNldC1wcm90b3R5cGUtb2YnKTtcbm1vZHVsZS5leHBvcnRzID0gcmVxdWlyZSgnLi4vLi4vbW9kdWxlcy9fY29yZScpLk9iamVjdC5zZXRQcm90b3R5cGVPZjtcbiIsInJlcXVpcmUoJy4uLy4uL21vZHVsZXMvZXM3Lm9iamVjdC52YWx1ZXMnKTtcbm1vZHVsZS5leHBvcnRzID0gcmVxdWlyZSgnLi4vLi4vbW9kdWxlcy9fY29yZScpLk9iamVjdC52YWx1ZXM7XG4iLCJyZXF1aXJlKCcuLi9tb2R1bGVzL2VzNi5vYmplY3QudG8tc3RyaW5nJyk7XG5yZXF1aXJlKCcuLi9tb2R1bGVzL2VzNi5zdHJpbmcuaXRlcmF0b3InKTtcbnJlcXVpcmUoJy4uL21vZHVsZXMvd2ViLmRvbS5pdGVyYWJsZScpO1xucmVxdWlyZSgnLi4vbW9kdWxlcy9lczYucHJvbWlzZScpO1xucmVxdWlyZSgnLi4vbW9kdWxlcy9lczcucHJvbWlzZS5maW5hbGx5Jyk7XG5yZXF1aXJlKCcuLi9tb2R1bGVzL2VzNy5wcm9taXNlLnRyeScpO1xubW9kdWxlLmV4cG9ydHMgPSByZXF1aXJlKCcuLi9tb2R1bGVzL19jb3JlJykuUHJvbWlzZTtcbiIsInJlcXVpcmUoJy4uL21vZHVsZXMvZXM2Lm9iamVjdC50by1zdHJpbmcnKTtcbnJlcXVpcmUoJy4uL21vZHVsZXMvZXM2LnN0cmluZy5pdGVyYXRvcicpO1xucmVxdWlyZSgnLi4vbW9kdWxlcy93ZWIuZG9tLml0ZXJhYmxlJyk7XG5yZXF1aXJlKCcuLi9tb2R1bGVzL2VzNi5zZXQnKTtcbnJlcXVpcmUoJy4uL21vZHVsZXMvZXM3LnNldC50by1qc29uJyk7XG5yZXF1aXJlKCcuLi9tb2R1bGVzL2VzNy5zZXQub2YnKTtcbnJlcXVpcmUoJy4uL21vZHVsZXMvZXM3LnNldC5mcm9tJyk7XG5tb2R1bGUuZXhwb3J0cyA9IHJlcXVpcmUoJy4uL21vZHVsZXMvX2NvcmUnKS5TZXQ7XG4iLCJyZXF1aXJlKCcuLi8uLi9tb2R1bGVzL2VzNi5zeW1ib2wnKTtcbnJlcXVpcmUoJy4uLy4uL21vZHVsZXMvZXM2Lm9iamVjdC50by1zdHJpbmcnKTtcbnJlcXVpcmUoJy4uLy4uL21vZHVsZXMvZXM3LnN5bWJvbC5hc3luYy1pdGVyYXRvcicpO1xucmVxdWlyZSgnLi4vLi4vbW9kdWxlcy9lczcuc3ltYm9sLm9ic2VydmFibGUnKTtcbm1vZHVsZS5leHBvcnRzID0gcmVxdWlyZSgnLi4vLi4vbW9kdWxlcy9fY29yZScpLlN5bWJvbDtcbiIsInJlcXVpcmUoJy4uLy4uL21vZHVsZXMvZXM2LnN0cmluZy5pdGVyYXRvcicpO1xucmVxdWlyZSgnLi4vLi4vbW9kdWxlcy93ZWIuZG9tLml0ZXJhYmxlJyk7XG5tb2R1bGUuZXhwb3J0cyA9IHJlcXVpcmUoJy4uLy4uL21vZHVsZXMvX3drcy1leHQnKS5mKCdpdGVyYXRvcicpO1xuIiwibW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoaXQpIHtcbiAgaWYgKHR5cGVvZiBpdCAhPSAnZnVuY3Rpb24nKSB0aHJvdyBUeXBlRXJyb3IoaXQgKyAnIGlzIG5vdCBhIGZ1bmN0aW9uIScpO1xuICByZXR1cm4gaXQ7XG59O1xuIiwibW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoKSB7IC8qIGVtcHR5ICovIH07XG4iLCJtb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChpdCwgQ29uc3RydWN0b3IsIG5hbWUsIGZvcmJpZGRlbkZpZWxkKSB7XG4gIGlmICghKGl0IGluc3RhbmNlb2YgQ29uc3RydWN0b3IpIHx8IChmb3JiaWRkZW5GaWVsZCAhPT0gdW5kZWZpbmVkICYmIGZvcmJpZGRlbkZpZWxkIGluIGl0KSkge1xuICAgIHRocm93IFR5cGVFcnJvcihuYW1lICsgJzogaW5jb3JyZWN0IGludm9jYXRpb24hJyk7XG4gIH0gcmV0dXJuIGl0O1xufTtcbiIsInZhciBpc09iamVjdCA9IHJlcXVpcmUoJy4vX2lzLW9iamVjdCcpO1xubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoaXQpIHtcbiAgaWYgKCFpc09iamVjdChpdCkpIHRocm93IFR5cGVFcnJvcihpdCArICcgaXMgbm90IGFuIG9iamVjdCEnKTtcbiAgcmV0dXJuIGl0O1xufTtcbiIsInZhciBmb3JPZiA9IHJlcXVpcmUoJy4vX2Zvci1vZicpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChpdGVyLCBJVEVSQVRPUikge1xuICB2YXIgcmVzdWx0ID0gW107XG4gIGZvck9mKGl0ZXIsIGZhbHNlLCByZXN1bHQucHVzaCwgcmVzdWx0LCBJVEVSQVRPUik7XG4gIHJldHVybiByZXN1bHQ7XG59O1xuIiwiLy8gZmFsc2UgLT4gQXJyYXkjaW5kZXhPZlxuLy8gdHJ1ZSAgLT4gQXJyYXkjaW5jbHVkZXNcbnZhciB0b0lPYmplY3QgPSByZXF1aXJlKCcuL190by1pb2JqZWN0Jyk7XG52YXIgdG9MZW5ndGggPSByZXF1aXJlKCcuL190by1sZW5ndGgnKTtcbnZhciB0b0Fic29sdXRlSW5kZXggPSByZXF1aXJlKCcuL190by1hYnNvbHV0ZS1pbmRleCcpO1xubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoSVNfSU5DTFVERVMpIHtcbiAgcmV0dXJuIGZ1bmN0aW9uICgkdGhpcywgZWwsIGZyb21JbmRleCkge1xuICAgIHZhciBPID0gdG9JT2JqZWN0KCR0aGlzKTtcbiAgICB2YXIgbGVuZ3RoID0gdG9MZW5ndGgoTy5sZW5ndGgpO1xuICAgIHZhciBpbmRleCA9IHRvQWJzb2x1dGVJbmRleChmcm9tSW5kZXgsIGxlbmd0aCk7XG4gICAgdmFyIHZhbHVlO1xuICAgIC8vIEFycmF5I2luY2x1ZGVzIHVzZXMgU2FtZVZhbHVlWmVybyBlcXVhbGl0eSBhbGdvcml0aG1cbiAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tc2VsZi1jb21wYXJlXG4gICAgaWYgKElTX0lOQ0xVREVTICYmIGVsICE9IGVsKSB3aGlsZSAobGVuZ3RoID4gaW5kZXgpIHtcbiAgICAgIHZhbHVlID0gT1tpbmRleCsrXTtcbiAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1zZWxmLWNvbXBhcmVcbiAgICAgIGlmICh2YWx1ZSAhPSB2YWx1ZSkgcmV0dXJuIHRydWU7XG4gICAgLy8gQXJyYXkjaW5kZXhPZiBpZ25vcmVzIGhvbGVzLCBBcnJheSNpbmNsdWRlcyAtIG5vdFxuICAgIH0gZWxzZSBmb3IgKDtsZW5ndGggPiBpbmRleDsgaW5kZXgrKykgaWYgKElTX0lOQ0xVREVTIHx8IGluZGV4IGluIE8pIHtcbiAgICAgIGlmIChPW2luZGV4XSA9PT0gZWwpIHJldHVybiBJU19JTkNMVURFUyB8fCBpbmRleCB8fCAwO1xuICAgIH0gcmV0dXJuICFJU19JTkNMVURFUyAmJiAtMTtcbiAgfTtcbn07XG4iLCIvLyAwIC0+IEFycmF5I2ZvckVhY2hcbi8vIDEgLT4gQXJyYXkjbWFwXG4vLyAyIC0+IEFycmF5I2ZpbHRlclxuLy8gMyAtPiBBcnJheSNzb21lXG4vLyA0IC0+IEFycmF5I2V2ZXJ5XG4vLyA1IC0+IEFycmF5I2ZpbmRcbi8vIDYgLT4gQXJyYXkjZmluZEluZGV4XG52YXIgY3R4ID0gcmVxdWlyZSgnLi9fY3R4Jyk7XG52YXIgSU9iamVjdCA9IHJlcXVpcmUoJy4vX2lvYmplY3QnKTtcbnZhciB0b09iamVjdCA9IHJlcXVpcmUoJy4vX3RvLW9iamVjdCcpO1xudmFyIHRvTGVuZ3RoID0gcmVxdWlyZSgnLi9fdG8tbGVuZ3RoJyk7XG52YXIgYXNjID0gcmVxdWlyZSgnLi9fYXJyYXktc3BlY2llcy1jcmVhdGUnKTtcbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKFRZUEUsICRjcmVhdGUpIHtcbiAgdmFyIElTX01BUCA9IFRZUEUgPT0gMTtcbiAgdmFyIElTX0ZJTFRFUiA9IFRZUEUgPT0gMjtcbiAgdmFyIElTX1NPTUUgPSBUWVBFID09IDM7XG4gIHZhciBJU19FVkVSWSA9IFRZUEUgPT0gNDtcbiAgdmFyIElTX0ZJTkRfSU5ERVggPSBUWVBFID09IDY7XG4gIHZhciBOT19IT0xFUyA9IFRZUEUgPT0gNSB8fCBJU19GSU5EX0lOREVYO1xuICB2YXIgY3JlYXRlID0gJGNyZWF0ZSB8fCBhc2M7XG4gIHJldHVybiBmdW5jdGlvbiAoJHRoaXMsIGNhbGxiYWNrZm4sIHRoYXQpIHtcbiAgICB2YXIgTyA9IHRvT2JqZWN0KCR0aGlzKTtcbiAgICB2YXIgc2VsZiA9IElPYmplY3QoTyk7XG4gICAgdmFyIGYgPSBjdHgoY2FsbGJhY2tmbiwgdGhhdCwgMyk7XG4gICAgdmFyIGxlbmd0aCA9IHRvTGVuZ3RoKHNlbGYubGVuZ3RoKTtcbiAgICB2YXIgaW5kZXggPSAwO1xuICAgIHZhciByZXN1bHQgPSBJU19NQVAgPyBjcmVhdGUoJHRoaXMsIGxlbmd0aCkgOiBJU19GSUxURVIgPyBjcmVhdGUoJHRoaXMsIDApIDogdW5kZWZpbmVkO1xuICAgIHZhciB2YWwsIHJlcztcbiAgICBmb3IgKDtsZW5ndGggPiBpbmRleDsgaW5kZXgrKykgaWYgKE5PX0hPTEVTIHx8IGluZGV4IGluIHNlbGYpIHtcbiAgICAgIHZhbCA9IHNlbGZbaW5kZXhdO1xuICAgICAgcmVzID0gZih2YWwsIGluZGV4LCBPKTtcbiAgICAgIGlmIChUWVBFKSB7XG4gICAgICAgIGlmIChJU19NQVApIHJlc3VsdFtpbmRleF0gPSByZXM7ICAgLy8gbWFwXG4gICAgICAgIGVsc2UgaWYgKHJlcykgc3dpdGNoIChUWVBFKSB7XG4gICAgICAgICAgY2FzZSAzOiByZXR1cm4gdHJ1ZTsgICAgICAgICAgICAgLy8gc29tZVxuICAgICAgICAgIGNhc2UgNTogcmV0dXJuIHZhbDsgICAgICAgICAgICAgIC8vIGZpbmRcbiAgICAgICAgICBjYXNlIDY6IHJldHVybiBpbmRleDsgICAgICAgICAgICAvLyBmaW5kSW5kZXhcbiAgICAgICAgICBjYXNlIDI6IHJlc3VsdC5wdXNoKHZhbCk7ICAgICAgICAvLyBmaWx0ZXJcbiAgICAgICAgfSBlbHNlIGlmIChJU19FVkVSWSkgcmV0dXJuIGZhbHNlOyAvLyBldmVyeVxuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gSVNfRklORF9JTkRFWCA/IC0xIDogSVNfU09NRSB8fCBJU19FVkVSWSA/IElTX0VWRVJZIDogcmVzdWx0O1xuICB9O1xufTtcbiIsInZhciBpc09iamVjdCA9IHJlcXVpcmUoJy4vX2lzLW9iamVjdCcpO1xudmFyIGlzQXJyYXkgPSByZXF1aXJlKCcuL19pcy1hcnJheScpO1xudmFyIFNQRUNJRVMgPSByZXF1aXJlKCcuL193a3MnKSgnc3BlY2llcycpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChvcmlnaW5hbCkge1xuICB2YXIgQztcbiAgaWYgKGlzQXJyYXkob3JpZ2luYWwpKSB7XG4gICAgQyA9IG9yaWdpbmFsLmNvbnN0cnVjdG9yO1xuICAgIC8vIGNyb3NzLXJlYWxtIGZhbGxiYWNrXG4gICAgaWYgKHR5cGVvZiBDID09ICdmdW5jdGlvbicgJiYgKEMgPT09IEFycmF5IHx8IGlzQXJyYXkoQy5wcm90b3R5cGUpKSkgQyA9IHVuZGVmaW5lZDtcbiAgICBpZiAoaXNPYmplY3QoQykpIHtcbiAgICAgIEMgPSBDW1NQRUNJRVNdO1xuICAgICAgaWYgKEMgPT09IG51bGwpIEMgPSB1bmRlZmluZWQ7XG4gICAgfVxuICB9IHJldHVybiBDID09PSB1bmRlZmluZWQgPyBBcnJheSA6IEM7XG59O1xuIiwiLy8gOS40LjIuMyBBcnJheVNwZWNpZXNDcmVhdGUob3JpZ2luYWxBcnJheSwgbGVuZ3RoKVxudmFyIHNwZWNpZXNDb25zdHJ1Y3RvciA9IHJlcXVpcmUoJy4vX2FycmF5LXNwZWNpZXMtY29uc3RydWN0b3InKTtcblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAob3JpZ2luYWwsIGxlbmd0aCkge1xuICByZXR1cm4gbmV3IChzcGVjaWVzQ29uc3RydWN0b3Iob3JpZ2luYWwpKShsZW5ndGgpO1xufTtcbiIsIi8vIGdldHRpbmcgdGFnIGZyb20gMTkuMS4zLjYgT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZygpXG52YXIgY29mID0gcmVxdWlyZSgnLi9fY29mJyk7XG52YXIgVEFHID0gcmVxdWlyZSgnLi9fd2tzJykoJ3RvU3RyaW5nVGFnJyk7XG4vLyBFUzMgd3JvbmcgaGVyZVxudmFyIEFSRyA9IGNvZihmdW5jdGlvbiAoKSB7IHJldHVybiBhcmd1bWVudHM7IH0oKSkgPT0gJ0FyZ3VtZW50cyc7XG5cbi8vIGZhbGxiYWNrIGZvciBJRTExIFNjcmlwdCBBY2Nlc3MgRGVuaWVkIGVycm9yXG52YXIgdHJ5R2V0ID0gZnVuY3Rpb24gKGl0LCBrZXkpIHtcbiAgdHJ5IHtcbiAgICByZXR1cm4gaXRba2V5XTtcbiAgfSBjYXRjaCAoZSkgeyAvKiBlbXB0eSAqLyB9XG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChpdCkge1xuICB2YXIgTywgVCwgQjtcbiAgcmV0dXJuIGl0ID09PSB1bmRlZmluZWQgPyAnVW5kZWZpbmVkJyA6IGl0ID09PSBudWxsID8gJ051bGwnXG4gICAgLy8gQEB0b1N0cmluZ1RhZyBjYXNlXG4gICAgOiB0eXBlb2YgKFQgPSB0cnlHZXQoTyA9IE9iamVjdChpdCksIFRBRykpID09ICdzdHJpbmcnID8gVFxuICAgIC8vIGJ1aWx0aW5UYWcgY2FzZVxuICAgIDogQVJHID8gY29mKE8pXG4gICAgLy8gRVMzIGFyZ3VtZW50cyBmYWxsYmFja1xuICAgIDogKEIgPSBjb2YoTykpID09ICdPYmplY3QnICYmIHR5cGVvZiBPLmNhbGxlZSA9PSAnZnVuY3Rpb24nID8gJ0FyZ3VtZW50cycgOiBCO1xufTtcbiIsInZhciB0b1N0cmluZyA9IHt9LnRvU3RyaW5nO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChpdCkge1xuICByZXR1cm4gdG9TdHJpbmcuY2FsbChpdCkuc2xpY2UoOCwgLTEpO1xufTtcbiIsIid1c2Ugc3RyaWN0JztcbnZhciBkUCA9IHJlcXVpcmUoJy4vX29iamVjdC1kcCcpLmY7XG52YXIgY3JlYXRlID0gcmVxdWlyZSgnLi9fb2JqZWN0LWNyZWF0ZScpO1xudmFyIHJlZGVmaW5lQWxsID0gcmVxdWlyZSgnLi9fcmVkZWZpbmUtYWxsJyk7XG52YXIgY3R4ID0gcmVxdWlyZSgnLi9fY3R4Jyk7XG52YXIgYW5JbnN0YW5jZSA9IHJlcXVpcmUoJy4vX2FuLWluc3RhbmNlJyk7XG52YXIgZm9yT2YgPSByZXF1aXJlKCcuL19mb3Itb2YnKTtcbnZhciAkaXRlckRlZmluZSA9IHJlcXVpcmUoJy4vX2l0ZXItZGVmaW5lJyk7XG52YXIgc3RlcCA9IHJlcXVpcmUoJy4vX2l0ZXItc3RlcCcpO1xudmFyIHNldFNwZWNpZXMgPSByZXF1aXJlKCcuL19zZXQtc3BlY2llcycpO1xudmFyIERFU0NSSVBUT1JTID0gcmVxdWlyZSgnLi9fZGVzY3JpcHRvcnMnKTtcbnZhciBmYXN0S2V5ID0gcmVxdWlyZSgnLi9fbWV0YScpLmZhc3RLZXk7XG52YXIgdmFsaWRhdGUgPSByZXF1aXJlKCcuL192YWxpZGF0ZS1jb2xsZWN0aW9uJyk7XG52YXIgU0laRSA9IERFU0NSSVBUT1JTID8gJ19zJyA6ICdzaXplJztcblxudmFyIGdldEVudHJ5ID0gZnVuY3Rpb24gKHRoYXQsIGtleSkge1xuICAvLyBmYXN0IGNhc2VcbiAgdmFyIGluZGV4ID0gZmFzdEtleShrZXkpO1xuICB2YXIgZW50cnk7XG4gIGlmIChpbmRleCAhPT0gJ0YnKSByZXR1cm4gdGhhdC5faVtpbmRleF07XG4gIC8vIGZyb3plbiBvYmplY3QgY2FzZVxuICBmb3IgKGVudHJ5ID0gdGhhdC5fZjsgZW50cnk7IGVudHJ5ID0gZW50cnkubikge1xuICAgIGlmIChlbnRyeS5rID09IGtleSkgcmV0dXJuIGVudHJ5O1xuICB9XG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IHtcbiAgZ2V0Q29uc3RydWN0b3I6IGZ1bmN0aW9uICh3cmFwcGVyLCBOQU1FLCBJU19NQVAsIEFEREVSKSB7XG4gICAgdmFyIEMgPSB3cmFwcGVyKGZ1bmN0aW9uICh0aGF0LCBpdGVyYWJsZSkge1xuICAgICAgYW5JbnN0YW5jZSh0aGF0LCBDLCBOQU1FLCAnX2knKTtcbiAgICAgIHRoYXQuX3QgPSBOQU1FOyAgICAgICAgIC8vIGNvbGxlY3Rpb24gdHlwZVxuICAgICAgdGhhdC5faSA9IGNyZWF0ZShudWxsKTsgLy8gaW5kZXhcbiAgICAgIHRoYXQuX2YgPSB1bmRlZmluZWQ7ICAgIC8vIGZpcnN0IGVudHJ5XG4gICAgICB0aGF0Ll9sID0gdW5kZWZpbmVkOyAgICAvLyBsYXN0IGVudHJ5XG4gICAgICB0aGF0W1NJWkVdID0gMDsgICAgICAgICAvLyBzaXplXG4gICAgICBpZiAoaXRlcmFibGUgIT0gdW5kZWZpbmVkKSBmb3JPZihpdGVyYWJsZSwgSVNfTUFQLCB0aGF0W0FEREVSXSwgdGhhdCk7XG4gICAgfSk7XG4gICAgcmVkZWZpbmVBbGwoQy5wcm90b3R5cGUsIHtcbiAgICAgIC8vIDIzLjEuMy4xIE1hcC5wcm90b3R5cGUuY2xlYXIoKVxuICAgICAgLy8gMjMuMi4zLjIgU2V0LnByb3RvdHlwZS5jbGVhcigpXG4gICAgICBjbGVhcjogZnVuY3Rpb24gY2xlYXIoKSB7XG4gICAgICAgIGZvciAodmFyIHRoYXQgPSB2YWxpZGF0ZSh0aGlzLCBOQU1FKSwgZGF0YSA9IHRoYXQuX2ksIGVudHJ5ID0gdGhhdC5fZjsgZW50cnk7IGVudHJ5ID0gZW50cnkubikge1xuICAgICAgICAgIGVudHJ5LnIgPSB0cnVlO1xuICAgICAgICAgIGlmIChlbnRyeS5wKSBlbnRyeS5wID0gZW50cnkucC5uID0gdW5kZWZpbmVkO1xuICAgICAgICAgIGRlbGV0ZSBkYXRhW2VudHJ5LmldO1xuICAgICAgICB9XG4gICAgICAgIHRoYXQuX2YgPSB0aGF0Ll9sID0gdW5kZWZpbmVkO1xuICAgICAgICB0aGF0W1NJWkVdID0gMDtcbiAgICAgIH0sXG4gICAgICAvLyAyMy4xLjMuMyBNYXAucHJvdG90eXBlLmRlbGV0ZShrZXkpXG4gICAgICAvLyAyMy4yLjMuNCBTZXQucHJvdG90eXBlLmRlbGV0ZSh2YWx1ZSlcbiAgICAgICdkZWxldGUnOiBmdW5jdGlvbiAoa2V5KSB7XG4gICAgICAgIHZhciB0aGF0ID0gdmFsaWRhdGUodGhpcywgTkFNRSk7XG4gICAgICAgIHZhciBlbnRyeSA9IGdldEVudHJ5KHRoYXQsIGtleSk7XG4gICAgICAgIGlmIChlbnRyeSkge1xuICAgICAgICAgIHZhciBuZXh0ID0gZW50cnkubjtcbiAgICAgICAgICB2YXIgcHJldiA9IGVudHJ5LnA7XG4gICAgICAgICAgZGVsZXRlIHRoYXQuX2lbZW50cnkuaV07XG4gICAgICAgICAgZW50cnkuciA9IHRydWU7XG4gICAgICAgICAgaWYgKHByZXYpIHByZXYubiA9IG5leHQ7XG4gICAgICAgICAgaWYgKG5leHQpIG5leHQucCA9IHByZXY7XG4gICAgICAgICAgaWYgKHRoYXQuX2YgPT0gZW50cnkpIHRoYXQuX2YgPSBuZXh0O1xuICAgICAgICAgIGlmICh0aGF0Ll9sID09IGVudHJ5KSB0aGF0Ll9sID0gcHJldjtcbiAgICAgICAgICB0aGF0W1NJWkVdLS07XG4gICAgICAgIH0gcmV0dXJuICEhZW50cnk7XG4gICAgICB9LFxuICAgICAgLy8gMjMuMi4zLjYgU2V0LnByb3RvdHlwZS5mb3JFYWNoKGNhbGxiYWNrZm4sIHRoaXNBcmcgPSB1bmRlZmluZWQpXG4gICAgICAvLyAyMy4xLjMuNSBNYXAucHJvdG90eXBlLmZvckVhY2goY2FsbGJhY2tmbiwgdGhpc0FyZyA9IHVuZGVmaW5lZClcbiAgICAgIGZvckVhY2g6IGZ1bmN0aW9uIGZvckVhY2goY2FsbGJhY2tmbiAvKiAsIHRoYXQgPSB1bmRlZmluZWQgKi8pIHtcbiAgICAgICAgdmFsaWRhdGUodGhpcywgTkFNRSk7XG4gICAgICAgIHZhciBmID0gY3R4KGNhbGxiYWNrZm4sIGFyZ3VtZW50cy5sZW5ndGggPiAxID8gYXJndW1lbnRzWzFdIDogdW5kZWZpbmVkLCAzKTtcbiAgICAgICAgdmFyIGVudHJ5O1xuICAgICAgICB3aGlsZSAoZW50cnkgPSBlbnRyeSA/IGVudHJ5Lm4gOiB0aGlzLl9mKSB7XG4gICAgICAgICAgZihlbnRyeS52LCBlbnRyeS5rLCB0aGlzKTtcbiAgICAgICAgICAvLyByZXZlcnQgdG8gdGhlIGxhc3QgZXhpc3RpbmcgZW50cnlcbiAgICAgICAgICB3aGlsZSAoZW50cnkgJiYgZW50cnkucikgZW50cnkgPSBlbnRyeS5wO1xuICAgICAgICB9XG4gICAgICB9LFxuICAgICAgLy8gMjMuMS4zLjcgTWFwLnByb3RvdHlwZS5oYXMoa2V5KVxuICAgICAgLy8gMjMuMi4zLjcgU2V0LnByb3RvdHlwZS5oYXModmFsdWUpXG4gICAgICBoYXM6IGZ1bmN0aW9uIGhhcyhrZXkpIHtcbiAgICAgICAgcmV0dXJuICEhZ2V0RW50cnkodmFsaWRhdGUodGhpcywgTkFNRSksIGtleSk7XG4gICAgICB9XG4gICAgfSk7XG4gICAgaWYgKERFU0NSSVBUT1JTKSBkUChDLnByb3RvdHlwZSwgJ3NpemUnLCB7XG4gICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIHZhbGlkYXRlKHRoaXMsIE5BTUUpW1NJWkVdO1xuICAgICAgfVxuICAgIH0pO1xuICAgIHJldHVybiBDO1xuICB9LFxuICBkZWY6IGZ1bmN0aW9uICh0aGF0LCBrZXksIHZhbHVlKSB7XG4gICAgdmFyIGVudHJ5ID0gZ2V0RW50cnkodGhhdCwga2V5KTtcbiAgICB2YXIgcHJldiwgaW5kZXg7XG4gICAgLy8gY2hhbmdlIGV4aXN0aW5nIGVudHJ5XG4gICAgaWYgKGVudHJ5KSB7XG4gICAgICBlbnRyeS52ID0gdmFsdWU7XG4gICAgLy8gY3JlYXRlIG5ldyBlbnRyeVxuICAgIH0gZWxzZSB7XG4gICAgICB0aGF0Ll9sID0gZW50cnkgPSB7XG4gICAgICAgIGk6IGluZGV4ID0gZmFzdEtleShrZXksIHRydWUpLCAvLyA8LSBpbmRleFxuICAgICAgICBrOiBrZXksICAgICAgICAgICAgICAgICAgICAgICAgLy8gPC0ga2V5XG4gICAgICAgIHY6IHZhbHVlLCAgICAgICAgICAgICAgICAgICAgICAvLyA8LSB2YWx1ZVxuICAgICAgICBwOiBwcmV2ID0gdGhhdC5fbCwgICAgICAgICAgICAgLy8gPC0gcHJldmlvdXMgZW50cnlcbiAgICAgICAgbjogdW5kZWZpbmVkLCAgICAgICAgICAgICAgICAgIC8vIDwtIG5leHQgZW50cnlcbiAgICAgICAgcjogZmFsc2UgICAgICAgICAgICAgICAgICAgICAgIC8vIDwtIHJlbW92ZWRcbiAgICAgIH07XG4gICAgICBpZiAoIXRoYXQuX2YpIHRoYXQuX2YgPSBlbnRyeTtcbiAgICAgIGlmIChwcmV2KSBwcmV2Lm4gPSBlbnRyeTtcbiAgICAgIHRoYXRbU0laRV0rKztcbiAgICAgIC8vIGFkZCB0byBpbmRleFxuICAgICAgaWYgKGluZGV4ICE9PSAnRicpIHRoYXQuX2lbaW5kZXhdID0gZW50cnk7XG4gICAgfSByZXR1cm4gdGhhdDtcbiAgfSxcbiAgZ2V0RW50cnk6IGdldEVudHJ5LFxuICBzZXRTdHJvbmc6IGZ1bmN0aW9uIChDLCBOQU1FLCBJU19NQVApIHtcbiAgICAvLyBhZGQgLmtleXMsIC52YWx1ZXMsIC5lbnRyaWVzLCBbQEBpdGVyYXRvcl1cbiAgICAvLyAyMy4xLjMuNCwgMjMuMS4zLjgsIDIzLjEuMy4xMSwgMjMuMS4zLjEyLCAyMy4yLjMuNSwgMjMuMi4zLjgsIDIzLjIuMy4xMCwgMjMuMi4zLjExXG4gICAgJGl0ZXJEZWZpbmUoQywgTkFNRSwgZnVuY3Rpb24gKGl0ZXJhdGVkLCBraW5kKSB7XG4gICAgICB0aGlzLl90ID0gdmFsaWRhdGUoaXRlcmF0ZWQsIE5BTUUpOyAvLyB0YXJnZXRcbiAgICAgIHRoaXMuX2sgPSBraW5kOyAgICAgICAgICAgICAgICAgICAgIC8vIGtpbmRcbiAgICAgIHRoaXMuX2wgPSB1bmRlZmluZWQ7ICAgICAgICAgICAgICAgIC8vIHByZXZpb3VzXG4gICAgfSwgZnVuY3Rpb24gKCkge1xuICAgICAgdmFyIHRoYXQgPSB0aGlzO1xuICAgICAgdmFyIGtpbmQgPSB0aGF0Ll9rO1xuICAgICAgdmFyIGVudHJ5ID0gdGhhdC5fbDtcbiAgICAgIC8vIHJldmVydCB0byB0aGUgbGFzdCBleGlzdGluZyBlbnRyeVxuICAgICAgd2hpbGUgKGVudHJ5ICYmIGVudHJ5LnIpIGVudHJ5ID0gZW50cnkucDtcbiAgICAgIC8vIGdldCBuZXh0IGVudHJ5XG4gICAgICBpZiAoIXRoYXQuX3QgfHwgISh0aGF0Ll9sID0gZW50cnkgPSBlbnRyeSA/IGVudHJ5Lm4gOiB0aGF0Ll90Ll9mKSkge1xuICAgICAgICAvLyBvciBmaW5pc2ggdGhlIGl0ZXJhdGlvblxuICAgICAgICB0aGF0Ll90ID0gdW5kZWZpbmVkO1xuICAgICAgICByZXR1cm4gc3RlcCgxKTtcbiAgICAgIH1cbiAgICAgIC8vIHJldHVybiBzdGVwIGJ5IGtpbmRcbiAgICAgIGlmIChraW5kID09ICdrZXlzJykgcmV0dXJuIHN0ZXAoMCwgZW50cnkuayk7XG4gICAgICBpZiAoa2luZCA9PSAndmFsdWVzJykgcmV0dXJuIHN0ZXAoMCwgZW50cnkudik7XG4gICAgICByZXR1cm4gc3RlcCgwLCBbZW50cnkuaywgZW50cnkudl0pO1xuICAgIH0sIElTX01BUCA/ICdlbnRyaWVzJyA6ICd2YWx1ZXMnLCAhSVNfTUFQLCB0cnVlKTtcblxuICAgIC8vIGFkZCBbQEBzcGVjaWVzXSwgMjMuMS4yLjIsIDIzLjIuMi4yXG4gICAgc2V0U3BlY2llcyhOQU1FKTtcbiAgfVxufTtcbiIsIi8vIGh0dHBzOi8vZ2l0aHViLmNvbS9EYXZpZEJydWFudC9NYXAtU2V0LnByb3RvdHlwZS50b0pTT05cbnZhciBjbGFzc29mID0gcmVxdWlyZSgnLi9fY2xhc3NvZicpO1xudmFyIGZyb20gPSByZXF1aXJlKCcuL19hcnJheS1mcm9tLWl0ZXJhYmxlJyk7XG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChOQU1FKSB7XG4gIHJldHVybiBmdW5jdGlvbiB0b0pTT04oKSB7XG4gICAgaWYgKGNsYXNzb2YodGhpcykgIT0gTkFNRSkgdGhyb3cgVHlwZUVycm9yKE5BTUUgKyBcIiN0b0pTT04gaXNuJ3QgZ2VuZXJpY1wiKTtcbiAgICByZXR1cm4gZnJvbSh0aGlzKTtcbiAgfTtcbn07XG4iLCIndXNlIHN0cmljdCc7XG52YXIgZ2xvYmFsID0gcmVxdWlyZSgnLi9fZ2xvYmFsJyk7XG52YXIgJGV4cG9ydCA9IHJlcXVpcmUoJy4vX2V4cG9ydCcpO1xudmFyIG1ldGEgPSByZXF1aXJlKCcuL19tZXRhJyk7XG52YXIgZmFpbHMgPSByZXF1aXJlKCcuL19mYWlscycpO1xudmFyIGhpZGUgPSByZXF1aXJlKCcuL19oaWRlJyk7XG52YXIgcmVkZWZpbmVBbGwgPSByZXF1aXJlKCcuL19yZWRlZmluZS1hbGwnKTtcbnZhciBmb3JPZiA9IHJlcXVpcmUoJy4vX2Zvci1vZicpO1xudmFyIGFuSW5zdGFuY2UgPSByZXF1aXJlKCcuL19hbi1pbnN0YW5jZScpO1xudmFyIGlzT2JqZWN0ID0gcmVxdWlyZSgnLi9faXMtb2JqZWN0Jyk7XG52YXIgc2V0VG9TdHJpbmdUYWcgPSByZXF1aXJlKCcuL19zZXQtdG8tc3RyaW5nLXRhZycpO1xudmFyIGRQID0gcmVxdWlyZSgnLi9fb2JqZWN0LWRwJykuZjtcbnZhciBlYWNoID0gcmVxdWlyZSgnLi9fYXJyYXktbWV0aG9kcycpKDApO1xudmFyIERFU0NSSVBUT1JTID0gcmVxdWlyZSgnLi9fZGVzY3JpcHRvcnMnKTtcblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoTkFNRSwgd3JhcHBlciwgbWV0aG9kcywgY29tbW9uLCBJU19NQVAsIElTX1dFQUspIHtcbiAgdmFyIEJhc2UgPSBnbG9iYWxbTkFNRV07XG4gIHZhciBDID0gQmFzZTtcbiAgdmFyIEFEREVSID0gSVNfTUFQID8gJ3NldCcgOiAnYWRkJztcbiAgdmFyIHByb3RvID0gQyAmJiBDLnByb3RvdHlwZTtcbiAgdmFyIE8gPSB7fTtcbiAgaWYgKCFERVNDUklQVE9SUyB8fCB0eXBlb2YgQyAhPSAnZnVuY3Rpb24nIHx8ICEoSVNfV0VBSyB8fCBwcm90by5mb3JFYWNoICYmICFmYWlscyhmdW5jdGlvbiAoKSB7XG4gICAgbmV3IEMoKS5lbnRyaWVzKCkubmV4dCgpO1xuICB9KSkpIHtcbiAgICAvLyBjcmVhdGUgY29sbGVjdGlvbiBjb25zdHJ1Y3RvclxuICAgIEMgPSBjb21tb24uZ2V0Q29uc3RydWN0b3Iod3JhcHBlciwgTkFNRSwgSVNfTUFQLCBBRERFUik7XG4gICAgcmVkZWZpbmVBbGwoQy5wcm90b3R5cGUsIG1ldGhvZHMpO1xuICAgIG1ldGEuTkVFRCA9IHRydWU7XG4gIH0gZWxzZSB7XG4gICAgQyA9IHdyYXBwZXIoZnVuY3Rpb24gKHRhcmdldCwgaXRlcmFibGUpIHtcbiAgICAgIGFuSW5zdGFuY2UodGFyZ2V0LCBDLCBOQU1FLCAnX2MnKTtcbiAgICAgIHRhcmdldC5fYyA9IG5ldyBCYXNlKCk7XG4gICAgICBpZiAoaXRlcmFibGUgIT0gdW5kZWZpbmVkKSBmb3JPZihpdGVyYWJsZSwgSVNfTUFQLCB0YXJnZXRbQURERVJdLCB0YXJnZXQpO1xuICAgIH0pO1xuICAgIGVhY2goJ2FkZCxjbGVhcixkZWxldGUsZm9yRWFjaCxnZXQsaGFzLHNldCxrZXlzLHZhbHVlcyxlbnRyaWVzLHRvSlNPTicuc3BsaXQoJywnKSwgZnVuY3Rpb24gKEtFWSkge1xuICAgICAgdmFyIElTX0FEREVSID0gS0VZID09ICdhZGQnIHx8IEtFWSA9PSAnc2V0JztcbiAgICAgIGlmIChLRVkgaW4gcHJvdG8gJiYgIShJU19XRUFLICYmIEtFWSA9PSAnY2xlYXInKSkgaGlkZShDLnByb3RvdHlwZSwgS0VZLCBmdW5jdGlvbiAoYSwgYikge1xuICAgICAgICBhbkluc3RhbmNlKHRoaXMsIEMsIEtFWSk7XG4gICAgICAgIGlmICghSVNfQURERVIgJiYgSVNfV0VBSyAmJiAhaXNPYmplY3QoYSkpIHJldHVybiBLRVkgPT0gJ2dldCcgPyB1bmRlZmluZWQgOiBmYWxzZTtcbiAgICAgICAgdmFyIHJlc3VsdCA9IHRoaXMuX2NbS0VZXShhID09PSAwID8gMCA6IGEsIGIpO1xuICAgICAgICByZXR1cm4gSVNfQURERVIgPyB0aGlzIDogcmVzdWx0O1xuICAgICAgfSk7XG4gICAgfSk7XG4gICAgSVNfV0VBSyB8fCBkUChDLnByb3RvdHlwZSwgJ3NpemUnLCB7XG4gICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2Muc2l6ZTtcbiAgICAgIH1cbiAgICB9KTtcbiAgfVxuXG4gIHNldFRvU3RyaW5nVGFnKEMsIE5BTUUpO1xuXG4gIE9bTkFNRV0gPSBDO1xuICAkZXhwb3J0KCRleHBvcnQuRyArICRleHBvcnQuVyArICRleHBvcnQuRiwgTyk7XG5cbiAgaWYgKCFJU19XRUFLKSBjb21tb24uc2V0U3Ryb25nKEMsIE5BTUUsIElTX01BUCk7XG5cbiAgcmV0dXJuIEM7XG59O1xuIiwidmFyIGNvcmUgPSBtb2R1bGUuZXhwb3J0cyA9IHsgdmVyc2lvbjogJzIuNS4wJyB9O1xuaWYgKHR5cGVvZiBfX2UgPT0gJ251bWJlcicpIF9fZSA9IGNvcmU7IC8vIGVzbGludC1kaXNhYmxlLWxpbmUgbm8tdW5kZWZcbiIsIid1c2Ugc3RyaWN0JztcbnZhciAkZGVmaW5lUHJvcGVydHkgPSByZXF1aXJlKCcuL19vYmplY3QtZHAnKTtcbnZhciBjcmVhdGVEZXNjID0gcmVxdWlyZSgnLi9fcHJvcGVydHktZGVzYycpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChvYmplY3QsIGluZGV4LCB2YWx1ZSkge1xuICBpZiAoaW5kZXggaW4gb2JqZWN0KSAkZGVmaW5lUHJvcGVydHkuZihvYmplY3QsIGluZGV4LCBjcmVhdGVEZXNjKDAsIHZhbHVlKSk7XG4gIGVsc2Ugb2JqZWN0W2luZGV4XSA9IHZhbHVlO1xufTtcbiIsIi8vIG9wdGlvbmFsIC8gc2ltcGxlIGNvbnRleHQgYmluZGluZ1xudmFyIGFGdW5jdGlvbiA9IHJlcXVpcmUoJy4vX2EtZnVuY3Rpb24nKTtcbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKGZuLCB0aGF0LCBsZW5ndGgpIHtcbiAgYUZ1bmN0aW9uKGZuKTtcbiAgaWYgKHRoYXQgPT09IHVuZGVmaW5lZCkgcmV0dXJuIGZuO1xuICBzd2l0Y2ggKGxlbmd0aCkge1xuICAgIGNhc2UgMTogcmV0dXJuIGZ1bmN0aW9uIChhKSB7XG4gICAgICByZXR1cm4gZm4uY2FsbCh0aGF0LCBhKTtcbiAgICB9O1xuICAgIGNhc2UgMjogcmV0dXJuIGZ1bmN0aW9uIChhLCBiKSB7XG4gICAgICByZXR1cm4gZm4uY2FsbCh0aGF0LCBhLCBiKTtcbiAgICB9O1xuICAgIGNhc2UgMzogcmV0dXJuIGZ1bmN0aW9uIChhLCBiLCBjKSB7XG4gICAgICByZXR1cm4gZm4uY2FsbCh0aGF0LCBhLCBiLCBjKTtcbiAgICB9O1xuICB9XG4gIHJldHVybiBmdW5jdGlvbiAoLyogLi4uYXJncyAqLykge1xuICAgIHJldHVybiBmbi5hcHBseSh0aGF0LCBhcmd1bWVudHMpO1xuICB9O1xufTtcbiIsIi8vIDcuMi4xIFJlcXVpcmVPYmplY3RDb2VyY2libGUoYXJndW1lbnQpXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChpdCkge1xuICBpZiAoaXQgPT0gdW5kZWZpbmVkKSB0aHJvdyBUeXBlRXJyb3IoXCJDYW4ndCBjYWxsIG1ldGhvZCBvbiAgXCIgKyBpdCk7XG4gIHJldHVybiBpdDtcbn07XG4iLCIvLyBUaGFuaydzIElFOCBmb3IgaGlzIGZ1bm55IGRlZmluZVByb3BlcnR5XG5tb2R1bGUuZXhwb3J0cyA9ICFyZXF1aXJlKCcuL19mYWlscycpKGZ1bmN0aW9uICgpIHtcbiAgcmV0dXJuIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh7fSwgJ2EnLCB7IGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gNzsgfSB9KS5hICE9IDc7XG59KTtcbiIsInZhciBpc09iamVjdCA9IHJlcXVpcmUoJy4vX2lzLW9iamVjdCcpO1xudmFyIGRvY3VtZW50ID0gcmVxdWlyZSgnLi9fZ2xvYmFsJykuZG9jdW1lbnQ7XG4vLyB0eXBlb2YgZG9jdW1lbnQuY3JlYXRlRWxlbWVudCBpcyAnb2JqZWN0JyBpbiBvbGQgSUVcbnZhciBpcyA9IGlzT2JqZWN0KGRvY3VtZW50KSAmJiBpc09iamVjdChkb2N1bWVudC5jcmVhdGVFbGVtZW50KTtcbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKGl0KSB7XG4gIHJldHVybiBpcyA/IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoaXQpIDoge307XG59O1xuIiwiLy8gSUUgOC0gZG9uJ3QgZW51bSBidWcga2V5c1xubW9kdWxlLmV4cG9ydHMgPSAoXG4gICdjb25zdHJ1Y3RvcixoYXNPd25Qcm9wZXJ0eSxpc1Byb3RvdHlwZU9mLHByb3BlcnR5SXNFbnVtZXJhYmxlLHRvTG9jYWxlU3RyaW5nLHRvU3RyaW5nLHZhbHVlT2YnXG4pLnNwbGl0KCcsJyk7XG4iLCIvLyBhbGwgZW51bWVyYWJsZSBvYmplY3Qga2V5cywgaW5jbHVkZXMgc3ltYm9sc1xudmFyIGdldEtleXMgPSByZXF1aXJlKCcuL19vYmplY3Qta2V5cycpO1xudmFyIGdPUFMgPSByZXF1aXJlKCcuL19vYmplY3QtZ29wcycpO1xudmFyIHBJRSA9IHJlcXVpcmUoJy4vX29iamVjdC1waWUnKTtcbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKGl0KSB7XG4gIHZhciByZXN1bHQgPSBnZXRLZXlzKGl0KTtcbiAgdmFyIGdldFN5bWJvbHMgPSBnT1BTLmY7XG4gIGlmIChnZXRTeW1ib2xzKSB7XG4gICAgdmFyIHN5bWJvbHMgPSBnZXRTeW1ib2xzKGl0KTtcbiAgICB2YXIgaXNFbnVtID0gcElFLmY7XG4gICAgdmFyIGkgPSAwO1xuICAgIHZhciBrZXk7XG4gICAgd2hpbGUgKHN5bWJvbHMubGVuZ3RoID4gaSkgaWYgKGlzRW51bS5jYWxsKGl0LCBrZXkgPSBzeW1ib2xzW2krK10pKSByZXN1bHQucHVzaChrZXkpO1xuICB9IHJldHVybiByZXN1bHQ7XG59O1xuIiwidmFyIGdsb2JhbCA9IHJlcXVpcmUoJy4vX2dsb2JhbCcpO1xudmFyIGNvcmUgPSByZXF1aXJlKCcuL19jb3JlJyk7XG52YXIgY3R4ID0gcmVxdWlyZSgnLi9fY3R4Jyk7XG52YXIgaGlkZSA9IHJlcXVpcmUoJy4vX2hpZGUnKTtcbnZhciBQUk9UT1RZUEUgPSAncHJvdG90eXBlJztcblxudmFyICRleHBvcnQgPSBmdW5jdGlvbiAodHlwZSwgbmFtZSwgc291cmNlKSB7XG4gIHZhciBJU19GT1JDRUQgPSB0eXBlICYgJGV4cG9ydC5GO1xuICB2YXIgSVNfR0xPQkFMID0gdHlwZSAmICRleHBvcnQuRztcbiAgdmFyIElTX1NUQVRJQyA9IHR5cGUgJiAkZXhwb3J0LlM7XG4gIHZhciBJU19QUk9UTyA9IHR5cGUgJiAkZXhwb3J0LlA7XG4gIHZhciBJU19CSU5EID0gdHlwZSAmICRleHBvcnQuQjtcbiAgdmFyIElTX1dSQVAgPSB0eXBlICYgJGV4cG9ydC5XO1xuICB2YXIgZXhwb3J0cyA9IElTX0dMT0JBTCA/IGNvcmUgOiBjb3JlW25hbWVdIHx8IChjb3JlW25hbWVdID0ge30pO1xuICB2YXIgZXhwUHJvdG8gPSBleHBvcnRzW1BST1RPVFlQRV07XG4gIHZhciB0YXJnZXQgPSBJU19HTE9CQUwgPyBnbG9iYWwgOiBJU19TVEFUSUMgPyBnbG9iYWxbbmFtZV0gOiAoZ2xvYmFsW25hbWVdIHx8IHt9KVtQUk9UT1RZUEVdO1xuICB2YXIga2V5LCBvd24sIG91dDtcbiAgaWYgKElTX0dMT0JBTCkgc291cmNlID0gbmFtZTtcbiAgZm9yIChrZXkgaW4gc291cmNlKSB7XG4gICAgLy8gY29udGFpbnMgaW4gbmF0aXZlXG4gICAgb3duID0gIUlTX0ZPUkNFRCAmJiB0YXJnZXQgJiYgdGFyZ2V0W2tleV0gIT09IHVuZGVmaW5lZDtcbiAgICBpZiAob3duICYmIGtleSBpbiBleHBvcnRzKSBjb250aW51ZTtcbiAgICAvLyBleHBvcnQgbmF0aXZlIG9yIHBhc3NlZFxuICAgIG91dCA9IG93biA/IHRhcmdldFtrZXldIDogc291cmNlW2tleV07XG4gICAgLy8gcHJldmVudCBnbG9iYWwgcG9sbHV0aW9uIGZvciBuYW1lc3BhY2VzXG4gICAgZXhwb3J0c1trZXldID0gSVNfR0xPQkFMICYmIHR5cGVvZiB0YXJnZXRba2V5XSAhPSAnZnVuY3Rpb24nID8gc291cmNlW2tleV1cbiAgICAvLyBiaW5kIHRpbWVycyB0byBnbG9iYWwgZm9yIGNhbGwgZnJvbSBleHBvcnQgY29udGV4dFxuICAgIDogSVNfQklORCAmJiBvd24gPyBjdHgob3V0LCBnbG9iYWwpXG4gICAgLy8gd3JhcCBnbG9iYWwgY29uc3RydWN0b3JzIGZvciBwcmV2ZW50IGNoYW5nZSB0aGVtIGluIGxpYnJhcnlcbiAgICA6IElTX1dSQVAgJiYgdGFyZ2V0W2tleV0gPT0gb3V0ID8gKGZ1bmN0aW9uIChDKSB7XG4gICAgICB2YXIgRiA9IGZ1bmN0aW9uIChhLCBiLCBjKSB7XG4gICAgICAgIGlmICh0aGlzIGluc3RhbmNlb2YgQykge1xuICAgICAgICAgIHN3aXRjaCAoYXJndW1lbnRzLmxlbmd0aCkge1xuICAgICAgICAgICAgY2FzZSAwOiByZXR1cm4gbmV3IEMoKTtcbiAgICAgICAgICAgIGNhc2UgMTogcmV0dXJuIG5ldyBDKGEpO1xuICAgICAgICAgICAgY2FzZSAyOiByZXR1cm4gbmV3IEMoYSwgYik7XG4gICAgICAgICAgfSByZXR1cm4gbmV3IEMoYSwgYiwgYyk7XG4gICAgICAgIH0gcmV0dXJuIEMuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICAgIH07XG4gICAgICBGW1BST1RPVFlQRV0gPSBDW1BST1RPVFlQRV07XG4gICAgICByZXR1cm4gRjtcbiAgICAvLyBtYWtlIHN0YXRpYyB2ZXJzaW9ucyBmb3IgcHJvdG90eXBlIG1ldGhvZHNcbiAgICB9KShvdXQpIDogSVNfUFJPVE8gJiYgdHlwZW9mIG91dCA9PSAnZnVuY3Rpb24nID8gY3R4KEZ1bmN0aW9uLmNhbGwsIG91dCkgOiBvdXQ7XG4gICAgLy8gZXhwb3J0IHByb3RvIG1ldGhvZHMgdG8gY29yZS4lQ09OU1RSVUNUT1IlLm1ldGhvZHMuJU5BTUUlXG4gICAgaWYgKElTX1BST1RPKSB7XG4gICAgICAoZXhwb3J0cy52aXJ0dWFsIHx8IChleHBvcnRzLnZpcnR1YWwgPSB7fSkpW2tleV0gPSBvdXQ7XG4gICAgICAvLyBleHBvcnQgcHJvdG8gbWV0aG9kcyB0byBjb3JlLiVDT05TVFJVQ1RPUiUucHJvdG90eXBlLiVOQU1FJVxuICAgICAgaWYgKHR5cGUgJiAkZXhwb3J0LlIgJiYgZXhwUHJvdG8gJiYgIWV4cFByb3RvW2tleV0pIGhpZGUoZXhwUHJvdG8sIGtleSwgb3V0KTtcbiAgICB9XG4gIH1cbn07XG4vLyB0eXBlIGJpdG1hcFxuJGV4cG9ydC5GID0gMTsgICAvLyBmb3JjZWRcbiRleHBvcnQuRyA9IDI7ICAgLy8gZ2xvYmFsXG4kZXhwb3J0LlMgPSA0OyAgIC8vIHN0YXRpY1xuJGV4cG9ydC5QID0gODsgICAvLyBwcm90b1xuJGV4cG9ydC5CID0gMTY7ICAvLyBiaW5kXG4kZXhwb3J0LlcgPSAzMjsgIC8vIHdyYXBcbiRleHBvcnQuVSA9IDY0OyAgLy8gc2FmZVxuJGV4cG9ydC5SID0gMTI4OyAvLyByZWFsIHByb3RvIG1ldGhvZCBmb3IgYGxpYnJhcnlgXG5tb2R1bGUuZXhwb3J0cyA9ICRleHBvcnQ7XG4iLCJtb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChleGVjKSB7XG4gIHRyeSB7XG4gICAgcmV0dXJuICEhZXhlYygpO1xuICB9IGNhdGNoIChlKSB7XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cbn07XG4iLCJ2YXIgY3R4ID0gcmVxdWlyZSgnLi9fY3R4Jyk7XG52YXIgY2FsbCA9IHJlcXVpcmUoJy4vX2l0ZXItY2FsbCcpO1xudmFyIGlzQXJyYXlJdGVyID0gcmVxdWlyZSgnLi9faXMtYXJyYXktaXRlcicpO1xudmFyIGFuT2JqZWN0ID0gcmVxdWlyZSgnLi9fYW4tb2JqZWN0Jyk7XG52YXIgdG9MZW5ndGggPSByZXF1aXJlKCcuL190by1sZW5ndGgnKTtcbnZhciBnZXRJdGVyRm4gPSByZXF1aXJlKCcuL2NvcmUuZ2V0LWl0ZXJhdG9yLW1ldGhvZCcpO1xudmFyIEJSRUFLID0ge307XG52YXIgUkVUVVJOID0ge307XG52YXIgZXhwb3J0cyA9IG1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKGl0ZXJhYmxlLCBlbnRyaWVzLCBmbiwgdGhhdCwgSVRFUkFUT1IpIHtcbiAgdmFyIGl0ZXJGbiA9IElURVJBVE9SID8gZnVuY3Rpb24gKCkgeyByZXR1cm4gaXRlcmFibGU7IH0gOiBnZXRJdGVyRm4oaXRlcmFibGUpO1xuICB2YXIgZiA9IGN0eChmbiwgdGhhdCwgZW50cmllcyA/IDIgOiAxKTtcbiAgdmFyIGluZGV4ID0gMDtcbiAgdmFyIGxlbmd0aCwgc3RlcCwgaXRlcmF0b3IsIHJlc3VsdDtcbiAgaWYgKHR5cGVvZiBpdGVyRm4gIT0gJ2Z1bmN0aW9uJykgdGhyb3cgVHlwZUVycm9yKGl0ZXJhYmxlICsgJyBpcyBub3QgaXRlcmFibGUhJyk7XG4gIC8vIGZhc3QgY2FzZSBmb3IgYXJyYXlzIHdpdGggZGVmYXVsdCBpdGVyYXRvclxuICBpZiAoaXNBcnJheUl0ZXIoaXRlckZuKSkgZm9yIChsZW5ndGggPSB0b0xlbmd0aChpdGVyYWJsZS5sZW5ndGgpOyBsZW5ndGggPiBpbmRleDsgaW5kZXgrKykge1xuICAgIHJlc3VsdCA9IGVudHJpZXMgPyBmKGFuT2JqZWN0KHN0ZXAgPSBpdGVyYWJsZVtpbmRleF0pWzBdLCBzdGVwWzFdKSA6IGYoaXRlcmFibGVbaW5kZXhdKTtcbiAgICBpZiAocmVzdWx0ID09PSBCUkVBSyB8fCByZXN1bHQgPT09IFJFVFVSTikgcmV0dXJuIHJlc3VsdDtcbiAgfSBlbHNlIGZvciAoaXRlcmF0b3IgPSBpdGVyRm4uY2FsbChpdGVyYWJsZSk7ICEoc3RlcCA9IGl0ZXJhdG9yLm5leHQoKSkuZG9uZTspIHtcbiAgICByZXN1bHQgPSBjYWxsKGl0ZXJhdG9yLCBmLCBzdGVwLnZhbHVlLCBlbnRyaWVzKTtcbiAgICBpZiAocmVzdWx0ID09PSBCUkVBSyB8fCByZXN1bHQgPT09IFJFVFVSTikgcmV0dXJuIHJlc3VsdDtcbiAgfVxufTtcbmV4cG9ydHMuQlJFQUsgPSBCUkVBSztcbmV4cG9ydHMuUkVUVVJOID0gUkVUVVJOO1xuIiwiLy8gaHR0cHM6Ly9naXRodWIuY29tL3psb2lyb2NrL2NvcmUtanMvaXNzdWVzLzg2I2lzc3VlY29tbWVudC0xMTU3NTkwMjhcbnZhciBnbG9iYWwgPSBtb2R1bGUuZXhwb3J0cyA9IHR5cGVvZiB3aW5kb3cgIT0gJ3VuZGVmaW5lZCcgJiYgd2luZG93Lk1hdGggPT0gTWF0aFxuICA/IHdpbmRvdyA6IHR5cGVvZiBzZWxmICE9ICd1bmRlZmluZWQnICYmIHNlbGYuTWF0aCA9PSBNYXRoID8gc2VsZlxuICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tbmV3LWZ1bmNcbiAgOiBGdW5jdGlvbigncmV0dXJuIHRoaXMnKSgpO1xuaWYgKHR5cGVvZiBfX2cgPT0gJ251bWJlcicpIF9fZyA9IGdsb2JhbDsgLy8gZXNsaW50LWRpc2FibGUtbGluZSBuby11bmRlZlxuIiwidmFyIGhhc093blByb3BlcnR5ID0ge30uaGFzT3duUHJvcGVydHk7XG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChpdCwga2V5KSB7XG4gIHJldHVybiBoYXNPd25Qcm9wZXJ0eS5jYWxsKGl0LCBrZXkpO1xufTtcbiIsInZhciBkUCA9IHJlcXVpcmUoJy4vX29iamVjdC1kcCcpO1xudmFyIGNyZWF0ZURlc2MgPSByZXF1aXJlKCcuL19wcm9wZXJ0eS1kZXNjJyk7XG5tb2R1bGUuZXhwb3J0cyA9IHJlcXVpcmUoJy4vX2Rlc2NyaXB0b3JzJykgPyBmdW5jdGlvbiAob2JqZWN0LCBrZXksIHZhbHVlKSB7XG4gIHJldHVybiBkUC5mKG9iamVjdCwga2V5LCBjcmVhdGVEZXNjKDEsIHZhbHVlKSk7XG59IDogZnVuY3Rpb24gKG9iamVjdCwga2V5LCB2YWx1ZSkge1xuICBvYmplY3Rba2V5XSA9IHZhbHVlO1xuICByZXR1cm4gb2JqZWN0O1xufTtcbiIsInZhciBkb2N1bWVudCA9IHJlcXVpcmUoJy4vX2dsb2JhbCcpLmRvY3VtZW50O1xubW9kdWxlLmV4cG9ydHMgPSBkb2N1bWVudCAmJiBkb2N1bWVudC5kb2N1bWVudEVsZW1lbnQ7XG4iLCJtb2R1bGUuZXhwb3J0cyA9ICFyZXF1aXJlKCcuL19kZXNjcmlwdG9ycycpICYmICFyZXF1aXJlKCcuL19mYWlscycpKGZ1bmN0aW9uICgpIHtcbiAgcmV0dXJuIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShyZXF1aXJlKCcuL19kb20tY3JlYXRlJykoJ2RpdicpLCAnYScsIHsgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiA3OyB9IH0pLmEgIT0gNztcbn0pO1xuIiwiLy8gZmFzdCBhcHBseSwgaHR0cDovL2pzcGVyZi5sbmtpdC5jb20vZmFzdC1hcHBseS81XG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChmbiwgYXJncywgdGhhdCkge1xuICB2YXIgdW4gPSB0aGF0ID09PSB1bmRlZmluZWQ7XG4gIHN3aXRjaCAoYXJncy5sZW5ndGgpIHtcbiAgICBjYXNlIDA6IHJldHVybiB1biA/IGZuKClcbiAgICAgICAgICAgICAgICAgICAgICA6IGZuLmNhbGwodGhhdCk7XG4gICAgY2FzZSAxOiByZXR1cm4gdW4gPyBmbihhcmdzWzBdKVxuICAgICAgICAgICAgICAgICAgICAgIDogZm4uY2FsbCh0aGF0LCBhcmdzWzBdKTtcbiAgICBjYXNlIDI6IHJldHVybiB1biA/IGZuKGFyZ3NbMF0sIGFyZ3NbMV0pXG4gICAgICAgICAgICAgICAgICAgICAgOiBmbi5jYWxsKHRoYXQsIGFyZ3NbMF0sIGFyZ3NbMV0pO1xuICAgIGNhc2UgMzogcmV0dXJuIHVuID8gZm4oYXJnc1swXSwgYXJnc1sxXSwgYXJnc1syXSlcbiAgICAgICAgICAgICAgICAgICAgICA6IGZuLmNhbGwodGhhdCwgYXJnc1swXSwgYXJnc1sxXSwgYXJnc1syXSk7XG4gICAgY2FzZSA0OiByZXR1cm4gdW4gPyBmbihhcmdzWzBdLCBhcmdzWzFdLCBhcmdzWzJdLCBhcmdzWzNdKVxuICAgICAgICAgICAgICAgICAgICAgIDogZm4uY2FsbCh0aGF0LCBhcmdzWzBdLCBhcmdzWzFdLCBhcmdzWzJdLCBhcmdzWzNdKTtcbiAgfSByZXR1cm4gZm4uYXBwbHkodGhhdCwgYXJncyk7XG59O1xuIiwiLy8gZmFsbGJhY2sgZm9yIG5vbi1hcnJheS1saWtlIEVTMyBhbmQgbm9uLWVudW1lcmFibGUgb2xkIFY4IHN0cmluZ3NcbnZhciBjb2YgPSByZXF1aXJlKCcuL19jb2YnKTtcbi8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1wcm90b3R5cGUtYnVpbHRpbnNcbm1vZHVsZS5leHBvcnRzID0gT2JqZWN0KCd6JykucHJvcGVydHlJc0VudW1lcmFibGUoMCkgPyBPYmplY3QgOiBmdW5jdGlvbiAoaXQpIHtcbiAgcmV0dXJuIGNvZihpdCkgPT0gJ1N0cmluZycgPyBpdC5zcGxpdCgnJykgOiBPYmplY3QoaXQpO1xufTtcbiIsIi8vIGNoZWNrIG9uIGRlZmF1bHQgQXJyYXkgaXRlcmF0b3JcbnZhciBJdGVyYXRvcnMgPSByZXF1aXJlKCcuL19pdGVyYXRvcnMnKTtcbnZhciBJVEVSQVRPUiA9IHJlcXVpcmUoJy4vX3drcycpKCdpdGVyYXRvcicpO1xudmFyIEFycmF5UHJvdG8gPSBBcnJheS5wcm90b3R5cGU7XG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKGl0KSB7XG4gIHJldHVybiBpdCAhPT0gdW5kZWZpbmVkICYmIChJdGVyYXRvcnMuQXJyYXkgPT09IGl0IHx8IEFycmF5UHJvdG9bSVRFUkFUT1JdID09PSBpdCk7XG59O1xuIiwiLy8gNy4yLjIgSXNBcnJheShhcmd1bWVudClcbnZhciBjb2YgPSByZXF1aXJlKCcuL19jb2YnKTtcbm1vZHVsZS5leHBvcnRzID0gQXJyYXkuaXNBcnJheSB8fCBmdW5jdGlvbiBpc0FycmF5KGFyZykge1xuICByZXR1cm4gY29mKGFyZykgPT0gJ0FycmF5Jztcbn07XG4iLCJtb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChpdCkge1xuICByZXR1cm4gdHlwZW9mIGl0ID09PSAnb2JqZWN0JyA/IGl0ICE9PSBudWxsIDogdHlwZW9mIGl0ID09PSAnZnVuY3Rpb24nO1xufTtcbiIsIi8vIGNhbGwgc29tZXRoaW5nIG9uIGl0ZXJhdG9yIHN0ZXAgd2l0aCBzYWZlIGNsb3Npbmcgb24gZXJyb3JcbnZhciBhbk9iamVjdCA9IHJlcXVpcmUoJy4vX2FuLW9iamVjdCcpO1xubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoaXRlcmF0b3IsIGZuLCB2YWx1ZSwgZW50cmllcykge1xuICB0cnkge1xuICAgIHJldHVybiBlbnRyaWVzID8gZm4oYW5PYmplY3QodmFsdWUpWzBdLCB2YWx1ZVsxXSkgOiBmbih2YWx1ZSk7XG4gIC8vIDcuNC42IEl0ZXJhdG9yQ2xvc2UoaXRlcmF0b3IsIGNvbXBsZXRpb24pXG4gIH0gY2F0Y2ggKGUpIHtcbiAgICB2YXIgcmV0ID0gaXRlcmF0b3JbJ3JldHVybiddO1xuICAgIGlmIChyZXQgIT09IHVuZGVmaW5lZCkgYW5PYmplY3QocmV0LmNhbGwoaXRlcmF0b3IpKTtcbiAgICB0aHJvdyBlO1xuICB9XG59O1xuIiwiJ3VzZSBzdHJpY3QnO1xudmFyIGNyZWF0ZSA9IHJlcXVpcmUoJy4vX29iamVjdC1jcmVhdGUnKTtcbnZhciBkZXNjcmlwdG9yID0gcmVxdWlyZSgnLi9fcHJvcGVydHktZGVzYycpO1xudmFyIHNldFRvU3RyaW5nVGFnID0gcmVxdWlyZSgnLi9fc2V0LXRvLXN0cmluZy10YWcnKTtcbnZhciBJdGVyYXRvclByb3RvdHlwZSA9IHt9O1xuXG4vLyAyNS4xLjIuMS4xICVJdGVyYXRvclByb3RvdHlwZSVbQEBpdGVyYXRvcl0oKVxucmVxdWlyZSgnLi9faGlkZScpKEl0ZXJhdG9yUHJvdG90eXBlLCByZXF1aXJlKCcuL193a3MnKSgnaXRlcmF0b3InKSwgZnVuY3Rpb24gKCkgeyByZXR1cm4gdGhpczsgfSk7XG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKENvbnN0cnVjdG9yLCBOQU1FLCBuZXh0KSB7XG4gIENvbnN0cnVjdG9yLnByb3RvdHlwZSA9IGNyZWF0ZShJdGVyYXRvclByb3RvdHlwZSwgeyBuZXh0OiBkZXNjcmlwdG9yKDEsIG5leHQpIH0pO1xuICBzZXRUb1N0cmluZ1RhZyhDb25zdHJ1Y3RvciwgTkFNRSArICcgSXRlcmF0b3InKTtcbn07XG4iLCIndXNlIHN0cmljdCc7XG52YXIgTElCUkFSWSA9IHJlcXVpcmUoJy4vX2xpYnJhcnknKTtcbnZhciAkZXhwb3J0ID0gcmVxdWlyZSgnLi9fZXhwb3J0Jyk7XG52YXIgcmVkZWZpbmUgPSByZXF1aXJlKCcuL19yZWRlZmluZScpO1xudmFyIGhpZGUgPSByZXF1aXJlKCcuL19oaWRlJyk7XG52YXIgaGFzID0gcmVxdWlyZSgnLi9faGFzJyk7XG52YXIgSXRlcmF0b3JzID0gcmVxdWlyZSgnLi9faXRlcmF0b3JzJyk7XG52YXIgJGl0ZXJDcmVhdGUgPSByZXF1aXJlKCcuL19pdGVyLWNyZWF0ZScpO1xudmFyIHNldFRvU3RyaW5nVGFnID0gcmVxdWlyZSgnLi9fc2V0LXRvLXN0cmluZy10YWcnKTtcbnZhciBnZXRQcm90b3R5cGVPZiA9IHJlcXVpcmUoJy4vX29iamVjdC1ncG8nKTtcbnZhciBJVEVSQVRPUiA9IHJlcXVpcmUoJy4vX3drcycpKCdpdGVyYXRvcicpO1xudmFyIEJVR0dZID0gIShbXS5rZXlzICYmICduZXh0JyBpbiBbXS5rZXlzKCkpOyAvLyBTYWZhcmkgaGFzIGJ1Z2d5IGl0ZXJhdG9ycyB3L28gYG5leHRgXG52YXIgRkZfSVRFUkFUT1IgPSAnQEBpdGVyYXRvcic7XG52YXIgS0VZUyA9ICdrZXlzJztcbnZhciBWQUxVRVMgPSAndmFsdWVzJztcblxudmFyIHJldHVyblRoaXMgPSBmdW5jdGlvbiAoKSB7IHJldHVybiB0aGlzOyB9O1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChCYXNlLCBOQU1FLCBDb25zdHJ1Y3RvciwgbmV4dCwgREVGQVVMVCwgSVNfU0VULCBGT1JDRUQpIHtcbiAgJGl0ZXJDcmVhdGUoQ29uc3RydWN0b3IsIE5BTUUsIG5leHQpO1xuICB2YXIgZ2V0TWV0aG9kID0gZnVuY3Rpb24gKGtpbmQpIHtcbiAgICBpZiAoIUJVR0dZICYmIGtpbmQgaW4gcHJvdG8pIHJldHVybiBwcm90b1traW5kXTtcbiAgICBzd2l0Y2ggKGtpbmQpIHtcbiAgICAgIGNhc2UgS0VZUzogcmV0dXJuIGZ1bmN0aW9uIGtleXMoKSB7IHJldHVybiBuZXcgQ29uc3RydWN0b3IodGhpcywga2luZCk7IH07XG4gICAgICBjYXNlIFZBTFVFUzogcmV0dXJuIGZ1bmN0aW9uIHZhbHVlcygpIHsgcmV0dXJuIG5ldyBDb25zdHJ1Y3Rvcih0aGlzLCBraW5kKTsgfTtcbiAgICB9IHJldHVybiBmdW5jdGlvbiBlbnRyaWVzKCkgeyByZXR1cm4gbmV3IENvbnN0cnVjdG9yKHRoaXMsIGtpbmQpOyB9O1xuICB9O1xuICB2YXIgVEFHID0gTkFNRSArICcgSXRlcmF0b3InO1xuICB2YXIgREVGX1ZBTFVFUyA9IERFRkFVTFQgPT0gVkFMVUVTO1xuICB2YXIgVkFMVUVTX0JVRyA9IGZhbHNlO1xuICB2YXIgcHJvdG8gPSBCYXNlLnByb3RvdHlwZTtcbiAgdmFyICRuYXRpdmUgPSBwcm90b1tJVEVSQVRPUl0gfHwgcHJvdG9bRkZfSVRFUkFUT1JdIHx8IERFRkFVTFQgJiYgcHJvdG9bREVGQVVMVF07XG4gIHZhciAkZGVmYXVsdCA9ICRuYXRpdmUgfHwgZ2V0TWV0aG9kKERFRkFVTFQpO1xuICB2YXIgJGVudHJpZXMgPSBERUZBVUxUID8gIURFRl9WQUxVRVMgPyAkZGVmYXVsdCA6IGdldE1ldGhvZCgnZW50cmllcycpIDogdW5kZWZpbmVkO1xuICB2YXIgJGFueU5hdGl2ZSA9IE5BTUUgPT0gJ0FycmF5JyA/IHByb3RvLmVudHJpZXMgfHwgJG5hdGl2ZSA6ICRuYXRpdmU7XG4gIHZhciBtZXRob2RzLCBrZXksIEl0ZXJhdG9yUHJvdG90eXBlO1xuICAvLyBGaXggbmF0aXZlXG4gIGlmICgkYW55TmF0aXZlKSB7XG4gICAgSXRlcmF0b3JQcm90b3R5cGUgPSBnZXRQcm90b3R5cGVPZigkYW55TmF0aXZlLmNhbGwobmV3IEJhc2UoKSkpO1xuICAgIGlmIChJdGVyYXRvclByb3RvdHlwZSAhPT0gT2JqZWN0LnByb3RvdHlwZSAmJiBJdGVyYXRvclByb3RvdHlwZS5uZXh0KSB7XG4gICAgICAvLyBTZXQgQEB0b1N0cmluZ1RhZyB0byBuYXRpdmUgaXRlcmF0b3JzXG4gICAgICBzZXRUb1N0cmluZ1RhZyhJdGVyYXRvclByb3RvdHlwZSwgVEFHLCB0cnVlKTtcbiAgICAgIC8vIGZpeCBmb3Igc29tZSBvbGQgZW5naW5lc1xuICAgICAgaWYgKCFMSUJSQVJZICYmICFoYXMoSXRlcmF0b3JQcm90b3R5cGUsIElURVJBVE9SKSkgaGlkZShJdGVyYXRvclByb3RvdHlwZSwgSVRFUkFUT1IsIHJldHVyblRoaXMpO1xuICAgIH1cbiAgfVxuICAvLyBmaXggQXJyYXkje3ZhbHVlcywgQEBpdGVyYXRvcn0ubmFtZSBpbiBWOCAvIEZGXG4gIGlmIChERUZfVkFMVUVTICYmICRuYXRpdmUgJiYgJG5hdGl2ZS5uYW1lICE9PSBWQUxVRVMpIHtcbiAgICBWQUxVRVNfQlVHID0gdHJ1ZTtcbiAgICAkZGVmYXVsdCA9IGZ1bmN0aW9uIHZhbHVlcygpIHsgcmV0dXJuICRuYXRpdmUuY2FsbCh0aGlzKTsgfTtcbiAgfVxuICAvLyBEZWZpbmUgaXRlcmF0b3JcbiAgaWYgKCghTElCUkFSWSB8fCBGT1JDRUQpICYmIChCVUdHWSB8fCBWQUxVRVNfQlVHIHx8ICFwcm90b1tJVEVSQVRPUl0pKSB7XG4gICAgaGlkZShwcm90bywgSVRFUkFUT1IsICRkZWZhdWx0KTtcbiAgfVxuICAvLyBQbHVnIGZvciBsaWJyYXJ5XG4gIEl0ZXJhdG9yc1tOQU1FXSA9ICRkZWZhdWx0O1xuICBJdGVyYXRvcnNbVEFHXSA9IHJldHVyblRoaXM7XG4gIGlmIChERUZBVUxUKSB7XG4gICAgbWV0aG9kcyA9IHtcbiAgICAgIHZhbHVlczogREVGX1ZBTFVFUyA/ICRkZWZhdWx0IDogZ2V0TWV0aG9kKFZBTFVFUyksXG4gICAgICBrZXlzOiBJU19TRVQgPyAkZGVmYXVsdCA6IGdldE1ldGhvZChLRVlTKSxcbiAgICAgIGVudHJpZXM6ICRlbnRyaWVzXG4gICAgfTtcbiAgICBpZiAoRk9SQ0VEKSBmb3IgKGtleSBpbiBtZXRob2RzKSB7XG4gICAgICBpZiAoIShrZXkgaW4gcHJvdG8pKSByZWRlZmluZShwcm90bywga2V5LCBtZXRob2RzW2tleV0pO1xuICAgIH0gZWxzZSAkZXhwb3J0KCRleHBvcnQuUCArICRleHBvcnQuRiAqIChCVUdHWSB8fCBWQUxVRVNfQlVHKSwgTkFNRSwgbWV0aG9kcyk7XG4gIH1cbiAgcmV0dXJuIG1ldGhvZHM7XG59O1xuIiwidmFyIElURVJBVE9SID0gcmVxdWlyZSgnLi9fd2tzJykoJ2l0ZXJhdG9yJyk7XG52YXIgU0FGRV9DTE9TSU5HID0gZmFsc2U7XG5cbnRyeSB7XG4gIHZhciByaXRlciA9IFs3XVtJVEVSQVRPUl0oKTtcbiAgcml0ZXJbJ3JldHVybiddID0gZnVuY3Rpb24gKCkgeyBTQUZFX0NMT1NJTkcgPSB0cnVlOyB9O1xuICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tdGhyb3ctbGl0ZXJhbFxuICBBcnJheS5mcm9tKHJpdGVyLCBmdW5jdGlvbiAoKSB7IHRocm93IDI7IH0pO1xufSBjYXRjaCAoZSkgeyAvKiBlbXB0eSAqLyB9XG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKGV4ZWMsIHNraXBDbG9zaW5nKSB7XG4gIGlmICghc2tpcENsb3NpbmcgJiYgIVNBRkVfQ0xPU0lORykgcmV0dXJuIGZhbHNlO1xuICB2YXIgc2FmZSA9IGZhbHNlO1xuICB0cnkge1xuICAgIHZhciBhcnIgPSBbN107XG4gICAgdmFyIGl0ZXIgPSBhcnJbSVRFUkFUT1JdKCk7XG4gICAgaXRlci5uZXh0ID0gZnVuY3Rpb24gKCkgeyByZXR1cm4geyBkb25lOiBzYWZlID0gdHJ1ZSB9OyB9O1xuICAgIGFycltJVEVSQVRPUl0gPSBmdW5jdGlvbiAoKSB7IHJldHVybiBpdGVyOyB9O1xuICAgIGV4ZWMoYXJyKTtcbiAgfSBjYXRjaCAoZSkgeyAvKiBlbXB0eSAqLyB9XG4gIHJldHVybiBzYWZlO1xufTtcbiIsIm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKGRvbmUsIHZhbHVlKSB7XG4gIHJldHVybiB7IHZhbHVlOiB2YWx1ZSwgZG9uZTogISFkb25lIH07XG59O1xuIiwibW9kdWxlLmV4cG9ydHMgPSB7fTtcbiIsInZhciBnZXRLZXlzID0gcmVxdWlyZSgnLi9fb2JqZWN0LWtleXMnKTtcbnZhciB0b0lPYmplY3QgPSByZXF1aXJlKCcuL190by1pb2JqZWN0Jyk7XG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChvYmplY3QsIGVsKSB7XG4gIHZhciBPID0gdG9JT2JqZWN0KG9iamVjdCk7XG4gIHZhciBrZXlzID0gZ2V0S2V5cyhPKTtcbiAgdmFyIGxlbmd0aCA9IGtleXMubGVuZ3RoO1xuICB2YXIgaW5kZXggPSAwO1xuICB2YXIga2V5O1xuICB3aGlsZSAobGVuZ3RoID4gaW5kZXgpIGlmIChPW2tleSA9IGtleXNbaW5kZXgrK11dID09PSBlbCkgcmV0dXJuIGtleTtcbn07XG4iLCJtb2R1bGUuZXhwb3J0cyA9IHRydWU7XG4iLCJ2YXIgTUVUQSA9IHJlcXVpcmUoJy4vX3VpZCcpKCdtZXRhJyk7XG52YXIgaXNPYmplY3QgPSByZXF1aXJlKCcuL19pcy1vYmplY3QnKTtcbnZhciBoYXMgPSByZXF1aXJlKCcuL19oYXMnKTtcbnZhciBzZXREZXNjID0gcmVxdWlyZSgnLi9fb2JqZWN0LWRwJykuZjtcbnZhciBpZCA9IDA7XG52YXIgaXNFeHRlbnNpYmxlID0gT2JqZWN0LmlzRXh0ZW5zaWJsZSB8fCBmdW5jdGlvbiAoKSB7XG4gIHJldHVybiB0cnVlO1xufTtcbnZhciBGUkVFWkUgPSAhcmVxdWlyZSgnLi9fZmFpbHMnKShmdW5jdGlvbiAoKSB7XG4gIHJldHVybiBpc0V4dGVuc2libGUoT2JqZWN0LnByZXZlbnRFeHRlbnNpb25zKHt9KSk7XG59KTtcbnZhciBzZXRNZXRhID0gZnVuY3Rpb24gKGl0KSB7XG4gIHNldERlc2MoaXQsIE1FVEEsIHsgdmFsdWU6IHtcbiAgICBpOiAnTycgKyArK2lkLCAvLyBvYmplY3QgSURcbiAgICB3OiB7fSAgICAgICAgICAvLyB3ZWFrIGNvbGxlY3Rpb25zIElEc1xuICB9IH0pO1xufTtcbnZhciBmYXN0S2V5ID0gZnVuY3Rpb24gKGl0LCBjcmVhdGUpIHtcbiAgLy8gcmV0dXJuIHByaW1pdGl2ZSB3aXRoIHByZWZpeFxuICBpZiAoIWlzT2JqZWN0KGl0KSkgcmV0dXJuIHR5cGVvZiBpdCA9PSAnc3ltYm9sJyA/IGl0IDogKHR5cGVvZiBpdCA9PSAnc3RyaW5nJyA/ICdTJyA6ICdQJykgKyBpdDtcbiAgaWYgKCFoYXMoaXQsIE1FVEEpKSB7XG4gICAgLy8gY2FuJ3Qgc2V0IG1ldGFkYXRhIHRvIHVuY2F1Z2h0IGZyb3plbiBvYmplY3RcbiAgICBpZiAoIWlzRXh0ZW5zaWJsZShpdCkpIHJldHVybiAnRic7XG4gICAgLy8gbm90IG5lY2Vzc2FyeSB0byBhZGQgbWV0YWRhdGFcbiAgICBpZiAoIWNyZWF0ZSkgcmV0dXJuICdFJztcbiAgICAvLyBhZGQgbWlzc2luZyBtZXRhZGF0YVxuICAgIHNldE1ldGEoaXQpO1xuICAvLyByZXR1cm4gb2JqZWN0IElEXG4gIH0gcmV0dXJuIGl0W01FVEFdLmk7XG59O1xudmFyIGdldFdlYWsgPSBmdW5jdGlvbiAoaXQsIGNyZWF0ZSkge1xuICBpZiAoIWhhcyhpdCwgTUVUQSkpIHtcbiAgICAvLyBjYW4ndCBzZXQgbWV0YWRhdGEgdG8gdW5jYXVnaHQgZnJvemVuIG9iamVjdFxuICAgIGlmICghaXNFeHRlbnNpYmxlKGl0KSkgcmV0dXJuIHRydWU7XG4gICAgLy8gbm90IG5lY2Vzc2FyeSB0byBhZGQgbWV0YWRhdGFcbiAgICBpZiAoIWNyZWF0ZSkgcmV0dXJuIGZhbHNlO1xuICAgIC8vIGFkZCBtaXNzaW5nIG1ldGFkYXRhXG4gICAgc2V0TWV0YShpdCk7XG4gIC8vIHJldHVybiBoYXNoIHdlYWsgY29sbGVjdGlvbnMgSURzXG4gIH0gcmV0dXJuIGl0W01FVEFdLnc7XG59O1xuLy8gYWRkIG1ldGFkYXRhIG9uIGZyZWV6ZS1mYW1pbHkgbWV0aG9kcyBjYWxsaW5nXG52YXIgb25GcmVlemUgPSBmdW5jdGlvbiAoaXQpIHtcbiAgaWYgKEZSRUVaRSAmJiBtZXRhLk5FRUQgJiYgaXNFeHRlbnNpYmxlKGl0KSAmJiAhaGFzKGl0LCBNRVRBKSkgc2V0TWV0YShpdCk7XG4gIHJldHVybiBpdDtcbn07XG52YXIgbWV0YSA9IG1vZHVsZS5leHBvcnRzID0ge1xuICBLRVk6IE1FVEEsXG4gIE5FRUQ6IGZhbHNlLFxuICBmYXN0S2V5OiBmYXN0S2V5LFxuICBnZXRXZWFrOiBnZXRXZWFrLFxuICBvbkZyZWV6ZTogb25GcmVlemVcbn07XG4iLCJ2YXIgZ2xvYmFsID0gcmVxdWlyZSgnLi9fZ2xvYmFsJyk7XG52YXIgbWFjcm90YXNrID0gcmVxdWlyZSgnLi9fdGFzaycpLnNldDtcbnZhciBPYnNlcnZlciA9IGdsb2JhbC5NdXRhdGlvbk9ic2VydmVyIHx8IGdsb2JhbC5XZWJLaXRNdXRhdGlvbk9ic2VydmVyO1xudmFyIHByb2Nlc3MgPSBnbG9iYWwucHJvY2VzcztcbnZhciBQcm9taXNlID0gZ2xvYmFsLlByb21pc2U7XG52YXIgaXNOb2RlID0gcmVxdWlyZSgnLi9fY29mJykocHJvY2VzcykgPT0gJ3Byb2Nlc3MnO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uICgpIHtcbiAgdmFyIGhlYWQsIGxhc3QsIG5vdGlmeTtcblxuICB2YXIgZmx1c2ggPSBmdW5jdGlvbiAoKSB7XG4gICAgdmFyIHBhcmVudCwgZm47XG4gICAgaWYgKGlzTm9kZSAmJiAocGFyZW50ID0gcHJvY2Vzcy5kb21haW4pKSBwYXJlbnQuZXhpdCgpO1xuICAgIHdoaWxlIChoZWFkKSB7XG4gICAgICBmbiA9IGhlYWQuZm47XG4gICAgICBoZWFkID0gaGVhZC5uZXh0O1xuICAgICAgdHJ5IHtcbiAgICAgICAgZm4oKTtcbiAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgaWYgKGhlYWQpIG5vdGlmeSgpO1xuICAgICAgICBlbHNlIGxhc3QgPSB1bmRlZmluZWQ7XG4gICAgICAgIHRocm93IGU7XG4gICAgICB9XG4gICAgfSBsYXN0ID0gdW5kZWZpbmVkO1xuICAgIGlmIChwYXJlbnQpIHBhcmVudC5lbnRlcigpO1xuICB9O1xuXG4gIC8vIE5vZGUuanNcbiAgaWYgKGlzTm9kZSkge1xuICAgIG5vdGlmeSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgIHByb2Nlc3MubmV4dFRpY2soZmx1c2gpO1xuICAgIH07XG4gIC8vIGJyb3dzZXJzIHdpdGggTXV0YXRpb25PYnNlcnZlclxuICB9IGVsc2UgaWYgKE9ic2VydmVyKSB7XG4gICAgdmFyIHRvZ2dsZSA9IHRydWU7XG4gICAgdmFyIG5vZGUgPSBkb2N1bWVudC5jcmVhdGVUZXh0Tm9kZSgnJyk7XG4gICAgbmV3IE9ic2VydmVyKGZsdXNoKS5vYnNlcnZlKG5vZGUsIHsgY2hhcmFjdGVyRGF0YTogdHJ1ZSB9KTsgLy8gZXNsaW50LWRpc2FibGUtbGluZSBuby1uZXdcbiAgICBub3RpZnkgPSBmdW5jdGlvbiAoKSB7XG4gICAgICBub2RlLmRhdGEgPSB0b2dnbGUgPSAhdG9nZ2xlO1xuICAgIH07XG4gIC8vIGVudmlyb25tZW50cyB3aXRoIG1heWJlIG5vbi1jb21wbGV0ZWx5IGNvcnJlY3QsIGJ1dCBleGlzdGVudCBQcm9taXNlXG4gIH0gZWxzZSBpZiAoUHJvbWlzZSAmJiBQcm9taXNlLnJlc29sdmUpIHtcbiAgICB2YXIgcHJvbWlzZSA9IFByb21pc2UucmVzb2x2ZSgpO1xuICAgIG5vdGlmeSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgIHByb21pc2UudGhlbihmbHVzaCk7XG4gICAgfTtcbiAgLy8gZm9yIG90aGVyIGVudmlyb25tZW50cyAtIG1hY3JvdGFzayBiYXNlZCBvbjpcbiAgLy8gLSBzZXRJbW1lZGlhdGVcbiAgLy8gLSBNZXNzYWdlQ2hhbm5lbFxuICAvLyAtIHdpbmRvdy5wb3N0TWVzc2FnXG4gIC8vIC0gb25yZWFkeXN0YXRlY2hhbmdlXG4gIC8vIC0gc2V0VGltZW91dFxuICB9IGVsc2Uge1xuICAgIG5vdGlmeSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgIC8vIHN0cmFuZ2UgSUUgKyB3ZWJwYWNrIGRldiBzZXJ2ZXIgYnVnIC0gdXNlIC5jYWxsKGdsb2JhbClcbiAgICAgIG1hY3JvdGFzay5jYWxsKGdsb2JhbCwgZmx1c2gpO1xuICAgIH07XG4gIH1cblxuICByZXR1cm4gZnVuY3Rpb24gKGZuKSB7XG4gICAgdmFyIHRhc2sgPSB7IGZuOiBmbiwgbmV4dDogdW5kZWZpbmVkIH07XG4gICAgaWYgKGxhc3QpIGxhc3QubmV4dCA9IHRhc2s7XG4gICAgaWYgKCFoZWFkKSB7XG4gICAgICBoZWFkID0gdGFzaztcbiAgICAgIG5vdGlmeSgpO1xuICAgIH0gbGFzdCA9IHRhc2s7XG4gIH07XG59O1xuIiwiJ3VzZSBzdHJpY3QnO1xuLy8gMjUuNC4xLjUgTmV3UHJvbWlzZUNhcGFiaWxpdHkoQylcbnZhciBhRnVuY3Rpb24gPSByZXF1aXJlKCcuL19hLWZ1bmN0aW9uJyk7XG5cbmZ1bmN0aW9uIFByb21pc2VDYXBhYmlsaXR5KEMpIHtcbiAgdmFyIHJlc29sdmUsIHJlamVjdDtcbiAgdGhpcy5wcm9taXNlID0gbmV3IEMoZnVuY3Rpb24gKCQkcmVzb2x2ZSwgJCRyZWplY3QpIHtcbiAgICBpZiAocmVzb2x2ZSAhPT0gdW5kZWZpbmVkIHx8IHJlamVjdCAhPT0gdW5kZWZpbmVkKSB0aHJvdyBUeXBlRXJyb3IoJ0JhZCBQcm9taXNlIGNvbnN0cnVjdG9yJyk7XG4gICAgcmVzb2x2ZSA9ICQkcmVzb2x2ZTtcbiAgICByZWplY3QgPSAkJHJlamVjdDtcbiAgfSk7XG4gIHRoaXMucmVzb2x2ZSA9IGFGdW5jdGlvbihyZXNvbHZlKTtcbiAgdGhpcy5yZWplY3QgPSBhRnVuY3Rpb24ocmVqZWN0KTtcbn1cblxubW9kdWxlLmV4cG9ydHMuZiA9IGZ1bmN0aW9uIChDKSB7XG4gIHJldHVybiBuZXcgUHJvbWlzZUNhcGFiaWxpdHkoQyk7XG59O1xuIiwiJ3VzZSBzdHJpY3QnO1xuLy8gMTkuMS4yLjEgT2JqZWN0LmFzc2lnbih0YXJnZXQsIHNvdXJjZSwgLi4uKVxudmFyIGdldEtleXMgPSByZXF1aXJlKCcuL19vYmplY3Qta2V5cycpO1xudmFyIGdPUFMgPSByZXF1aXJlKCcuL19vYmplY3QtZ29wcycpO1xudmFyIHBJRSA9IHJlcXVpcmUoJy4vX29iamVjdC1waWUnKTtcbnZhciB0b09iamVjdCA9IHJlcXVpcmUoJy4vX3RvLW9iamVjdCcpO1xudmFyIElPYmplY3QgPSByZXF1aXJlKCcuL19pb2JqZWN0Jyk7XG52YXIgJGFzc2lnbiA9IE9iamVjdC5hc3NpZ247XG5cbi8vIHNob3VsZCB3b3JrIHdpdGggc3ltYm9scyBhbmQgc2hvdWxkIGhhdmUgZGV0ZXJtaW5pc3RpYyBwcm9wZXJ0eSBvcmRlciAoVjggYnVnKVxubW9kdWxlLmV4cG9ydHMgPSAhJGFzc2lnbiB8fCByZXF1aXJlKCcuL19mYWlscycpKGZ1bmN0aW9uICgpIHtcbiAgdmFyIEEgPSB7fTtcbiAgdmFyIEIgPSB7fTtcbiAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLXVuZGVmXG4gIHZhciBTID0gU3ltYm9sKCk7XG4gIHZhciBLID0gJ2FiY2RlZmdoaWprbG1ub3BxcnN0JztcbiAgQVtTXSA9IDc7XG4gIEsuc3BsaXQoJycpLmZvckVhY2goZnVuY3Rpb24gKGspIHsgQltrXSA9IGs7IH0pO1xuICByZXR1cm4gJGFzc2lnbih7fSwgQSlbU10gIT0gNyB8fCBPYmplY3Qua2V5cygkYXNzaWduKHt9LCBCKSkuam9pbignJykgIT0gSztcbn0pID8gZnVuY3Rpb24gYXNzaWduKHRhcmdldCwgc291cmNlKSB7IC8vIGVzbGludC1kaXNhYmxlLWxpbmUgbm8tdW51c2VkLXZhcnNcbiAgdmFyIFQgPSB0b09iamVjdCh0YXJnZXQpO1xuICB2YXIgYUxlbiA9IGFyZ3VtZW50cy5sZW5ndGg7XG4gIHZhciBpbmRleCA9IDE7XG4gIHZhciBnZXRTeW1ib2xzID0gZ09QUy5mO1xuICB2YXIgaXNFbnVtID0gcElFLmY7XG4gIHdoaWxlIChhTGVuID4gaW5kZXgpIHtcbiAgICB2YXIgUyA9IElPYmplY3QoYXJndW1lbnRzW2luZGV4KytdKTtcbiAgICB2YXIga2V5cyA9IGdldFN5bWJvbHMgPyBnZXRLZXlzKFMpLmNvbmNhdChnZXRTeW1ib2xzKFMpKSA6IGdldEtleXMoUyk7XG4gICAgdmFyIGxlbmd0aCA9IGtleXMubGVuZ3RoO1xuICAgIHZhciBqID0gMDtcbiAgICB2YXIga2V5O1xuICAgIHdoaWxlIChsZW5ndGggPiBqKSBpZiAoaXNFbnVtLmNhbGwoUywga2V5ID0ga2V5c1tqKytdKSkgVFtrZXldID0gU1trZXldO1xuICB9IHJldHVybiBUO1xufSA6ICRhc3NpZ247XG4iLCIvLyAxOS4xLjIuMiAvIDE1LjIuMy41IE9iamVjdC5jcmVhdGUoTyBbLCBQcm9wZXJ0aWVzXSlcbnZhciBhbk9iamVjdCA9IHJlcXVpcmUoJy4vX2FuLW9iamVjdCcpO1xudmFyIGRQcyA9IHJlcXVpcmUoJy4vX29iamVjdC1kcHMnKTtcbnZhciBlbnVtQnVnS2V5cyA9IHJlcXVpcmUoJy4vX2VudW0tYnVnLWtleXMnKTtcbnZhciBJRV9QUk9UTyA9IHJlcXVpcmUoJy4vX3NoYXJlZC1rZXknKSgnSUVfUFJPVE8nKTtcbnZhciBFbXB0eSA9IGZ1bmN0aW9uICgpIHsgLyogZW1wdHkgKi8gfTtcbnZhciBQUk9UT1RZUEUgPSAncHJvdG90eXBlJztcblxuLy8gQ3JlYXRlIG9iamVjdCB3aXRoIGZha2UgYG51bGxgIHByb3RvdHlwZTogdXNlIGlmcmFtZSBPYmplY3Qgd2l0aCBjbGVhcmVkIHByb3RvdHlwZVxudmFyIGNyZWF0ZURpY3QgPSBmdW5jdGlvbiAoKSB7XG4gIC8vIFRocmFzaCwgd2FzdGUgYW5kIHNvZG9teTogSUUgR0MgYnVnXG4gIHZhciBpZnJhbWUgPSByZXF1aXJlKCcuL19kb20tY3JlYXRlJykoJ2lmcmFtZScpO1xuICB2YXIgaSA9IGVudW1CdWdLZXlzLmxlbmd0aDtcbiAgdmFyIGx0ID0gJzwnO1xuICB2YXIgZ3QgPSAnPic7XG4gIHZhciBpZnJhbWVEb2N1bWVudDtcbiAgaWZyYW1lLnN0eWxlLmRpc3BsYXkgPSAnbm9uZSc7XG4gIHJlcXVpcmUoJy4vX2h0bWwnKS5hcHBlbmRDaGlsZChpZnJhbWUpO1xuICBpZnJhbWUuc3JjID0gJ2phdmFzY3JpcHQ6JzsgLy8gZXNsaW50LWRpc2FibGUtbGluZSBuby1zY3JpcHQtdXJsXG4gIC8vIGNyZWF0ZURpY3QgPSBpZnJhbWUuY29udGVudFdpbmRvdy5PYmplY3Q7XG4gIC8vIGh0bWwucmVtb3ZlQ2hpbGQoaWZyYW1lKTtcbiAgaWZyYW1lRG9jdW1lbnQgPSBpZnJhbWUuY29udGVudFdpbmRvdy5kb2N1bWVudDtcbiAgaWZyYW1lRG9jdW1lbnQub3BlbigpO1xuICBpZnJhbWVEb2N1bWVudC53cml0ZShsdCArICdzY3JpcHQnICsgZ3QgKyAnZG9jdW1lbnQuRj1PYmplY3QnICsgbHQgKyAnL3NjcmlwdCcgKyBndCk7XG4gIGlmcmFtZURvY3VtZW50LmNsb3NlKCk7XG4gIGNyZWF0ZURpY3QgPSBpZnJhbWVEb2N1bWVudC5GO1xuICB3aGlsZSAoaS0tKSBkZWxldGUgY3JlYXRlRGljdFtQUk9UT1RZUEVdW2VudW1CdWdLZXlzW2ldXTtcbiAgcmV0dXJuIGNyZWF0ZURpY3QoKTtcbn07XG5cbm1vZHVsZS5leHBvcnRzID0gT2JqZWN0LmNyZWF0ZSB8fCBmdW5jdGlvbiBjcmVhdGUoTywgUHJvcGVydGllcykge1xuICB2YXIgcmVzdWx0O1xuICBpZiAoTyAhPT0gbnVsbCkge1xuICAgIEVtcHR5W1BST1RPVFlQRV0gPSBhbk9iamVjdChPKTtcbiAgICByZXN1bHQgPSBuZXcgRW1wdHkoKTtcbiAgICBFbXB0eVtQUk9UT1RZUEVdID0gbnVsbDtcbiAgICAvLyBhZGQgXCJfX3Byb3RvX19cIiBmb3IgT2JqZWN0LmdldFByb3RvdHlwZU9mIHBvbHlmaWxsXG4gICAgcmVzdWx0W0lFX1BST1RPXSA9IE87XG4gIH0gZWxzZSByZXN1bHQgPSBjcmVhdGVEaWN0KCk7XG4gIHJldHVybiBQcm9wZXJ0aWVzID09PSB1bmRlZmluZWQgPyByZXN1bHQgOiBkUHMocmVzdWx0LCBQcm9wZXJ0aWVzKTtcbn07XG4iLCJ2YXIgYW5PYmplY3QgPSByZXF1aXJlKCcuL19hbi1vYmplY3QnKTtcbnZhciBJRThfRE9NX0RFRklORSA9IHJlcXVpcmUoJy4vX2llOC1kb20tZGVmaW5lJyk7XG52YXIgdG9QcmltaXRpdmUgPSByZXF1aXJlKCcuL190by1wcmltaXRpdmUnKTtcbnZhciBkUCA9IE9iamVjdC5kZWZpbmVQcm9wZXJ0eTtcblxuZXhwb3J0cy5mID0gcmVxdWlyZSgnLi9fZGVzY3JpcHRvcnMnKSA/IE9iamVjdC5kZWZpbmVQcm9wZXJ0eSA6IGZ1bmN0aW9uIGRlZmluZVByb3BlcnR5KE8sIFAsIEF0dHJpYnV0ZXMpIHtcbiAgYW5PYmplY3QoTyk7XG4gIFAgPSB0b1ByaW1pdGl2ZShQLCB0cnVlKTtcbiAgYW5PYmplY3QoQXR0cmlidXRlcyk7XG4gIGlmIChJRThfRE9NX0RFRklORSkgdHJ5IHtcbiAgICByZXR1cm4gZFAoTywgUCwgQXR0cmlidXRlcyk7XG4gIH0gY2F0Y2ggKGUpIHsgLyogZW1wdHkgKi8gfVxuICBpZiAoJ2dldCcgaW4gQXR0cmlidXRlcyB8fCAnc2V0JyBpbiBBdHRyaWJ1dGVzKSB0aHJvdyBUeXBlRXJyb3IoJ0FjY2Vzc29ycyBub3Qgc3VwcG9ydGVkIScpO1xuICBpZiAoJ3ZhbHVlJyBpbiBBdHRyaWJ1dGVzKSBPW1BdID0gQXR0cmlidXRlcy52YWx1ZTtcbiAgcmV0dXJuIE87XG59O1xuIiwidmFyIGRQID0gcmVxdWlyZSgnLi9fb2JqZWN0LWRwJyk7XG52YXIgYW5PYmplY3QgPSByZXF1aXJlKCcuL19hbi1vYmplY3QnKTtcbnZhciBnZXRLZXlzID0gcmVxdWlyZSgnLi9fb2JqZWN0LWtleXMnKTtcblxubW9kdWxlLmV4cG9ydHMgPSByZXF1aXJlKCcuL19kZXNjcmlwdG9ycycpID8gT2JqZWN0LmRlZmluZVByb3BlcnRpZXMgOiBmdW5jdGlvbiBkZWZpbmVQcm9wZXJ0aWVzKE8sIFByb3BlcnRpZXMpIHtcbiAgYW5PYmplY3QoTyk7XG4gIHZhciBrZXlzID0gZ2V0S2V5cyhQcm9wZXJ0aWVzKTtcbiAgdmFyIGxlbmd0aCA9IGtleXMubGVuZ3RoO1xuICB2YXIgaSA9IDA7XG4gIHZhciBQO1xuICB3aGlsZSAobGVuZ3RoID4gaSkgZFAuZihPLCBQID0ga2V5c1tpKytdLCBQcm9wZXJ0aWVzW1BdKTtcbiAgcmV0dXJuIE87XG59O1xuIiwidmFyIHBJRSA9IHJlcXVpcmUoJy4vX29iamVjdC1waWUnKTtcbnZhciBjcmVhdGVEZXNjID0gcmVxdWlyZSgnLi9fcHJvcGVydHktZGVzYycpO1xudmFyIHRvSU9iamVjdCA9IHJlcXVpcmUoJy4vX3RvLWlvYmplY3QnKTtcbnZhciB0b1ByaW1pdGl2ZSA9IHJlcXVpcmUoJy4vX3RvLXByaW1pdGl2ZScpO1xudmFyIGhhcyA9IHJlcXVpcmUoJy4vX2hhcycpO1xudmFyIElFOF9ET01fREVGSU5FID0gcmVxdWlyZSgnLi9faWU4LWRvbS1kZWZpbmUnKTtcbnZhciBnT1BEID0gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcjtcblxuZXhwb3J0cy5mID0gcmVxdWlyZSgnLi9fZGVzY3JpcHRvcnMnKSA/IGdPUEQgOiBmdW5jdGlvbiBnZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IoTywgUCkge1xuICBPID0gdG9JT2JqZWN0KE8pO1xuICBQID0gdG9QcmltaXRpdmUoUCwgdHJ1ZSk7XG4gIGlmIChJRThfRE9NX0RFRklORSkgdHJ5IHtcbiAgICByZXR1cm4gZ09QRChPLCBQKTtcbiAgfSBjYXRjaCAoZSkgeyAvKiBlbXB0eSAqLyB9XG4gIGlmIChoYXMoTywgUCkpIHJldHVybiBjcmVhdGVEZXNjKCFwSUUuZi5jYWxsKE8sIFApLCBPW1BdKTtcbn07XG4iLCIvLyBmYWxsYmFjayBmb3IgSUUxMSBidWdneSBPYmplY3QuZ2V0T3duUHJvcGVydHlOYW1lcyB3aXRoIGlmcmFtZSBhbmQgd2luZG93XG52YXIgdG9JT2JqZWN0ID0gcmVxdWlyZSgnLi9fdG8taW9iamVjdCcpO1xudmFyIGdPUE4gPSByZXF1aXJlKCcuL19vYmplY3QtZ29wbicpLmY7XG52YXIgdG9TdHJpbmcgPSB7fS50b1N0cmluZztcblxudmFyIHdpbmRvd05hbWVzID0gdHlwZW9mIHdpbmRvdyA9PSAnb2JqZWN0JyAmJiB3aW5kb3cgJiYgT2JqZWN0LmdldE93blByb3BlcnR5TmFtZXNcbiAgPyBPYmplY3QuZ2V0T3duUHJvcGVydHlOYW1lcyh3aW5kb3cpIDogW107XG5cbnZhciBnZXRXaW5kb3dOYW1lcyA9IGZ1bmN0aW9uIChpdCkge1xuICB0cnkge1xuICAgIHJldHVybiBnT1BOKGl0KTtcbiAgfSBjYXRjaCAoZSkge1xuICAgIHJldHVybiB3aW5kb3dOYW1lcy5zbGljZSgpO1xuICB9XG59O1xuXG5tb2R1bGUuZXhwb3J0cy5mID0gZnVuY3Rpb24gZ2V0T3duUHJvcGVydHlOYW1lcyhpdCkge1xuICByZXR1cm4gd2luZG93TmFtZXMgJiYgdG9TdHJpbmcuY2FsbChpdCkgPT0gJ1tvYmplY3QgV2luZG93XScgPyBnZXRXaW5kb3dOYW1lcyhpdCkgOiBnT1BOKHRvSU9iamVjdChpdCkpO1xufTtcbiIsIi8vIDE5LjEuMi43IC8gMTUuMi4zLjQgT2JqZWN0LmdldE93blByb3BlcnR5TmFtZXMoTylcbnZhciAka2V5cyA9IHJlcXVpcmUoJy4vX29iamVjdC1rZXlzLWludGVybmFsJyk7XG52YXIgaGlkZGVuS2V5cyA9IHJlcXVpcmUoJy4vX2VudW0tYnVnLWtleXMnKS5jb25jYXQoJ2xlbmd0aCcsICdwcm90b3R5cGUnKTtcblxuZXhwb3J0cy5mID0gT2JqZWN0LmdldE93blByb3BlcnR5TmFtZXMgfHwgZnVuY3Rpb24gZ2V0T3duUHJvcGVydHlOYW1lcyhPKSB7XG4gIHJldHVybiAka2V5cyhPLCBoaWRkZW5LZXlzKTtcbn07XG4iLCJleHBvcnRzLmYgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlTeW1ib2xzO1xuIiwiLy8gMTkuMS4yLjkgLyAxNS4yLjMuMiBPYmplY3QuZ2V0UHJvdG90eXBlT2YoTylcbnZhciBoYXMgPSByZXF1aXJlKCcuL19oYXMnKTtcbnZhciB0b09iamVjdCA9IHJlcXVpcmUoJy4vX3RvLW9iamVjdCcpO1xudmFyIElFX1BST1RPID0gcmVxdWlyZSgnLi9fc2hhcmVkLWtleScpKCdJRV9QUk9UTycpO1xudmFyIE9iamVjdFByb3RvID0gT2JqZWN0LnByb3RvdHlwZTtcblxubW9kdWxlLmV4cG9ydHMgPSBPYmplY3QuZ2V0UHJvdG90eXBlT2YgfHwgZnVuY3Rpb24gKE8pIHtcbiAgTyA9IHRvT2JqZWN0KE8pO1xuICBpZiAoaGFzKE8sIElFX1BST1RPKSkgcmV0dXJuIE9bSUVfUFJPVE9dO1xuICBpZiAodHlwZW9mIE8uY29uc3RydWN0b3IgPT0gJ2Z1bmN0aW9uJyAmJiBPIGluc3RhbmNlb2YgTy5jb25zdHJ1Y3Rvcikge1xuICAgIHJldHVybiBPLmNvbnN0cnVjdG9yLnByb3RvdHlwZTtcbiAgfSByZXR1cm4gTyBpbnN0YW5jZW9mIE9iamVjdCA/IE9iamVjdFByb3RvIDogbnVsbDtcbn07XG4iLCJ2YXIgaGFzID0gcmVxdWlyZSgnLi9faGFzJyk7XG52YXIgdG9JT2JqZWN0ID0gcmVxdWlyZSgnLi9fdG8taW9iamVjdCcpO1xudmFyIGFycmF5SW5kZXhPZiA9IHJlcXVpcmUoJy4vX2FycmF5LWluY2x1ZGVzJykoZmFsc2UpO1xudmFyIElFX1BST1RPID0gcmVxdWlyZSgnLi9fc2hhcmVkLWtleScpKCdJRV9QUk9UTycpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChvYmplY3QsIG5hbWVzKSB7XG4gIHZhciBPID0gdG9JT2JqZWN0KG9iamVjdCk7XG4gIHZhciBpID0gMDtcbiAgdmFyIHJlc3VsdCA9IFtdO1xuICB2YXIga2V5O1xuICBmb3IgKGtleSBpbiBPKSBpZiAoa2V5ICE9IElFX1BST1RPKSBoYXMoTywga2V5KSAmJiByZXN1bHQucHVzaChrZXkpO1xuICAvLyBEb24ndCBlbnVtIGJ1ZyAmIGhpZGRlbiBrZXlzXG4gIHdoaWxlIChuYW1lcy5sZW5ndGggPiBpKSBpZiAoaGFzKE8sIGtleSA9IG5hbWVzW2krK10pKSB7XG4gICAgfmFycmF5SW5kZXhPZihyZXN1bHQsIGtleSkgfHwgcmVzdWx0LnB1c2goa2V5KTtcbiAgfVxuICByZXR1cm4gcmVzdWx0O1xufTtcbiIsIi8vIDE5LjEuMi4xNCAvIDE1LjIuMy4xNCBPYmplY3Qua2V5cyhPKVxudmFyICRrZXlzID0gcmVxdWlyZSgnLi9fb2JqZWN0LWtleXMtaW50ZXJuYWwnKTtcbnZhciBlbnVtQnVnS2V5cyA9IHJlcXVpcmUoJy4vX2VudW0tYnVnLWtleXMnKTtcblxubW9kdWxlLmV4cG9ydHMgPSBPYmplY3Qua2V5cyB8fCBmdW5jdGlvbiBrZXlzKE8pIHtcbiAgcmV0dXJuICRrZXlzKE8sIGVudW1CdWdLZXlzKTtcbn07XG4iLCJleHBvcnRzLmYgPSB7fS5wcm9wZXJ0eUlzRW51bWVyYWJsZTtcbiIsIi8vIG1vc3QgT2JqZWN0IG1ldGhvZHMgYnkgRVM2IHNob3VsZCBhY2NlcHQgcHJpbWl0aXZlc1xudmFyICRleHBvcnQgPSByZXF1aXJlKCcuL19leHBvcnQnKTtcbnZhciBjb3JlID0gcmVxdWlyZSgnLi9fY29yZScpO1xudmFyIGZhaWxzID0gcmVxdWlyZSgnLi9fZmFpbHMnKTtcbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKEtFWSwgZXhlYykge1xuICB2YXIgZm4gPSAoY29yZS5PYmplY3QgfHwge30pW0tFWV0gfHwgT2JqZWN0W0tFWV07XG4gIHZhciBleHAgPSB7fTtcbiAgZXhwW0tFWV0gPSBleGVjKGZuKTtcbiAgJGV4cG9ydCgkZXhwb3J0LlMgKyAkZXhwb3J0LkYgKiBmYWlscyhmdW5jdGlvbiAoKSB7IGZuKDEpOyB9KSwgJ09iamVjdCcsIGV4cCk7XG59O1xuIiwidmFyIGdldEtleXMgPSByZXF1aXJlKCcuL19vYmplY3Qta2V5cycpO1xudmFyIHRvSU9iamVjdCA9IHJlcXVpcmUoJy4vX3RvLWlvYmplY3QnKTtcbnZhciBpc0VudW0gPSByZXF1aXJlKCcuL19vYmplY3QtcGllJykuZjtcbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKGlzRW50cmllcykge1xuICByZXR1cm4gZnVuY3Rpb24gKGl0KSB7XG4gICAgdmFyIE8gPSB0b0lPYmplY3QoaXQpO1xuICAgIHZhciBrZXlzID0gZ2V0S2V5cyhPKTtcbiAgICB2YXIgbGVuZ3RoID0ga2V5cy5sZW5ndGg7XG4gICAgdmFyIGkgPSAwO1xuICAgIHZhciByZXN1bHQgPSBbXTtcbiAgICB2YXIga2V5O1xuICAgIHdoaWxlIChsZW5ndGggPiBpKSBpZiAoaXNFbnVtLmNhbGwoTywga2V5ID0ga2V5c1tpKytdKSkge1xuICAgICAgcmVzdWx0LnB1c2goaXNFbnRyaWVzID8gW2tleSwgT1trZXldXSA6IE9ba2V5XSk7XG4gICAgfSByZXR1cm4gcmVzdWx0O1xuICB9O1xufTtcbiIsIm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKGV4ZWMpIHtcbiAgdHJ5IHtcbiAgICByZXR1cm4geyBlOiBmYWxzZSwgdjogZXhlYygpIH07XG4gIH0gY2F0Y2ggKGUpIHtcbiAgICByZXR1cm4geyBlOiB0cnVlLCB2OiBlIH07XG4gIH1cbn07XG4iLCJ2YXIgbmV3UHJvbWlzZUNhcGFiaWxpdHkgPSByZXF1aXJlKCcuL19uZXctcHJvbWlzZS1jYXBhYmlsaXR5Jyk7XG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKEMsIHgpIHtcbiAgdmFyIHByb21pc2VDYXBhYmlsaXR5ID0gbmV3UHJvbWlzZUNhcGFiaWxpdHkuZihDKTtcbiAgdmFyIHJlc29sdmUgPSBwcm9taXNlQ2FwYWJpbGl0eS5yZXNvbHZlO1xuICByZXNvbHZlKHgpO1xuICByZXR1cm4gcHJvbWlzZUNhcGFiaWxpdHkucHJvbWlzZTtcbn07XG4iLCJtb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChiaXRtYXAsIHZhbHVlKSB7XG4gIHJldHVybiB7XG4gICAgZW51bWVyYWJsZTogIShiaXRtYXAgJiAxKSxcbiAgICBjb25maWd1cmFibGU6ICEoYml0bWFwICYgMiksXG4gICAgd3JpdGFibGU6ICEoYml0bWFwICYgNCksXG4gICAgdmFsdWU6IHZhbHVlXG4gIH07XG59O1xuIiwidmFyIGhpZGUgPSByZXF1aXJlKCcuL19oaWRlJyk7XG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uICh0YXJnZXQsIHNyYywgc2FmZSkge1xuICBmb3IgKHZhciBrZXkgaW4gc3JjKSB7XG4gICAgaWYgKHNhZmUgJiYgdGFyZ2V0W2tleV0pIHRhcmdldFtrZXldID0gc3JjW2tleV07XG4gICAgZWxzZSBoaWRlKHRhcmdldCwga2V5LCBzcmNba2V5XSk7XG4gIH0gcmV0dXJuIHRhcmdldDtcbn07XG4iLCJtb2R1bGUuZXhwb3J0cyA9IHJlcXVpcmUoJy4vX2hpZGUnKTtcbiIsIid1c2Ugc3RyaWN0Jztcbi8vIGh0dHBzOi8vdGMzOS5naXRodWIuaW8vcHJvcG9zYWwtc2V0bWFwLW9mZnJvbS9cbnZhciAkZXhwb3J0ID0gcmVxdWlyZSgnLi9fZXhwb3J0Jyk7XG52YXIgYUZ1bmN0aW9uID0gcmVxdWlyZSgnLi9fYS1mdW5jdGlvbicpO1xudmFyIGN0eCA9IHJlcXVpcmUoJy4vX2N0eCcpO1xudmFyIGZvck9mID0gcmVxdWlyZSgnLi9fZm9yLW9mJyk7XG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKENPTExFQ1RJT04pIHtcbiAgJGV4cG9ydCgkZXhwb3J0LlMsIENPTExFQ1RJT04sIHsgZnJvbTogZnVuY3Rpb24gZnJvbShzb3VyY2UgLyogLCBtYXBGbiwgdGhpc0FyZyAqLykge1xuICAgIHZhciBtYXBGbiA9IGFyZ3VtZW50c1sxXTtcbiAgICB2YXIgbWFwcGluZywgQSwgbiwgY2I7XG4gICAgYUZ1bmN0aW9uKHRoaXMpO1xuICAgIG1hcHBpbmcgPSBtYXBGbiAhPT0gdW5kZWZpbmVkO1xuICAgIGlmIChtYXBwaW5nKSBhRnVuY3Rpb24obWFwRm4pO1xuICAgIGlmIChzb3VyY2UgPT0gdW5kZWZpbmVkKSByZXR1cm4gbmV3IHRoaXMoKTtcbiAgICBBID0gW107XG4gICAgaWYgKG1hcHBpbmcpIHtcbiAgICAgIG4gPSAwO1xuICAgICAgY2IgPSBjdHgobWFwRm4sIGFyZ3VtZW50c1syXSwgMik7XG4gICAgICBmb3JPZihzb3VyY2UsIGZhbHNlLCBmdW5jdGlvbiAobmV4dEl0ZW0pIHtcbiAgICAgICAgQS5wdXNoKGNiKG5leHRJdGVtLCBuKyspKTtcbiAgICAgIH0pO1xuICAgIH0gZWxzZSB7XG4gICAgICBmb3JPZihzb3VyY2UsIGZhbHNlLCBBLnB1c2gsIEEpO1xuICAgIH1cbiAgICByZXR1cm4gbmV3IHRoaXMoQSk7XG4gIH0gfSk7XG59O1xuIiwiJ3VzZSBzdHJpY3QnO1xuLy8gaHR0cHM6Ly90YzM5LmdpdGh1Yi5pby9wcm9wb3NhbC1zZXRtYXAtb2Zmcm9tL1xudmFyICRleHBvcnQgPSByZXF1aXJlKCcuL19leHBvcnQnKTtcblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoQ09MTEVDVElPTikge1xuICAkZXhwb3J0KCRleHBvcnQuUywgQ09MTEVDVElPTiwgeyBvZjogZnVuY3Rpb24gb2YoKSB7XG4gICAgdmFyIGxlbmd0aCA9IGFyZ3VtZW50cy5sZW5ndGg7XG4gICAgdmFyIEEgPSBBcnJheShsZW5ndGgpO1xuICAgIHdoaWxlIChsZW5ndGgtLSkgQVtsZW5ndGhdID0gYXJndW1lbnRzW2xlbmd0aF07XG4gICAgcmV0dXJuIG5ldyB0aGlzKEEpO1xuICB9IH0pO1xufTtcbiIsIi8vIFdvcmtzIHdpdGggX19wcm90b19fIG9ubHkuIE9sZCB2OCBjYW4ndCB3b3JrIHdpdGggbnVsbCBwcm90byBvYmplY3RzLlxuLyogZXNsaW50LWRpc2FibGUgbm8tcHJvdG8gKi9cbnZhciBpc09iamVjdCA9IHJlcXVpcmUoJy4vX2lzLW9iamVjdCcpO1xudmFyIGFuT2JqZWN0ID0gcmVxdWlyZSgnLi9fYW4tb2JqZWN0Jyk7XG52YXIgY2hlY2sgPSBmdW5jdGlvbiAoTywgcHJvdG8pIHtcbiAgYW5PYmplY3QoTyk7XG4gIGlmICghaXNPYmplY3QocHJvdG8pICYmIHByb3RvICE9PSBudWxsKSB0aHJvdyBUeXBlRXJyb3IocHJvdG8gKyBcIjogY2FuJ3Qgc2V0IGFzIHByb3RvdHlwZSFcIik7XG59O1xubW9kdWxlLmV4cG9ydHMgPSB7XG4gIHNldDogT2JqZWN0LnNldFByb3RvdHlwZU9mIHx8ICgnX19wcm90b19fJyBpbiB7fSA/IC8vIGVzbGludC1kaXNhYmxlLWxpbmVcbiAgICBmdW5jdGlvbiAodGVzdCwgYnVnZ3ksIHNldCkge1xuICAgICAgdHJ5IHtcbiAgICAgICAgc2V0ID0gcmVxdWlyZSgnLi9fY3R4JykoRnVuY3Rpb24uY2FsbCwgcmVxdWlyZSgnLi9fb2JqZWN0LWdvcGQnKS5mKE9iamVjdC5wcm90b3R5cGUsICdfX3Byb3RvX18nKS5zZXQsIDIpO1xuICAgICAgICBzZXQodGVzdCwgW10pO1xuICAgICAgICBidWdneSA9ICEodGVzdCBpbnN0YW5jZW9mIEFycmF5KTtcbiAgICAgIH0gY2F0Y2ggKGUpIHsgYnVnZ3kgPSB0cnVlOyB9XG4gICAgICByZXR1cm4gZnVuY3Rpb24gc2V0UHJvdG90eXBlT2YoTywgcHJvdG8pIHtcbiAgICAgICAgY2hlY2soTywgcHJvdG8pO1xuICAgICAgICBpZiAoYnVnZ3kpIE8uX19wcm90b19fID0gcHJvdG87XG4gICAgICAgIGVsc2Ugc2V0KE8sIHByb3RvKTtcbiAgICAgICAgcmV0dXJuIE87XG4gICAgICB9O1xuICAgIH0oe30sIGZhbHNlKSA6IHVuZGVmaW5lZCksXG4gIGNoZWNrOiBjaGVja1xufTtcbiIsIid1c2Ugc3RyaWN0JztcbnZhciBnbG9iYWwgPSByZXF1aXJlKCcuL19nbG9iYWwnKTtcbnZhciBjb3JlID0gcmVxdWlyZSgnLi9fY29yZScpO1xudmFyIGRQID0gcmVxdWlyZSgnLi9fb2JqZWN0LWRwJyk7XG52YXIgREVTQ1JJUFRPUlMgPSByZXF1aXJlKCcuL19kZXNjcmlwdG9ycycpO1xudmFyIFNQRUNJRVMgPSByZXF1aXJlKCcuL193a3MnKSgnc3BlY2llcycpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChLRVkpIHtcbiAgdmFyIEMgPSB0eXBlb2YgY29yZVtLRVldID09ICdmdW5jdGlvbicgPyBjb3JlW0tFWV0gOiBnbG9iYWxbS0VZXTtcbiAgaWYgKERFU0NSSVBUT1JTICYmIEMgJiYgIUNbU1BFQ0lFU10pIGRQLmYoQywgU1BFQ0lFUywge1xuICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHRoaXM7IH1cbiAgfSk7XG59O1xuIiwidmFyIGRlZiA9IHJlcXVpcmUoJy4vX29iamVjdC1kcCcpLmY7XG52YXIgaGFzID0gcmVxdWlyZSgnLi9faGFzJyk7XG52YXIgVEFHID0gcmVxdWlyZSgnLi9fd2tzJykoJ3RvU3RyaW5nVGFnJyk7XG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKGl0LCB0YWcsIHN0YXQpIHtcbiAgaWYgKGl0ICYmICFoYXMoaXQgPSBzdGF0ID8gaXQgOiBpdC5wcm90b3R5cGUsIFRBRykpIGRlZihpdCwgVEFHLCB7IGNvbmZpZ3VyYWJsZTogdHJ1ZSwgdmFsdWU6IHRhZyB9KTtcbn07XG4iLCJ2YXIgc2hhcmVkID0gcmVxdWlyZSgnLi9fc2hhcmVkJykoJ2tleXMnKTtcbnZhciB1aWQgPSByZXF1aXJlKCcuL191aWQnKTtcbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKGtleSkge1xuICByZXR1cm4gc2hhcmVkW2tleV0gfHwgKHNoYXJlZFtrZXldID0gdWlkKGtleSkpO1xufTtcbiIsInZhciBnbG9iYWwgPSByZXF1aXJlKCcuL19nbG9iYWwnKTtcbnZhciBTSEFSRUQgPSAnX19jb3JlLWpzX3NoYXJlZF9fJztcbnZhciBzdG9yZSA9IGdsb2JhbFtTSEFSRURdIHx8IChnbG9iYWxbU0hBUkVEXSA9IHt9KTtcbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKGtleSkge1xuICByZXR1cm4gc3RvcmVba2V5XSB8fCAoc3RvcmVba2V5XSA9IHt9KTtcbn07XG4iLCIvLyA3LjMuMjAgU3BlY2llc0NvbnN0cnVjdG9yKE8sIGRlZmF1bHRDb25zdHJ1Y3RvcilcbnZhciBhbk9iamVjdCA9IHJlcXVpcmUoJy4vX2FuLW9iamVjdCcpO1xudmFyIGFGdW5jdGlvbiA9IHJlcXVpcmUoJy4vX2EtZnVuY3Rpb24nKTtcbnZhciBTUEVDSUVTID0gcmVxdWlyZSgnLi9fd2tzJykoJ3NwZWNpZXMnKTtcbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKE8sIEQpIHtcbiAgdmFyIEMgPSBhbk9iamVjdChPKS5jb25zdHJ1Y3RvcjtcbiAgdmFyIFM7XG4gIHJldHVybiBDID09PSB1bmRlZmluZWQgfHwgKFMgPSBhbk9iamVjdChDKVtTUEVDSUVTXSkgPT0gdW5kZWZpbmVkID8gRCA6IGFGdW5jdGlvbihTKTtcbn07XG4iLCJ2YXIgdG9JbnRlZ2VyID0gcmVxdWlyZSgnLi9fdG8taW50ZWdlcicpO1xudmFyIGRlZmluZWQgPSByZXF1aXJlKCcuL19kZWZpbmVkJyk7XG4vLyB0cnVlICAtPiBTdHJpbmcjYXRcbi8vIGZhbHNlIC0+IFN0cmluZyNjb2RlUG9pbnRBdFxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoVE9fU1RSSU5HKSB7XG4gIHJldHVybiBmdW5jdGlvbiAodGhhdCwgcG9zKSB7XG4gICAgdmFyIHMgPSBTdHJpbmcoZGVmaW5lZCh0aGF0KSk7XG4gICAgdmFyIGkgPSB0b0ludGVnZXIocG9zKTtcbiAgICB2YXIgbCA9IHMubGVuZ3RoO1xuICAgIHZhciBhLCBiO1xuICAgIGlmIChpIDwgMCB8fCBpID49IGwpIHJldHVybiBUT19TVFJJTkcgPyAnJyA6IHVuZGVmaW5lZDtcbiAgICBhID0gcy5jaGFyQ29kZUF0KGkpO1xuICAgIHJldHVybiBhIDwgMHhkODAwIHx8IGEgPiAweGRiZmYgfHwgaSArIDEgPT09IGwgfHwgKGIgPSBzLmNoYXJDb2RlQXQoaSArIDEpKSA8IDB4ZGMwMCB8fCBiID4gMHhkZmZmXG4gICAgICA/IFRPX1NUUklORyA/IHMuY2hhckF0KGkpIDogYVxuICAgICAgOiBUT19TVFJJTkcgPyBzLnNsaWNlKGksIGkgKyAyKSA6IChhIC0gMHhkODAwIDw8IDEwKSArIChiIC0gMHhkYzAwKSArIDB4MTAwMDA7XG4gIH07XG59O1xuIiwidmFyIGN0eCA9IHJlcXVpcmUoJy4vX2N0eCcpO1xudmFyIGludm9rZSA9IHJlcXVpcmUoJy4vX2ludm9rZScpO1xudmFyIGh0bWwgPSByZXF1aXJlKCcuL19odG1sJyk7XG52YXIgY2VsID0gcmVxdWlyZSgnLi9fZG9tLWNyZWF0ZScpO1xudmFyIGdsb2JhbCA9IHJlcXVpcmUoJy4vX2dsb2JhbCcpO1xudmFyIHByb2Nlc3MgPSBnbG9iYWwucHJvY2VzcztcbnZhciBzZXRUYXNrID0gZ2xvYmFsLnNldEltbWVkaWF0ZTtcbnZhciBjbGVhclRhc2sgPSBnbG9iYWwuY2xlYXJJbW1lZGlhdGU7XG52YXIgTWVzc2FnZUNoYW5uZWwgPSBnbG9iYWwuTWVzc2FnZUNoYW5uZWw7XG52YXIgRGlzcGF0Y2ggPSBnbG9iYWwuRGlzcGF0Y2g7XG52YXIgY291bnRlciA9IDA7XG52YXIgcXVldWUgPSB7fTtcbnZhciBPTlJFQURZU1RBVEVDSEFOR0UgPSAnb25yZWFkeXN0YXRlY2hhbmdlJztcbnZhciBkZWZlciwgY2hhbm5lbCwgcG9ydDtcbnZhciBydW4gPSBmdW5jdGlvbiAoKSB7XG4gIHZhciBpZCA9ICt0aGlzO1xuICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tcHJvdG90eXBlLWJ1aWx0aW5zXG4gIGlmIChxdWV1ZS5oYXNPd25Qcm9wZXJ0eShpZCkpIHtcbiAgICB2YXIgZm4gPSBxdWV1ZVtpZF07XG4gICAgZGVsZXRlIHF1ZXVlW2lkXTtcbiAgICBmbigpO1xuICB9XG59O1xudmFyIGxpc3RlbmVyID0gZnVuY3Rpb24gKGV2ZW50KSB7XG4gIHJ1bi5jYWxsKGV2ZW50LmRhdGEpO1xufTtcbi8vIE5vZGUuanMgMC45KyAmIElFMTArIGhhcyBzZXRJbW1lZGlhdGUsIG90aGVyd2lzZTpcbmlmICghc2V0VGFzayB8fCAhY2xlYXJUYXNrKSB7XG4gIHNldFRhc2sgPSBmdW5jdGlvbiBzZXRJbW1lZGlhdGUoZm4pIHtcbiAgICB2YXIgYXJncyA9IFtdO1xuICAgIHZhciBpID0gMTtcbiAgICB3aGlsZSAoYXJndW1lbnRzLmxlbmd0aCA+IGkpIGFyZ3MucHVzaChhcmd1bWVudHNbaSsrXSk7XG4gICAgcXVldWVbKytjb3VudGVyXSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1uZXctZnVuY1xuICAgICAgaW52b2tlKHR5cGVvZiBmbiA9PSAnZnVuY3Rpb24nID8gZm4gOiBGdW5jdGlvbihmbiksIGFyZ3MpO1xuICAgIH07XG4gICAgZGVmZXIoY291bnRlcik7XG4gICAgcmV0dXJuIGNvdW50ZXI7XG4gIH07XG4gIGNsZWFyVGFzayA9IGZ1bmN0aW9uIGNsZWFySW1tZWRpYXRlKGlkKSB7XG4gICAgZGVsZXRlIHF1ZXVlW2lkXTtcbiAgfTtcbiAgLy8gTm9kZS5qcyAwLjgtXG4gIGlmIChyZXF1aXJlKCcuL19jb2YnKShwcm9jZXNzKSA9PSAncHJvY2VzcycpIHtcbiAgICBkZWZlciA9IGZ1bmN0aW9uIChpZCkge1xuICAgICAgcHJvY2Vzcy5uZXh0VGljayhjdHgocnVuLCBpZCwgMSkpO1xuICAgIH07XG4gIC8vIFNwaGVyZSAoSlMgZ2FtZSBlbmdpbmUpIERpc3BhdGNoIEFQSVxuICB9IGVsc2UgaWYgKERpc3BhdGNoICYmIERpc3BhdGNoLm5vdykge1xuICAgIGRlZmVyID0gZnVuY3Rpb24gKGlkKSB7XG4gICAgICBEaXNwYXRjaC5ub3coY3R4KHJ1biwgaWQsIDEpKTtcbiAgICB9O1xuICAvLyBCcm93c2VycyB3aXRoIE1lc3NhZ2VDaGFubmVsLCBpbmNsdWRlcyBXZWJXb3JrZXJzXG4gIH0gZWxzZSBpZiAoTWVzc2FnZUNoYW5uZWwpIHtcbiAgICBjaGFubmVsID0gbmV3IE1lc3NhZ2VDaGFubmVsKCk7XG4gICAgcG9ydCA9IGNoYW5uZWwucG9ydDI7XG4gICAgY2hhbm5lbC5wb3J0MS5vbm1lc3NhZ2UgPSBsaXN0ZW5lcjtcbiAgICBkZWZlciA9IGN0eChwb3J0LnBvc3RNZXNzYWdlLCBwb3J0LCAxKTtcbiAgLy8gQnJvd3NlcnMgd2l0aCBwb3N0TWVzc2FnZSwgc2tpcCBXZWJXb3JrZXJzXG4gIC8vIElFOCBoYXMgcG9zdE1lc3NhZ2UsIGJ1dCBpdCdzIHN5bmMgJiB0eXBlb2YgaXRzIHBvc3RNZXNzYWdlIGlzICdvYmplY3QnXG4gIH0gZWxzZSBpZiAoZ2xvYmFsLmFkZEV2ZW50TGlzdGVuZXIgJiYgdHlwZW9mIHBvc3RNZXNzYWdlID09ICdmdW5jdGlvbicgJiYgIWdsb2JhbC5pbXBvcnRTY3JpcHRzKSB7XG4gICAgZGVmZXIgPSBmdW5jdGlvbiAoaWQpIHtcbiAgICAgIGdsb2JhbC5wb3N0TWVzc2FnZShpZCArICcnLCAnKicpO1xuICAgIH07XG4gICAgZ2xvYmFsLmFkZEV2ZW50TGlzdGVuZXIoJ21lc3NhZ2UnLCBsaXN0ZW5lciwgZmFsc2UpO1xuICAvLyBJRTgtXG4gIH0gZWxzZSBpZiAoT05SRUFEWVNUQVRFQ0hBTkdFIGluIGNlbCgnc2NyaXB0JykpIHtcbiAgICBkZWZlciA9IGZ1bmN0aW9uIChpZCkge1xuICAgICAgaHRtbC5hcHBlbmRDaGlsZChjZWwoJ3NjcmlwdCcpKVtPTlJFQURZU1RBVEVDSEFOR0VdID0gZnVuY3Rpb24gKCkge1xuICAgICAgICBodG1sLnJlbW92ZUNoaWxkKHRoaXMpO1xuICAgICAgICBydW4uY2FsbChpZCk7XG4gICAgICB9O1xuICAgIH07XG4gIC8vIFJlc3Qgb2xkIGJyb3dzZXJzXG4gIH0gZWxzZSB7XG4gICAgZGVmZXIgPSBmdW5jdGlvbiAoaWQpIHtcbiAgICAgIHNldFRpbWVvdXQoY3R4KHJ1biwgaWQsIDEpLCAwKTtcbiAgICB9O1xuICB9XG59XG5tb2R1bGUuZXhwb3J0cyA9IHtcbiAgc2V0OiBzZXRUYXNrLFxuICBjbGVhcjogY2xlYXJUYXNrXG59O1xuIiwidmFyIHRvSW50ZWdlciA9IHJlcXVpcmUoJy4vX3RvLWludGVnZXInKTtcbnZhciBtYXggPSBNYXRoLm1heDtcbnZhciBtaW4gPSBNYXRoLm1pbjtcbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKGluZGV4LCBsZW5ndGgpIHtcbiAgaW5kZXggPSB0b0ludGVnZXIoaW5kZXgpO1xuICByZXR1cm4gaW5kZXggPCAwID8gbWF4KGluZGV4ICsgbGVuZ3RoLCAwKSA6IG1pbihpbmRleCwgbGVuZ3RoKTtcbn07XG4iLCIvLyA3LjEuNCBUb0ludGVnZXJcbnZhciBjZWlsID0gTWF0aC5jZWlsO1xudmFyIGZsb29yID0gTWF0aC5mbG9vcjtcbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKGl0KSB7XG4gIHJldHVybiBpc05hTihpdCA9ICtpdCkgPyAwIDogKGl0ID4gMCA/IGZsb29yIDogY2VpbCkoaXQpO1xufTtcbiIsIi8vIHRvIGluZGV4ZWQgb2JqZWN0LCB0b09iamVjdCB3aXRoIGZhbGxiYWNrIGZvciBub24tYXJyYXktbGlrZSBFUzMgc3RyaW5nc1xudmFyIElPYmplY3QgPSByZXF1aXJlKCcuL19pb2JqZWN0Jyk7XG52YXIgZGVmaW5lZCA9IHJlcXVpcmUoJy4vX2RlZmluZWQnKTtcbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKGl0KSB7XG4gIHJldHVybiBJT2JqZWN0KGRlZmluZWQoaXQpKTtcbn07XG4iLCIvLyA3LjEuMTUgVG9MZW5ndGhcbnZhciB0b0ludGVnZXIgPSByZXF1aXJlKCcuL190by1pbnRlZ2VyJyk7XG52YXIgbWluID0gTWF0aC5taW47XG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChpdCkge1xuICByZXR1cm4gaXQgPiAwID8gbWluKHRvSW50ZWdlcihpdCksIDB4MWZmZmZmZmZmZmZmZmYpIDogMDsgLy8gcG93KDIsIDUzKSAtIDEgPT0gOTAwNzE5OTI1NDc0MDk5MVxufTtcbiIsIi8vIDcuMS4xMyBUb09iamVjdChhcmd1bWVudClcbnZhciBkZWZpbmVkID0gcmVxdWlyZSgnLi9fZGVmaW5lZCcpO1xubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoaXQpIHtcbiAgcmV0dXJuIE9iamVjdChkZWZpbmVkKGl0KSk7XG59O1xuIiwiLy8gNy4xLjEgVG9QcmltaXRpdmUoaW5wdXQgWywgUHJlZmVycmVkVHlwZV0pXG52YXIgaXNPYmplY3QgPSByZXF1aXJlKCcuL19pcy1vYmplY3QnKTtcbi8vIGluc3RlYWQgb2YgdGhlIEVTNiBzcGVjIHZlcnNpb24sIHdlIGRpZG4ndCBpbXBsZW1lbnQgQEB0b1ByaW1pdGl2ZSBjYXNlXG4vLyBhbmQgdGhlIHNlY29uZCBhcmd1bWVudCAtIGZsYWcgLSBwcmVmZXJyZWQgdHlwZSBpcyBhIHN0cmluZ1xubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoaXQsIFMpIHtcbiAgaWYgKCFpc09iamVjdChpdCkpIHJldHVybiBpdDtcbiAgdmFyIGZuLCB2YWw7XG4gIGlmIChTICYmIHR5cGVvZiAoZm4gPSBpdC50b1N0cmluZykgPT0gJ2Z1bmN0aW9uJyAmJiAhaXNPYmplY3QodmFsID0gZm4uY2FsbChpdCkpKSByZXR1cm4gdmFsO1xuICBpZiAodHlwZW9mIChmbiA9IGl0LnZhbHVlT2YpID09ICdmdW5jdGlvbicgJiYgIWlzT2JqZWN0KHZhbCA9IGZuLmNhbGwoaXQpKSkgcmV0dXJuIHZhbDtcbiAgaWYgKCFTICYmIHR5cGVvZiAoZm4gPSBpdC50b1N0cmluZykgPT0gJ2Z1bmN0aW9uJyAmJiAhaXNPYmplY3QodmFsID0gZm4uY2FsbChpdCkpKSByZXR1cm4gdmFsO1xuICB0aHJvdyBUeXBlRXJyb3IoXCJDYW4ndCBjb252ZXJ0IG9iamVjdCB0byBwcmltaXRpdmUgdmFsdWVcIik7XG59O1xuIiwidmFyIGlkID0gMDtcbnZhciBweCA9IE1hdGgucmFuZG9tKCk7XG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChrZXkpIHtcbiAgcmV0dXJuICdTeW1ib2woJy5jb25jYXQoa2V5ID09PSB1bmRlZmluZWQgPyAnJyA6IGtleSwgJylfJywgKCsraWQgKyBweCkudG9TdHJpbmcoMzYpKTtcbn07XG4iLCJ2YXIgaXNPYmplY3QgPSByZXF1aXJlKCcuL19pcy1vYmplY3QnKTtcbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKGl0LCBUWVBFKSB7XG4gIGlmICghaXNPYmplY3QoaXQpIHx8IGl0Ll90ICE9PSBUWVBFKSB0aHJvdyBUeXBlRXJyb3IoJ0luY29tcGF0aWJsZSByZWNlaXZlciwgJyArIFRZUEUgKyAnIHJlcXVpcmVkIScpO1xuICByZXR1cm4gaXQ7XG59O1xuIiwidmFyIGdsb2JhbCA9IHJlcXVpcmUoJy4vX2dsb2JhbCcpO1xudmFyIGNvcmUgPSByZXF1aXJlKCcuL19jb3JlJyk7XG52YXIgTElCUkFSWSA9IHJlcXVpcmUoJy4vX2xpYnJhcnknKTtcbnZhciB3a3NFeHQgPSByZXF1aXJlKCcuL193a3MtZXh0Jyk7XG52YXIgZGVmaW5lUHJvcGVydHkgPSByZXF1aXJlKCcuL19vYmplY3QtZHAnKS5mO1xubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAobmFtZSkge1xuICB2YXIgJFN5bWJvbCA9IGNvcmUuU3ltYm9sIHx8IChjb3JlLlN5bWJvbCA9IExJQlJBUlkgPyB7fSA6IGdsb2JhbC5TeW1ib2wgfHwge30pO1xuICBpZiAobmFtZS5jaGFyQXQoMCkgIT0gJ18nICYmICEobmFtZSBpbiAkU3ltYm9sKSkgZGVmaW5lUHJvcGVydHkoJFN5bWJvbCwgbmFtZSwgeyB2YWx1ZTogd2tzRXh0LmYobmFtZSkgfSk7XG59O1xuIiwiZXhwb3J0cy5mID0gcmVxdWlyZSgnLi9fd2tzJyk7XG4iLCJ2YXIgc3RvcmUgPSByZXF1aXJlKCcuL19zaGFyZWQnKSgnd2tzJyk7XG52YXIgdWlkID0gcmVxdWlyZSgnLi9fdWlkJyk7XG52YXIgU3ltYm9sID0gcmVxdWlyZSgnLi9fZ2xvYmFsJykuU3ltYm9sO1xudmFyIFVTRV9TWU1CT0wgPSB0eXBlb2YgU3ltYm9sID09ICdmdW5jdGlvbic7XG5cbnZhciAkZXhwb3J0cyA9IG1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKG5hbWUpIHtcbiAgcmV0dXJuIHN0b3JlW25hbWVdIHx8IChzdG9yZVtuYW1lXSA9XG4gICAgVVNFX1NZTUJPTCAmJiBTeW1ib2xbbmFtZV0gfHwgKFVTRV9TWU1CT0wgPyBTeW1ib2wgOiB1aWQpKCdTeW1ib2wuJyArIG5hbWUpKTtcbn07XG5cbiRleHBvcnRzLnN0b3JlID0gc3RvcmU7XG4iLCJ2YXIgY2xhc3NvZiA9IHJlcXVpcmUoJy4vX2NsYXNzb2YnKTtcbnZhciBJVEVSQVRPUiA9IHJlcXVpcmUoJy4vX3drcycpKCdpdGVyYXRvcicpO1xudmFyIEl0ZXJhdG9ycyA9IHJlcXVpcmUoJy4vX2l0ZXJhdG9ycycpO1xubW9kdWxlLmV4cG9ydHMgPSByZXF1aXJlKCcuL19jb3JlJykuZ2V0SXRlcmF0b3JNZXRob2QgPSBmdW5jdGlvbiAoaXQpIHtcbiAgaWYgKGl0ICE9IHVuZGVmaW5lZCkgcmV0dXJuIGl0W0lURVJBVE9SXVxuICAgIHx8IGl0WydAQGl0ZXJhdG9yJ11cbiAgICB8fCBJdGVyYXRvcnNbY2xhc3NvZihpdCldO1xufTtcbiIsInZhciBhbk9iamVjdCA9IHJlcXVpcmUoJy4vX2FuLW9iamVjdCcpO1xudmFyIGdldCA9IHJlcXVpcmUoJy4vY29yZS5nZXQtaXRlcmF0b3ItbWV0aG9kJyk7XG5tb2R1bGUuZXhwb3J0cyA9IHJlcXVpcmUoJy4vX2NvcmUnKS5nZXRJdGVyYXRvciA9IGZ1bmN0aW9uIChpdCkge1xuICB2YXIgaXRlckZuID0gZ2V0KGl0KTtcbiAgaWYgKHR5cGVvZiBpdGVyRm4gIT0gJ2Z1bmN0aW9uJykgdGhyb3cgVHlwZUVycm9yKGl0ICsgJyBpcyBub3QgaXRlcmFibGUhJyk7XG4gIHJldHVybiBhbk9iamVjdChpdGVyRm4uY2FsbChpdCkpO1xufTtcbiIsInZhciBjbGFzc29mID0gcmVxdWlyZSgnLi9fY2xhc3NvZicpO1xudmFyIElURVJBVE9SID0gcmVxdWlyZSgnLi9fd2tzJykoJ2l0ZXJhdG9yJyk7XG52YXIgSXRlcmF0b3JzID0gcmVxdWlyZSgnLi9faXRlcmF0b3JzJyk7XG5tb2R1bGUuZXhwb3J0cyA9IHJlcXVpcmUoJy4vX2NvcmUnKS5pc0l0ZXJhYmxlID0gZnVuY3Rpb24gKGl0KSB7XG4gIHZhciBPID0gT2JqZWN0KGl0KTtcbiAgcmV0dXJuIE9bSVRFUkFUT1JdICE9PSB1bmRlZmluZWRcbiAgICB8fCAnQEBpdGVyYXRvcicgaW4gT1xuICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1wcm90b3R5cGUtYnVpbHRpbnNcbiAgICB8fCBJdGVyYXRvcnMuaGFzT3duUHJvcGVydHkoY2xhc3NvZihPKSk7XG59O1xuIiwiJ3VzZSBzdHJpY3QnO1xudmFyIGN0eCA9IHJlcXVpcmUoJy4vX2N0eCcpO1xudmFyICRleHBvcnQgPSByZXF1aXJlKCcuL19leHBvcnQnKTtcbnZhciB0b09iamVjdCA9IHJlcXVpcmUoJy4vX3RvLW9iamVjdCcpO1xudmFyIGNhbGwgPSByZXF1aXJlKCcuL19pdGVyLWNhbGwnKTtcbnZhciBpc0FycmF5SXRlciA9IHJlcXVpcmUoJy4vX2lzLWFycmF5LWl0ZXInKTtcbnZhciB0b0xlbmd0aCA9IHJlcXVpcmUoJy4vX3RvLWxlbmd0aCcpO1xudmFyIGNyZWF0ZVByb3BlcnR5ID0gcmVxdWlyZSgnLi9fY3JlYXRlLXByb3BlcnR5Jyk7XG52YXIgZ2V0SXRlckZuID0gcmVxdWlyZSgnLi9jb3JlLmdldC1pdGVyYXRvci1tZXRob2QnKTtcblxuJGV4cG9ydCgkZXhwb3J0LlMgKyAkZXhwb3J0LkYgKiAhcmVxdWlyZSgnLi9faXRlci1kZXRlY3QnKShmdW5jdGlvbiAoaXRlcikgeyBBcnJheS5mcm9tKGl0ZXIpOyB9KSwgJ0FycmF5Jywge1xuICAvLyAyMi4xLjIuMSBBcnJheS5mcm9tKGFycmF5TGlrZSwgbWFwZm4gPSB1bmRlZmluZWQsIHRoaXNBcmcgPSB1bmRlZmluZWQpXG4gIGZyb206IGZ1bmN0aW9uIGZyb20oYXJyYXlMaWtlIC8qICwgbWFwZm4gPSB1bmRlZmluZWQsIHRoaXNBcmcgPSB1bmRlZmluZWQgKi8pIHtcbiAgICB2YXIgTyA9IHRvT2JqZWN0KGFycmF5TGlrZSk7XG4gICAgdmFyIEMgPSB0eXBlb2YgdGhpcyA9PSAnZnVuY3Rpb24nID8gdGhpcyA6IEFycmF5O1xuICAgIHZhciBhTGVuID0gYXJndW1lbnRzLmxlbmd0aDtcbiAgICB2YXIgbWFwZm4gPSBhTGVuID4gMSA/IGFyZ3VtZW50c1sxXSA6IHVuZGVmaW5lZDtcbiAgICB2YXIgbWFwcGluZyA9IG1hcGZuICE9PSB1bmRlZmluZWQ7XG4gICAgdmFyIGluZGV4ID0gMDtcbiAgICB2YXIgaXRlckZuID0gZ2V0SXRlckZuKE8pO1xuICAgIHZhciBsZW5ndGgsIHJlc3VsdCwgc3RlcCwgaXRlcmF0b3I7XG4gICAgaWYgKG1hcHBpbmcpIG1hcGZuID0gY3R4KG1hcGZuLCBhTGVuID4gMiA/IGFyZ3VtZW50c1syXSA6IHVuZGVmaW5lZCwgMik7XG4gICAgLy8gaWYgb2JqZWN0IGlzbid0IGl0ZXJhYmxlIG9yIGl0J3MgYXJyYXkgd2l0aCBkZWZhdWx0IGl0ZXJhdG9yIC0gdXNlIHNpbXBsZSBjYXNlXG4gICAgaWYgKGl0ZXJGbiAhPSB1bmRlZmluZWQgJiYgIShDID09IEFycmF5ICYmIGlzQXJyYXlJdGVyKGl0ZXJGbikpKSB7XG4gICAgICBmb3IgKGl0ZXJhdG9yID0gaXRlckZuLmNhbGwoTyksIHJlc3VsdCA9IG5ldyBDKCk7ICEoc3RlcCA9IGl0ZXJhdG9yLm5leHQoKSkuZG9uZTsgaW5kZXgrKykge1xuICAgICAgICBjcmVhdGVQcm9wZXJ0eShyZXN1bHQsIGluZGV4LCBtYXBwaW5nID8gY2FsbChpdGVyYXRvciwgbWFwZm4sIFtzdGVwLnZhbHVlLCBpbmRleF0sIHRydWUpIDogc3RlcC52YWx1ZSk7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIGxlbmd0aCA9IHRvTGVuZ3RoKE8ubGVuZ3RoKTtcbiAgICAgIGZvciAocmVzdWx0ID0gbmV3IEMobGVuZ3RoKTsgbGVuZ3RoID4gaW5kZXg7IGluZGV4KyspIHtcbiAgICAgICAgY3JlYXRlUHJvcGVydHkocmVzdWx0LCBpbmRleCwgbWFwcGluZyA/IG1hcGZuKE9baW5kZXhdLCBpbmRleCkgOiBPW2luZGV4XSk7XG4gICAgICB9XG4gICAgfVxuICAgIHJlc3VsdC5sZW5ndGggPSBpbmRleDtcbiAgICByZXR1cm4gcmVzdWx0O1xuICB9XG59KTtcbiIsIid1c2Ugc3RyaWN0JztcbnZhciBhZGRUb1Vuc2NvcGFibGVzID0gcmVxdWlyZSgnLi9fYWRkLXRvLXVuc2NvcGFibGVzJyk7XG52YXIgc3RlcCA9IHJlcXVpcmUoJy4vX2l0ZXItc3RlcCcpO1xudmFyIEl0ZXJhdG9ycyA9IHJlcXVpcmUoJy4vX2l0ZXJhdG9ycycpO1xudmFyIHRvSU9iamVjdCA9IHJlcXVpcmUoJy4vX3RvLWlvYmplY3QnKTtcblxuLy8gMjIuMS4zLjQgQXJyYXkucHJvdG90eXBlLmVudHJpZXMoKVxuLy8gMjIuMS4zLjEzIEFycmF5LnByb3RvdHlwZS5rZXlzKClcbi8vIDIyLjEuMy4yOSBBcnJheS5wcm90b3R5cGUudmFsdWVzKClcbi8vIDIyLjEuMy4zMCBBcnJheS5wcm90b3R5cGVbQEBpdGVyYXRvcl0oKVxubW9kdWxlLmV4cG9ydHMgPSByZXF1aXJlKCcuL19pdGVyLWRlZmluZScpKEFycmF5LCAnQXJyYXknLCBmdW5jdGlvbiAoaXRlcmF0ZWQsIGtpbmQpIHtcbiAgdGhpcy5fdCA9IHRvSU9iamVjdChpdGVyYXRlZCk7IC8vIHRhcmdldFxuICB0aGlzLl9pID0gMDsgICAgICAgICAgICAgICAgICAgLy8gbmV4dCBpbmRleFxuICB0aGlzLl9rID0ga2luZDsgICAgICAgICAgICAgICAgLy8ga2luZFxuLy8gMjIuMS41LjIuMSAlQXJyYXlJdGVyYXRvclByb3RvdHlwZSUubmV4dCgpXG59LCBmdW5jdGlvbiAoKSB7XG4gIHZhciBPID0gdGhpcy5fdDtcbiAgdmFyIGtpbmQgPSB0aGlzLl9rO1xuICB2YXIgaW5kZXggPSB0aGlzLl9pKys7XG4gIGlmICghTyB8fCBpbmRleCA+PSBPLmxlbmd0aCkge1xuICAgIHRoaXMuX3QgPSB1bmRlZmluZWQ7XG4gICAgcmV0dXJuIHN0ZXAoMSk7XG4gIH1cbiAgaWYgKGtpbmQgPT0gJ2tleXMnKSByZXR1cm4gc3RlcCgwLCBpbmRleCk7XG4gIGlmIChraW5kID09ICd2YWx1ZXMnKSByZXR1cm4gc3RlcCgwLCBPW2luZGV4XSk7XG4gIHJldHVybiBzdGVwKDAsIFtpbmRleCwgT1tpbmRleF1dKTtcbn0sICd2YWx1ZXMnKTtcblxuLy8gYXJndW1lbnRzTGlzdFtAQGl0ZXJhdG9yXSBpcyAlQXJyYXlQcm90b192YWx1ZXMlICg5LjQuNC42LCA5LjQuNC43KVxuSXRlcmF0b3JzLkFyZ3VtZW50cyA9IEl0ZXJhdG9ycy5BcnJheTtcblxuYWRkVG9VbnNjb3BhYmxlcygna2V5cycpO1xuYWRkVG9VbnNjb3BhYmxlcygndmFsdWVzJyk7XG5hZGRUb1Vuc2NvcGFibGVzKCdlbnRyaWVzJyk7XG4iLCIndXNlIHN0cmljdCc7XG52YXIgc3Ryb25nID0gcmVxdWlyZSgnLi9fY29sbGVjdGlvbi1zdHJvbmcnKTtcbnZhciB2YWxpZGF0ZSA9IHJlcXVpcmUoJy4vX3ZhbGlkYXRlLWNvbGxlY3Rpb24nKTtcbnZhciBNQVAgPSAnTWFwJztcblxuLy8gMjMuMSBNYXAgT2JqZWN0c1xubW9kdWxlLmV4cG9ydHMgPSByZXF1aXJlKCcuL19jb2xsZWN0aW9uJykoTUFQLCBmdW5jdGlvbiAoZ2V0KSB7XG4gIHJldHVybiBmdW5jdGlvbiBNYXAoKSB7IHJldHVybiBnZXQodGhpcywgYXJndW1lbnRzLmxlbmd0aCA+IDAgPyBhcmd1bWVudHNbMF0gOiB1bmRlZmluZWQpOyB9O1xufSwge1xuICAvLyAyMy4xLjMuNiBNYXAucHJvdG90eXBlLmdldChrZXkpXG4gIGdldDogZnVuY3Rpb24gZ2V0KGtleSkge1xuICAgIHZhciBlbnRyeSA9IHN0cm9uZy5nZXRFbnRyeSh2YWxpZGF0ZSh0aGlzLCBNQVApLCBrZXkpO1xuICAgIHJldHVybiBlbnRyeSAmJiBlbnRyeS52O1xuICB9LFxuICAvLyAyMy4xLjMuOSBNYXAucHJvdG90eXBlLnNldChrZXksIHZhbHVlKVxuICBzZXQ6IGZ1bmN0aW9uIHNldChrZXksIHZhbHVlKSB7XG4gICAgcmV0dXJuIHN0cm9uZy5kZWYodmFsaWRhdGUodGhpcywgTUFQKSwga2V5ID09PSAwID8gMCA6IGtleSwgdmFsdWUpO1xuICB9XG59LCBzdHJvbmcsIHRydWUpO1xuIiwiLy8gMTkuMS4zLjEgT2JqZWN0LmFzc2lnbih0YXJnZXQsIHNvdXJjZSlcbnZhciAkZXhwb3J0ID0gcmVxdWlyZSgnLi9fZXhwb3J0Jyk7XG5cbiRleHBvcnQoJGV4cG9ydC5TICsgJGV4cG9ydC5GLCAnT2JqZWN0JywgeyBhc3NpZ246IHJlcXVpcmUoJy4vX29iamVjdC1hc3NpZ24nKSB9KTtcbiIsInZhciAkZXhwb3J0ID0gcmVxdWlyZSgnLi9fZXhwb3J0Jyk7XG4vLyAxOS4xLjIuMiAvIDE1LjIuMy41IE9iamVjdC5jcmVhdGUoTyBbLCBQcm9wZXJ0aWVzXSlcbiRleHBvcnQoJGV4cG9ydC5TLCAnT2JqZWN0JywgeyBjcmVhdGU6IHJlcXVpcmUoJy4vX29iamVjdC1jcmVhdGUnKSB9KTtcbiIsInZhciAkZXhwb3J0ID0gcmVxdWlyZSgnLi9fZXhwb3J0Jyk7XG4vLyAxOS4xLjIuNCAvIDE1LjIuMy42IE9iamVjdC5kZWZpbmVQcm9wZXJ0eShPLCBQLCBBdHRyaWJ1dGVzKVxuJGV4cG9ydCgkZXhwb3J0LlMgKyAkZXhwb3J0LkYgKiAhcmVxdWlyZSgnLi9fZGVzY3JpcHRvcnMnKSwgJ09iamVjdCcsIHsgZGVmaW5lUHJvcGVydHk6IHJlcXVpcmUoJy4vX29iamVjdC1kcCcpLmYgfSk7XG4iLCIvLyAxOS4xLjIuOSBPYmplY3QuZ2V0UHJvdG90eXBlT2YoTylcbnZhciB0b09iamVjdCA9IHJlcXVpcmUoJy4vX3RvLW9iamVjdCcpO1xudmFyICRnZXRQcm90b3R5cGVPZiA9IHJlcXVpcmUoJy4vX29iamVjdC1ncG8nKTtcblxucmVxdWlyZSgnLi9fb2JqZWN0LXNhcCcpKCdnZXRQcm90b3R5cGVPZicsIGZ1bmN0aW9uICgpIHtcbiAgcmV0dXJuIGZ1bmN0aW9uIGdldFByb3RvdHlwZU9mKGl0KSB7XG4gICAgcmV0dXJuICRnZXRQcm90b3R5cGVPZih0b09iamVjdChpdCkpO1xuICB9O1xufSk7XG4iLCIvLyAxOS4xLjIuMTQgT2JqZWN0LmtleXMoTylcbnZhciB0b09iamVjdCA9IHJlcXVpcmUoJy4vX3RvLW9iamVjdCcpO1xudmFyICRrZXlzID0gcmVxdWlyZSgnLi9fb2JqZWN0LWtleXMnKTtcblxucmVxdWlyZSgnLi9fb2JqZWN0LXNhcCcpKCdrZXlzJywgZnVuY3Rpb24gKCkge1xuICByZXR1cm4gZnVuY3Rpb24ga2V5cyhpdCkge1xuICAgIHJldHVybiAka2V5cyh0b09iamVjdChpdCkpO1xuICB9O1xufSk7XG4iLCIvLyAxOS4xLjMuMTkgT2JqZWN0LnNldFByb3RvdHlwZU9mKE8sIHByb3RvKVxudmFyICRleHBvcnQgPSByZXF1aXJlKCcuL19leHBvcnQnKTtcbiRleHBvcnQoJGV4cG9ydC5TLCAnT2JqZWN0JywgeyBzZXRQcm90b3R5cGVPZjogcmVxdWlyZSgnLi9fc2V0LXByb3RvJykuc2V0IH0pO1xuIiwiIiwiJ3VzZSBzdHJpY3QnO1xudmFyIExJQlJBUlkgPSByZXF1aXJlKCcuL19saWJyYXJ5Jyk7XG52YXIgZ2xvYmFsID0gcmVxdWlyZSgnLi9fZ2xvYmFsJyk7XG52YXIgY3R4ID0gcmVxdWlyZSgnLi9fY3R4Jyk7XG52YXIgY2xhc3NvZiA9IHJlcXVpcmUoJy4vX2NsYXNzb2YnKTtcbnZhciAkZXhwb3J0ID0gcmVxdWlyZSgnLi9fZXhwb3J0Jyk7XG52YXIgaXNPYmplY3QgPSByZXF1aXJlKCcuL19pcy1vYmplY3QnKTtcbnZhciBhRnVuY3Rpb24gPSByZXF1aXJlKCcuL19hLWZ1bmN0aW9uJyk7XG52YXIgYW5JbnN0YW5jZSA9IHJlcXVpcmUoJy4vX2FuLWluc3RhbmNlJyk7XG52YXIgZm9yT2YgPSByZXF1aXJlKCcuL19mb3Itb2YnKTtcbnZhciBzcGVjaWVzQ29uc3RydWN0b3IgPSByZXF1aXJlKCcuL19zcGVjaWVzLWNvbnN0cnVjdG9yJyk7XG52YXIgdGFzayA9IHJlcXVpcmUoJy4vX3Rhc2snKS5zZXQ7XG52YXIgbWljcm90YXNrID0gcmVxdWlyZSgnLi9fbWljcm90YXNrJykoKTtcbnZhciBuZXdQcm9taXNlQ2FwYWJpbGl0eU1vZHVsZSA9IHJlcXVpcmUoJy4vX25ldy1wcm9taXNlLWNhcGFiaWxpdHknKTtcbnZhciBwZXJmb3JtID0gcmVxdWlyZSgnLi9fcGVyZm9ybScpO1xudmFyIHByb21pc2VSZXNvbHZlID0gcmVxdWlyZSgnLi9fcHJvbWlzZS1yZXNvbHZlJyk7XG52YXIgUFJPTUlTRSA9ICdQcm9taXNlJztcbnZhciBUeXBlRXJyb3IgPSBnbG9iYWwuVHlwZUVycm9yO1xudmFyIHByb2Nlc3MgPSBnbG9iYWwucHJvY2VzcztcbnZhciAkUHJvbWlzZSA9IGdsb2JhbFtQUk9NSVNFXTtcbnZhciBpc05vZGUgPSBjbGFzc29mKHByb2Nlc3MpID09ICdwcm9jZXNzJztcbnZhciBlbXB0eSA9IGZ1bmN0aW9uICgpIHsgLyogZW1wdHkgKi8gfTtcbnZhciBJbnRlcm5hbCwgbmV3R2VuZXJpY1Byb21pc2VDYXBhYmlsaXR5LCBPd25Qcm9taXNlQ2FwYWJpbGl0eSwgV3JhcHBlcjtcbnZhciBuZXdQcm9taXNlQ2FwYWJpbGl0eSA9IG5ld0dlbmVyaWNQcm9taXNlQ2FwYWJpbGl0eSA9IG5ld1Byb21pc2VDYXBhYmlsaXR5TW9kdWxlLmY7XG5cbnZhciBVU0VfTkFUSVZFID0gISFmdW5jdGlvbiAoKSB7XG4gIHRyeSB7XG4gICAgLy8gY29ycmVjdCBzdWJjbGFzc2luZyB3aXRoIEBAc3BlY2llcyBzdXBwb3J0XG4gICAgdmFyIHByb21pc2UgPSAkUHJvbWlzZS5yZXNvbHZlKDEpO1xuICAgIHZhciBGYWtlUHJvbWlzZSA9IChwcm9taXNlLmNvbnN0cnVjdG9yID0ge30pW3JlcXVpcmUoJy4vX3drcycpKCdzcGVjaWVzJyldID0gZnVuY3Rpb24gKGV4ZWMpIHtcbiAgICAgIGV4ZWMoZW1wdHksIGVtcHR5KTtcbiAgICB9O1xuICAgIC8vIHVuaGFuZGxlZCByZWplY3Rpb25zIHRyYWNraW5nIHN1cHBvcnQsIE5vZGVKUyBQcm9taXNlIHdpdGhvdXQgaXQgZmFpbHMgQEBzcGVjaWVzIHRlc3RcbiAgICByZXR1cm4gKGlzTm9kZSB8fCB0eXBlb2YgUHJvbWlzZVJlamVjdGlvbkV2ZW50ID09ICdmdW5jdGlvbicpICYmIHByb21pc2UudGhlbihlbXB0eSkgaW5zdGFuY2VvZiBGYWtlUHJvbWlzZTtcbiAgfSBjYXRjaCAoZSkgeyAvKiBlbXB0eSAqLyB9XG59KCk7XG5cbi8vIGhlbHBlcnNcbnZhciBzYW1lQ29uc3RydWN0b3IgPSBMSUJSQVJZID8gZnVuY3Rpb24gKGEsIGIpIHtcbiAgLy8gd2l0aCBsaWJyYXJ5IHdyYXBwZXIgc3BlY2lhbCBjYXNlXG4gIHJldHVybiBhID09PSBiIHx8IGEgPT09ICRQcm9taXNlICYmIGIgPT09IFdyYXBwZXI7XG59IDogZnVuY3Rpb24gKGEsIGIpIHtcbiAgcmV0dXJuIGEgPT09IGI7XG59O1xudmFyIGlzVGhlbmFibGUgPSBmdW5jdGlvbiAoaXQpIHtcbiAgdmFyIHRoZW47XG4gIHJldHVybiBpc09iamVjdChpdCkgJiYgdHlwZW9mICh0aGVuID0gaXQudGhlbikgPT0gJ2Z1bmN0aW9uJyA/IHRoZW4gOiBmYWxzZTtcbn07XG52YXIgbm90aWZ5ID0gZnVuY3Rpb24gKHByb21pc2UsIGlzUmVqZWN0KSB7XG4gIGlmIChwcm9taXNlLl9uKSByZXR1cm47XG4gIHByb21pc2UuX24gPSB0cnVlO1xuICB2YXIgY2hhaW4gPSBwcm9taXNlLl9jO1xuICBtaWNyb3Rhc2soZnVuY3Rpb24gKCkge1xuICAgIHZhciB2YWx1ZSA9IHByb21pc2UuX3Y7XG4gICAgdmFyIG9rID0gcHJvbWlzZS5fcyA9PSAxO1xuICAgIHZhciBpID0gMDtcbiAgICB2YXIgcnVuID0gZnVuY3Rpb24gKHJlYWN0aW9uKSB7XG4gICAgICB2YXIgaGFuZGxlciA9IG9rID8gcmVhY3Rpb24ub2sgOiByZWFjdGlvbi5mYWlsO1xuICAgICAgdmFyIHJlc29sdmUgPSByZWFjdGlvbi5yZXNvbHZlO1xuICAgICAgdmFyIHJlamVjdCA9IHJlYWN0aW9uLnJlamVjdDtcbiAgICAgIHZhciBkb21haW4gPSByZWFjdGlvbi5kb21haW47XG4gICAgICB2YXIgcmVzdWx0LCB0aGVuO1xuICAgICAgdHJ5IHtcbiAgICAgICAgaWYgKGhhbmRsZXIpIHtcbiAgICAgICAgICBpZiAoIW9rKSB7XG4gICAgICAgICAgICBpZiAocHJvbWlzZS5faCA9PSAyKSBvbkhhbmRsZVVuaGFuZGxlZChwcm9taXNlKTtcbiAgICAgICAgICAgIHByb21pc2UuX2ggPSAxO1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAoaGFuZGxlciA9PT0gdHJ1ZSkgcmVzdWx0ID0gdmFsdWU7XG4gICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBpZiAoZG9tYWluKSBkb21haW4uZW50ZXIoKTtcbiAgICAgICAgICAgIHJlc3VsdCA9IGhhbmRsZXIodmFsdWUpO1xuICAgICAgICAgICAgaWYgKGRvbWFpbikgZG9tYWluLmV4aXQoKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKHJlc3VsdCA9PT0gcmVhY3Rpb24ucHJvbWlzZSkge1xuICAgICAgICAgICAgcmVqZWN0KFR5cGVFcnJvcignUHJvbWlzZS1jaGFpbiBjeWNsZScpKTtcbiAgICAgICAgICB9IGVsc2UgaWYgKHRoZW4gPSBpc1RoZW5hYmxlKHJlc3VsdCkpIHtcbiAgICAgICAgICAgIHRoZW4uY2FsbChyZXN1bHQsIHJlc29sdmUsIHJlamVjdCk7XG4gICAgICAgICAgfSBlbHNlIHJlc29sdmUocmVzdWx0KTtcbiAgICAgICAgfSBlbHNlIHJlamVjdCh2YWx1ZSk7XG4gICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgIHJlamVjdChlKTtcbiAgICAgIH1cbiAgICB9O1xuICAgIHdoaWxlIChjaGFpbi5sZW5ndGggPiBpKSBydW4oY2hhaW5baSsrXSk7IC8vIHZhcmlhYmxlIGxlbmd0aCAtIGNhbid0IHVzZSBmb3JFYWNoXG4gICAgcHJvbWlzZS5fYyA9IFtdO1xuICAgIHByb21pc2UuX24gPSBmYWxzZTtcbiAgICBpZiAoaXNSZWplY3QgJiYgIXByb21pc2UuX2gpIG9uVW5oYW5kbGVkKHByb21pc2UpO1xuICB9KTtcbn07XG52YXIgb25VbmhhbmRsZWQgPSBmdW5jdGlvbiAocHJvbWlzZSkge1xuICB0YXNrLmNhbGwoZ2xvYmFsLCBmdW5jdGlvbiAoKSB7XG4gICAgdmFyIHZhbHVlID0gcHJvbWlzZS5fdjtcbiAgICB2YXIgdW5oYW5kbGVkID0gaXNVbmhhbmRsZWQocHJvbWlzZSk7XG4gICAgdmFyIHJlc3VsdCwgaGFuZGxlciwgY29uc29sZTtcbiAgICBpZiAodW5oYW5kbGVkKSB7XG4gICAgICByZXN1bHQgPSBwZXJmb3JtKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgaWYgKGlzTm9kZSkge1xuICAgICAgICAgIHByb2Nlc3MuZW1pdCgndW5oYW5kbGVkUmVqZWN0aW9uJywgdmFsdWUsIHByb21pc2UpO1xuICAgICAgICB9IGVsc2UgaWYgKGhhbmRsZXIgPSBnbG9iYWwub251bmhhbmRsZWRyZWplY3Rpb24pIHtcbiAgICAgICAgICBoYW5kbGVyKHsgcHJvbWlzZTogcHJvbWlzZSwgcmVhc29uOiB2YWx1ZSB9KTtcbiAgICAgICAgfSBlbHNlIGlmICgoY29uc29sZSA9IGdsb2JhbC5jb25zb2xlKSAmJiBjb25zb2xlLmVycm9yKSB7XG4gICAgICAgICAgY29uc29sZS5lcnJvcignVW5oYW5kbGVkIHByb21pc2UgcmVqZWN0aW9uJywgdmFsdWUpO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICAgIC8vIEJyb3dzZXJzIHNob3VsZCBub3QgdHJpZ2dlciBgcmVqZWN0aW9uSGFuZGxlZGAgZXZlbnQgaWYgaXQgd2FzIGhhbmRsZWQgaGVyZSwgTm9kZUpTIC0gc2hvdWxkXG4gICAgICBwcm9taXNlLl9oID0gaXNOb2RlIHx8IGlzVW5oYW5kbGVkKHByb21pc2UpID8gMiA6IDE7XG4gICAgfSBwcm9taXNlLl9hID0gdW5kZWZpbmVkO1xuICAgIGlmICh1bmhhbmRsZWQgJiYgcmVzdWx0LmUpIHRocm93IHJlc3VsdC52O1xuICB9KTtcbn07XG52YXIgaXNVbmhhbmRsZWQgPSBmdW5jdGlvbiAocHJvbWlzZSkge1xuICBpZiAocHJvbWlzZS5faCA9PSAxKSByZXR1cm4gZmFsc2U7XG4gIHZhciBjaGFpbiA9IHByb21pc2UuX2EgfHwgcHJvbWlzZS5fYztcbiAgdmFyIGkgPSAwO1xuICB2YXIgcmVhY3Rpb247XG4gIHdoaWxlIChjaGFpbi5sZW5ndGggPiBpKSB7XG4gICAgcmVhY3Rpb24gPSBjaGFpbltpKytdO1xuICAgIGlmIChyZWFjdGlvbi5mYWlsIHx8ICFpc1VuaGFuZGxlZChyZWFjdGlvbi5wcm9taXNlKSkgcmV0dXJuIGZhbHNlO1xuICB9IHJldHVybiB0cnVlO1xufTtcbnZhciBvbkhhbmRsZVVuaGFuZGxlZCA9IGZ1bmN0aW9uIChwcm9taXNlKSB7XG4gIHRhc2suY2FsbChnbG9iYWwsIGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgaGFuZGxlcjtcbiAgICBpZiAoaXNOb2RlKSB7XG4gICAgICBwcm9jZXNzLmVtaXQoJ3JlamVjdGlvbkhhbmRsZWQnLCBwcm9taXNlKTtcbiAgICB9IGVsc2UgaWYgKGhhbmRsZXIgPSBnbG9iYWwub25yZWplY3Rpb25oYW5kbGVkKSB7XG4gICAgICBoYW5kbGVyKHsgcHJvbWlzZTogcHJvbWlzZSwgcmVhc29uOiBwcm9taXNlLl92IH0pO1xuICAgIH1cbiAgfSk7XG59O1xudmFyICRyZWplY3QgPSBmdW5jdGlvbiAodmFsdWUpIHtcbiAgdmFyIHByb21pc2UgPSB0aGlzO1xuICBpZiAocHJvbWlzZS5fZCkgcmV0dXJuO1xuICBwcm9taXNlLl9kID0gdHJ1ZTtcbiAgcHJvbWlzZSA9IHByb21pc2UuX3cgfHwgcHJvbWlzZTsgLy8gdW53cmFwXG4gIHByb21pc2UuX3YgPSB2YWx1ZTtcbiAgcHJvbWlzZS5fcyA9IDI7XG4gIGlmICghcHJvbWlzZS5fYSkgcHJvbWlzZS5fYSA9IHByb21pc2UuX2Muc2xpY2UoKTtcbiAgbm90aWZ5KHByb21pc2UsIHRydWUpO1xufTtcbnZhciAkcmVzb2x2ZSA9IGZ1bmN0aW9uICh2YWx1ZSkge1xuICB2YXIgcHJvbWlzZSA9IHRoaXM7XG4gIHZhciB0aGVuO1xuICBpZiAocHJvbWlzZS5fZCkgcmV0dXJuO1xuICBwcm9taXNlLl9kID0gdHJ1ZTtcbiAgcHJvbWlzZSA9IHByb21pc2UuX3cgfHwgcHJvbWlzZTsgLy8gdW53cmFwXG4gIHRyeSB7XG4gICAgaWYgKHByb21pc2UgPT09IHZhbHVlKSB0aHJvdyBUeXBlRXJyb3IoXCJQcm9taXNlIGNhbid0IGJlIHJlc29sdmVkIGl0c2VsZlwiKTtcbiAgICBpZiAodGhlbiA9IGlzVGhlbmFibGUodmFsdWUpKSB7XG4gICAgICBtaWNyb3Rhc2soZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgd3JhcHBlciA9IHsgX3c6IHByb21pc2UsIF9kOiBmYWxzZSB9OyAvLyB3cmFwXG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgdGhlbi5jYWxsKHZhbHVlLCBjdHgoJHJlc29sdmUsIHdyYXBwZXIsIDEpLCBjdHgoJHJlamVjdCwgd3JhcHBlciwgMSkpO1xuICAgICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgICAgJHJlamVjdC5jYWxsKHdyYXBwZXIsIGUpO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICB9IGVsc2Uge1xuICAgICAgcHJvbWlzZS5fdiA9IHZhbHVlO1xuICAgICAgcHJvbWlzZS5fcyA9IDE7XG4gICAgICBub3RpZnkocHJvbWlzZSwgZmFsc2UpO1xuICAgIH1cbiAgfSBjYXRjaCAoZSkge1xuICAgICRyZWplY3QuY2FsbCh7IF93OiBwcm9taXNlLCBfZDogZmFsc2UgfSwgZSk7IC8vIHdyYXBcbiAgfVxufTtcblxuLy8gY29uc3RydWN0b3IgcG9seWZpbGxcbmlmICghVVNFX05BVElWRSkge1xuICAvLyAyNS40LjMuMSBQcm9taXNlKGV4ZWN1dG9yKVxuICAkUHJvbWlzZSA9IGZ1bmN0aW9uIFByb21pc2UoZXhlY3V0b3IpIHtcbiAgICBhbkluc3RhbmNlKHRoaXMsICRQcm9taXNlLCBQUk9NSVNFLCAnX2gnKTtcbiAgICBhRnVuY3Rpb24oZXhlY3V0b3IpO1xuICAgIEludGVybmFsLmNhbGwodGhpcyk7XG4gICAgdHJ5IHtcbiAgICAgIGV4ZWN1dG9yKGN0eCgkcmVzb2x2ZSwgdGhpcywgMSksIGN0eCgkcmVqZWN0LCB0aGlzLCAxKSk7XG4gICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICAkcmVqZWN0LmNhbGwodGhpcywgZXJyKTtcbiAgICB9XG4gIH07XG4gIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby11bnVzZWQtdmFyc1xuICBJbnRlcm5hbCA9IGZ1bmN0aW9uIFByb21pc2UoZXhlY3V0b3IpIHtcbiAgICB0aGlzLl9jID0gW107ICAgICAgICAgICAgIC8vIDwtIGF3YWl0aW5nIHJlYWN0aW9uc1xuICAgIHRoaXMuX2EgPSB1bmRlZmluZWQ7ICAgICAgLy8gPC0gY2hlY2tlZCBpbiBpc1VuaGFuZGxlZCByZWFjdGlvbnNcbiAgICB0aGlzLl9zID0gMDsgICAgICAgICAgICAgIC8vIDwtIHN0YXRlXG4gICAgdGhpcy5fZCA9IGZhbHNlOyAgICAgICAgICAvLyA8LSBkb25lXG4gICAgdGhpcy5fdiA9IHVuZGVmaW5lZDsgICAgICAvLyA8LSB2YWx1ZVxuICAgIHRoaXMuX2ggPSAwOyAgICAgICAgICAgICAgLy8gPC0gcmVqZWN0aW9uIHN0YXRlLCAwIC0gZGVmYXVsdCwgMSAtIGhhbmRsZWQsIDIgLSB1bmhhbmRsZWRcbiAgICB0aGlzLl9uID0gZmFsc2U7ICAgICAgICAgIC8vIDwtIG5vdGlmeVxuICB9O1xuICBJbnRlcm5hbC5wcm90b3R5cGUgPSByZXF1aXJlKCcuL19yZWRlZmluZS1hbGwnKSgkUHJvbWlzZS5wcm90b3R5cGUsIHtcbiAgICAvLyAyNS40LjUuMyBQcm9taXNlLnByb3RvdHlwZS50aGVuKG9uRnVsZmlsbGVkLCBvblJlamVjdGVkKVxuICAgIHRoZW46IGZ1bmN0aW9uIHRoZW4ob25GdWxmaWxsZWQsIG9uUmVqZWN0ZWQpIHtcbiAgICAgIHZhciByZWFjdGlvbiA9IG5ld1Byb21pc2VDYXBhYmlsaXR5KHNwZWNpZXNDb25zdHJ1Y3Rvcih0aGlzLCAkUHJvbWlzZSkpO1xuICAgICAgcmVhY3Rpb24ub2sgPSB0eXBlb2Ygb25GdWxmaWxsZWQgPT0gJ2Z1bmN0aW9uJyA/IG9uRnVsZmlsbGVkIDogdHJ1ZTtcbiAgICAgIHJlYWN0aW9uLmZhaWwgPSB0eXBlb2Ygb25SZWplY3RlZCA9PSAnZnVuY3Rpb24nICYmIG9uUmVqZWN0ZWQ7XG4gICAgICByZWFjdGlvbi5kb21haW4gPSBpc05vZGUgPyBwcm9jZXNzLmRvbWFpbiA6IHVuZGVmaW5lZDtcbiAgICAgIHRoaXMuX2MucHVzaChyZWFjdGlvbik7XG4gICAgICBpZiAodGhpcy5fYSkgdGhpcy5fYS5wdXNoKHJlYWN0aW9uKTtcbiAgICAgIGlmICh0aGlzLl9zKSBub3RpZnkodGhpcywgZmFsc2UpO1xuICAgICAgcmV0dXJuIHJlYWN0aW9uLnByb21pc2U7XG4gICAgfSxcbiAgICAvLyAyNS40LjUuMSBQcm9taXNlLnByb3RvdHlwZS5jYXRjaChvblJlamVjdGVkKVxuICAgICdjYXRjaCc6IGZ1bmN0aW9uIChvblJlamVjdGVkKSB7XG4gICAgICByZXR1cm4gdGhpcy50aGVuKHVuZGVmaW5lZCwgb25SZWplY3RlZCk7XG4gICAgfVxuICB9KTtcbiAgT3duUHJvbWlzZUNhcGFiaWxpdHkgPSBmdW5jdGlvbiAoKSB7XG4gICAgdmFyIHByb21pc2UgPSBuZXcgSW50ZXJuYWwoKTtcbiAgICB0aGlzLnByb21pc2UgPSBwcm9taXNlO1xuICAgIHRoaXMucmVzb2x2ZSA9IGN0eCgkcmVzb2x2ZSwgcHJvbWlzZSwgMSk7XG4gICAgdGhpcy5yZWplY3QgPSBjdHgoJHJlamVjdCwgcHJvbWlzZSwgMSk7XG4gIH07XG4gIG5ld1Byb21pc2VDYXBhYmlsaXR5TW9kdWxlLmYgPSBuZXdQcm9taXNlQ2FwYWJpbGl0eSA9IGZ1bmN0aW9uIChDKSB7XG4gICAgcmV0dXJuIHNhbWVDb25zdHJ1Y3RvcigkUHJvbWlzZSwgQylcbiAgICAgID8gbmV3IE93blByb21pc2VDYXBhYmlsaXR5KEMpXG4gICAgICA6IG5ld0dlbmVyaWNQcm9taXNlQ2FwYWJpbGl0eShDKTtcbiAgfTtcbn1cblxuJGV4cG9ydCgkZXhwb3J0LkcgKyAkZXhwb3J0LlcgKyAkZXhwb3J0LkYgKiAhVVNFX05BVElWRSwgeyBQcm9taXNlOiAkUHJvbWlzZSB9KTtcbnJlcXVpcmUoJy4vX3NldC10by1zdHJpbmctdGFnJykoJFByb21pc2UsIFBST01JU0UpO1xucmVxdWlyZSgnLi9fc2V0LXNwZWNpZXMnKShQUk9NSVNFKTtcbldyYXBwZXIgPSByZXF1aXJlKCcuL19jb3JlJylbUFJPTUlTRV07XG5cbi8vIHN0YXRpY3NcbiRleHBvcnQoJGV4cG9ydC5TICsgJGV4cG9ydC5GICogIVVTRV9OQVRJVkUsIFBST01JU0UsIHtcbiAgLy8gMjUuNC40LjUgUHJvbWlzZS5yZWplY3QocilcbiAgcmVqZWN0OiBmdW5jdGlvbiByZWplY3Qocikge1xuICAgIHZhciBjYXBhYmlsaXR5ID0gbmV3UHJvbWlzZUNhcGFiaWxpdHkodGhpcyk7XG4gICAgdmFyICQkcmVqZWN0ID0gY2FwYWJpbGl0eS5yZWplY3Q7XG4gICAgJCRyZWplY3Qocik7XG4gICAgcmV0dXJuIGNhcGFiaWxpdHkucHJvbWlzZTtcbiAgfVxufSk7XG4kZXhwb3J0KCRleHBvcnQuUyArICRleHBvcnQuRiAqIChMSUJSQVJZIHx8ICFVU0VfTkFUSVZFKSwgUFJPTUlTRSwge1xuICAvLyAyNS40LjQuNiBQcm9taXNlLnJlc29sdmUoeClcbiAgcmVzb2x2ZTogZnVuY3Rpb24gcmVzb2x2ZSh4KSB7XG4gICAgLy8gaW5zdGFuY2VvZiBpbnN0ZWFkIG9mIGludGVybmFsIHNsb3QgY2hlY2sgYmVjYXVzZSB3ZSBzaG91bGQgZml4IGl0IHdpdGhvdXQgcmVwbGFjZW1lbnQgbmF0aXZlIFByb21pc2UgY29yZVxuICAgIGlmICh4IGluc3RhbmNlb2YgJFByb21pc2UgJiYgc2FtZUNvbnN0cnVjdG9yKHguY29uc3RydWN0b3IsIHRoaXMpKSByZXR1cm4geDtcbiAgICByZXR1cm4gcHJvbWlzZVJlc29sdmUodGhpcywgeCk7XG4gIH1cbn0pO1xuJGV4cG9ydCgkZXhwb3J0LlMgKyAkZXhwb3J0LkYgKiAhKFVTRV9OQVRJVkUgJiYgcmVxdWlyZSgnLi9faXRlci1kZXRlY3QnKShmdW5jdGlvbiAoaXRlcikge1xuICAkUHJvbWlzZS5hbGwoaXRlcilbJ2NhdGNoJ10oZW1wdHkpO1xufSkpLCBQUk9NSVNFLCB7XG4gIC8vIDI1LjQuNC4xIFByb21pc2UuYWxsKGl0ZXJhYmxlKVxuICBhbGw6IGZ1bmN0aW9uIGFsbChpdGVyYWJsZSkge1xuICAgIHZhciBDID0gdGhpcztcbiAgICB2YXIgY2FwYWJpbGl0eSA9IG5ld1Byb21pc2VDYXBhYmlsaXR5KEMpO1xuICAgIHZhciByZXNvbHZlID0gY2FwYWJpbGl0eS5yZXNvbHZlO1xuICAgIHZhciByZWplY3QgPSBjYXBhYmlsaXR5LnJlamVjdDtcbiAgICB2YXIgcmVzdWx0ID0gcGVyZm9ybShmdW5jdGlvbiAoKSB7XG4gICAgICB2YXIgdmFsdWVzID0gW107XG4gICAgICB2YXIgaW5kZXggPSAwO1xuICAgICAgdmFyIHJlbWFpbmluZyA9IDE7XG4gICAgICBmb3JPZihpdGVyYWJsZSwgZmFsc2UsIGZ1bmN0aW9uIChwcm9taXNlKSB7XG4gICAgICAgIHZhciAkaW5kZXggPSBpbmRleCsrO1xuICAgICAgICB2YXIgYWxyZWFkeUNhbGxlZCA9IGZhbHNlO1xuICAgICAgICB2YWx1ZXMucHVzaCh1bmRlZmluZWQpO1xuICAgICAgICByZW1haW5pbmcrKztcbiAgICAgICAgQy5yZXNvbHZlKHByb21pc2UpLnRoZW4oZnVuY3Rpb24gKHZhbHVlKSB7XG4gICAgICAgICAgaWYgKGFscmVhZHlDYWxsZWQpIHJldHVybjtcbiAgICAgICAgICBhbHJlYWR5Q2FsbGVkID0gdHJ1ZTtcbiAgICAgICAgICB2YWx1ZXNbJGluZGV4XSA9IHZhbHVlO1xuICAgICAgICAgIC0tcmVtYWluaW5nIHx8IHJlc29sdmUodmFsdWVzKTtcbiAgICAgICAgfSwgcmVqZWN0KTtcbiAgICAgIH0pO1xuICAgICAgLS1yZW1haW5pbmcgfHwgcmVzb2x2ZSh2YWx1ZXMpO1xuICAgIH0pO1xuICAgIGlmIChyZXN1bHQuZSkgcmVqZWN0KHJlc3VsdC52KTtcbiAgICByZXR1cm4gY2FwYWJpbGl0eS5wcm9taXNlO1xuICB9LFxuICAvLyAyNS40LjQuNCBQcm9taXNlLnJhY2UoaXRlcmFibGUpXG4gIHJhY2U6IGZ1bmN0aW9uIHJhY2UoaXRlcmFibGUpIHtcbiAgICB2YXIgQyA9IHRoaXM7XG4gICAgdmFyIGNhcGFiaWxpdHkgPSBuZXdQcm9taXNlQ2FwYWJpbGl0eShDKTtcbiAgICB2YXIgcmVqZWN0ID0gY2FwYWJpbGl0eS5yZWplY3Q7XG4gICAgdmFyIHJlc3VsdCA9IHBlcmZvcm0oZnVuY3Rpb24gKCkge1xuICAgICAgZm9yT2YoaXRlcmFibGUsIGZhbHNlLCBmdW5jdGlvbiAocHJvbWlzZSkge1xuICAgICAgICBDLnJlc29sdmUocHJvbWlzZSkudGhlbihjYXBhYmlsaXR5LnJlc29sdmUsIHJlamVjdCk7XG4gICAgICB9KTtcbiAgICB9KTtcbiAgICBpZiAocmVzdWx0LmUpIHJlamVjdChyZXN1bHQudik7XG4gICAgcmV0dXJuIGNhcGFiaWxpdHkucHJvbWlzZTtcbiAgfVxufSk7XG4iLCIndXNlIHN0cmljdCc7XG52YXIgc3Ryb25nID0gcmVxdWlyZSgnLi9fY29sbGVjdGlvbi1zdHJvbmcnKTtcbnZhciB2YWxpZGF0ZSA9IHJlcXVpcmUoJy4vX3ZhbGlkYXRlLWNvbGxlY3Rpb24nKTtcbnZhciBTRVQgPSAnU2V0JztcblxuLy8gMjMuMiBTZXQgT2JqZWN0c1xubW9kdWxlLmV4cG9ydHMgPSByZXF1aXJlKCcuL19jb2xsZWN0aW9uJykoU0VULCBmdW5jdGlvbiAoZ2V0KSB7XG4gIHJldHVybiBmdW5jdGlvbiBTZXQoKSB7IHJldHVybiBnZXQodGhpcywgYXJndW1lbnRzLmxlbmd0aCA+IDAgPyBhcmd1bWVudHNbMF0gOiB1bmRlZmluZWQpOyB9O1xufSwge1xuICAvLyAyMy4yLjMuMSBTZXQucHJvdG90eXBlLmFkZCh2YWx1ZSlcbiAgYWRkOiBmdW5jdGlvbiBhZGQodmFsdWUpIHtcbiAgICByZXR1cm4gc3Ryb25nLmRlZih2YWxpZGF0ZSh0aGlzLCBTRVQpLCB2YWx1ZSA9IHZhbHVlID09PSAwID8gMCA6IHZhbHVlLCB2YWx1ZSk7XG4gIH1cbn0sIHN0cm9uZyk7XG4iLCIndXNlIHN0cmljdCc7XG52YXIgJGF0ID0gcmVxdWlyZSgnLi9fc3RyaW5nLWF0JykodHJ1ZSk7XG5cbi8vIDIxLjEuMy4yNyBTdHJpbmcucHJvdG90eXBlW0BAaXRlcmF0b3JdKClcbnJlcXVpcmUoJy4vX2l0ZXItZGVmaW5lJykoU3RyaW5nLCAnU3RyaW5nJywgZnVuY3Rpb24gKGl0ZXJhdGVkKSB7XG4gIHRoaXMuX3QgPSBTdHJpbmcoaXRlcmF0ZWQpOyAvLyB0YXJnZXRcbiAgdGhpcy5faSA9IDA7ICAgICAgICAgICAgICAgIC8vIG5leHQgaW5kZXhcbi8vIDIxLjEuNS4yLjEgJVN0cmluZ0l0ZXJhdG9yUHJvdG90eXBlJS5uZXh0KClcbn0sIGZ1bmN0aW9uICgpIHtcbiAgdmFyIE8gPSB0aGlzLl90O1xuICB2YXIgaW5kZXggPSB0aGlzLl9pO1xuICB2YXIgcG9pbnQ7XG4gIGlmIChpbmRleCA+PSBPLmxlbmd0aCkgcmV0dXJuIHsgdmFsdWU6IHVuZGVmaW5lZCwgZG9uZTogdHJ1ZSB9O1xuICBwb2ludCA9ICRhdChPLCBpbmRleCk7XG4gIHRoaXMuX2kgKz0gcG9pbnQubGVuZ3RoO1xuICByZXR1cm4geyB2YWx1ZTogcG9pbnQsIGRvbmU6IGZhbHNlIH07XG59KTtcbiIsIid1c2Ugc3RyaWN0Jztcbi8vIEVDTUFTY3JpcHQgNiBzeW1ib2xzIHNoaW1cbnZhciBnbG9iYWwgPSByZXF1aXJlKCcuL19nbG9iYWwnKTtcbnZhciBoYXMgPSByZXF1aXJlKCcuL19oYXMnKTtcbnZhciBERVNDUklQVE9SUyA9IHJlcXVpcmUoJy4vX2Rlc2NyaXB0b3JzJyk7XG52YXIgJGV4cG9ydCA9IHJlcXVpcmUoJy4vX2V4cG9ydCcpO1xudmFyIHJlZGVmaW5lID0gcmVxdWlyZSgnLi9fcmVkZWZpbmUnKTtcbnZhciBNRVRBID0gcmVxdWlyZSgnLi9fbWV0YScpLktFWTtcbnZhciAkZmFpbHMgPSByZXF1aXJlKCcuL19mYWlscycpO1xudmFyIHNoYXJlZCA9IHJlcXVpcmUoJy4vX3NoYXJlZCcpO1xudmFyIHNldFRvU3RyaW5nVGFnID0gcmVxdWlyZSgnLi9fc2V0LXRvLXN0cmluZy10YWcnKTtcbnZhciB1aWQgPSByZXF1aXJlKCcuL191aWQnKTtcbnZhciB3a3MgPSByZXF1aXJlKCcuL193a3MnKTtcbnZhciB3a3NFeHQgPSByZXF1aXJlKCcuL193a3MtZXh0Jyk7XG52YXIgd2tzRGVmaW5lID0gcmVxdWlyZSgnLi9fd2tzLWRlZmluZScpO1xudmFyIGtleU9mID0gcmVxdWlyZSgnLi9fa2V5b2YnKTtcbnZhciBlbnVtS2V5cyA9IHJlcXVpcmUoJy4vX2VudW0ta2V5cycpO1xudmFyIGlzQXJyYXkgPSByZXF1aXJlKCcuL19pcy1hcnJheScpO1xudmFyIGFuT2JqZWN0ID0gcmVxdWlyZSgnLi9fYW4tb2JqZWN0Jyk7XG52YXIgdG9JT2JqZWN0ID0gcmVxdWlyZSgnLi9fdG8taW9iamVjdCcpO1xudmFyIHRvUHJpbWl0aXZlID0gcmVxdWlyZSgnLi9fdG8tcHJpbWl0aXZlJyk7XG52YXIgY3JlYXRlRGVzYyA9IHJlcXVpcmUoJy4vX3Byb3BlcnR5LWRlc2MnKTtcbnZhciBfY3JlYXRlID0gcmVxdWlyZSgnLi9fb2JqZWN0LWNyZWF0ZScpO1xudmFyIGdPUE5FeHQgPSByZXF1aXJlKCcuL19vYmplY3QtZ29wbi1leHQnKTtcbnZhciAkR09QRCA9IHJlcXVpcmUoJy4vX29iamVjdC1nb3BkJyk7XG52YXIgJERQID0gcmVxdWlyZSgnLi9fb2JqZWN0LWRwJyk7XG52YXIgJGtleXMgPSByZXF1aXJlKCcuL19vYmplY3Qta2V5cycpO1xudmFyIGdPUEQgPSAkR09QRC5mO1xudmFyIGRQID0gJERQLmY7XG52YXIgZ09QTiA9IGdPUE5FeHQuZjtcbnZhciAkU3ltYm9sID0gZ2xvYmFsLlN5bWJvbDtcbnZhciAkSlNPTiA9IGdsb2JhbC5KU09OO1xudmFyIF9zdHJpbmdpZnkgPSAkSlNPTiAmJiAkSlNPTi5zdHJpbmdpZnk7XG52YXIgUFJPVE9UWVBFID0gJ3Byb3RvdHlwZSc7XG52YXIgSElEREVOID0gd2tzKCdfaGlkZGVuJyk7XG52YXIgVE9fUFJJTUlUSVZFID0gd2tzKCd0b1ByaW1pdGl2ZScpO1xudmFyIGlzRW51bSA9IHt9LnByb3BlcnR5SXNFbnVtZXJhYmxlO1xudmFyIFN5bWJvbFJlZ2lzdHJ5ID0gc2hhcmVkKCdzeW1ib2wtcmVnaXN0cnknKTtcbnZhciBBbGxTeW1ib2xzID0gc2hhcmVkKCdzeW1ib2xzJyk7XG52YXIgT1BTeW1ib2xzID0gc2hhcmVkKCdvcC1zeW1ib2xzJyk7XG52YXIgT2JqZWN0UHJvdG8gPSBPYmplY3RbUFJPVE9UWVBFXTtcbnZhciBVU0VfTkFUSVZFID0gdHlwZW9mICRTeW1ib2wgPT0gJ2Z1bmN0aW9uJztcbnZhciBRT2JqZWN0ID0gZ2xvYmFsLlFPYmplY3Q7XG4vLyBEb24ndCB1c2Ugc2V0dGVycyBpbiBRdCBTY3JpcHQsIGh0dHBzOi8vZ2l0aHViLmNvbS96bG9pcm9jay9jb3JlLWpzL2lzc3Vlcy8xNzNcbnZhciBzZXR0ZXIgPSAhUU9iamVjdCB8fCAhUU9iamVjdFtQUk9UT1RZUEVdIHx8ICFRT2JqZWN0W1BST1RPVFlQRV0uZmluZENoaWxkO1xuXG4vLyBmYWxsYmFjayBmb3Igb2xkIEFuZHJvaWQsIGh0dHBzOi8vY29kZS5nb29nbGUuY29tL3AvdjgvaXNzdWVzL2RldGFpbD9pZD02ODdcbnZhciBzZXRTeW1ib2xEZXNjID0gREVTQ1JJUFRPUlMgJiYgJGZhaWxzKGZ1bmN0aW9uICgpIHtcbiAgcmV0dXJuIF9jcmVhdGUoZFAoe30sICdhJywge1xuICAgIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gZFAodGhpcywgJ2EnLCB7IHZhbHVlOiA3IH0pLmE7IH1cbiAgfSkpLmEgIT0gNztcbn0pID8gZnVuY3Rpb24gKGl0LCBrZXksIEQpIHtcbiAgdmFyIHByb3RvRGVzYyA9IGdPUEQoT2JqZWN0UHJvdG8sIGtleSk7XG4gIGlmIChwcm90b0Rlc2MpIGRlbGV0ZSBPYmplY3RQcm90b1trZXldO1xuICBkUChpdCwga2V5LCBEKTtcbiAgaWYgKHByb3RvRGVzYyAmJiBpdCAhPT0gT2JqZWN0UHJvdG8pIGRQKE9iamVjdFByb3RvLCBrZXksIHByb3RvRGVzYyk7XG59IDogZFA7XG5cbnZhciB3cmFwID0gZnVuY3Rpb24gKHRhZykge1xuICB2YXIgc3ltID0gQWxsU3ltYm9sc1t0YWddID0gX2NyZWF0ZSgkU3ltYm9sW1BST1RPVFlQRV0pO1xuICBzeW0uX2sgPSB0YWc7XG4gIHJldHVybiBzeW07XG59O1xuXG52YXIgaXNTeW1ib2wgPSBVU0VfTkFUSVZFICYmIHR5cGVvZiAkU3ltYm9sLml0ZXJhdG9yID09ICdzeW1ib2wnID8gZnVuY3Rpb24gKGl0KSB7XG4gIHJldHVybiB0eXBlb2YgaXQgPT0gJ3N5bWJvbCc7XG59IDogZnVuY3Rpb24gKGl0KSB7XG4gIHJldHVybiBpdCBpbnN0YW5jZW9mICRTeW1ib2w7XG59O1xuXG52YXIgJGRlZmluZVByb3BlcnR5ID0gZnVuY3Rpb24gZGVmaW5lUHJvcGVydHkoaXQsIGtleSwgRCkge1xuICBpZiAoaXQgPT09IE9iamVjdFByb3RvKSAkZGVmaW5lUHJvcGVydHkoT1BTeW1ib2xzLCBrZXksIEQpO1xuICBhbk9iamVjdChpdCk7XG4gIGtleSA9IHRvUHJpbWl0aXZlKGtleSwgdHJ1ZSk7XG4gIGFuT2JqZWN0KEQpO1xuICBpZiAoaGFzKEFsbFN5bWJvbHMsIGtleSkpIHtcbiAgICBpZiAoIUQuZW51bWVyYWJsZSkge1xuICAgICAgaWYgKCFoYXMoaXQsIEhJRERFTikpIGRQKGl0LCBISURERU4sIGNyZWF0ZURlc2MoMSwge30pKTtcbiAgICAgIGl0W0hJRERFTl1ba2V5XSA9IHRydWU7XG4gICAgfSBlbHNlIHtcbiAgICAgIGlmIChoYXMoaXQsIEhJRERFTikgJiYgaXRbSElEREVOXVtrZXldKSBpdFtISURERU5dW2tleV0gPSBmYWxzZTtcbiAgICAgIEQgPSBfY3JlYXRlKEQsIHsgZW51bWVyYWJsZTogY3JlYXRlRGVzYygwLCBmYWxzZSkgfSk7XG4gICAgfSByZXR1cm4gc2V0U3ltYm9sRGVzYyhpdCwga2V5LCBEKTtcbiAgfSByZXR1cm4gZFAoaXQsIGtleSwgRCk7XG59O1xudmFyICRkZWZpbmVQcm9wZXJ0aWVzID0gZnVuY3Rpb24gZGVmaW5lUHJvcGVydGllcyhpdCwgUCkge1xuICBhbk9iamVjdChpdCk7XG4gIHZhciBrZXlzID0gZW51bUtleXMoUCA9IHRvSU9iamVjdChQKSk7XG4gIHZhciBpID0gMDtcbiAgdmFyIGwgPSBrZXlzLmxlbmd0aDtcbiAgdmFyIGtleTtcbiAgd2hpbGUgKGwgPiBpKSAkZGVmaW5lUHJvcGVydHkoaXQsIGtleSA9IGtleXNbaSsrXSwgUFtrZXldKTtcbiAgcmV0dXJuIGl0O1xufTtcbnZhciAkY3JlYXRlID0gZnVuY3Rpb24gY3JlYXRlKGl0LCBQKSB7XG4gIHJldHVybiBQID09PSB1bmRlZmluZWQgPyBfY3JlYXRlKGl0KSA6ICRkZWZpbmVQcm9wZXJ0aWVzKF9jcmVhdGUoaXQpLCBQKTtcbn07XG52YXIgJHByb3BlcnR5SXNFbnVtZXJhYmxlID0gZnVuY3Rpb24gcHJvcGVydHlJc0VudW1lcmFibGUoa2V5KSB7XG4gIHZhciBFID0gaXNFbnVtLmNhbGwodGhpcywga2V5ID0gdG9QcmltaXRpdmUoa2V5LCB0cnVlKSk7XG4gIGlmICh0aGlzID09PSBPYmplY3RQcm90byAmJiBoYXMoQWxsU3ltYm9scywga2V5KSAmJiAhaGFzKE9QU3ltYm9scywga2V5KSkgcmV0dXJuIGZhbHNlO1xuICByZXR1cm4gRSB8fCAhaGFzKHRoaXMsIGtleSkgfHwgIWhhcyhBbGxTeW1ib2xzLCBrZXkpIHx8IGhhcyh0aGlzLCBISURERU4pICYmIHRoaXNbSElEREVOXVtrZXldID8gRSA6IHRydWU7XG59O1xudmFyICRnZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IgPSBmdW5jdGlvbiBnZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IoaXQsIGtleSkge1xuICBpdCA9IHRvSU9iamVjdChpdCk7XG4gIGtleSA9IHRvUHJpbWl0aXZlKGtleSwgdHJ1ZSk7XG4gIGlmIChpdCA9PT0gT2JqZWN0UHJvdG8gJiYgaGFzKEFsbFN5bWJvbHMsIGtleSkgJiYgIWhhcyhPUFN5bWJvbHMsIGtleSkpIHJldHVybjtcbiAgdmFyIEQgPSBnT1BEKGl0LCBrZXkpO1xuICBpZiAoRCAmJiBoYXMoQWxsU3ltYm9scywga2V5KSAmJiAhKGhhcyhpdCwgSElEREVOKSAmJiBpdFtISURERU5dW2tleV0pKSBELmVudW1lcmFibGUgPSB0cnVlO1xuICByZXR1cm4gRDtcbn07XG52YXIgJGdldE93blByb3BlcnR5TmFtZXMgPSBmdW5jdGlvbiBnZXRPd25Qcm9wZXJ0eU5hbWVzKGl0KSB7XG4gIHZhciBuYW1lcyA9IGdPUE4odG9JT2JqZWN0KGl0KSk7XG4gIHZhciByZXN1bHQgPSBbXTtcbiAgdmFyIGkgPSAwO1xuICB2YXIga2V5O1xuICB3aGlsZSAobmFtZXMubGVuZ3RoID4gaSkge1xuICAgIGlmICghaGFzKEFsbFN5bWJvbHMsIGtleSA9IG5hbWVzW2krK10pICYmIGtleSAhPSBISURERU4gJiYga2V5ICE9IE1FVEEpIHJlc3VsdC5wdXNoKGtleSk7XG4gIH0gcmV0dXJuIHJlc3VsdDtcbn07XG52YXIgJGdldE93blByb3BlcnR5U3ltYm9scyA9IGZ1bmN0aW9uIGdldE93blByb3BlcnR5U3ltYm9scyhpdCkge1xuICB2YXIgSVNfT1AgPSBpdCA9PT0gT2JqZWN0UHJvdG87XG4gIHZhciBuYW1lcyA9IGdPUE4oSVNfT1AgPyBPUFN5bWJvbHMgOiB0b0lPYmplY3QoaXQpKTtcbiAgdmFyIHJlc3VsdCA9IFtdO1xuICB2YXIgaSA9IDA7XG4gIHZhciBrZXk7XG4gIHdoaWxlIChuYW1lcy5sZW5ndGggPiBpKSB7XG4gICAgaWYgKGhhcyhBbGxTeW1ib2xzLCBrZXkgPSBuYW1lc1tpKytdKSAmJiAoSVNfT1AgPyBoYXMoT2JqZWN0UHJvdG8sIGtleSkgOiB0cnVlKSkgcmVzdWx0LnB1c2goQWxsU3ltYm9sc1trZXldKTtcbiAgfSByZXR1cm4gcmVzdWx0O1xufTtcblxuLy8gMTkuNC4xLjEgU3ltYm9sKFtkZXNjcmlwdGlvbl0pXG5pZiAoIVVTRV9OQVRJVkUpIHtcbiAgJFN5bWJvbCA9IGZ1bmN0aW9uIFN5bWJvbCgpIHtcbiAgICBpZiAodGhpcyBpbnN0YW5jZW9mICRTeW1ib2wpIHRocm93IFR5cGVFcnJvcignU3ltYm9sIGlzIG5vdCBhIGNvbnN0cnVjdG9yIScpO1xuICAgIHZhciB0YWcgPSB1aWQoYXJndW1lbnRzLmxlbmd0aCA+IDAgPyBhcmd1bWVudHNbMF0gOiB1bmRlZmluZWQpO1xuICAgIHZhciAkc2V0ID0gZnVuY3Rpb24gKHZhbHVlKSB7XG4gICAgICBpZiAodGhpcyA9PT0gT2JqZWN0UHJvdG8pICRzZXQuY2FsbChPUFN5bWJvbHMsIHZhbHVlKTtcbiAgICAgIGlmIChoYXModGhpcywgSElEREVOKSAmJiBoYXModGhpc1tISURERU5dLCB0YWcpKSB0aGlzW0hJRERFTl1bdGFnXSA9IGZhbHNlO1xuICAgICAgc2V0U3ltYm9sRGVzYyh0aGlzLCB0YWcsIGNyZWF0ZURlc2MoMSwgdmFsdWUpKTtcbiAgICB9O1xuICAgIGlmIChERVNDUklQVE9SUyAmJiBzZXR0ZXIpIHNldFN5bWJvbERlc2MoT2JqZWN0UHJvdG8sIHRhZywgeyBjb25maWd1cmFibGU6IHRydWUsIHNldDogJHNldCB9KTtcbiAgICByZXR1cm4gd3JhcCh0YWcpO1xuICB9O1xuICByZWRlZmluZSgkU3ltYm9sW1BST1RPVFlQRV0sICd0b1N0cmluZycsIGZ1bmN0aW9uIHRvU3RyaW5nKCkge1xuICAgIHJldHVybiB0aGlzLl9rO1xuICB9KTtcblxuICAkR09QRC5mID0gJGdldE93blByb3BlcnR5RGVzY3JpcHRvcjtcbiAgJERQLmYgPSAkZGVmaW5lUHJvcGVydHk7XG4gIHJlcXVpcmUoJy4vX29iamVjdC1nb3BuJykuZiA9IGdPUE5FeHQuZiA9ICRnZXRPd25Qcm9wZXJ0eU5hbWVzO1xuICByZXF1aXJlKCcuL19vYmplY3QtcGllJykuZiA9ICRwcm9wZXJ0eUlzRW51bWVyYWJsZTtcbiAgcmVxdWlyZSgnLi9fb2JqZWN0LWdvcHMnKS5mID0gJGdldE93blByb3BlcnR5U3ltYm9scztcblxuICBpZiAoREVTQ1JJUFRPUlMgJiYgIXJlcXVpcmUoJy4vX2xpYnJhcnknKSkge1xuICAgIHJlZGVmaW5lKE9iamVjdFByb3RvLCAncHJvcGVydHlJc0VudW1lcmFibGUnLCAkcHJvcGVydHlJc0VudW1lcmFibGUsIHRydWUpO1xuICB9XG5cbiAgd2tzRXh0LmYgPSBmdW5jdGlvbiAobmFtZSkge1xuICAgIHJldHVybiB3cmFwKHdrcyhuYW1lKSk7XG4gIH07XG59XG5cbiRleHBvcnQoJGV4cG9ydC5HICsgJGV4cG9ydC5XICsgJGV4cG9ydC5GICogIVVTRV9OQVRJVkUsIHsgU3ltYm9sOiAkU3ltYm9sIH0pO1xuXG5mb3IgKHZhciBlczZTeW1ib2xzID0gKFxuICAvLyAxOS40LjIuMiwgMTkuNC4yLjMsIDE5LjQuMi40LCAxOS40LjIuNiwgMTkuNC4yLjgsIDE5LjQuMi45LCAxOS40LjIuMTAsIDE5LjQuMi4xMSwgMTkuNC4yLjEyLCAxOS40LjIuMTMsIDE5LjQuMi4xNFxuICAnaGFzSW5zdGFuY2UsaXNDb25jYXRTcHJlYWRhYmxlLGl0ZXJhdG9yLG1hdGNoLHJlcGxhY2Usc2VhcmNoLHNwZWNpZXMsc3BsaXQsdG9QcmltaXRpdmUsdG9TdHJpbmdUYWcsdW5zY29wYWJsZXMnXG4pLnNwbGl0KCcsJyksIGogPSAwOyBlczZTeW1ib2xzLmxlbmd0aCA+IGo7KXdrcyhlczZTeW1ib2xzW2orK10pO1xuXG5mb3IgKHZhciB3ZWxsS25vd25TeW1ib2xzID0gJGtleXMod2tzLnN0b3JlKSwgayA9IDA7IHdlbGxLbm93blN5bWJvbHMubGVuZ3RoID4gazspIHdrc0RlZmluZSh3ZWxsS25vd25TeW1ib2xzW2srK10pO1xuXG4kZXhwb3J0KCRleHBvcnQuUyArICRleHBvcnQuRiAqICFVU0VfTkFUSVZFLCAnU3ltYm9sJywge1xuICAvLyAxOS40LjIuMSBTeW1ib2wuZm9yKGtleSlcbiAgJ2Zvcic6IGZ1bmN0aW9uIChrZXkpIHtcbiAgICByZXR1cm4gaGFzKFN5bWJvbFJlZ2lzdHJ5LCBrZXkgKz0gJycpXG4gICAgICA/IFN5bWJvbFJlZ2lzdHJ5W2tleV1cbiAgICAgIDogU3ltYm9sUmVnaXN0cnlba2V5XSA9ICRTeW1ib2woa2V5KTtcbiAgfSxcbiAgLy8gMTkuNC4yLjUgU3ltYm9sLmtleUZvcihzeW0pXG4gIGtleUZvcjogZnVuY3Rpb24ga2V5Rm9yKGtleSkge1xuICAgIGlmIChpc1N5bWJvbChrZXkpKSByZXR1cm4ga2V5T2YoU3ltYm9sUmVnaXN0cnksIGtleSk7XG4gICAgdGhyb3cgVHlwZUVycm9yKGtleSArICcgaXMgbm90IGEgc3ltYm9sIScpO1xuICB9LFxuICB1c2VTZXR0ZXI6IGZ1bmN0aW9uICgpIHsgc2V0dGVyID0gdHJ1ZTsgfSxcbiAgdXNlU2ltcGxlOiBmdW5jdGlvbiAoKSB7IHNldHRlciA9IGZhbHNlOyB9XG59KTtcblxuJGV4cG9ydCgkZXhwb3J0LlMgKyAkZXhwb3J0LkYgKiAhVVNFX05BVElWRSwgJ09iamVjdCcsIHtcbiAgLy8gMTkuMS4yLjIgT2JqZWN0LmNyZWF0ZShPIFssIFByb3BlcnRpZXNdKVxuICBjcmVhdGU6ICRjcmVhdGUsXG4gIC8vIDE5LjEuMi40IE9iamVjdC5kZWZpbmVQcm9wZXJ0eShPLCBQLCBBdHRyaWJ1dGVzKVxuICBkZWZpbmVQcm9wZXJ0eTogJGRlZmluZVByb3BlcnR5LFxuICAvLyAxOS4xLjIuMyBPYmplY3QuZGVmaW5lUHJvcGVydGllcyhPLCBQcm9wZXJ0aWVzKVxuICBkZWZpbmVQcm9wZXJ0aWVzOiAkZGVmaW5lUHJvcGVydGllcyxcbiAgLy8gMTkuMS4yLjYgT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihPLCBQKVxuICBnZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3I6ICRnZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IsXG4gIC8vIDE5LjEuMi43IE9iamVjdC5nZXRPd25Qcm9wZXJ0eU5hbWVzKE8pXG4gIGdldE93blByb3BlcnR5TmFtZXM6ICRnZXRPd25Qcm9wZXJ0eU5hbWVzLFxuICAvLyAxOS4xLjIuOCBPYmplY3QuZ2V0T3duUHJvcGVydHlTeW1ib2xzKE8pXG4gIGdldE93blByb3BlcnR5U3ltYm9sczogJGdldE93blByb3BlcnR5U3ltYm9sc1xufSk7XG5cbi8vIDI0LjMuMiBKU09OLnN0cmluZ2lmeSh2YWx1ZSBbLCByZXBsYWNlciBbLCBzcGFjZV1dKVxuJEpTT04gJiYgJGV4cG9ydCgkZXhwb3J0LlMgKyAkZXhwb3J0LkYgKiAoIVVTRV9OQVRJVkUgfHwgJGZhaWxzKGZ1bmN0aW9uICgpIHtcbiAgdmFyIFMgPSAkU3ltYm9sKCk7XG4gIC8vIE1TIEVkZ2UgY29udmVydHMgc3ltYm9sIHZhbHVlcyB0byBKU09OIGFzIHt9XG4gIC8vIFdlYktpdCBjb252ZXJ0cyBzeW1ib2wgdmFsdWVzIHRvIEpTT04gYXMgbnVsbFxuICAvLyBWOCB0aHJvd3Mgb24gYm94ZWQgc3ltYm9sc1xuICByZXR1cm4gX3N0cmluZ2lmeShbU10pICE9ICdbbnVsbF0nIHx8IF9zdHJpbmdpZnkoeyBhOiBTIH0pICE9ICd7fScgfHwgX3N0cmluZ2lmeShPYmplY3QoUykpICE9ICd7fSc7XG59KSksICdKU09OJywge1xuICBzdHJpbmdpZnk6IGZ1bmN0aW9uIHN0cmluZ2lmeShpdCkge1xuICAgIGlmIChpdCA9PT0gdW5kZWZpbmVkIHx8IGlzU3ltYm9sKGl0KSkgcmV0dXJuOyAvLyBJRTggcmV0dXJucyBzdHJpbmcgb24gdW5kZWZpbmVkXG4gICAgdmFyIGFyZ3MgPSBbaXRdO1xuICAgIHZhciBpID0gMTtcbiAgICB2YXIgcmVwbGFjZXIsICRyZXBsYWNlcjtcbiAgICB3aGlsZSAoYXJndW1lbnRzLmxlbmd0aCA+IGkpIGFyZ3MucHVzaChhcmd1bWVudHNbaSsrXSk7XG4gICAgcmVwbGFjZXIgPSBhcmdzWzFdO1xuICAgIGlmICh0eXBlb2YgcmVwbGFjZXIgPT0gJ2Z1bmN0aW9uJykgJHJlcGxhY2VyID0gcmVwbGFjZXI7XG4gICAgaWYgKCRyZXBsYWNlciB8fCAhaXNBcnJheShyZXBsYWNlcikpIHJlcGxhY2VyID0gZnVuY3Rpb24gKGtleSwgdmFsdWUpIHtcbiAgICAgIGlmICgkcmVwbGFjZXIpIHZhbHVlID0gJHJlcGxhY2VyLmNhbGwodGhpcywga2V5LCB2YWx1ZSk7XG4gICAgICBpZiAoIWlzU3ltYm9sKHZhbHVlKSkgcmV0dXJuIHZhbHVlO1xuICAgIH07XG4gICAgYXJnc1sxXSA9IHJlcGxhY2VyO1xuICAgIHJldHVybiBfc3RyaW5naWZ5LmFwcGx5KCRKU09OLCBhcmdzKTtcbiAgfVxufSk7XG5cbi8vIDE5LjQuMy40IFN5bWJvbC5wcm90b3R5cGVbQEB0b1ByaW1pdGl2ZV0oaGludClcbiRTeW1ib2xbUFJPVE9UWVBFXVtUT19QUklNSVRJVkVdIHx8IHJlcXVpcmUoJy4vX2hpZGUnKSgkU3ltYm9sW1BST1RPVFlQRV0sIFRPX1BSSU1JVElWRSwgJFN5bWJvbFtQUk9UT1RZUEVdLnZhbHVlT2YpO1xuLy8gMTkuNC4zLjUgU3ltYm9sLnByb3RvdHlwZVtAQHRvU3RyaW5nVGFnXVxuc2V0VG9TdHJpbmdUYWcoJFN5bWJvbCwgJ1N5bWJvbCcpO1xuLy8gMjAuMi4xLjkgTWF0aFtAQHRvU3RyaW5nVGFnXVxuc2V0VG9TdHJpbmdUYWcoTWF0aCwgJ01hdGgnLCB0cnVlKTtcbi8vIDI0LjMuMyBKU09OW0BAdG9TdHJpbmdUYWddXG5zZXRUb1N0cmluZ1RhZyhnbG9iYWwuSlNPTiwgJ0pTT04nLCB0cnVlKTtcbiIsIi8vIGh0dHBzOi8vdGMzOS5naXRodWIuaW8vcHJvcG9zYWwtc2V0bWFwLW9mZnJvbS8jc2VjLW1hcC5mcm9tXG5yZXF1aXJlKCcuL19zZXQtY29sbGVjdGlvbi1mcm9tJykoJ01hcCcpO1xuIiwiLy8gaHR0cHM6Ly90YzM5LmdpdGh1Yi5pby9wcm9wb3NhbC1zZXRtYXAtb2Zmcm9tLyNzZWMtbWFwLm9mXG5yZXF1aXJlKCcuL19zZXQtY29sbGVjdGlvbi1vZicpKCdNYXAnKTtcbiIsIi8vIGh0dHBzOi8vZ2l0aHViLmNvbS9EYXZpZEJydWFudC9NYXAtU2V0LnByb3RvdHlwZS50b0pTT05cbnZhciAkZXhwb3J0ID0gcmVxdWlyZSgnLi9fZXhwb3J0Jyk7XG5cbiRleHBvcnQoJGV4cG9ydC5QICsgJGV4cG9ydC5SLCAnTWFwJywgeyB0b0pTT046IHJlcXVpcmUoJy4vX2NvbGxlY3Rpb24tdG8tanNvbicpKCdNYXAnKSB9KTtcbiIsIi8vIGh0dHBzOi8vZ2l0aHViLmNvbS90YzM5L3Byb3Bvc2FsLW9iamVjdC12YWx1ZXMtZW50cmllc1xudmFyICRleHBvcnQgPSByZXF1aXJlKCcuL19leHBvcnQnKTtcbnZhciAkdmFsdWVzID0gcmVxdWlyZSgnLi9fb2JqZWN0LXRvLWFycmF5JykoZmFsc2UpO1xuXG4kZXhwb3J0KCRleHBvcnQuUywgJ09iamVjdCcsIHtcbiAgdmFsdWVzOiBmdW5jdGlvbiB2YWx1ZXMoaXQpIHtcbiAgICByZXR1cm4gJHZhbHVlcyhpdCk7XG4gIH1cbn0pO1xuIiwiLy8gaHR0cHM6Ly9naXRodWIuY29tL3RjMzkvcHJvcG9zYWwtcHJvbWlzZS1maW5hbGx5XG4ndXNlIHN0cmljdCc7XG52YXIgJGV4cG9ydCA9IHJlcXVpcmUoJy4vX2V4cG9ydCcpO1xudmFyIGNvcmUgPSByZXF1aXJlKCcuL19jb3JlJyk7XG52YXIgZ2xvYmFsID0gcmVxdWlyZSgnLi9fZ2xvYmFsJyk7XG52YXIgc3BlY2llc0NvbnN0cnVjdG9yID0gcmVxdWlyZSgnLi9fc3BlY2llcy1jb25zdHJ1Y3RvcicpO1xudmFyIHByb21pc2VSZXNvbHZlID0gcmVxdWlyZSgnLi9fcHJvbWlzZS1yZXNvbHZlJyk7XG5cbiRleHBvcnQoJGV4cG9ydC5QICsgJGV4cG9ydC5SLCAnUHJvbWlzZScsIHsgJ2ZpbmFsbHknOiBmdW5jdGlvbiAob25GaW5hbGx5KSB7XG4gIHZhciBDID0gc3BlY2llc0NvbnN0cnVjdG9yKHRoaXMsIGNvcmUuUHJvbWlzZSB8fCBnbG9iYWwuUHJvbWlzZSk7XG4gIHZhciBpc0Z1bmN0aW9uID0gdHlwZW9mIG9uRmluYWxseSA9PSAnZnVuY3Rpb24nO1xuICByZXR1cm4gdGhpcy50aGVuKFxuICAgIGlzRnVuY3Rpb24gPyBmdW5jdGlvbiAoeCkge1xuICAgICAgcmV0dXJuIHByb21pc2VSZXNvbHZlKEMsIG9uRmluYWxseSgpKS50aGVuKGZ1bmN0aW9uICgpIHsgcmV0dXJuIHg7IH0pO1xuICAgIH0gOiBvbkZpbmFsbHksXG4gICAgaXNGdW5jdGlvbiA/IGZ1bmN0aW9uIChlKSB7XG4gICAgICByZXR1cm4gcHJvbWlzZVJlc29sdmUoQywgb25GaW5hbGx5KCkpLnRoZW4oZnVuY3Rpb24gKCkgeyB0aHJvdyBlOyB9KTtcbiAgICB9IDogb25GaW5hbGx5XG4gICk7XG59IH0pO1xuIiwiJ3VzZSBzdHJpY3QnO1xuLy8gaHR0cHM6Ly9naXRodWIuY29tL3RjMzkvcHJvcG9zYWwtcHJvbWlzZS10cnlcbnZhciAkZXhwb3J0ID0gcmVxdWlyZSgnLi9fZXhwb3J0Jyk7XG52YXIgbmV3UHJvbWlzZUNhcGFiaWxpdHkgPSByZXF1aXJlKCcuL19uZXctcHJvbWlzZS1jYXBhYmlsaXR5Jyk7XG52YXIgcGVyZm9ybSA9IHJlcXVpcmUoJy4vX3BlcmZvcm0nKTtcblxuJGV4cG9ydCgkZXhwb3J0LlMsICdQcm9taXNlJywgeyAndHJ5JzogZnVuY3Rpb24gKGNhbGxiYWNrZm4pIHtcbiAgdmFyIHByb21pc2VDYXBhYmlsaXR5ID0gbmV3UHJvbWlzZUNhcGFiaWxpdHkuZih0aGlzKTtcbiAgdmFyIHJlc3VsdCA9IHBlcmZvcm0oY2FsbGJhY2tmbik7XG4gIChyZXN1bHQuZSA/IHByb21pc2VDYXBhYmlsaXR5LnJlamVjdCA6IHByb21pc2VDYXBhYmlsaXR5LnJlc29sdmUpKHJlc3VsdC52KTtcbiAgcmV0dXJuIHByb21pc2VDYXBhYmlsaXR5LnByb21pc2U7XG59IH0pO1xuIiwiLy8gaHR0cHM6Ly90YzM5LmdpdGh1Yi5pby9wcm9wb3NhbC1zZXRtYXAtb2Zmcm9tLyNzZWMtc2V0LmZyb21cbnJlcXVpcmUoJy4vX3NldC1jb2xsZWN0aW9uLWZyb20nKSgnU2V0Jyk7XG4iLCIvLyBodHRwczovL3RjMzkuZ2l0aHViLmlvL3Byb3Bvc2FsLXNldG1hcC1vZmZyb20vI3NlYy1zZXQub2ZcbnJlcXVpcmUoJy4vX3NldC1jb2xsZWN0aW9uLW9mJykoJ1NldCcpO1xuIiwiLy8gaHR0cHM6Ly9naXRodWIuY29tL0RhdmlkQnJ1YW50L01hcC1TZXQucHJvdG90eXBlLnRvSlNPTlxudmFyICRleHBvcnQgPSByZXF1aXJlKCcuL19leHBvcnQnKTtcblxuJGV4cG9ydCgkZXhwb3J0LlAgKyAkZXhwb3J0LlIsICdTZXQnLCB7IHRvSlNPTjogcmVxdWlyZSgnLi9fY29sbGVjdGlvbi10by1qc29uJykoJ1NldCcpIH0pO1xuIiwicmVxdWlyZSgnLi9fd2tzLWRlZmluZScpKCdhc3luY0l0ZXJhdG9yJyk7XG4iLCJyZXF1aXJlKCcuL193a3MtZGVmaW5lJykoJ29ic2VydmFibGUnKTtcbiIsInJlcXVpcmUoJy4vZXM2LmFycmF5Lml0ZXJhdG9yJyk7XG52YXIgZ2xvYmFsID0gcmVxdWlyZSgnLi9fZ2xvYmFsJyk7XG52YXIgaGlkZSA9IHJlcXVpcmUoJy4vX2hpZGUnKTtcbnZhciBJdGVyYXRvcnMgPSByZXF1aXJlKCcuL19pdGVyYXRvcnMnKTtcbnZhciBUT19TVFJJTkdfVEFHID0gcmVxdWlyZSgnLi9fd2tzJykoJ3RvU3RyaW5nVGFnJyk7XG5cbnZhciBET01JdGVyYWJsZXMgPSAoJ0NTU1J1bGVMaXN0LENTU1N0eWxlRGVjbGFyYXRpb24sQ1NTVmFsdWVMaXN0LENsaWVudFJlY3RMaXN0LERPTVJlY3RMaXN0LERPTVN0cmluZ0xpc3QsJyArXG4gICdET01Ub2tlbkxpc3QsRGF0YVRyYW5zZmVySXRlbUxpc3QsRmlsZUxpc3QsSFRNTEFsbENvbGxlY3Rpb24sSFRNTENvbGxlY3Rpb24sSFRNTEZvcm1FbGVtZW50LEhUTUxTZWxlY3RFbGVtZW50LCcgK1xuICAnTWVkaWFMaXN0LE1pbWVUeXBlQXJyYXksTmFtZWROb2RlTWFwLE5vZGVMaXN0LFBhaW50UmVxdWVzdExpc3QsUGx1Z2luLFBsdWdpbkFycmF5LFNWR0xlbmd0aExpc3QsU1ZHTnVtYmVyTGlzdCwnICtcbiAgJ1NWR1BhdGhTZWdMaXN0LFNWR1BvaW50TGlzdCxTVkdTdHJpbmdMaXN0LFNWR1RyYW5zZm9ybUxpc3QsU291cmNlQnVmZmVyTGlzdCxTdHlsZVNoZWV0TGlzdCxUZXh0VHJhY2tDdWVMaXN0LCcgK1xuICAnVGV4dFRyYWNrTGlzdCxUb3VjaExpc3QnKS5zcGxpdCgnLCcpO1xuXG5mb3IgKHZhciBpID0gMDsgaSA8IERPTUl0ZXJhYmxlcy5sZW5ndGg7IGkrKykge1xuICB2YXIgTkFNRSA9IERPTUl0ZXJhYmxlc1tpXTtcbiAgdmFyIENvbGxlY3Rpb24gPSBnbG9iYWxbTkFNRV07XG4gIHZhciBwcm90byA9IENvbGxlY3Rpb24gJiYgQ29sbGVjdGlvbi5wcm90b3R5cGU7XG4gIGlmIChwcm90byAmJiAhcHJvdG9bVE9fU1RSSU5HX1RBR10pIGhpZGUocHJvdG8sIFRPX1NUUklOR19UQUcsIE5BTUUpO1xuICBJdGVyYXRvcnNbTkFNRV0gPSBJdGVyYXRvcnMuQXJyYXk7XG59XG4iLCIvKipcbiAqIFRoaXMgaXMgdGhlIHdlYiBicm93c2VyIGltcGxlbWVudGF0aW9uIG9mIGBkZWJ1ZygpYC5cbiAqXG4gKiBFeHBvc2UgYGRlYnVnKClgIGFzIHRoZSBtb2R1bGUuXG4gKi9cblxuZXhwb3J0cyA9IG1vZHVsZS5leHBvcnRzID0gcmVxdWlyZSgnLi9kZWJ1ZycpO1xuZXhwb3J0cy5sb2cgPSBsb2c7XG5leHBvcnRzLmZvcm1hdEFyZ3MgPSBmb3JtYXRBcmdzO1xuZXhwb3J0cy5zYXZlID0gc2F2ZTtcbmV4cG9ydHMubG9hZCA9IGxvYWQ7XG5leHBvcnRzLnVzZUNvbG9ycyA9IHVzZUNvbG9ycztcbmV4cG9ydHMuc3RvcmFnZSA9ICd1bmRlZmluZWQnICE9IHR5cGVvZiBjaHJvbWVcbiAgICAgICAgICAgICAgICYmICd1bmRlZmluZWQnICE9IHR5cGVvZiBjaHJvbWUuc3RvcmFnZVxuICAgICAgICAgICAgICAgICAgPyBjaHJvbWUuc3RvcmFnZS5sb2NhbFxuICAgICAgICAgICAgICAgICAgOiBsb2NhbHN0b3JhZ2UoKTtcblxuLyoqXG4gKiBDb2xvcnMuXG4gKi9cblxuZXhwb3J0cy5jb2xvcnMgPSBbXG4gICcjMDAwMENDJywgJyMwMDAwRkYnLCAnIzAwMzNDQycsICcjMDAzM0ZGJywgJyMwMDY2Q0MnLCAnIzAwNjZGRicsICcjMDA5OUNDJyxcbiAgJyMwMDk5RkYnLCAnIzAwQ0MwMCcsICcjMDBDQzMzJywgJyMwMENDNjYnLCAnIzAwQ0M5OScsICcjMDBDQ0NDJywgJyMwMENDRkYnLFxuICAnIzMzMDBDQycsICcjMzMwMEZGJywgJyMzMzMzQ0MnLCAnIzMzMzNGRicsICcjMzM2NkNDJywgJyMzMzY2RkYnLCAnIzMzOTlDQycsXG4gICcjMzM5OUZGJywgJyMzM0NDMDAnLCAnIzMzQ0MzMycsICcjMzNDQzY2JywgJyMzM0NDOTknLCAnIzMzQ0NDQycsICcjMzNDQ0ZGJyxcbiAgJyM2NjAwQ0MnLCAnIzY2MDBGRicsICcjNjYzM0NDJywgJyM2NjMzRkYnLCAnIzY2Q0MwMCcsICcjNjZDQzMzJywgJyM5OTAwQ0MnLFxuICAnIzk5MDBGRicsICcjOTkzM0NDJywgJyM5OTMzRkYnLCAnIzk5Q0MwMCcsICcjOTlDQzMzJywgJyNDQzAwMDAnLCAnI0NDMDAzMycsXG4gICcjQ0MwMDY2JywgJyNDQzAwOTknLCAnI0NDMDBDQycsICcjQ0MwMEZGJywgJyNDQzMzMDAnLCAnI0NDMzMzMycsICcjQ0MzMzY2JyxcbiAgJyNDQzMzOTknLCAnI0NDMzNDQycsICcjQ0MzM0ZGJywgJyNDQzY2MDAnLCAnI0NDNjYzMycsICcjQ0M5OTAwJywgJyNDQzk5MzMnLFxuICAnI0NDQ0MwMCcsICcjQ0NDQzMzJywgJyNGRjAwMDAnLCAnI0ZGMDAzMycsICcjRkYwMDY2JywgJyNGRjAwOTknLCAnI0ZGMDBDQycsXG4gICcjRkYwMEZGJywgJyNGRjMzMDAnLCAnI0ZGMzMzMycsICcjRkYzMzY2JywgJyNGRjMzOTknLCAnI0ZGMzNDQycsICcjRkYzM0ZGJyxcbiAgJyNGRjY2MDAnLCAnI0ZGNjYzMycsICcjRkY5OTAwJywgJyNGRjk5MzMnLCAnI0ZGQ0MwMCcsICcjRkZDQzMzJ1xuXTtcblxuLyoqXG4gKiBDdXJyZW50bHkgb25seSBXZWJLaXQtYmFzZWQgV2ViIEluc3BlY3RvcnMsIEZpcmVmb3ggPj0gdjMxLFxuICogYW5kIHRoZSBGaXJlYnVnIGV4dGVuc2lvbiAoYW55IEZpcmVmb3ggdmVyc2lvbikgYXJlIGtub3duXG4gKiB0byBzdXBwb3J0IFwiJWNcIiBDU1MgY3VzdG9taXphdGlvbnMuXG4gKlxuICogVE9ETzogYWRkIGEgYGxvY2FsU3RvcmFnZWAgdmFyaWFibGUgdG8gZXhwbGljaXRseSBlbmFibGUvZGlzYWJsZSBjb2xvcnNcbiAqL1xuXG5mdW5jdGlvbiB1c2VDb2xvcnMoKSB7XG4gIC8vIE5COiBJbiBhbiBFbGVjdHJvbiBwcmVsb2FkIHNjcmlwdCwgZG9jdW1lbnQgd2lsbCBiZSBkZWZpbmVkIGJ1dCBub3QgZnVsbHlcbiAgLy8gaW5pdGlhbGl6ZWQuIFNpbmNlIHdlIGtub3cgd2UncmUgaW4gQ2hyb21lLCB3ZSdsbCBqdXN0IGRldGVjdCB0aGlzIGNhc2VcbiAgLy8gZXhwbGljaXRseVxuICBpZiAodHlwZW9mIHdpbmRvdyAhPT0gJ3VuZGVmaW5lZCcgJiYgd2luZG93LnByb2Nlc3MgJiYgd2luZG93LnByb2Nlc3MudHlwZSA9PT0gJ3JlbmRlcmVyJykge1xuICAgIHJldHVybiB0cnVlO1xuICB9XG5cbiAgLy8gSW50ZXJuZXQgRXhwbG9yZXIgYW5kIEVkZ2UgZG8gbm90IHN1cHBvcnQgY29sb3JzLlxuICBpZiAodHlwZW9mIG5hdmlnYXRvciAhPT0gJ3VuZGVmaW5lZCcgJiYgbmF2aWdhdG9yLnVzZXJBZ2VudCAmJiBuYXZpZ2F0b3IudXNlckFnZW50LnRvTG93ZXJDYXNlKCkubWF0Y2goLyhlZGdlfHRyaWRlbnQpXFwvKFxcZCspLykpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cblxuICAvLyBpcyB3ZWJraXQ/IGh0dHA6Ly9zdGFja292ZXJmbG93LmNvbS9hLzE2NDU5NjA2LzM3Njc3M1xuICAvLyBkb2N1bWVudCBpcyB1bmRlZmluZWQgaW4gcmVhY3QtbmF0aXZlOiBodHRwczovL2dpdGh1Yi5jb20vZmFjZWJvb2svcmVhY3QtbmF0aXZlL3B1bGwvMTYzMlxuICByZXR1cm4gKHR5cGVvZiBkb2N1bWVudCAhPT0gJ3VuZGVmaW5lZCcgJiYgZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50ICYmIGRvY3VtZW50LmRvY3VtZW50RWxlbWVudC5zdHlsZSAmJiBkb2N1bWVudC5kb2N1bWVudEVsZW1lbnQuc3R5bGUuV2Via2l0QXBwZWFyYW5jZSkgfHxcbiAgICAvLyBpcyBmaXJlYnVnPyBodHRwOi8vc3RhY2tvdmVyZmxvdy5jb20vYS8zOTgxMjAvMzc2NzczXG4gICAgKHR5cGVvZiB3aW5kb3cgIT09ICd1bmRlZmluZWQnICYmIHdpbmRvdy5jb25zb2xlICYmICh3aW5kb3cuY29uc29sZS5maXJlYnVnIHx8ICh3aW5kb3cuY29uc29sZS5leGNlcHRpb24gJiYgd2luZG93LmNvbnNvbGUudGFibGUpKSkgfHxcbiAgICAvLyBpcyBmaXJlZm94ID49IHYzMT9cbiAgICAvLyBodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL1Rvb2xzL1dlYl9Db25zb2xlI1N0eWxpbmdfbWVzc2FnZXNcbiAgICAodHlwZW9mIG5hdmlnYXRvciAhPT0gJ3VuZGVmaW5lZCcgJiYgbmF2aWdhdG9yLnVzZXJBZ2VudCAmJiBuYXZpZ2F0b3IudXNlckFnZW50LnRvTG93ZXJDYXNlKCkubWF0Y2goL2ZpcmVmb3hcXC8oXFxkKykvKSAmJiBwYXJzZUludChSZWdFeHAuJDEsIDEwKSA+PSAzMSkgfHxcbiAgICAvLyBkb3VibGUgY2hlY2sgd2Via2l0IGluIHVzZXJBZ2VudCBqdXN0IGluIGNhc2Ugd2UgYXJlIGluIGEgd29ya2VyXG4gICAgKHR5cGVvZiBuYXZpZ2F0b3IgIT09ICd1bmRlZmluZWQnICYmIG5hdmlnYXRvci51c2VyQWdlbnQgJiYgbmF2aWdhdG9yLnVzZXJBZ2VudC50b0xvd2VyQ2FzZSgpLm1hdGNoKC9hcHBsZXdlYmtpdFxcLyhcXGQrKS8pKTtcbn1cblxuLyoqXG4gKiBNYXAgJWogdG8gYEpTT04uc3RyaW5naWZ5KClgLCBzaW5jZSBubyBXZWIgSW5zcGVjdG9ycyBkbyB0aGF0IGJ5IGRlZmF1bHQuXG4gKi9cblxuZXhwb3J0cy5mb3JtYXR0ZXJzLmogPSBmdW5jdGlvbih2KSB7XG4gIHRyeSB7XG4gICAgcmV0dXJuIEpTT04uc3RyaW5naWZ5KHYpO1xuICB9IGNhdGNoIChlcnIpIHtcbiAgICByZXR1cm4gJ1tVbmV4cGVjdGVkSlNPTlBhcnNlRXJyb3JdOiAnICsgZXJyLm1lc3NhZ2U7XG4gIH1cbn07XG5cblxuLyoqXG4gKiBDb2xvcml6ZSBsb2cgYXJndW1lbnRzIGlmIGVuYWJsZWQuXG4gKlxuICogQGFwaSBwdWJsaWNcbiAqL1xuXG5mdW5jdGlvbiBmb3JtYXRBcmdzKGFyZ3MpIHtcbiAgdmFyIHVzZUNvbG9ycyA9IHRoaXMudXNlQ29sb3JzO1xuXG4gIGFyZ3NbMF0gPSAodXNlQ29sb3JzID8gJyVjJyA6ICcnKVxuICAgICsgdGhpcy5uYW1lc3BhY2VcbiAgICArICh1c2VDb2xvcnMgPyAnICVjJyA6ICcgJylcbiAgICArIGFyZ3NbMF1cbiAgICArICh1c2VDb2xvcnMgPyAnJWMgJyA6ICcgJylcbiAgICArICcrJyArIGV4cG9ydHMuaHVtYW5pemUodGhpcy5kaWZmKTtcblxuICBpZiAoIXVzZUNvbG9ycykgcmV0dXJuO1xuXG4gIHZhciBjID0gJ2NvbG9yOiAnICsgdGhpcy5jb2xvcjtcbiAgYXJncy5zcGxpY2UoMSwgMCwgYywgJ2NvbG9yOiBpbmhlcml0JylcblxuICAvLyB0aGUgZmluYWwgXCIlY1wiIGlzIHNvbWV3aGF0IHRyaWNreSwgYmVjYXVzZSB0aGVyZSBjb3VsZCBiZSBvdGhlclxuICAvLyBhcmd1bWVudHMgcGFzc2VkIGVpdGhlciBiZWZvcmUgb3IgYWZ0ZXIgdGhlICVjLCBzbyB3ZSBuZWVkIHRvXG4gIC8vIGZpZ3VyZSBvdXQgdGhlIGNvcnJlY3QgaW5kZXggdG8gaW5zZXJ0IHRoZSBDU1MgaW50b1xuICB2YXIgaW5kZXggPSAwO1xuICB2YXIgbGFzdEMgPSAwO1xuICBhcmdzWzBdLnJlcGxhY2UoLyVbYS16QS1aJV0vZywgZnVuY3Rpb24obWF0Y2gpIHtcbiAgICBpZiAoJyUlJyA9PT0gbWF0Y2gpIHJldHVybjtcbiAgICBpbmRleCsrO1xuICAgIGlmICgnJWMnID09PSBtYXRjaCkge1xuICAgICAgLy8gd2Ugb25seSBhcmUgaW50ZXJlc3RlZCBpbiB0aGUgKmxhc3QqICVjXG4gICAgICAvLyAodGhlIHVzZXIgbWF5IGhhdmUgcHJvdmlkZWQgdGhlaXIgb3duKVxuICAgICAgbGFzdEMgPSBpbmRleDtcbiAgICB9XG4gIH0pO1xuXG4gIGFyZ3Muc3BsaWNlKGxhc3RDLCAwLCBjKTtcbn1cblxuLyoqXG4gKiBJbnZva2VzIGBjb25zb2xlLmxvZygpYCB3aGVuIGF2YWlsYWJsZS5cbiAqIE5vLW9wIHdoZW4gYGNvbnNvbGUubG9nYCBpcyBub3QgYSBcImZ1bmN0aW9uXCIuXG4gKlxuICogQGFwaSBwdWJsaWNcbiAqL1xuXG5mdW5jdGlvbiBsb2coKSB7XG4gIC8vIHRoaXMgaGFja2VyeSBpcyByZXF1aXJlZCBmb3IgSUU4LzksIHdoZXJlXG4gIC8vIHRoZSBgY29uc29sZS5sb2dgIGZ1bmN0aW9uIGRvZXNuJ3QgaGF2ZSAnYXBwbHknXG4gIHJldHVybiAnb2JqZWN0JyA9PT0gdHlwZW9mIGNvbnNvbGVcbiAgICAmJiBjb25zb2xlLmxvZ1xuICAgICYmIEZ1bmN0aW9uLnByb3RvdHlwZS5hcHBseS5jYWxsKGNvbnNvbGUubG9nLCBjb25zb2xlLCBhcmd1bWVudHMpO1xufVxuXG4vKipcbiAqIFNhdmUgYG5hbWVzcGFjZXNgLlxuICpcbiAqIEBwYXJhbSB7U3RyaW5nfSBuYW1lc3BhY2VzXG4gKiBAYXBpIHByaXZhdGVcbiAqL1xuXG5mdW5jdGlvbiBzYXZlKG5hbWVzcGFjZXMpIHtcbiAgdHJ5IHtcbiAgICBpZiAobnVsbCA9PSBuYW1lc3BhY2VzKSB7XG4gICAgICBleHBvcnRzLnN0b3JhZ2UucmVtb3ZlSXRlbSgnZGVidWcnKTtcbiAgICB9IGVsc2Uge1xuICAgICAgZXhwb3J0cy5zdG9yYWdlLmRlYnVnID0gbmFtZXNwYWNlcztcbiAgICB9XG4gIH0gY2F0Y2goZSkge31cbn1cblxuLyoqXG4gKiBMb2FkIGBuYW1lc3BhY2VzYC5cbiAqXG4gKiBAcmV0dXJuIHtTdHJpbmd9IHJldHVybnMgdGhlIHByZXZpb3VzbHkgcGVyc2lzdGVkIGRlYnVnIG1vZGVzXG4gKiBAYXBpIHByaXZhdGVcbiAqL1xuXG5mdW5jdGlvbiBsb2FkKCkge1xuICB2YXIgcjtcbiAgdHJ5IHtcbiAgICByID0gZXhwb3J0cy5zdG9yYWdlLmRlYnVnO1xuICB9IGNhdGNoKGUpIHt9XG5cbiAgLy8gSWYgZGVidWcgaXNuJ3Qgc2V0IGluIExTLCBhbmQgd2UncmUgaW4gRWxlY3Ryb24sIHRyeSB0byBsb2FkICRERUJVR1xuICBpZiAoIXIgJiYgdHlwZW9mIHByb2Nlc3MgIT09ICd1bmRlZmluZWQnICYmICdlbnYnIGluIHByb2Nlc3MpIHtcbiAgICByID0gcHJvY2Vzcy5lbnYuREVCVUc7XG4gIH1cblxuICByZXR1cm4gcjtcbn1cblxuLyoqXG4gKiBFbmFibGUgbmFtZXNwYWNlcyBsaXN0ZWQgaW4gYGxvY2FsU3RvcmFnZS5kZWJ1Z2AgaW5pdGlhbGx5LlxuICovXG5cbmV4cG9ydHMuZW5hYmxlKGxvYWQoKSk7XG5cbi8qKlxuICogTG9jYWxzdG9yYWdlIGF0dGVtcHRzIHRvIHJldHVybiB0aGUgbG9jYWxzdG9yYWdlLlxuICpcbiAqIFRoaXMgaXMgbmVjZXNzYXJ5IGJlY2F1c2Ugc2FmYXJpIHRocm93c1xuICogd2hlbiBhIHVzZXIgZGlzYWJsZXMgY29va2llcy9sb2NhbHN0b3JhZ2VcbiAqIGFuZCB5b3UgYXR0ZW1wdCB0byBhY2Nlc3MgaXQuXG4gKlxuICogQHJldHVybiB7TG9jYWxTdG9yYWdlfVxuICogQGFwaSBwcml2YXRlXG4gKi9cblxuZnVuY3Rpb24gbG9jYWxzdG9yYWdlKCkge1xuICB0cnkge1xuICAgIHJldHVybiB3aW5kb3cubG9jYWxTdG9yYWdlO1xuICB9IGNhdGNoIChlKSB7fVxufVxuIiwiXG4vKipcbiAqIFRoaXMgaXMgdGhlIGNvbW1vbiBsb2dpYyBmb3IgYm90aCB0aGUgTm9kZS5qcyBhbmQgd2ViIGJyb3dzZXJcbiAqIGltcGxlbWVudGF0aW9ucyBvZiBgZGVidWcoKWAuXG4gKlxuICogRXhwb3NlIGBkZWJ1ZygpYCBhcyB0aGUgbW9kdWxlLlxuICovXG5cbmV4cG9ydHMgPSBtb2R1bGUuZXhwb3J0cyA9IGNyZWF0ZURlYnVnLmRlYnVnID0gY3JlYXRlRGVidWdbJ2RlZmF1bHQnXSA9IGNyZWF0ZURlYnVnO1xuZXhwb3J0cy5jb2VyY2UgPSBjb2VyY2U7XG5leHBvcnRzLmRpc2FibGUgPSBkaXNhYmxlO1xuZXhwb3J0cy5lbmFibGUgPSBlbmFibGU7XG5leHBvcnRzLmVuYWJsZWQgPSBlbmFibGVkO1xuZXhwb3J0cy5odW1hbml6ZSA9IHJlcXVpcmUoJ21zJyk7XG5cbi8qKlxuICogQWN0aXZlIGBkZWJ1Z2AgaW5zdGFuY2VzLlxuICovXG5leHBvcnRzLmluc3RhbmNlcyA9IFtdO1xuXG4vKipcbiAqIFRoZSBjdXJyZW50bHkgYWN0aXZlIGRlYnVnIG1vZGUgbmFtZXMsIGFuZCBuYW1lcyB0byBza2lwLlxuICovXG5cbmV4cG9ydHMubmFtZXMgPSBbXTtcbmV4cG9ydHMuc2tpcHMgPSBbXTtcblxuLyoqXG4gKiBNYXAgb2Ygc3BlY2lhbCBcIiVuXCIgaGFuZGxpbmcgZnVuY3Rpb25zLCBmb3IgdGhlIGRlYnVnIFwiZm9ybWF0XCIgYXJndW1lbnQuXG4gKlxuICogVmFsaWQga2V5IG5hbWVzIGFyZSBhIHNpbmdsZSwgbG93ZXIgb3IgdXBwZXItY2FzZSBsZXR0ZXIsIGkuZS4gXCJuXCIgYW5kIFwiTlwiLlxuICovXG5cbmV4cG9ydHMuZm9ybWF0dGVycyA9IHt9O1xuXG4vKipcbiAqIFNlbGVjdCBhIGNvbG9yLlxuICogQHBhcmFtIHtTdHJpbmd9IG5hbWVzcGFjZVxuICogQHJldHVybiB7TnVtYmVyfVxuICogQGFwaSBwcml2YXRlXG4gKi9cblxuZnVuY3Rpb24gc2VsZWN0Q29sb3IobmFtZXNwYWNlKSB7XG4gIHZhciBoYXNoID0gMCwgaTtcblxuICBmb3IgKGkgaW4gbmFtZXNwYWNlKSB7XG4gICAgaGFzaCAgPSAoKGhhc2ggPDwgNSkgLSBoYXNoKSArIG5hbWVzcGFjZS5jaGFyQ29kZUF0KGkpO1xuICAgIGhhc2ggfD0gMDsgLy8gQ29udmVydCB0byAzMmJpdCBpbnRlZ2VyXG4gIH1cblxuICByZXR1cm4gZXhwb3J0cy5jb2xvcnNbTWF0aC5hYnMoaGFzaCkgJSBleHBvcnRzLmNvbG9ycy5sZW5ndGhdO1xufVxuXG4vKipcbiAqIENyZWF0ZSBhIGRlYnVnZ2VyIHdpdGggdGhlIGdpdmVuIGBuYW1lc3BhY2VgLlxuICpcbiAqIEBwYXJhbSB7U3RyaW5nfSBuYW1lc3BhY2VcbiAqIEByZXR1cm4ge0Z1bmN0aW9ufVxuICogQGFwaSBwdWJsaWNcbiAqL1xuXG5mdW5jdGlvbiBjcmVhdGVEZWJ1ZyhuYW1lc3BhY2UpIHtcblxuICB2YXIgcHJldlRpbWU7XG5cbiAgZnVuY3Rpb24gZGVidWcoKSB7XG4gICAgLy8gZGlzYWJsZWQ/XG4gICAgaWYgKCFkZWJ1Zy5lbmFibGVkKSByZXR1cm47XG5cbiAgICB2YXIgc2VsZiA9IGRlYnVnO1xuXG4gICAgLy8gc2V0IGBkaWZmYCB0aW1lc3RhbXBcbiAgICB2YXIgY3VyciA9ICtuZXcgRGF0ZSgpO1xuICAgIHZhciBtcyA9IGN1cnIgLSAocHJldlRpbWUgfHwgY3Vycik7XG4gICAgc2VsZi5kaWZmID0gbXM7XG4gICAgc2VsZi5wcmV2ID0gcHJldlRpbWU7XG4gICAgc2VsZi5jdXJyID0gY3VycjtcbiAgICBwcmV2VGltZSA9IGN1cnI7XG5cbiAgICAvLyB0dXJuIHRoZSBgYXJndW1lbnRzYCBpbnRvIGEgcHJvcGVyIEFycmF5XG4gICAgdmFyIGFyZ3MgPSBuZXcgQXJyYXkoYXJndW1lbnRzLmxlbmd0aCk7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBhcmdzLmxlbmd0aDsgaSsrKSB7XG4gICAgICBhcmdzW2ldID0gYXJndW1lbnRzW2ldO1xuICAgIH1cblxuICAgIGFyZ3NbMF0gPSBleHBvcnRzLmNvZXJjZShhcmdzWzBdKTtcblxuICAgIGlmICgnc3RyaW5nJyAhPT0gdHlwZW9mIGFyZ3NbMF0pIHtcbiAgICAgIC8vIGFueXRoaW5nIGVsc2UgbGV0J3MgaW5zcGVjdCB3aXRoICVPXG4gICAgICBhcmdzLnVuc2hpZnQoJyVPJyk7XG4gICAgfVxuXG4gICAgLy8gYXBwbHkgYW55IGBmb3JtYXR0ZXJzYCB0cmFuc2Zvcm1hdGlvbnNcbiAgICB2YXIgaW5kZXggPSAwO1xuICAgIGFyZ3NbMF0gPSBhcmdzWzBdLnJlcGxhY2UoLyUoW2EtekEtWiVdKS9nLCBmdW5jdGlvbihtYXRjaCwgZm9ybWF0KSB7XG4gICAgICAvLyBpZiB3ZSBlbmNvdW50ZXIgYW4gZXNjYXBlZCAlIHRoZW4gZG9uJ3QgaW5jcmVhc2UgdGhlIGFycmF5IGluZGV4XG4gICAgICBpZiAobWF0Y2ggPT09ICclJScpIHJldHVybiBtYXRjaDtcbiAgICAgIGluZGV4Kys7XG4gICAgICB2YXIgZm9ybWF0dGVyID0gZXhwb3J0cy5mb3JtYXR0ZXJzW2Zvcm1hdF07XG4gICAgICBpZiAoJ2Z1bmN0aW9uJyA9PT0gdHlwZW9mIGZvcm1hdHRlcikge1xuICAgICAgICB2YXIgdmFsID0gYXJnc1tpbmRleF07XG4gICAgICAgIG1hdGNoID0gZm9ybWF0dGVyLmNhbGwoc2VsZiwgdmFsKTtcblxuICAgICAgICAvLyBub3cgd2UgbmVlZCB0byByZW1vdmUgYGFyZ3NbaW5kZXhdYCBzaW5jZSBpdCdzIGlubGluZWQgaW4gdGhlIGBmb3JtYXRgXG4gICAgICAgIGFyZ3Muc3BsaWNlKGluZGV4LCAxKTtcbiAgICAgICAgaW5kZXgtLTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBtYXRjaDtcbiAgICB9KTtcblxuICAgIC8vIGFwcGx5IGVudi1zcGVjaWZpYyBmb3JtYXR0aW5nIChjb2xvcnMsIGV0Yy4pXG4gICAgZXhwb3J0cy5mb3JtYXRBcmdzLmNhbGwoc2VsZiwgYXJncyk7XG5cbiAgICB2YXIgbG9nRm4gPSBkZWJ1Zy5sb2cgfHwgZXhwb3J0cy5sb2cgfHwgY29uc29sZS5sb2cuYmluZChjb25zb2xlKTtcbiAgICBsb2dGbi5hcHBseShzZWxmLCBhcmdzKTtcbiAgfVxuXG4gIGRlYnVnLm5hbWVzcGFjZSA9IG5hbWVzcGFjZTtcbiAgZGVidWcuZW5hYmxlZCA9IGV4cG9ydHMuZW5hYmxlZChuYW1lc3BhY2UpO1xuICBkZWJ1Zy51c2VDb2xvcnMgPSBleHBvcnRzLnVzZUNvbG9ycygpO1xuICBkZWJ1Zy5jb2xvciA9IHNlbGVjdENvbG9yKG5hbWVzcGFjZSk7XG4gIGRlYnVnLmRlc3Ryb3kgPSBkZXN0cm95O1xuXG4gIC8vIGVudi1zcGVjaWZpYyBpbml0aWFsaXphdGlvbiBsb2dpYyBmb3IgZGVidWcgaW5zdGFuY2VzXG4gIGlmICgnZnVuY3Rpb24nID09PSB0eXBlb2YgZXhwb3J0cy5pbml0KSB7XG4gICAgZXhwb3J0cy5pbml0KGRlYnVnKTtcbiAgfVxuXG4gIGV4cG9ydHMuaW5zdGFuY2VzLnB1c2goZGVidWcpO1xuXG4gIHJldHVybiBkZWJ1Zztcbn1cblxuZnVuY3Rpb24gZGVzdHJveSAoKSB7XG4gIHZhciBpbmRleCA9IGV4cG9ydHMuaW5zdGFuY2VzLmluZGV4T2YodGhpcyk7XG4gIGlmIChpbmRleCAhPT0gLTEpIHtcbiAgICBleHBvcnRzLmluc3RhbmNlcy5zcGxpY2UoaW5kZXgsIDEpO1xuICAgIHJldHVybiB0cnVlO1xuICB9IGVsc2Uge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxufVxuXG4vKipcbiAqIEVuYWJsZXMgYSBkZWJ1ZyBtb2RlIGJ5IG5hbWVzcGFjZXMuIFRoaXMgY2FuIGluY2x1ZGUgbW9kZXNcbiAqIHNlcGFyYXRlZCBieSBhIGNvbG9uIGFuZCB3aWxkY2FyZHMuXG4gKlxuICogQHBhcmFtIHtTdHJpbmd9IG5hbWVzcGFjZXNcbiAqIEBhcGkgcHVibGljXG4gKi9cblxuZnVuY3Rpb24gZW5hYmxlKG5hbWVzcGFjZXMpIHtcbiAgZXhwb3J0cy5zYXZlKG5hbWVzcGFjZXMpO1xuXG4gIGV4cG9ydHMubmFtZXMgPSBbXTtcbiAgZXhwb3J0cy5za2lwcyA9IFtdO1xuXG4gIHZhciBpO1xuICB2YXIgc3BsaXQgPSAodHlwZW9mIG5hbWVzcGFjZXMgPT09ICdzdHJpbmcnID8gbmFtZXNwYWNlcyA6ICcnKS5zcGxpdCgvW1xccyxdKy8pO1xuICB2YXIgbGVuID0gc3BsaXQubGVuZ3RoO1xuXG4gIGZvciAoaSA9IDA7IGkgPCBsZW47IGkrKykge1xuICAgIGlmICghc3BsaXRbaV0pIGNvbnRpbnVlOyAvLyBpZ25vcmUgZW1wdHkgc3RyaW5nc1xuICAgIG5hbWVzcGFjZXMgPSBzcGxpdFtpXS5yZXBsYWNlKC9cXCovZywgJy4qPycpO1xuICAgIGlmIChuYW1lc3BhY2VzWzBdID09PSAnLScpIHtcbiAgICAgIGV4cG9ydHMuc2tpcHMucHVzaChuZXcgUmVnRXhwKCdeJyArIG5hbWVzcGFjZXMuc3Vic3RyKDEpICsgJyQnKSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGV4cG9ydHMubmFtZXMucHVzaChuZXcgUmVnRXhwKCdeJyArIG5hbWVzcGFjZXMgKyAnJCcpKTtcbiAgICB9XG4gIH1cblxuICBmb3IgKGkgPSAwOyBpIDwgZXhwb3J0cy5pbnN0YW5jZXMubGVuZ3RoOyBpKyspIHtcbiAgICB2YXIgaW5zdGFuY2UgPSBleHBvcnRzLmluc3RhbmNlc1tpXTtcbiAgICBpbnN0YW5jZS5lbmFibGVkID0gZXhwb3J0cy5lbmFibGVkKGluc3RhbmNlLm5hbWVzcGFjZSk7XG4gIH1cbn1cblxuLyoqXG4gKiBEaXNhYmxlIGRlYnVnIG91dHB1dC5cbiAqXG4gKiBAYXBpIHB1YmxpY1xuICovXG5cbmZ1bmN0aW9uIGRpc2FibGUoKSB7XG4gIGV4cG9ydHMuZW5hYmxlKCcnKTtcbn1cblxuLyoqXG4gKiBSZXR1cm5zIHRydWUgaWYgdGhlIGdpdmVuIG1vZGUgbmFtZSBpcyBlbmFibGVkLCBmYWxzZSBvdGhlcndpc2UuXG4gKlxuICogQHBhcmFtIHtTdHJpbmd9IG5hbWVcbiAqIEByZXR1cm4ge0Jvb2xlYW59XG4gKiBAYXBpIHB1YmxpY1xuICovXG5cbmZ1bmN0aW9uIGVuYWJsZWQobmFtZSkge1xuICBpZiAobmFtZVtuYW1lLmxlbmd0aCAtIDFdID09PSAnKicpIHtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuICB2YXIgaSwgbGVuO1xuICBmb3IgKGkgPSAwLCBsZW4gPSBleHBvcnRzLnNraXBzLmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgaWYgKGV4cG9ydHMuc2tpcHNbaV0udGVzdChuYW1lKSkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgfVxuICBmb3IgKGkgPSAwLCBsZW4gPSBleHBvcnRzLm5hbWVzLmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgaWYgKGV4cG9ydHMubmFtZXNbaV0udGVzdChuYW1lKSkge1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICB9XG4gIHJldHVybiBmYWxzZTtcbn1cblxuLyoqXG4gKiBDb2VyY2UgYHZhbGAuXG4gKlxuICogQHBhcmFtIHtNaXhlZH0gdmFsXG4gKiBAcmV0dXJuIHtNaXhlZH1cbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5cbmZ1bmN0aW9uIGNvZXJjZSh2YWwpIHtcbiAgaWYgKHZhbCBpbnN0YW5jZW9mIEVycm9yKSByZXR1cm4gdmFsLnN0YWNrIHx8IHZhbC5tZXNzYWdlO1xuICByZXR1cm4gdmFsO1xufVxuIiwiLyohXG4gICogZG9tcmVhZHkgKGMpIER1c3RpbiBEaWF6IDIwMTQgLSBMaWNlbnNlIE1JVFxuICAqL1xuIWZ1bmN0aW9uIChuYW1lLCBkZWZpbml0aW9uKSB7XG5cbiAgaWYgKHR5cGVvZiBtb2R1bGUgIT0gJ3VuZGVmaW5lZCcpIG1vZHVsZS5leHBvcnRzID0gZGVmaW5pdGlvbigpXG4gIGVsc2UgaWYgKHR5cGVvZiBkZWZpbmUgPT0gJ2Z1bmN0aW9uJyAmJiB0eXBlb2YgZGVmaW5lLmFtZCA9PSAnb2JqZWN0JykgZGVmaW5lKGRlZmluaXRpb24pXG4gIGVsc2UgdGhpc1tuYW1lXSA9IGRlZmluaXRpb24oKVxuXG59KCdkb21yZWFkeScsIGZ1bmN0aW9uICgpIHtcblxuICB2YXIgZm5zID0gW10sIGxpc3RlbmVyXG4gICAgLCBkb2MgPSBkb2N1bWVudFxuICAgICwgaGFjayA9IGRvYy5kb2N1bWVudEVsZW1lbnQuZG9TY3JvbGxcbiAgICAsIGRvbUNvbnRlbnRMb2FkZWQgPSAnRE9NQ29udGVudExvYWRlZCdcbiAgICAsIGxvYWRlZCA9IChoYWNrID8gL15sb2FkZWR8XmMvIDogL15sb2FkZWR8Xml8XmMvKS50ZXN0KGRvYy5yZWFkeVN0YXRlKVxuXG5cbiAgaWYgKCFsb2FkZWQpXG4gIGRvYy5hZGRFdmVudExpc3RlbmVyKGRvbUNvbnRlbnRMb2FkZWQsIGxpc3RlbmVyID0gZnVuY3Rpb24gKCkge1xuICAgIGRvYy5yZW1vdmVFdmVudExpc3RlbmVyKGRvbUNvbnRlbnRMb2FkZWQsIGxpc3RlbmVyKVxuICAgIGxvYWRlZCA9IDFcbiAgICB3aGlsZSAobGlzdGVuZXIgPSBmbnMuc2hpZnQoKSkgbGlzdGVuZXIoKVxuICB9KVxuXG4gIHJldHVybiBmdW5jdGlvbiAoZm4pIHtcbiAgICBsb2FkZWQgPyBzZXRUaW1lb3V0KGZuLCAwKSA6IGZucy5wdXNoKGZuKVxuICB9XG5cbn0pO1xuIiwidmFyIFdpbGRFbWl0dGVyID0gcmVxdWlyZSgnd2lsZGVtaXR0ZXInKTtcblxuZnVuY3Rpb24gZ2V0TWF4Vm9sdW1lIChhbmFseXNlciwgZmZ0Qmlucykge1xuICB2YXIgbWF4Vm9sdW1lID0gLUluZmluaXR5O1xuICBhbmFseXNlci5nZXRGbG9hdEZyZXF1ZW5jeURhdGEoZmZ0Qmlucyk7XG5cbiAgZm9yKHZhciBpPTQsIGlpPWZmdEJpbnMubGVuZ3RoOyBpIDwgaWk7IGkrKykge1xuICAgIGlmIChmZnRCaW5zW2ldID4gbWF4Vm9sdW1lICYmIGZmdEJpbnNbaV0gPCAwKSB7XG4gICAgICBtYXhWb2x1bWUgPSBmZnRCaW5zW2ldO1xuICAgIH1cbiAgfTtcblxuICByZXR1cm4gbWF4Vm9sdW1lO1xufVxuXG5cbnZhciBhdWRpb0NvbnRleHRUeXBlO1xuaWYgKHR5cGVvZiB3aW5kb3cgIT09ICd1bmRlZmluZWQnKSB7XG4gIGF1ZGlvQ29udGV4dFR5cGUgPSB3aW5kb3cuQXVkaW9Db250ZXh0IHx8IHdpbmRvdy53ZWJraXRBdWRpb0NvbnRleHQ7XG59XG4vLyB1c2UgYSBzaW5nbGUgYXVkaW8gY29udGV4dCBkdWUgdG8gaGFyZHdhcmUgbGltaXRzXG52YXIgYXVkaW9Db250ZXh0ID0gbnVsbDtcbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24oc3RyZWFtLCBvcHRpb25zKSB7XG4gIHZhciBoYXJrZXIgPSBuZXcgV2lsZEVtaXR0ZXIoKTtcblxuICAvLyBtYWtlIGl0IG5vdCBicmVhayBpbiBub24tc3VwcG9ydGVkIGJyb3dzZXJzXG4gIGlmICghYXVkaW9Db250ZXh0VHlwZSkgcmV0dXJuIGhhcmtlcjtcblxuICAvL0NvbmZpZ1xuICB2YXIgb3B0aW9ucyA9IG9wdGlvbnMgfHwge30sXG4gICAgICBzbW9vdGhpbmcgPSAob3B0aW9ucy5zbW9vdGhpbmcgfHwgMC4xKSxcbiAgICAgIGludGVydmFsID0gKG9wdGlvbnMuaW50ZXJ2YWwgfHwgNTApLFxuICAgICAgdGhyZXNob2xkID0gb3B0aW9ucy50aHJlc2hvbGQsXG4gICAgICBwbGF5ID0gb3B0aW9ucy5wbGF5LFxuICAgICAgaGlzdG9yeSA9IG9wdGlvbnMuaGlzdG9yeSB8fCAxMCxcbiAgICAgIHJ1bm5pbmcgPSB0cnVlO1xuXG4gIC8vIEVuc3VyZSB0aGF0IGp1c3QgYSBzaW5nbGUgQXVkaW9Db250ZXh0IGlzIGludGVybmFsbHkgY3JlYXRlZFxuICBhdWRpb0NvbnRleHQgPSBvcHRpb25zLmF1ZGlvQ29udGV4dCB8fCBhdWRpb0NvbnRleHQgfHwgbmV3IGF1ZGlvQ29udGV4dFR5cGUoKTtcblxuICB2YXIgc291cmNlTm9kZSwgZmZ0QmlucywgYW5hbHlzZXI7XG5cbiAgYW5hbHlzZXIgPSBhdWRpb0NvbnRleHQuY3JlYXRlQW5hbHlzZXIoKTtcbiAgYW5hbHlzZXIuZmZ0U2l6ZSA9IDUxMjtcbiAgYW5hbHlzZXIuc21vb3RoaW5nVGltZUNvbnN0YW50ID0gc21vb3RoaW5nO1xuICBmZnRCaW5zID0gbmV3IEZsb2F0MzJBcnJheShhbmFseXNlci5mcmVxdWVuY3lCaW5Db3VudCk7XG5cbiAgaWYgKHN0cmVhbS5qcXVlcnkpIHN0cmVhbSA9IHN0cmVhbVswXTtcbiAgaWYgKHN0cmVhbSBpbnN0YW5jZW9mIEhUTUxBdWRpb0VsZW1lbnQgfHwgc3RyZWFtIGluc3RhbmNlb2YgSFRNTFZpZGVvRWxlbWVudCkge1xuICAgIC8vQXVkaW8gVGFnXG4gICAgc291cmNlTm9kZSA9IGF1ZGlvQ29udGV4dC5jcmVhdGVNZWRpYUVsZW1lbnRTb3VyY2Uoc3RyZWFtKTtcbiAgICBpZiAodHlwZW9mIHBsYXkgPT09ICd1bmRlZmluZWQnKSBwbGF5ID0gdHJ1ZTtcbiAgICB0aHJlc2hvbGQgPSB0aHJlc2hvbGQgfHwgLTUwO1xuICB9IGVsc2Uge1xuICAgIC8vV2ViUlRDIFN0cmVhbVxuICAgIHNvdXJjZU5vZGUgPSBhdWRpb0NvbnRleHQuY3JlYXRlTWVkaWFTdHJlYW1Tb3VyY2Uoc3RyZWFtKTtcbiAgICB0aHJlc2hvbGQgPSB0aHJlc2hvbGQgfHwgLTUwO1xuICB9XG5cbiAgc291cmNlTm9kZS5jb25uZWN0KGFuYWx5c2VyKTtcbiAgaWYgKHBsYXkpIGFuYWx5c2VyLmNvbm5lY3QoYXVkaW9Db250ZXh0LmRlc3RpbmF0aW9uKTtcblxuICBoYXJrZXIuc3BlYWtpbmcgPSBmYWxzZTtcblxuICBoYXJrZXIuc3VzcGVuZCA9IGZ1bmN0aW9uKCkge1xuICAgIHJldHVybiBhdWRpb0NvbnRleHQuc3VzcGVuZCgpO1xuICB9XG4gIGhhcmtlci5yZXN1bWUgPSBmdW5jdGlvbigpIHtcbiAgICByZXR1cm4gYXVkaW9Db250ZXh0LnJlc3VtZSgpO1xuICB9XG4gIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShoYXJrZXIsICdzdGF0ZScsIHsgZ2V0OiBmdW5jdGlvbigpIHtcbiAgICByZXR1cm4gYXVkaW9Db250ZXh0LnN0YXRlO1xuICB9fSk7XG4gIGF1ZGlvQ29udGV4dC5vbnN0YXRlY2hhbmdlID0gZnVuY3Rpb24oKSB7XG4gICAgaGFya2VyLmVtaXQoJ3N0YXRlX2NoYW5nZScsIGF1ZGlvQ29udGV4dC5zdGF0ZSk7XG4gIH1cblxuICBoYXJrZXIuc2V0VGhyZXNob2xkID0gZnVuY3Rpb24odCkge1xuICAgIHRocmVzaG9sZCA9IHQ7XG4gIH07XG5cbiAgaGFya2VyLnNldEludGVydmFsID0gZnVuY3Rpb24oaSkge1xuICAgIGludGVydmFsID0gaTtcbiAgfTtcblxuICBoYXJrZXIuc3RvcCA9IGZ1bmN0aW9uKCkge1xuICAgIHJ1bm5pbmcgPSBmYWxzZTtcbiAgICBoYXJrZXIuZW1pdCgndm9sdW1lX2NoYW5nZScsIC0xMDAsIHRocmVzaG9sZCk7XG4gICAgaWYgKGhhcmtlci5zcGVha2luZykge1xuICAgICAgaGFya2VyLnNwZWFraW5nID0gZmFsc2U7XG4gICAgICBoYXJrZXIuZW1pdCgnc3RvcHBlZF9zcGVha2luZycpO1xuICAgIH1cbiAgICBhbmFseXNlci5kaXNjb25uZWN0KCk7XG4gICAgc291cmNlTm9kZS5kaXNjb25uZWN0KCk7XG4gIH07XG4gIGhhcmtlci5zcGVha2luZ0hpc3RvcnkgPSBbXTtcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBoaXN0b3J5OyBpKyspIHtcbiAgICAgIGhhcmtlci5zcGVha2luZ0hpc3RvcnkucHVzaCgwKTtcbiAgfVxuXG4gIC8vIFBvbGwgdGhlIGFuYWx5c2VyIG5vZGUgdG8gZGV0ZXJtaW5lIGlmIHNwZWFraW5nXG4gIC8vIGFuZCBlbWl0IGV2ZW50cyBpZiBjaGFuZ2VkXG4gIHZhciBsb29wZXIgPSBmdW5jdGlvbigpIHtcbiAgICBzZXRUaW1lb3V0KGZ1bmN0aW9uKCkge1xuXG4gICAgICAvL2NoZWNrIGlmIHN0b3AgaGFzIGJlZW4gY2FsbGVkXG4gICAgICBpZighcnVubmluZykge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICAgIHZhciBjdXJyZW50Vm9sdW1lID0gZ2V0TWF4Vm9sdW1lKGFuYWx5c2VyLCBmZnRCaW5zKTtcblxuICAgICAgaGFya2VyLmVtaXQoJ3ZvbHVtZV9jaGFuZ2UnLCBjdXJyZW50Vm9sdW1lLCB0aHJlc2hvbGQpO1xuXG4gICAgICB2YXIgaGlzdG9yeSA9IDA7XG4gICAgICBpZiAoY3VycmVudFZvbHVtZSA+IHRocmVzaG9sZCAmJiAhaGFya2VyLnNwZWFraW5nKSB7XG4gICAgICAgIC8vIHRyaWdnZXIgcXVpY2tseSwgc2hvcnQgaGlzdG9yeVxuICAgICAgICBmb3IgKHZhciBpID0gaGFya2VyLnNwZWFraW5nSGlzdG9yeS5sZW5ndGggLSAzOyBpIDwgaGFya2VyLnNwZWFraW5nSGlzdG9yeS5sZW5ndGg7IGkrKykge1xuICAgICAgICAgIGhpc3RvcnkgKz0gaGFya2VyLnNwZWFraW5nSGlzdG9yeVtpXTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoaGlzdG9yeSA+PSAyKSB7XG4gICAgICAgICAgaGFya2VyLnNwZWFraW5nID0gdHJ1ZTtcbiAgICAgICAgICBoYXJrZXIuZW1pdCgnc3BlYWtpbmcnKTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIGlmIChjdXJyZW50Vm9sdW1lIDwgdGhyZXNob2xkICYmIGhhcmtlci5zcGVha2luZykge1xuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGhhcmtlci5zcGVha2luZ0hpc3RvcnkubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICBoaXN0b3J5ICs9IGhhcmtlci5zcGVha2luZ0hpc3RvcnlbaV07XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGhpc3RvcnkgPT0gMCkge1xuICAgICAgICAgIGhhcmtlci5zcGVha2luZyA9IGZhbHNlO1xuICAgICAgICAgIGhhcmtlci5lbWl0KCdzdG9wcGVkX3NwZWFraW5nJyk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGhhcmtlci5zcGVha2luZ0hpc3Rvcnkuc2hpZnQoKTtcbiAgICAgIGhhcmtlci5zcGVha2luZ0hpc3RvcnkucHVzaCgwICsgKGN1cnJlbnRWb2x1bWUgPiB0aHJlc2hvbGQpKTtcblxuICAgICAgbG9vcGVyKCk7XG4gICAgfSwgaW50ZXJ2YWwpO1xuICB9O1xuICBsb29wZXIoKTtcblxuICByZXR1cm4gaGFya2VyO1xufVxuIiwidmFyIHN1cHBvcnQgPSByZXF1aXJlKCd3ZWJydGNzdXBwb3J0Jyk7XG5cblxuZnVuY3Rpb24gR2FpbkNvbnRyb2xsZXIoc3RyZWFtKSB7XG4gICAgdGhpcy5zdXBwb3J0ID0gc3VwcG9ydC53ZWJBdWRpbyAmJiBzdXBwb3J0Lm1lZGlhU3RyZWFtO1xuXG4gICAgLy8gc2V0IG91ciBzdGFydGluZyB2YWx1ZVxuICAgIHRoaXMuZ2FpbiA9IDE7XG5cbiAgICBpZiAodGhpcy5zdXBwb3J0KSB7XG4gICAgICAgIHZhciBjb250ZXh0ID0gdGhpcy5jb250ZXh0ID0gbmV3IHN1cHBvcnQuQXVkaW9Db250ZXh0KCk7XG4gICAgICAgIHRoaXMubWljcm9waG9uZSA9IGNvbnRleHQuY3JlYXRlTWVkaWFTdHJlYW1Tb3VyY2Uoc3RyZWFtKTtcbiAgICAgICAgdGhpcy5nYWluRmlsdGVyID0gY29udGV4dC5jcmVhdGVHYWluKCk7XG4gICAgICAgIHRoaXMuZGVzdGluYXRpb24gPSBjb250ZXh0LmNyZWF0ZU1lZGlhU3RyZWFtRGVzdGluYXRpb24oKTtcbiAgICAgICAgdGhpcy5vdXRwdXRTdHJlYW0gPSB0aGlzLmRlc3RpbmF0aW9uLnN0cmVhbTtcbiAgICAgICAgdGhpcy5taWNyb3Bob25lLmNvbm5lY3QodGhpcy5nYWluRmlsdGVyKTtcbiAgICAgICAgdGhpcy5nYWluRmlsdGVyLmNvbm5lY3QodGhpcy5kZXN0aW5hdGlvbik7XG4gICAgICAgIHN0cmVhbS5hZGRUcmFjayh0aGlzLm91dHB1dFN0cmVhbS5nZXRBdWRpb1RyYWNrcygpWzBdKTtcbiAgICAgICAgc3RyZWFtLnJlbW92ZVRyYWNrKHN0cmVhbS5nZXRBdWRpb1RyYWNrcygpWzBdKTtcbiAgICB9XG4gICAgdGhpcy5zdHJlYW0gPSBzdHJlYW07XG59XG5cbi8vIHNldHRpbmdcbkdhaW5Db250cm9sbGVyLnByb3RvdHlwZS5zZXRHYWluID0gZnVuY3Rpb24gKHZhbCkge1xuICAgIC8vIGNoZWNrIGZvciBzdXBwb3J0XG4gICAgaWYgKCF0aGlzLnN1cHBvcnQpIHJldHVybjtcbiAgICB0aGlzLmdhaW5GaWx0ZXIuZ2Fpbi52YWx1ZSA9IHZhbDtcbiAgICB0aGlzLmdhaW4gPSB2YWw7XG59O1xuXG5HYWluQ29udHJvbGxlci5wcm90b3R5cGUuZ2V0R2FpbiA9IGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gdGhpcy5nYWluO1xufTtcblxuR2FpbkNvbnRyb2xsZXIucHJvdG90eXBlLm9mZiA9IGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gdGhpcy5zZXRHYWluKDApO1xufTtcblxuR2FpbkNvbnRyb2xsZXIucHJvdG90eXBlLm9uID0gZnVuY3Rpb24gKCkge1xuICAgIHRoaXMuc2V0R2FpbigxKTtcbn07XG5cblxubW9kdWxlLmV4cG9ydHMgPSBHYWluQ29udHJvbGxlcjtcbiIsIi8qKlxuICogSGVscGVycy5cbiAqL1xuXG52YXIgcyA9IDEwMDA7XG52YXIgbSA9IHMgKiA2MDtcbnZhciBoID0gbSAqIDYwO1xudmFyIGQgPSBoICogMjQ7XG52YXIgeSA9IGQgKiAzNjUuMjU7XG5cbi8qKlxuICogUGFyc2Ugb3IgZm9ybWF0IHRoZSBnaXZlbiBgdmFsYC5cbiAqXG4gKiBPcHRpb25zOlxuICpcbiAqICAtIGBsb25nYCB2ZXJib3NlIGZvcm1hdHRpbmcgW2ZhbHNlXVxuICpcbiAqIEBwYXJhbSB7U3RyaW5nfE51bWJlcn0gdmFsXG4gKiBAcGFyYW0ge09iamVjdH0gW29wdGlvbnNdXG4gKiBAdGhyb3dzIHtFcnJvcn0gdGhyb3cgYW4gZXJyb3IgaWYgdmFsIGlzIG5vdCBhIG5vbi1lbXB0eSBzdHJpbmcgb3IgYSBudW1iZXJcbiAqIEByZXR1cm4ge1N0cmluZ3xOdW1iZXJ9XG4gKiBAYXBpIHB1YmxpY1xuICovXG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24odmFsLCBvcHRpb25zKSB7XG4gIG9wdGlvbnMgPSBvcHRpb25zIHx8IHt9O1xuICB2YXIgdHlwZSA9IHR5cGVvZiB2YWw7XG4gIGlmICh0eXBlID09PSAnc3RyaW5nJyAmJiB2YWwubGVuZ3RoID4gMCkge1xuICAgIHJldHVybiBwYXJzZSh2YWwpO1xuICB9IGVsc2UgaWYgKHR5cGUgPT09ICdudW1iZXInICYmIGlzTmFOKHZhbCkgPT09IGZhbHNlKSB7XG4gICAgcmV0dXJuIG9wdGlvbnMubG9uZyA/IGZtdExvbmcodmFsKSA6IGZtdFNob3J0KHZhbCk7XG4gIH1cbiAgdGhyb3cgbmV3IEVycm9yKFxuICAgICd2YWwgaXMgbm90IGEgbm9uLWVtcHR5IHN0cmluZyBvciBhIHZhbGlkIG51bWJlci4gdmFsPScgK1xuICAgICAgSlNPTi5zdHJpbmdpZnkodmFsKVxuICApO1xufTtcblxuLyoqXG4gKiBQYXJzZSB0aGUgZ2l2ZW4gYHN0cmAgYW5kIHJldHVybiBtaWxsaXNlY29uZHMuXG4gKlxuICogQHBhcmFtIHtTdHJpbmd9IHN0clxuICogQHJldHVybiB7TnVtYmVyfVxuICogQGFwaSBwcml2YXRlXG4gKi9cblxuZnVuY3Rpb24gcGFyc2Uoc3RyKSB7XG4gIHN0ciA9IFN0cmluZyhzdHIpO1xuICBpZiAoc3RyLmxlbmd0aCA+IDEwMCkge1xuICAgIHJldHVybjtcbiAgfVxuICB2YXIgbWF0Y2ggPSAvXigoPzpcXGQrKT9cXC4/XFxkKykgKihtaWxsaXNlY29uZHM/fG1zZWNzP3xtc3xzZWNvbmRzP3xzZWNzP3xzfG1pbnV0ZXM/fG1pbnM/fG18aG91cnM/fGhycz98aHxkYXlzP3xkfHllYXJzP3x5cnM/fHkpPyQvaS5leGVjKFxuICAgIHN0clxuICApO1xuICBpZiAoIW1hdGNoKSB7XG4gICAgcmV0dXJuO1xuICB9XG4gIHZhciBuID0gcGFyc2VGbG9hdChtYXRjaFsxXSk7XG4gIHZhciB0eXBlID0gKG1hdGNoWzJdIHx8ICdtcycpLnRvTG93ZXJDYXNlKCk7XG4gIHN3aXRjaCAodHlwZSkge1xuICAgIGNhc2UgJ3llYXJzJzpcbiAgICBjYXNlICd5ZWFyJzpcbiAgICBjYXNlICd5cnMnOlxuICAgIGNhc2UgJ3lyJzpcbiAgICBjYXNlICd5JzpcbiAgICAgIHJldHVybiBuICogeTtcbiAgICBjYXNlICdkYXlzJzpcbiAgICBjYXNlICdkYXknOlxuICAgIGNhc2UgJ2QnOlxuICAgICAgcmV0dXJuIG4gKiBkO1xuICAgIGNhc2UgJ2hvdXJzJzpcbiAgICBjYXNlICdob3VyJzpcbiAgICBjYXNlICdocnMnOlxuICAgIGNhc2UgJ2hyJzpcbiAgICBjYXNlICdoJzpcbiAgICAgIHJldHVybiBuICogaDtcbiAgICBjYXNlICdtaW51dGVzJzpcbiAgICBjYXNlICdtaW51dGUnOlxuICAgIGNhc2UgJ21pbnMnOlxuICAgIGNhc2UgJ21pbic6XG4gICAgY2FzZSAnbSc6XG4gICAgICByZXR1cm4gbiAqIG07XG4gICAgY2FzZSAnc2Vjb25kcyc6XG4gICAgY2FzZSAnc2Vjb25kJzpcbiAgICBjYXNlICdzZWNzJzpcbiAgICBjYXNlICdzZWMnOlxuICAgIGNhc2UgJ3MnOlxuICAgICAgcmV0dXJuIG4gKiBzO1xuICAgIGNhc2UgJ21pbGxpc2Vjb25kcyc6XG4gICAgY2FzZSAnbWlsbGlzZWNvbmQnOlxuICAgIGNhc2UgJ21zZWNzJzpcbiAgICBjYXNlICdtc2VjJzpcbiAgICBjYXNlICdtcyc6XG4gICAgICByZXR1cm4gbjtcbiAgICBkZWZhdWx0OlxuICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgfVxufVxuXG4vKipcbiAqIFNob3J0IGZvcm1hdCBmb3IgYG1zYC5cbiAqXG4gKiBAcGFyYW0ge051bWJlcn0gbXNcbiAqIEByZXR1cm4ge1N0cmluZ31cbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5cbmZ1bmN0aW9uIGZtdFNob3J0KG1zKSB7XG4gIGlmIChtcyA+PSBkKSB7XG4gICAgcmV0dXJuIE1hdGgucm91bmQobXMgLyBkKSArICdkJztcbiAgfVxuICBpZiAobXMgPj0gaCkge1xuICAgIHJldHVybiBNYXRoLnJvdW5kKG1zIC8gaCkgKyAnaCc7XG4gIH1cbiAgaWYgKG1zID49IG0pIHtcbiAgICByZXR1cm4gTWF0aC5yb3VuZChtcyAvIG0pICsgJ20nO1xuICB9XG4gIGlmIChtcyA+PSBzKSB7XG4gICAgcmV0dXJuIE1hdGgucm91bmQobXMgLyBzKSArICdzJztcbiAgfVxuICByZXR1cm4gbXMgKyAnbXMnO1xufVxuXG4vKipcbiAqIExvbmcgZm9ybWF0IGZvciBgbXNgLlxuICpcbiAqIEBwYXJhbSB7TnVtYmVyfSBtc1xuICogQHJldHVybiB7U3RyaW5nfVxuICogQGFwaSBwcml2YXRlXG4gKi9cblxuZnVuY3Rpb24gZm10TG9uZyhtcykge1xuICByZXR1cm4gcGx1cmFsKG1zLCBkLCAnZGF5JykgfHxcbiAgICBwbHVyYWwobXMsIGgsICdob3VyJykgfHxcbiAgICBwbHVyYWwobXMsIG0sICdtaW51dGUnKSB8fFxuICAgIHBsdXJhbChtcywgcywgJ3NlY29uZCcpIHx8XG4gICAgbXMgKyAnIG1zJztcbn1cblxuLyoqXG4gKiBQbHVyYWxpemF0aW9uIGhlbHBlci5cbiAqL1xuXG5mdW5jdGlvbiBwbHVyYWwobXMsIG4sIG5hbWUpIHtcbiAgaWYgKG1zIDwgbikge1xuICAgIHJldHVybjtcbiAgfVxuICBpZiAobXMgPCBuICogMS41KSB7XG4gICAgcmV0dXJuIE1hdGguZmxvb3IobXMgLyBuKSArICcgJyArIG5hbWU7XG4gIH1cbiAgcmV0dXJuIE1hdGguY2VpbChtcyAvIG4pICsgJyAnICsgbmFtZSArICdzJztcbn1cbiIsIi8vIHNoaW0gZm9yIHVzaW5nIHByb2Nlc3MgaW4gYnJvd3NlclxudmFyIHByb2Nlc3MgPSBtb2R1bGUuZXhwb3J0cyA9IHt9O1xuXG4vLyBjYWNoZWQgZnJvbSB3aGF0ZXZlciBnbG9iYWwgaXMgcHJlc2VudCBzbyB0aGF0IHRlc3QgcnVubmVycyB0aGF0IHN0dWIgaXRcbi8vIGRvbid0IGJyZWFrIHRoaW5ncy4gIEJ1dCB3ZSBuZWVkIHRvIHdyYXAgaXQgaW4gYSB0cnkgY2F0Y2ggaW4gY2FzZSBpdCBpc1xuLy8gd3JhcHBlZCBpbiBzdHJpY3QgbW9kZSBjb2RlIHdoaWNoIGRvZXNuJ3QgZGVmaW5lIGFueSBnbG9iYWxzLiAgSXQncyBpbnNpZGUgYVxuLy8gZnVuY3Rpb24gYmVjYXVzZSB0cnkvY2F0Y2hlcyBkZW9wdGltaXplIGluIGNlcnRhaW4gZW5naW5lcy5cblxudmFyIGNhY2hlZFNldFRpbWVvdXQ7XG52YXIgY2FjaGVkQ2xlYXJUaW1lb3V0O1xuXG5mdW5jdGlvbiBkZWZhdWx0U2V0VGltb3V0KCkge1xuICAgIHRocm93IG5ldyBFcnJvcignc2V0VGltZW91dCBoYXMgbm90IGJlZW4gZGVmaW5lZCcpO1xufVxuZnVuY3Rpb24gZGVmYXVsdENsZWFyVGltZW91dCAoKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdjbGVhclRpbWVvdXQgaGFzIG5vdCBiZWVuIGRlZmluZWQnKTtcbn1cbihmdW5jdGlvbiAoKSB7XG4gICAgdHJ5IHtcbiAgICAgICAgaWYgKHR5cGVvZiBzZXRUaW1lb3V0ID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgICBjYWNoZWRTZXRUaW1lb3V0ID0gc2V0VGltZW91dDtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGNhY2hlZFNldFRpbWVvdXQgPSBkZWZhdWx0U2V0VGltb3V0O1xuICAgICAgICB9XG4gICAgfSBjYXRjaCAoZSkge1xuICAgICAgICBjYWNoZWRTZXRUaW1lb3V0ID0gZGVmYXVsdFNldFRpbW91dDtcbiAgICB9XG4gICAgdHJ5IHtcbiAgICAgICAgaWYgKHR5cGVvZiBjbGVhclRpbWVvdXQgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAgIGNhY2hlZENsZWFyVGltZW91dCA9IGNsZWFyVGltZW91dDtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGNhY2hlZENsZWFyVGltZW91dCA9IGRlZmF1bHRDbGVhclRpbWVvdXQ7XG4gICAgICAgIH1cbiAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgIGNhY2hlZENsZWFyVGltZW91dCA9IGRlZmF1bHRDbGVhclRpbWVvdXQ7XG4gICAgfVxufSAoKSlcbmZ1bmN0aW9uIHJ1blRpbWVvdXQoZnVuKSB7XG4gICAgaWYgKGNhY2hlZFNldFRpbWVvdXQgPT09IHNldFRpbWVvdXQpIHtcbiAgICAgICAgLy9ub3JtYWwgZW52aXJvbWVudHMgaW4gc2FuZSBzaXR1YXRpb25zXG4gICAgICAgIHJldHVybiBzZXRUaW1lb3V0KGZ1biwgMCk7XG4gICAgfVxuICAgIC8vIGlmIHNldFRpbWVvdXQgd2Fzbid0IGF2YWlsYWJsZSBidXQgd2FzIGxhdHRlciBkZWZpbmVkXG4gICAgaWYgKChjYWNoZWRTZXRUaW1lb3V0ID09PSBkZWZhdWx0U2V0VGltb3V0IHx8ICFjYWNoZWRTZXRUaW1lb3V0KSAmJiBzZXRUaW1lb3V0KSB7XG4gICAgICAgIGNhY2hlZFNldFRpbWVvdXQgPSBzZXRUaW1lb3V0O1xuICAgICAgICByZXR1cm4gc2V0VGltZW91dChmdW4sIDApO1xuICAgIH1cbiAgICB0cnkge1xuICAgICAgICAvLyB3aGVuIHdoZW4gc29tZWJvZHkgaGFzIHNjcmV3ZWQgd2l0aCBzZXRUaW1lb3V0IGJ1dCBubyBJLkUuIG1hZGRuZXNzXG4gICAgICAgIHJldHVybiBjYWNoZWRTZXRUaW1lb3V0KGZ1biwgMCk7XG4gICAgfSBjYXRjaChlKXtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIC8vIFdoZW4gd2UgYXJlIGluIEkuRS4gYnV0IHRoZSBzY3JpcHQgaGFzIGJlZW4gZXZhbGVkIHNvIEkuRS4gZG9lc24ndCB0cnVzdCB0aGUgZ2xvYmFsIG9iamVjdCB3aGVuIGNhbGxlZCBub3JtYWxseVxuICAgICAgICAgICAgcmV0dXJuIGNhY2hlZFNldFRpbWVvdXQuY2FsbChudWxsLCBmdW4sIDApO1xuICAgICAgICB9IGNhdGNoKGUpe1xuICAgICAgICAgICAgLy8gc2FtZSBhcyBhYm92ZSBidXQgd2hlbiBpdCdzIGEgdmVyc2lvbiBvZiBJLkUuIHRoYXQgbXVzdCBoYXZlIHRoZSBnbG9iYWwgb2JqZWN0IGZvciAndGhpcycsIGhvcGZ1bGx5IG91ciBjb250ZXh0IGNvcnJlY3Qgb3RoZXJ3aXNlIGl0IHdpbGwgdGhyb3cgYSBnbG9iYWwgZXJyb3JcbiAgICAgICAgICAgIHJldHVybiBjYWNoZWRTZXRUaW1lb3V0LmNhbGwodGhpcywgZnVuLCAwKTtcbiAgICAgICAgfVxuICAgIH1cblxuXG59XG5mdW5jdGlvbiBydW5DbGVhclRpbWVvdXQobWFya2VyKSB7XG4gICAgaWYgKGNhY2hlZENsZWFyVGltZW91dCA9PT0gY2xlYXJUaW1lb3V0KSB7XG4gICAgICAgIC8vbm9ybWFsIGVudmlyb21lbnRzIGluIHNhbmUgc2l0dWF0aW9uc1xuICAgICAgICByZXR1cm4gY2xlYXJUaW1lb3V0KG1hcmtlcik7XG4gICAgfVxuICAgIC8vIGlmIGNsZWFyVGltZW91dCB3YXNuJ3QgYXZhaWxhYmxlIGJ1dCB3YXMgbGF0dGVyIGRlZmluZWRcbiAgICBpZiAoKGNhY2hlZENsZWFyVGltZW91dCA9PT0gZGVmYXVsdENsZWFyVGltZW91dCB8fCAhY2FjaGVkQ2xlYXJUaW1lb3V0KSAmJiBjbGVhclRpbWVvdXQpIHtcbiAgICAgICAgY2FjaGVkQ2xlYXJUaW1lb3V0ID0gY2xlYXJUaW1lb3V0O1xuICAgICAgICByZXR1cm4gY2xlYXJUaW1lb3V0KG1hcmtlcik7XG4gICAgfVxuICAgIHRyeSB7XG4gICAgICAgIC8vIHdoZW4gd2hlbiBzb21lYm9keSBoYXMgc2NyZXdlZCB3aXRoIHNldFRpbWVvdXQgYnV0IG5vIEkuRS4gbWFkZG5lc3NcbiAgICAgICAgcmV0dXJuIGNhY2hlZENsZWFyVGltZW91dChtYXJrZXIpO1xuICAgIH0gY2F0Y2ggKGUpe1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgLy8gV2hlbiB3ZSBhcmUgaW4gSS5FLiBidXQgdGhlIHNjcmlwdCBoYXMgYmVlbiBldmFsZWQgc28gSS5FLiBkb2Vzbid0ICB0cnVzdCB0aGUgZ2xvYmFsIG9iamVjdCB3aGVuIGNhbGxlZCBub3JtYWxseVxuICAgICAgICAgICAgcmV0dXJuIGNhY2hlZENsZWFyVGltZW91dC5jYWxsKG51bGwsIG1hcmtlcik7XG4gICAgICAgIH0gY2F0Y2ggKGUpe1xuICAgICAgICAgICAgLy8gc2FtZSBhcyBhYm92ZSBidXQgd2hlbiBpdCdzIGEgdmVyc2lvbiBvZiBJLkUuIHRoYXQgbXVzdCBoYXZlIHRoZSBnbG9iYWwgb2JqZWN0IGZvciAndGhpcycsIGhvcGZ1bGx5IG91ciBjb250ZXh0IGNvcnJlY3Qgb3RoZXJ3aXNlIGl0IHdpbGwgdGhyb3cgYSBnbG9iYWwgZXJyb3IuXG4gICAgICAgICAgICAvLyBTb21lIHZlcnNpb25zIG9mIEkuRS4gaGF2ZSBkaWZmZXJlbnQgcnVsZXMgZm9yIGNsZWFyVGltZW91dCB2cyBzZXRUaW1lb3V0XG4gICAgICAgICAgICByZXR1cm4gY2FjaGVkQ2xlYXJUaW1lb3V0LmNhbGwodGhpcywgbWFya2VyKTtcbiAgICAgICAgfVxuICAgIH1cblxuXG5cbn1cbnZhciBxdWV1ZSA9IFtdO1xudmFyIGRyYWluaW5nID0gZmFsc2U7XG52YXIgY3VycmVudFF1ZXVlO1xudmFyIHF1ZXVlSW5kZXggPSAtMTtcblxuZnVuY3Rpb24gY2xlYW5VcE5leHRUaWNrKCkge1xuICAgIGlmICghZHJhaW5pbmcgfHwgIWN1cnJlbnRRdWV1ZSkge1xuICAgICAgICByZXR1cm47XG4gICAgfVxuICAgIGRyYWluaW5nID0gZmFsc2U7XG4gICAgaWYgKGN1cnJlbnRRdWV1ZS5sZW5ndGgpIHtcbiAgICAgICAgcXVldWUgPSBjdXJyZW50UXVldWUuY29uY2F0KHF1ZXVlKTtcbiAgICB9IGVsc2Uge1xuICAgICAgICBxdWV1ZUluZGV4ID0gLTE7XG4gICAgfVxuICAgIGlmIChxdWV1ZS5sZW5ndGgpIHtcbiAgICAgICAgZHJhaW5RdWV1ZSgpO1xuICAgIH1cbn1cblxuZnVuY3Rpb24gZHJhaW5RdWV1ZSgpIHtcbiAgICBpZiAoZHJhaW5pbmcpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICB2YXIgdGltZW91dCA9IHJ1blRpbWVvdXQoY2xlYW5VcE5leHRUaWNrKTtcbiAgICBkcmFpbmluZyA9IHRydWU7XG5cbiAgICB2YXIgbGVuID0gcXVldWUubGVuZ3RoO1xuICAgIHdoaWxlKGxlbikge1xuICAgICAgICBjdXJyZW50UXVldWUgPSBxdWV1ZTtcbiAgICAgICAgcXVldWUgPSBbXTtcbiAgICAgICAgd2hpbGUgKCsrcXVldWVJbmRleCA8IGxlbikge1xuICAgICAgICAgICAgaWYgKGN1cnJlbnRRdWV1ZSkge1xuICAgICAgICAgICAgICAgIGN1cnJlbnRRdWV1ZVtxdWV1ZUluZGV4XS5ydW4oKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBxdWV1ZUluZGV4ID0gLTE7XG4gICAgICAgIGxlbiA9IHF1ZXVlLmxlbmd0aDtcbiAgICB9XG4gICAgY3VycmVudFF1ZXVlID0gbnVsbDtcbiAgICBkcmFpbmluZyA9IGZhbHNlO1xuICAgIHJ1bkNsZWFyVGltZW91dCh0aW1lb3V0KTtcbn1cblxucHJvY2Vzcy5uZXh0VGljayA9IGZ1bmN0aW9uIChmdW4pIHtcbiAgICB2YXIgYXJncyA9IG5ldyBBcnJheShhcmd1bWVudHMubGVuZ3RoIC0gMSk7XG4gICAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPiAxKSB7XG4gICAgICAgIGZvciAodmFyIGkgPSAxOyBpIDwgYXJndW1lbnRzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICBhcmdzW2kgLSAxXSA9IGFyZ3VtZW50c1tpXTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBxdWV1ZS5wdXNoKG5ldyBJdGVtKGZ1biwgYXJncykpO1xuICAgIGlmIChxdWV1ZS5sZW5ndGggPT09IDEgJiYgIWRyYWluaW5nKSB7XG4gICAgICAgIHJ1blRpbWVvdXQoZHJhaW5RdWV1ZSk7XG4gICAgfVxufTtcblxuLy8gdjggbGlrZXMgcHJlZGljdGlibGUgb2JqZWN0c1xuZnVuY3Rpb24gSXRlbShmdW4sIGFycmF5KSB7XG4gICAgdGhpcy5mdW4gPSBmdW47XG4gICAgdGhpcy5hcnJheSA9IGFycmF5O1xufVxuSXRlbS5wcm90b3R5cGUucnVuID0gZnVuY3Rpb24gKCkge1xuICAgIHRoaXMuZnVuLmFwcGx5KG51bGwsIHRoaXMuYXJyYXkpO1xufTtcbnByb2Nlc3MudGl0bGUgPSAnYnJvd3Nlcic7XG5wcm9jZXNzLmJyb3dzZXIgPSB0cnVlO1xucHJvY2Vzcy5lbnYgPSB7fTtcbnByb2Nlc3MuYXJndiA9IFtdO1xucHJvY2Vzcy52ZXJzaW9uID0gJyc7IC8vIGVtcHR5IHN0cmluZyB0byBhdm9pZCByZWdleHAgaXNzdWVzXG5wcm9jZXNzLnZlcnNpb25zID0ge307XG5cbmZ1bmN0aW9uIG5vb3AoKSB7fVxuXG5wcm9jZXNzLm9uID0gbm9vcDtcbnByb2Nlc3MuYWRkTGlzdGVuZXIgPSBub29wO1xucHJvY2Vzcy5vbmNlID0gbm9vcDtcbnByb2Nlc3Mub2ZmID0gbm9vcDtcbnByb2Nlc3MucmVtb3ZlTGlzdGVuZXIgPSBub29wO1xucHJvY2Vzcy5yZW1vdmVBbGxMaXN0ZW5lcnMgPSBub29wO1xucHJvY2Vzcy5lbWl0ID0gbm9vcDtcbnByb2Nlc3MucHJlcGVuZExpc3RlbmVyID0gbm9vcDtcbnByb2Nlc3MucHJlcGVuZE9uY2VMaXN0ZW5lciA9IG5vb3A7XG5cbnByb2Nlc3MubGlzdGVuZXJzID0gZnVuY3Rpb24gKG5hbWUpIHsgcmV0dXJuIFtdIH1cblxucHJvY2Vzcy5iaW5kaW5nID0gZnVuY3Rpb24gKG5hbWUpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ3Byb2Nlc3MuYmluZGluZyBpcyBub3Qgc3VwcG9ydGVkJyk7XG59O1xuXG5wcm9jZXNzLmN3ZCA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuICcvJyB9O1xucHJvY2Vzcy5jaGRpciA9IGZ1bmN0aW9uIChkaXIpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ3Byb2Nlc3MuY2hkaXIgaXMgbm90IHN1cHBvcnRlZCcpO1xufTtcbnByb2Nlc3MudW1hc2sgPSBmdW5jdGlvbigpIHsgcmV0dXJuIDA7IH07XG4iLCIndXNlIHN0cmljdCc7XG5cbnZhciBfdHlwZW9mID0gdHlwZW9mIFN5bWJvbCA9PT0gXCJmdW5jdGlvblwiICYmIHR5cGVvZiBTeW1ib2wuaXRlcmF0b3IgPT09IFwic3ltYm9sXCIgPyBmdW5jdGlvbiAob2JqKSB7IHJldHVybiB0eXBlb2Ygb2JqOyB9IDogZnVuY3Rpb24gKG9iaikgeyByZXR1cm4gb2JqICYmIHR5cGVvZiBTeW1ib2wgPT09IFwiZnVuY3Rpb25cIiAmJiBvYmouY29uc3RydWN0b3IgPT09IFN5bWJvbCAmJiBvYmogIT09IFN5bWJvbC5wcm90b3R5cGUgPyBcInN5bWJvbFwiIDogdHlwZW9mIG9iajsgfTtcblxudmFyIF9jcmVhdGVDbGFzcyA9IGZ1bmN0aW9uICgpIHsgZnVuY3Rpb24gZGVmaW5lUHJvcGVydGllcyh0YXJnZXQsIHByb3BzKSB7IGZvciAodmFyIGkgPSAwOyBpIDwgcHJvcHMubGVuZ3RoOyBpKyspIHsgdmFyIGRlc2NyaXB0b3IgPSBwcm9wc1tpXTsgZGVzY3JpcHRvci5lbnVtZXJhYmxlID0gZGVzY3JpcHRvci5lbnVtZXJhYmxlIHx8IGZhbHNlOyBkZXNjcmlwdG9yLmNvbmZpZ3VyYWJsZSA9IHRydWU7IGlmIChcInZhbHVlXCIgaW4gZGVzY3JpcHRvcikgZGVzY3JpcHRvci53cml0YWJsZSA9IHRydWU7IE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0YXJnZXQsIGRlc2NyaXB0b3Iua2V5LCBkZXNjcmlwdG9yKTsgfSB9IHJldHVybiBmdW5jdGlvbiAoQ29uc3RydWN0b3IsIHByb3RvUHJvcHMsIHN0YXRpY1Byb3BzKSB7IGlmIChwcm90b1Byb3BzKSBkZWZpbmVQcm9wZXJ0aWVzKENvbnN0cnVjdG9yLnByb3RvdHlwZSwgcHJvdG9Qcm9wcyk7IGlmIChzdGF0aWNQcm9wcykgZGVmaW5lUHJvcGVydGllcyhDb25zdHJ1Y3Rvciwgc3RhdGljUHJvcHMpOyByZXR1cm4gQ29uc3RydWN0b3I7IH07IH0oKTtcblxuZnVuY3Rpb24gX2NsYXNzQ2FsbENoZWNrKGluc3RhbmNlLCBDb25zdHJ1Y3RvcikgeyBpZiAoIShpbnN0YW5jZSBpbnN0YW5jZW9mIENvbnN0cnVjdG9yKSkgeyB0aHJvdyBuZXcgVHlwZUVycm9yKFwiQ2Fubm90IGNhbGwgYSBjbGFzcyBhcyBhIGZ1bmN0aW9uXCIpOyB9IH1cblxudmFyIGxvZ2dlciA9IHJlcXVpcmUoJy4vbG9nZ2VyJykoJ01lc3NhZ2UnKTtcbnZhciB1dGlscyA9IHJlcXVpcmUoJy4vdXRpbHMnKTtcblxudmFyIE1lc3NhZ2UgPSBmdW5jdGlvbiAoKSB7XG5cdGZ1bmN0aW9uIE1lc3NhZ2UoKSB7XG5cdFx0X2NsYXNzQ2FsbENoZWNrKHRoaXMsIE1lc3NhZ2UpO1xuXHR9XG5cblx0X2NyZWF0ZUNsYXNzKE1lc3NhZ2UsIG51bGwsIFt7XG5cdFx0a2V5OiAncGFyc2UnLFxuXHRcdHZhbHVlOiBmdW5jdGlvbiBwYXJzZShyYXcpIHtcblx0XHRcdHZhciBvYmplY3QgPSB2b2lkIDA7XG5cdFx0XHR2YXIgbWVzc2FnZSA9IHt9O1xuXG5cdFx0XHR0cnkge1xuXHRcdFx0XHRvYmplY3QgPSBKU09OLnBhcnNlKHJhdyk7XG5cdFx0XHR9IGNhdGNoIChlcnJvcikge1xuXHRcdFx0XHRsb2dnZXIuZXJyb3IoJ3BhcnNlKCkgfCBpbnZhbGlkIEpTT046ICVzJywgZXJyb3IpO1xuXG5cdFx0XHRcdHJldHVybjtcblx0XHRcdH1cblxuXHRcdFx0aWYgKCh0eXBlb2Ygb2JqZWN0ID09PSAndW5kZWZpbmVkJyA/ICd1bmRlZmluZWQnIDogX3R5cGVvZihvYmplY3QpKSAhPT0gJ29iamVjdCcgfHwgQXJyYXkuaXNBcnJheShvYmplY3QpKSB7XG5cdFx0XHRcdGxvZ2dlci5lcnJvcigncGFyc2UoKSB8IG5vdCBhbiBvYmplY3QnKTtcblxuXHRcdFx0XHRyZXR1cm47XG5cdFx0XHR9XG5cblx0XHRcdGlmICh0eXBlb2Ygb2JqZWN0LmlkICE9PSAnbnVtYmVyJykge1xuXHRcdFx0XHRsb2dnZXIuZXJyb3IoJ3BhcnNlKCkgfCBtaXNzaW5nL2ludmFsaWQgaWQgZmllbGQnKTtcblxuXHRcdFx0XHRyZXR1cm47XG5cdFx0XHR9XG5cblx0XHRcdG1lc3NhZ2UuaWQgPSBvYmplY3QuaWQ7XG5cblx0XHRcdC8vIFJlcXVlc3QuXG5cdFx0XHRpZiAob2JqZWN0LnJlcXVlc3QpIHtcblx0XHRcdFx0bWVzc2FnZS5yZXF1ZXN0ID0gdHJ1ZTtcblxuXHRcdFx0XHRpZiAodHlwZW9mIG9iamVjdC5tZXRob2QgIT09ICdzdHJpbmcnKSB7XG5cdFx0XHRcdFx0bG9nZ2VyLmVycm9yKCdwYXJzZSgpIHwgbWlzc2luZy9pbnZhbGlkIG1ldGhvZCBmaWVsZCcpO1xuXG5cdFx0XHRcdFx0cmV0dXJuO1xuXHRcdFx0XHR9XG5cblx0XHRcdFx0bWVzc2FnZS5tZXRob2QgPSBvYmplY3QubWV0aG9kO1xuXHRcdFx0XHRtZXNzYWdlLmRhdGEgPSBvYmplY3QuZGF0YSB8fCB7fTtcblx0XHRcdH1cblx0XHRcdC8vIFJlc3BvbnNlLlxuXHRcdFx0ZWxzZSBpZiAob2JqZWN0LnJlc3BvbnNlKSB7XG5cdFx0XHRcdFx0bWVzc2FnZS5yZXNwb25zZSA9IHRydWU7XG5cblx0XHRcdFx0XHQvLyBTdWNjZXNzLlxuXHRcdFx0XHRcdGlmIChvYmplY3Qub2spIHtcblx0XHRcdFx0XHRcdG1lc3NhZ2Uub2sgPSB0cnVlO1xuXHRcdFx0XHRcdFx0bWVzc2FnZS5kYXRhID0gb2JqZWN0LmRhdGEgfHwge307XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHRcdC8vIEVycm9yLlxuXHRcdFx0XHRcdGVsc2Uge1xuXHRcdFx0XHRcdFx0XHRtZXNzYWdlLmVycm9yQ29kZSA9IG9iamVjdC5lcnJvckNvZGU7XG5cdFx0XHRcdFx0XHRcdG1lc3NhZ2UuZXJyb3JSZWFzb24gPSBvYmplY3QuZXJyb3JSZWFzb247XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblx0XHRcdFx0Ly8gSW52YWxpZC5cblx0XHRcdFx0ZWxzZSB7XG5cdFx0XHRcdFx0XHRsb2dnZXIuZXJyb3IoJ3BhcnNlKCkgfCBtaXNzaW5nIHJlcXVlc3QvcmVzcG9uc2UgZmllbGQnKTtcblxuXHRcdFx0XHRcdFx0cmV0dXJuO1xuXHRcdFx0XHRcdH1cblxuXHRcdFx0cmV0dXJuIG1lc3NhZ2U7XG5cdFx0fVxuXHR9LCB7XG5cdFx0a2V5OiAncmVxdWVzdEZhY3RvcnknLFxuXHRcdHZhbHVlOiBmdW5jdGlvbiByZXF1ZXN0RmFjdG9yeShtZXRob2QsIGRhdGEpIHtcblx0XHRcdHZhciByZXF1ZXN0ID0ge1xuXHRcdFx0XHRyZXF1ZXN0OiB0cnVlLFxuXHRcdFx0XHRpZDogdXRpbHMucmFuZG9tTnVtYmVyKCksXG5cdFx0XHRcdG1ldGhvZDogbWV0aG9kLFxuXHRcdFx0XHRkYXRhOiBkYXRhIHx8IHt9XG5cdFx0XHR9O1xuXG5cdFx0XHRyZXR1cm4gcmVxdWVzdDtcblx0XHR9XG5cdH0sIHtcblx0XHRrZXk6ICdzdWNjZXNzUmVzcG9uc2VGYWN0b3J5Jyxcblx0XHR2YWx1ZTogZnVuY3Rpb24gc3VjY2Vzc1Jlc3BvbnNlRmFjdG9yeShyZXF1ZXN0LCBkYXRhKSB7XG5cdFx0XHR2YXIgcmVzcG9uc2UgPSB7XG5cdFx0XHRcdHJlc3BvbnNlOiB0cnVlLFxuXHRcdFx0XHRpZDogcmVxdWVzdC5pZCxcblx0XHRcdFx0b2s6IHRydWUsXG5cdFx0XHRcdGRhdGE6IGRhdGEgfHwge31cblx0XHRcdH07XG5cblx0XHRcdHJldHVybiByZXNwb25zZTtcblx0XHR9XG5cdH0sIHtcblx0XHRrZXk6ICdlcnJvclJlc3BvbnNlRmFjdG9yeScsXG5cdFx0dmFsdWU6IGZ1bmN0aW9uIGVycm9yUmVzcG9uc2VGYWN0b3J5KHJlcXVlc3QsIGVycm9yQ29kZSwgZXJyb3JSZWFzb24pIHtcblx0XHRcdHZhciByZXNwb25zZSA9IHtcblx0XHRcdFx0cmVzcG9uc2U6IHRydWUsXG5cdFx0XHRcdGlkOiByZXF1ZXN0LmlkLFxuXHRcdFx0XHRlcnJvckNvZGU6IGVycm9yQ29kZSxcblx0XHRcdFx0ZXJyb3JSZWFzb246IGVycm9yUmVhc29uXG5cdFx0XHR9O1xuXG5cdFx0XHRyZXR1cm4gcmVzcG9uc2U7XG5cdFx0fVxuXHR9XSk7XG5cblx0cmV0dXJuIE1lc3NhZ2U7XG59KCk7XG5cbm1vZHVsZS5leHBvcnRzID0gTWVzc2FnZTsiLCIndXNlIHN0cmljdCc7XG5cbnZhciBfY3JlYXRlQ2xhc3MgPSBmdW5jdGlvbiAoKSB7IGZ1bmN0aW9uIGRlZmluZVByb3BlcnRpZXModGFyZ2V0LCBwcm9wcykgeyBmb3IgKHZhciBpID0gMDsgaSA8IHByb3BzLmxlbmd0aDsgaSsrKSB7IHZhciBkZXNjcmlwdG9yID0gcHJvcHNbaV07IGRlc2NyaXB0b3IuZW51bWVyYWJsZSA9IGRlc2NyaXB0b3IuZW51bWVyYWJsZSB8fCBmYWxzZTsgZGVzY3JpcHRvci5jb25maWd1cmFibGUgPSB0cnVlOyBpZiAoXCJ2YWx1ZVwiIGluIGRlc2NyaXB0b3IpIGRlc2NyaXB0b3Iud3JpdGFibGUgPSB0cnVlOyBPYmplY3QuZGVmaW5lUHJvcGVydHkodGFyZ2V0LCBkZXNjcmlwdG9yLmtleSwgZGVzY3JpcHRvcik7IH0gfSByZXR1cm4gZnVuY3Rpb24gKENvbnN0cnVjdG9yLCBwcm90b1Byb3BzLCBzdGF0aWNQcm9wcykgeyBpZiAocHJvdG9Qcm9wcykgZGVmaW5lUHJvcGVydGllcyhDb25zdHJ1Y3Rvci5wcm90b3R5cGUsIHByb3RvUHJvcHMpOyBpZiAoc3RhdGljUHJvcHMpIGRlZmluZVByb3BlcnRpZXMoQ29uc3RydWN0b3IsIHN0YXRpY1Byb3BzKTsgcmV0dXJuIENvbnN0cnVjdG9yOyB9OyB9KCk7XG5cbmZ1bmN0aW9uIF9jbGFzc0NhbGxDaGVjayhpbnN0YW5jZSwgQ29uc3RydWN0b3IpIHsgaWYgKCEoaW5zdGFuY2UgaW5zdGFuY2VvZiBDb25zdHJ1Y3RvcikpIHsgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkNhbm5vdCBjYWxsIGEgY2xhc3MgYXMgYSBmdW5jdGlvblwiKTsgfSB9XG5cbmZ1bmN0aW9uIF9wb3NzaWJsZUNvbnN0cnVjdG9yUmV0dXJuKHNlbGYsIGNhbGwpIHsgaWYgKCFzZWxmKSB7IHRocm93IG5ldyBSZWZlcmVuY2VFcnJvcihcInRoaXMgaGFzbid0IGJlZW4gaW5pdGlhbGlzZWQgLSBzdXBlcigpIGhhc24ndCBiZWVuIGNhbGxlZFwiKTsgfSByZXR1cm4gY2FsbCAmJiAodHlwZW9mIGNhbGwgPT09IFwib2JqZWN0XCIgfHwgdHlwZW9mIGNhbGwgPT09IFwiZnVuY3Rpb25cIikgPyBjYWxsIDogc2VsZjsgfVxuXG5mdW5jdGlvbiBfaW5oZXJpdHMoc3ViQ2xhc3MsIHN1cGVyQ2xhc3MpIHsgaWYgKHR5cGVvZiBzdXBlckNsYXNzICE9PSBcImZ1bmN0aW9uXCIgJiYgc3VwZXJDbGFzcyAhPT0gbnVsbCkgeyB0aHJvdyBuZXcgVHlwZUVycm9yKFwiU3VwZXIgZXhwcmVzc2lvbiBtdXN0IGVpdGhlciBiZSBudWxsIG9yIGEgZnVuY3Rpb24sIG5vdCBcIiArIHR5cGVvZiBzdXBlckNsYXNzKTsgfSBzdWJDbGFzcy5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKHN1cGVyQ2xhc3MgJiYgc3VwZXJDbGFzcy5wcm90b3R5cGUsIHsgY29uc3RydWN0b3I6IHsgdmFsdWU6IHN1YkNsYXNzLCBlbnVtZXJhYmxlOiBmYWxzZSwgd3JpdGFibGU6IHRydWUsIGNvbmZpZ3VyYWJsZTogdHJ1ZSB9IH0pOyBpZiAoc3VwZXJDbGFzcykgT2JqZWN0LnNldFByb3RvdHlwZU9mID8gT2JqZWN0LnNldFByb3RvdHlwZU9mKHN1YkNsYXNzLCBzdXBlckNsYXNzKSA6IHN1YkNsYXNzLl9fcHJvdG9fXyA9IHN1cGVyQ2xhc3M7IH1cblxudmFyIEV2ZW50RW1pdHRlciA9IHJlcXVpcmUoJ2V2ZW50cycpLkV2ZW50RW1pdHRlcjtcbnZhciBsb2dnZXIgPSByZXF1aXJlKCcuL2xvZ2dlcicpKCdQZWVyJyk7XG52YXIgTWVzc2FnZSA9IHJlcXVpcmUoJy4vTWVzc2FnZScpO1xuXG4vLyBNYXggdGltZSB3YWl0aW5nIGZvciBhIHJlc3BvbnNlLlxudmFyIFJFUVVFU1RfVElNRU9VVCA9IDIwMDAwO1xuXG52YXIgUGVlciA9IGZ1bmN0aW9uIChfRXZlbnRFbWl0dGVyKSB7XG5cdF9pbmhlcml0cyhQZWVyLCBfRXZlbnRFbWl0dGVyKTtcblxuXHRmdW5jdGlvbiBQZWVyKHRyYW5zcG9ydCkge1xuXHRcdF9jbGFzc0NhbGxDaGVjayh0aGlzLCBQZWVyKTtcblxuXHRcdGxvZ2dlci5kZWJ1ZygnY29uc3RydWN0b3IoKScpO1xuXG5cdFx0dmFyIF90aGlzID0gX3Bvc3NpYmxlQ29uc3RydWN0b3JSZXR1cm4odGhpcywgKFBlZXIuX19wcm90b19fIHx8IE9iamVjdC5nZXRQcm90b3R5cGVPZihQZWVyKSkuY2FsbCh0aGlzKSk7XG5cblx0XHRfdGhpcy5zZXRNYXhMaXN0ZW5lcnMoSW5maW5pdHkpO1xuXG5cdFx0Ly8gVHJhbnNwb3J0LlxuXHRcdF90aGlzLl90cmFuc3BvcnQgPSB0cmFuc3BvcnQ7XG5cblx0XHQvLyBDbG9zZWQgZmxhZy5cblx0XHRfdGhpcy5fY2xvc2VkID0gZmFsc2U7XG5cblx0XHQvLyBDdXN0b20gZGF0YSBvYmplY3QuXG5cdFx0X3RoaXMuX2RhdGEgPSB7fTtcblxuXHRcdC8vIE1hcCBvZiBzZW50IHJlcXVlc3RzJyBoYW5kbGVycyBpbmRleGVkIGJ5IHJlcXVlc3QuaWQuXG5cdFx0X3RoaXMuX3JlcXVlc3RIYW5kbGVycyA9IG5ldyBNYXAoKTtcblxuXHRcdC8vIEhhbmRsZSB0cmFuc3BvcnQuXG5cdFx0X3RoaXMuX2hhbmRsZVRyYW5zcG9ydCgpO1xuXHRcdHJldHVybiBfdGhpcztcblx0fVxuXG5cdF9jcmVhdGVDbGFzcyhQZWVyLCBbe1xuXHRcdGtleTogJ3NlbmQnLFxuXHRcdHZhbHVlOiBmdW5jdGlvbiBzZW5kKG1ldGhvZCwgZGF0YSkge1xuXHRcdFx0dmFyIF90aGlzMiA9IHRoaXM7XG5cblx0XHRcdHZhciByZXF1ZXN0ID0gTWVzc2FnZS5yZXF1ZXN0RmFjdG9yeShtZXRob2QsIGRhdGEpO1xuXG5cdFx0XHRyZXR1cm4gdGhpcy5fdHJhbnNwb3J0LnNlbmQocmVxdWVzdCkudGhlbihmdW5jdGlvbiAoKSB7XG5cdFx0XHRcdHJldHVybiBuZXcgUHJvbWlzZShmdW5jdGlvbiAocFJlc29sdmUsIHBSZWplY3QpIHtcblx0XHRcdFx0XHR2YXIgaGFuZGxlciA9IHtcblx0XHRcdFx0XHRcdHJlc29sdmU6IGZ1bmN0aW9uIHJlc29sdmUoZGF0YTIpIHtcblx0XHRcdFx0XHRcdFx0aWYgKCFfdGhpczIuX3JlcXVlc3RIYW5kbGVycy5kZWxldGUocmVxdWVzdC5pZCkpIHJldHVybjtcblxuXHRcdFx0XHRcdFx0XHRjbGVhclRpbWVvdXQoaGFuZGxlci50aW1lcik7XG5cdFx0XHRcdFx0XHRcdHBSZXNvbHZlKGRhdGEyKTtcblx0XHRcdFx0XHRcdH0sXG5cblx0XHRcdFx0XHRcdHJlamVjdDogZnVuY3Rpb24gcmVqZWN0KGVycm9yKSB7XG5cdFx0XHRcdFx0XHRcdGlmICghX3RoaXMyLl9yZXF1ZXN0SGFuZGxlcnMuZGVsZXRlKHJlcXVlc3QuaWQpKSByZXR1cm47XG5cblx0XHRcdFx0XHRcdFx0Y2xlYXJUaW1lb3V0KGhhbmRsZXIudGltZXIpO1xuXHRcdFx0XHRcdFx0XHRwUmVqZWN0KGVycm9yKTtcblx0XHRcdFx0XHRcdH0sXG5cblx0XHRcdFx0XHRcdHRpbWVyOiBzZXRUaW1lb3V0KGZ1bmN0aW9uICgpIHtcblx0XHRcdFx0XHRcdFx0aWYgKCFfdGhpczIuX3JlcXVlc3RIYW5kbGVycy5kZWxldGUocmVxdWVzdC5pZCkpIHJldHVybjtcblxuXHRcdFx0XHRcdFx0XHRwUmVqZWN0KG5ldyBFcnJvcigncmVxdWVzdCB0aW1lb3V0JykpO1xuXHRcdFx0XHRcdFx0fSwgUkVRVUVTVF9USU1FT1VUKSxcblxuXHRcdFx0XHRcdFx0Y2xvc2U6IGZ1bmN0aW9uIGNsb3NlKCkge1xuXHRcdFx0XHRcdFx0XHRjbGVhclRpbWVvdXQoaGFuZGxlci50aW1lcik7XG5cdFx0XHRcdFx0XHRcdHBSZWplY3QobmV3IEVycm9yKCdwZWVyIGNsb3NlZCcpKTtcblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHR9O1xuXG5cdFx0XHRcdFx0Ly8gQWRkIGhhbmRsZXIgc3R1ZmYgdG8gdGhlIE1hcC5cblx0XHRcdFx0XHRfdGhpczIuX3JlcXVlc3RIYW5kbGVycy5zZXQocmVxdWVzdC5pZCwgaGFuZGxlcik7XG5cdFx0XHRcdH0pO1xuXHRcdFx0fSk7XG5cdFx0fVxuXHR9LCB7XG5cdFx0a2V5OiAnY2xvc2UnLFxuXHRcdHZhbHVlOiBmdW5jdGlvbiBjbG9zZSgpIHtcblx0XHRcdGxvZ2dlci5kZWJ1ZygnY2xvc2UoKScpO1xuXG5cdFx0XHRpZiAodGhpcy5fY2xvc2VkKSByZXR1cm47XG5cblx0XHRcdHRoaXMuX2Nsb3NlZCA9IHRydWU7XG5cblx0XHRcdC8vIENsb3NlIHRyYW5zcG9ydC5cblx0XHRcdHRoaXMuX3RyYW5zcG9ydC5jbG9zZSgpO1xuXG5cdFx0XHQvLyBDbG9zZSBldmVyeSBwZW5kaW5nIHJlcXVlc3QgaGFuZGxlci5cblx0XHRcdHRoaXMuX3JlcXVlc3RIYW5kbGVycy5mb3JFYWNoKGZ1bmN0aW9uIChoYW5kbGVyKSB7XG5cdFx0XHRcdHJldHVybiBoYW5kbGVyLmNsb3NlKCk7XG5cdFx0XHR9KTtcblxuXHRcdFx0Ly8gRW1pdCAnY2xvc2UnIGV2ZW50LlxuXHRcdFx0dGhpcy5lbWl0KCdjbG9zZScpO1xuXHRcdH1cblx0fSwge1xuXHRcdGtleTogJ19oYW5kbGVUcmFuc3BvcnQnLFxuXHRcdHZhbHVlOiBmdW5jdGlvbiBfaGFuZGxlVHJhbnNwb3J0KCkge1xuXHRcdFx0dmFyIF90aGlzMyA9IHRoaXM7XG5cblx0XHRcdGlmICh0aGlzLl90cmFuc3BvcnQuY2xvc2VkKSB7XG5cdFx0XHRcdHRoaXMuX2Nsb3NlZCA9IHRydWU7XG5cdFx0XHRcdHNldFRpbWVvdXQoZnVuY3Rpb24gKCkge1xuXHRcdFx0XHRcdHJldHVybiBfdGhpczMuZW1pdCgnY2xvc2UnKTtcblx0XHRcdFx0fSk7XG5cblx0XHRcdFx0cmV0dXJuO1xuXHRcdFx0fVxuXG5cdFx0XHR0aGlzLl90cmFuc3BvcnQub24oJ2Nvbm5lY3RpbmcnLCBmdW5jdGlvbiAoY3VycmVudEF0dGVtcHQpIHtcblx0XHRcdFx0X3RoaXMzLmVtaXQoJ2Nvbm5lY3RpbmcnLCBjdXJyZW50QXR0ZW1wdCk7XG5cdFx0XHR9KTtcblxuXHRcdFx0dGhpcy5fdHJhbnNwb3J0Lm9uKCdvcGVuJywgZnVuY3Rpb24gKCkge1xuXHRcdFx0XHRpZiAoX3RoaXMzLl9jbG9zZWQpIHJldHVybjtcblxuXHRcdFx0XHQvLyBFbWl0ICdvcGVuJyBldmVudC5cblx0XHRcdFx0X3RoaXMzLmVtaXQoJ29wZW4nKTtcblx0XHRcdH0pO1xuXG5cdFx0XHR0aGlzLl90cmFuc3BvcnQub24oJ2Rpc2Nvbm5lY3RlZCcsIGZ1bmN0aW9uICgpIHtcblx0XHRcdFx0X3RoaXMzLmVtaXQoJ2Rpc2Nvbm5lY3RlZCcpO1xuXHRcdFx0fSk7XG5cblx0XHRcdHRoaXMuX3RyYW5zcG9ydC5vbignZmFpbGVkJywgZnVuY3Rpb24gKGN1cnJlbnRBdHRlbXB0KSB7XG5cdFx0XHRcdF90aGlzMy5lbWl0KCdmYWlsZWQnLCBjdXJyZW50QXR0ZW1wdCk7XG5cdFx0XHR9KTtcblxuXHRcdFx0dGhpcy5fdHJhbnNwb3J0Lm9uKCdjbG9zZScsIGZ1bmN0aW9uICgpIHtcblx0XHRcdFx0aWYgKF90aGlzMy5fY2xvc2VkKSByZXR1cm47XG5cblx0XHRcdFx0X3RoaXMzLl9jbG9zZWQgPSB0cnVlO1xuXG5cdFx0XHRcdC8vIEVtaXQgJ2Nsb3NlJyBldmVudC5cblx0XHRcdFx0X3RoaXMzLmVtaXQoJ2Nsb3NlJyk7XG5cdFx0XHR9KTtcblxuXHRcdFx0dGhpcy5fdHJhbnNwb3J0Lm9uKCdtZXNzYWdlJywgZnVuY3Rpb24gKG1lc3NhZ2UpIHtcblx0XHRcdFx0aWYgKG1lc3NhZ2UucmVzcG9uc2UpIHtcblx0XHRcdFx0XHRfdGhpczMuX2hhbmRsZVJlc3BvbnNlKG1lc3NhZ2UpO1xuXHRcdFx0XHR9IGVsc2UgaWYgKG1lc3NhZ2UucmVxdWVzdCkge1xuXHRcdFx0XHRcdF90aGlzMy5faGFuZGxlUmVxdWVzdChtZXNzYWdlKTtcblx0XHRcdFx0fVxuXHRcdFx0fSk7XG5cdFx0fVxuXHR9LCB7XG5cdFx0a2V5OiAnX2hhbmRsZVJlc3BvbnNlJyxcblx0XHR2YWx1ZTogZnVuY3Rpb24gX2hhbmRsZVJlc3BvbnNlKHJlc3BvbnNlKSB7XG5cdFx0XHR2YXIgaGFuZGxlciA9IHRoaXMuX3JlcXVlc3RIYW5kbGVycy5nZXQocmVzcG9uc2UuaWQpO1xuXG5cdFx0XHRpZiAoIWhhbmRsZXIpIHtcblx0XHRcdFx0bG9nZ2VyLmVycm9yKCdyZWNlaXZlZCByZXNwb25zZSBkb2VzIG5vdCBtYXRjaCBhbnkgc2VudCByZXF1ZXN0Jyk7XG5cblx0XHRcdFx0cmV0dXJuO1xuXHRcdFx0fVxuXG5cdFx0XHRpZiAocmVzcG9uc2Uub2spIHtcblx0XHRcdFx0aGFuZGxlci5yZXNvbHZlKHJlc3BvbnNlLmRhdGEpO1xuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0dmFyIGVycm9yID0gbmV3IEVycm9yKHJlc3BvbnNlLmVycm9yUmVhc29uKTtcblxuXHRcdFx0XHRlcnJvci5jb2RlID0gcmVzcG9uc2UuZXJyb3JDb2RlO1xuXHRcdFx0XHRoYW5kbGVyLnJlamVjdChlcnJvcik7XG5cdFx0XHR9XG5cdFx0fVxuXHR9LCB7XG5cdFx0a2V5OiAnX2hhbmRsZVJlcXVlc3QnLFxuXHRcdHZhbHVlOiBmdW5jdGlvbiBfaGFuZGxlUmVxdWVzdChyZXF1ZXN0KSB7XG5cdFx0XHR2YXIgX3RoaXM0ID0gdGhpcztcblxuXHRcdFx0dGhpcy5lbWl0KCdyZXF1ZXN0Jyxcblx0XHRcdC8vIFJlcXVlc3QuXG5cdFx0XHRyZXF1ZXN0LFxuXHRcdFx0Ly8gYWNjZXB0KCkgZnVuY3Rpb24uXG5cdFx0XHRmdW5jdGlvbiAoZGF0YSkge1xuXHRcdFx0XHR2YXIgcmVzcG9uc2UgPSBNZXNzYWdlLnN1Y2Nlc3NSZXNwb25zZUZhY3RvcnkocmVxdWVzdCwgZGF0YSk7XG5cblx0XHRcdFx0X3RoaXM0Ll90cmFuc3BvcnQuc2VuZChyZXNwb25zZSkuY2F0Y2goZnVuY3Rpb24gKGVycm9yKSB7XG5cdFx0XHRcdFx0bG9nZ2VyLndhcm4oJ2FjY2VwdCgpIGZhaWxlZCwgcmVzcG9uc2UgY291bGQgbm90IGJlIHNlbnQ6ICVvJywgZXJyb3IpO1xuXHRcdFx0XHR9KTtcblx0XHRcdH0sXG5cdFx0XHQvLyByZWplY3QoKSBmdW5jdGlvbi5cblx0XHRcdGZ1bmN0aW9uIChlcnJvckNvZGUsIGVycm9yUmVhc29uKSB7XG5cdFx0XHRcdGlmIChlcnJvckNvZGUgaW5zdGFuY2VvZiBFcnJvcikge1xuXHRcdFx0XHRcdGVycm9yUmVhc29uID0gZXJyb3JDb2RlLnRvU3RyaW5nKCk7XG5cdFx0XHRcdFx0ZXJyb3JDb2RlID0gNTAwO1xuXHRcdFx0XHR9IGVsc2UgaWYgKHR5cGVvZiBlcnJvckNvZGUgPT09ICdudW1iZXInICYmIGVycm9yUmVhc29uIGluc3RhbmNlb2YgRXJyb3IpIHtcblx0XHRcdFx0XHRlcnJvclJlYXNvbiA9IGVycm9yUmVhc29uLnRvU3RyaW5nKCk7XG5cdFx0XHRcdH1cblxuXHRcdFx0XHR2YXIgcmVzcG9uc2UgPSBNZXNzYWdlLmVycm9yUmVzcG9uc2VGYWN0b3J5KHJlcXVlc3QsIGVycm9yQ29kZSwgZXJyb3JSZWFzb24pO1xuXG5cdFx0XHRcdF90aGlzNC5fdHJhbnNwb3J0LnNlbmQocmVzcG9uc2UpLmNhdGNoKGZ1bmN0aW9uIChlcnJvcikge1xuXHRcdFx0XHRcdGxvZ2dlci53YXJuKCdyZWplY3QoKSBmYWlsZWQsIHJlc3BvbnNlIGNvdWxkIG5vdCBiZSBzZW50OiAlbycsIGVycm9yKTtcblx0XHRcdFx0fSk7XG5cdFx0XHR9KTtcblx0XHR9XG5cdH0sIHtcblx0XHRrZXk6ICdkYXRhJyxcblx0XHRnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcblx0XHRcdHJldHVybiB0aGlzLl9kYXRhO1xuXHRcdH0sXG5cdFx0c2V0OiBmdW5jdGlvbiBzZXQob2JqKSB7XG5cdFx0XHR0aGlzLl9kYXRhID0gb2JqIHx8IHt9O1xuXHRcdH1cblx0fSwge1xuXHRcdGtleTogJ2Nsb3NlZCcsXG5cdFx0Z2V0OiBmdW5jdGlvbiBnZXQoKSB7XG5cdFx0XHRyZXR1cm4gdGhpcy5fY2xvc2VkO1xuXHRcdH1cblx0fV0pO1xuXG5cdHJldHVybiBQZWVyO1xufShFdmVudEVtaXR0ZXIpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IFBlZXI7IiwiJ3VzZSBzdHJpY3QnO1xuXG52YXIgUGVlciA9IHJlcXVpcmUoJy4vUGVlcicpO1xudmFyIHRyYW5zcG9ydHMgPSByZXF1aXJlKCcuL3RyYW5zcG9ydHMnKTtcblxubW9kdWxlLmV4cG9ydHMgPSB7XG5cdC8qKlxuICAqIEV4cG9zZSBQZWVyLlxuICAqL1xuXHRQZWVyOiBQZWVyLFxuXG5cdC8qKlxuICAqIEV4cG9zZSB0aGUgYnVpbHQtaW4gV2ViU29ja2V0VHJhbnNwb3J0LlxuICAqL1xuXHRXZWJTb2NrZXRUcmFuc3BvcnQ6IHRyYW5zcG9ydHMuV2ViU29ja2V0VHJhbnNwb3J0XG59OyIsIid1c2Ugc3RyaWN0JztcblxudmFyIF9jcmVhdGVDbGFzcyA9IGZ1bmN0aW9uICgpIHsgZnVuY3Rpb24gZGVmaW5lUHJvcGVydGllcyh0YXJnZXQsIHByb3BzKSB7IGZvciAodmFyIGkgPSAwOyBpIDwgcHJvcHMubGVuZ3RoOyBpKyspIHsgdmFyIGRlc2NyaXB0b3IgPSBwcm9wc1tpXTsgZGVzY3JpcHRvci5lbnVtZXJhYmxlID0gZGVzY3JpcHRvci5lbnVtZXJhYmxlIHx8IGZhbHNlOyBkZXNjcmlwdG9yLmNvbmZpZ3VyYWJsZSA9IHRydWU7IGlmIChcInZhbHVlXCIgaW4gZGVzY3JpcHRvcikgZGVzY3JpcHRvci53cml0YWJsZSA9IHRydWU7IE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0YXJnZXQsIGRlc2NyaXB0b3Iua2V5LCBkZXNjcmlwdG9yKTsgfSB9IHJldHVybiBmdW5jdGlvbiAoQ29uc3RydWN0b3IsIHByb3RvUHJvcHMsIHN0YXRpY1Byb3BzKSB7IGlmIChwcm90b1Byb3BzKSBkZWZpbmVQcm9wZXJ0aWVzKENvbnN0cnVjdG9yLnByb3RvdHlwZSwgcHJvdG9Qcm9wcyk7IGlmIChzdGF0aWNQcm9wcykgZGVmaW5lUHJvcGVydGllcyhDb25zdHJ1Y3Rvciwgc3RhdGljUHJvcHMpOyByZXR1cm4gQ29uc3RydWN0b3I7IH07IH0oKTtcblxuZnVuY3Rpb24gX2NsYXNzQ2FsbENoZWNrKGluc3RhbmNlLCBDb25zdHJ1Y3RvcikgeyBpZiAoIShpbnN0YW5jZSBpbnN0YW5jZW9mIENvbnN0cnVjdG9yKSkgeyB0aHJvdyBuZXcgVHlwZUVycm9yKFwiQ2Fubm90IGNhbGwgYSBjbGFzcyBhcyBhIGZ1bmN0aW9uXCIpOyB9IH1cblxudmFyIGRlYnVnID0gcmVxdWlyZSgnZGVidWcnKTtcblxudmFyIEFQUF9OQU1FID0gJ3Byb3Rvby1jbGllbnQnO1xuXG52YXIgTG9nZ2VyID0gZnVuY3Rpb24gKCkge1xuXHRmdW5jdGlvbiBMb2dnZXIocHJlZml4KSB7XG5cdFx0X2NsYXNzQ2FsbENoZWNrKHRoaXMsIExvZ2dlcik7XG5cblx0XHRpZiAocHJlZml4KSB7XG5cdFx0XHR0aGlzLl9kZWJ1ZyA9IGRlYnVnKEFQUF9OQU1FICsgJzonICsgcHJlZml4KTtcblx0XHRcdHRoaXMuX3dhcm4gPSBkZWJ1ZyhBUFBfTkFNRSArICc6V0FSTjonICsgcHJlZml4KTtcblx0XHRcdHRoaXMuX2Vycm9yID0gZGVidWcoQVBQX05BTUUgKyAnOkVSUk9SOicgKyBwcmVmaXgpO1xuXHRcdH0gZWxzZSB7XG5cdFx0XHR0aGlzLl9kZWJ1ZyA9IGRlYnVnKEFQUF9OQU1FKTtcblx0XHRcdHRoaXMuX3dhcm4gPSBkZWJ1ZyhBUFBfTkFNRSArICc6V0FSTicpO1xuXHRcdFx0dGhpcy5fZXJyb3IgPSBkZWJ1ZyhBUFBfTkFNRSArICc6RVJST1InKTtcblx0XHR9XG5cblx0XHQvKiBlc2xpbnQtZGlzYWJsZSBuby1jb25zb2xlICovXG5cdFx0dGhpcy5fZGVidWcubG9nID0gY29uc29sZS5pbmZvLmJpbmQoY29uc29sZSk7XG5cdFx0dGhpcy5fd2Fybi5sb2cgPSBjb25zb2xlLndhcm4uYmluZChjb25zb2xlKTtcblx0XHR0aGlzLl9lcnJvci5sb2cgPSBjb25zb2xlLmVycm9yLmJpbmQoY29uc29sZSk7XG5cdFx0LyogZXNsaW50LWVuYWJsZSBuby1jb25zb2xlICovXG5cdH1cblxuXHRfY3JlYXRlQ2xhc3MoTG9nZ2VyLCBbe1xuXHRcdGtleTogJ2RlYnVnJyxcblx0XHRnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcblx0XHRcdHJldHVybiB0aGlzLl9kZWJ1Zztcblx0XHR9XG5cdH0sIHtcblx0XHRrZXk6ICd3YXJuJyxcblx0XHRnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcblx0XHRcdHJldHVybiB0aGlzLl93YXJuO1xuXHRcdH1cblx0fSwge1xuXHRcdGtleTogJ2Vycm9yJyxcblx0XHRnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcblx0XHRcdHJldHVybiB0aGlzLl9lcnJvcjtcblx0XHR9XG5cdH1dKTtcblxuXHRyZXR1cm4gTG9nZ2VyO1xufSgpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChwcmVmaXgpIHtcblx0cmV0dXJuIG5ldyBMb2dnZXIocHJlZml4KTtcbn07IiwiJ3VzZSBzdHJpY3QnO1xuXG52YXIgX2NyZWF0ZUNsYXNzID0gZnVuY3Rpb24gKCkgeyBmdW5jdGlvbiBkZWZpbmVQcm9wZXJ0aWVzKHRhcmdldCwgcHJvcHMpIHsgZm9yICh2YXIgaSA9IDA7IGkgPCBwcm9wcy5sZW5ndGg7IGkrKykgeyB2YXIgZGVzY3JpcHRvciA9IHByb3BzW2ldOyBkZXNjcmlwdG9yLmVudW1lcmFibGUgPSBkZXNjcmlwdG9yLmVudW1lcmFibGUgfHwgZmFsc2U7IGRlc2NyaXB0b3IuY29uZmlndXJhYmxlID0gdHJ1ZTsgaWYgKFwidmFsdWVcIiBpbiBkZXNjcmlwdG9yKSBkZXNjcmlwdG9yLndyaXRhYmxlID0gdHJ1ZTsgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRhcmdldCwgZGVzY3JpcHRvci5rZXksIGRlc2NyaXB0b3IpOyB9IH0gcmV0dXJuIGZ1bmN0aW9uIChDb25zdHJ1Y3RvciwgcHJvdG9Qcm9wcywgc3RhdGljUHJvcHMpIHsgaWYgKHByb3RvUHJvcHMpIGRlZmluZVByb3BlcnRpZXMoQ29uc3RydWN0b3IucHJvdG90eXBlLCBwcm90b1Byb3BzKTsgaWYgKHN0YXRpY1Byb3BzKSBkZWZpbmVQcm9wZXJ0aWVzKENvbnN0cnVjdG9yLCBzdGF0aWNQcm9wcyk7IHJldHVybiBDb25zdHJ1Y3RvcjsgfTsgfSgpO1xuXG5mdW5jdGlvbiBfY2xhc3NDYWxsQ2hlY2soaW5zdGFuY2UsIENvbnN0cnVjdG9yKSB7IGlmICghKGluc3RhbmNlIGluc3RhbmNlb2YgQ29uc3RydWN0b3IpKSB7IHRocm93IG5ldyBUeXBlRXJyb3IoXCJDYW5ub3QgY2FsbCBhIGNsYXNzIGFzIGEgZnVuY3Rpb25cIik7IH0gfVxuXG5mdW5jdGlvbiBfcG9zc2libGVDb25zdHJ1Y3RvclJldHVybihzZWxmLCBjYWxsKSB7IGlmICghc2VsZikgeyB0aHJvdyBuZXcgUmVmZXJlbmNlRXJyb3IoXCJ0aGlzIGhhc24ndCBiZWVuIGluaXRpYWxpc2VkIC0gc3VwZXIoKSBoYXNuJ3QgYmVlbiBjYWxsZWRcIik7IH0gcmV0dXJuIGNhbGwgJiYgKHR5cGVvZiBjYWxsID09PSBcIm9iamVjdFwiIHx8IHR5cGVvZiBjYWxsID09PSBcImZ1bmN0aW9uXCIpID8gY2FsbCA6IHNlbGY7IH1cblxuZnVuY3Rpb24gX2luaGVyaXRzKHN1YkNsYXNzLCBzdXBlckNsYXNzKSB7IGlmICh0eXBlb2Ygc3VwZXJDbGFzcyAhPT0gXCJmdW5jdGlvblwiICYmIHN1cGVyQ2xhc3MgIT09IG51bGwpIHsgdGhyb3cgbmV3IFR5cGVFcnJvcihcIlN1cGVyIGV4cHJlc3Npb24gbXVzdCBlaXRoZXIgYmUgbnVsbCBvciBhIGZ1bmN0aW9uLCBub3QgXCIgKyB0eXBlb2Ygc3VwZXJDbGFzcyk7IH0gc3ViQ2xhc3MucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZShzdXBlckNsYXNzICYmIHN1cGVyQ2xhc3MucHJvdG90eXBlLCB7IGNvbnN0cnVjdG9yOiB7IHZhbHVlOiBzdWJDbGFzcywgZW51bWVyYWJsZTogZmFsc2UsIHdyaXRhYmxlOiB0cnVlLCBjb25maWd1cmFibGU6IHRydWUgfSB9KTsgaWYgKHN1cGVyQ2xhc3MpIE9iamVjdC5zZXRQcm90b3R5cGVPZiA/IE9iamVjdC5zZXRQcm90b3R5cGVPZihzdWJDbGFzcywgc3VwZXJDbGFzcykgOiBzdWJDbGFzcy5fX3Byb3RvX18gPSBzdXBlckNsYXNzOyB9XG5cbnZhciBFdmVudEVtaXR0ZXIgPSByZXF1aXJlKCdldmVudHMnKS5FdmVudEVtaXR0ZXI7XG52YXIgVzNDV2ViU29ja2V0ID0gcmVxdWlyZSgnd2Vic29ja2V0JykudzNjd2Vic29ja2V0O1xudmFyIHJldHJ5ID0gcmVxdWlyZSgncmV0cnknKTtcbnZhciBsb2dnZXIgPSByZXF1aXJlKCcuLi9sb2dnZXInKSgnV2ViU29ja2V0VHJhbnNwb3J0Jyk7XG52YXIgTWVzc2FnZSA9IHJlcXVpcmUoJy4uL01lc3NhZ2UnKTtcblxudmFyIFdTX1NVQlBST1RPQ09MID0gJ3Byb3Rvbyc7XG52YXIgREVGQVVMVF9SRVRSWV9PUFRJT05TID0ge1xuXHRyZXRyaWVzOiAxMCxcblx0ZmFjdG9yOiAyLFxuXHRtaW5UaW1lb3V0OiAxICogMTAwMCxcblx0bWF4VGltZW91dDogOCAqIDEwMDBcbn07XG5cbnZhciBXZWJTb2NrZXRUcmFuc3BvcnQgPSBmdW5jdGlvbiAoX0V2ZW50RW1pdHRlcikge1xuXHRfaW5oZXJpdHMoV2ViU29ja2V0VHJhbnNwb3J0LCBfRXZlbnRFbWl0dGVyKTtcblxuXHRmdW5jdGlvbiBXZWJTb2NrZXRUcmFuc3BvcnQodXJsLCBvcHRpb25zKSB7XG5cdFx0X2NsYXNzQ2FsbENoZWNrKHRoaXMsIFdlYlNvY2tldFRyYW5zcG9ydCk7XG5cblx0XHRsb2dnZXIuZGVidWcoJ2NvbnN0cnVjdG9yKCkgW3VybDpcIiVzXCIsIG9wdGlvbnM6JW9dJywgdXJsLCBvcHRpb25zKTtcblxuXHRcdHZhciBfdGhpcyA9IF9wb3NzaWJsZUNvbnN0cnVjdG9yUmV0dXJuKHRoaXMsIChXZWJTb2NrZXRUcmFuc3BvcnQuX19wcm90b19fIHx8IE9iamVjdC5nZXRQcm90b3R5cGVPZihXZWJTb2NrZXRUcmFuc3BvcnQpKS5jYWxsKHRoaXMpKTtcblxuXHRcdF90aGlzLnNldE1heExpc3RlbmVycyhJbmZpbml0eSk7XG5cblx0XHQvLyBTYXZlIFVSTCBhbmQgb3B0aW9ucy5cblx0XHRfdGhpcy5fdXJsID0gdXJsO1xuXHRcdF90aGlzLl9vcHRpb25zID0gb3B0aW9ucyB8fCB7fTtcblxuXHRcdC8vIFdlYlNvY2tldCBpbnN0YW5jZS5cblx0XHRfdGhpcy5fd3MgPSBudWxsO1xuXG5cdFx0Ly8gQ2xvc2VkIGZsYWcuXG5cdFx0X3RoaXMuX2Nsb3NlZCA9IGZhbHNlO1xuXG5cdFx0Ly8gU2V0IFdlYlNvY2tldFxuXHRcdF90aGlzLl9zZXRXZWJTb2NrZXQoKTtcblx0XHRyZXR1cm4gX3RoaXM7XG5cdH1cblxuXHRfY3JlYXRlQ2xhc3MoV2ViU29ja2V0VHJhbnNwb3J0LCBbe1xuXHRcdGtleTogJ3NlbmQnLFxuXHRcdHZhbHVlOiBmdW5jdGlvbiBzZW5kKG1lc3NhZ2UpIHtcblx0XHRcdGlmICh0aGlzLl9jbG9zZWQpIHJldHVybiBQcm9taXNlLnJlamVjdChuZXcgRXJyb3IoJ3RyYW5zcG9ydCBjbG9zZWQnKSk7XG5cblx0XHRcdHRyeSB7XG5cdFx0XHRcdHRoaXMuX3dzLnNlbmQoSlNPTi5zdHJpbmdpZnkobWVzc2FnZSkpO1xuXG5cdFx0XHRcdHJldHVybiBQcm9taXNlLnJlc29sdmUoKTtcblx0XHRcdH0gY2F0Y2ggKGVycm9yKSB7XG5cdFx0XHRcdGxvZ2dlci5lcnJvcignc2VuZCgpIHwgZXJyb3Igc2VuZGluZyBtZXNzYWdlOiAlbycsIGVycm9yKTtcblxuXHRcdFx0XHRyZXR1cm4gUHJvbWlzZS5yZWplY3QoZXJyb3IpO1xuXHRcdFx0fVxuXHRcdH1cblx0fSwge1xuXHRcdGtleTogJ2Nsb3NlJyxcblx0XHR2YWx1ZTogZnVuY3Rpb24gY2xvc2UoKSB7XG5cdFx0XHRsb2dnZXIuZGVidWcoJ2Nsb3NlKCknKTtcblxuXHRcdFx0aWYgKHRoaXMuX2Nsb3NlZCkgcmV0dXJuO1xuXG5cdFx0XHQvLyBEb24ndCB3YWl0IGZvciB0aGUgV2ViU29ja2V0ICdjbG9zZScgZXZlbnQsIGRvIGl0IG5vdy5cblx0XHRcdHRoaXMuX2Nsb3NlZCA9IHRydWU7XG5cdFx0XHR0aGlzLmVtaXQoJ2Nsb3NlJyk7XG5cblx0XHRcdHRyeSB7XG5cdFx0XHRcdHRoaXMuX3dzLm9ub3BlbiA9IG51bGw7XG5cdFx0XHRcdHRoaXMuX3dzLm9uY2xvc2UgPSBudWxsO1xuXHRcdFx0XHR0aGlzLl93cy5vbmVycm9yID0gbnVsbDtcblx0XHRcdFx0dGhpcy5fd3Mub25tZXNzYWdlID0gbnVsbDtcblx0XHRcdFx0dGhpcy5fd3MuY2xvc2UoKTtcblx0XHRcdH0gY2F0Y2ggKGVycm9yKSB7XG5cdFx0XHRcdGxvZ2dlci5lcnJvcignY2xvc2UoKSB8IGVycm9yIGNsb3NpbmcgdGhlIFdlYlNvY2tldDogJW8nLCBlcnJvcik7XG5cdFx0XHR9XG5cdFx0fVxuXHR9LCB7XG5cdFx0a2V5OiAnX3NldFdlYlNvY2tldCcsXG5cdFx0dmFsdWU6IGZ1bmN0aW9uIF9zZXRXZWJTb2NrZXQoKSB7XG5cdFx0XHR2YXIgX3RoaXMyID0gdGhpcztcblxuXHRcdFx0dmFyIG9wdGlvbnMgPSB0aGlzLl9vcHRpb25zO1xuXHRcdFx0dmFyIG9wZXJhdGlvbiA9IHJldHJ5Lm9wZXJhdGlvbih0aGlzLl9vcHRpb25zLnJldHJ5IHx8IERFRkFVTFRfUkVUUllfT1BUSU9OUyk7XG5cdFx0XHR2YXIgd2FzQ29ubmVjdGVkID0gZmFsc2U7XG5cblx0XHRcdG9wZXJhdGlvbi5hdHRlbXB0KGZ1bmN0aW9uIChjdXJyZW50QXR0ZW1wdCkge1xuXHRcdFx0XHRpZiAoX3RoaXMyLl9jbG9zZWQpIHtcblx0XHRcdFx0XHRvcGVyYXRpb24uc3RvcCgpO1xuXG5cdFx0XHRcdFx0cmV0dXJuO1xuXHRcdFx0XHR9XG5cblx0XHRcdFx0bG9nZ2VyLmRlYnVnKCdfc2V0V2ViU29ja2V0KCkgW2N1cnJlbnRBdHRlbXB0OiVzXScsIGN1cnJlbnRBdHRlbXB0KTtcblxuXHRcdFx0XHRfdGhpczIuX3dzID0gbmV3IFczQ1dlYlNvY2tldChfdGhpczIuX3VybCwgV1NfU1VCUFJPVE9DT0wsIG9wdGlvbnMub3JpZ2luLCBvcHRpb25zLmhlYWRlcnMsIG9wdGlvbnMucmVxdWVzdE9wdGlvbnMsIG9wdGlvbnMuY2xpZW50Q29uZmlnKTtcblxuXHRcdFx0XHRfdGhpczIuZW1pdCgnY29ubmVjdGluZycsIGN1cnJlbnRBdHRlbXB0KTtcblxuXHRcdFx0XHRfdGhpczIuX3dzLm9ub3BlbiA9IGZ1bmN0aW9uICgpIHtcblx0XHRcdFx0XHRpZiAoX3RoaXMyLl9jbG9zZWQpIHJldHVybjtcblxuXHRcdFx0XHRcdHdhc0Nvbm5lY3RlZCA9IHRydWU7XG5cblx0XHRcdFx0XHQvLyBFbWl0ICdvcGVuJyBldmVudC5cblx0XHRcdFx0XHRfdGhpczIuZW1pdCgnb3BlbicpO1xuXHRcdFx0XHR9O1xuXG5cdFx0XHRcdF90aGlzMi5fd3Mub25jbG9zZSA9IGZ1bmN0aW9uIChldmVudCkge1xuXHRcdFx0XHRcdGlmIChfdGhpczIuX2Nsb3NlZCkgcmV0dXJuO1xuXG5cdFx0XHRcdFx0bG9nZ2VyLndhcm4oJ1dlYlNvY2tldCBcImNsb3NlXCIgZXZlbnQgW3dhc0NsZWFuOiVzLCBjb2RlOiVzLCByZWFzb246XCIlc1wiXScsIGV2ZW50Lndhc0NsZWFuLCBldmVudC5jb2RlLCBldmVudC5yZWFzb24pO1xuXG5cdFx0XHRcdFx0Ly8gRG9uJ3QgcmV0cnkgaWYgY29kZSBpcyA0MDAwIChjbG9zZWQgYnkgdGhlIHNlcnZlcikuXG5cdFx0XHRcdFx0aWYgKGV2ZW50LmNvZGUgIT09IDQwMDApIHtcblx0XHRcdFx0XHRcdC8vIElmIGl0IHdhcyBub3QgY29ubmVjdGVkLCB0cnkgYWdhaW4uXG5cdFx0XHRcdFx0XHRpZiAoIXdhc0Nvbm5lY3RlZCkge1xuXHRcdFx0XHRcdFx0XHRfdGhpczIuZW1pdCgnZmFpbGVkJywgY3VycmVudEF0dGVtcHQpO1xuXG5cdFx0XHRcdFx0XHRcdGlmIChvcGVyYXRpb24ucmV0cnkodHJ1ZSkpIHJldHVybjtcblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdC8vIElmIGl0IHdhcyBjb25uZWN0ZWQsIHN0YXJ0IGZyb20gc2NyYXRjaC5cblx0XHRcdFx0XHRcdGVsc2Uge1xuXHRcdFx0XHRcdFx0XHRcdG9wZXJhdGlvbi5zdG9wKCk7XG5cblx0XHRcdFx0XHRcdFx0XHRfdGhpczIuZW1pdCgnZGlzY29ubmVjdGVkJyk7XG5cdFx0XHRcdFx0XHRcdFx0X3RoaXMyLl9zZXRXZWJTb2NrZXQoKTtcblxuXHRcdFx0XHRcdFx0XHRcdHJldHVybjtcblx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdF90aGlzMi5fY2xvc2VkID0gdHJ1ZTtcblxuXHRcdFx0XHRcdC8vIEVtaXQgJ2Nsb3NlJyBldmVudC5cblx0XHRcdFx0XHRfdGhpczIuZW1pdCgnY2xvc2UnKTtcblx0XHRcdFx0fTtcblxuXHRcdFx0XHRfdGhpczIuX3dzLm9uZXJyb3IgPSBmdW5jdGlvbiAoKSB7XG5cdFx0XHRcdFx0aWYgKF90aGlzMi5fY2xvc2VkKSByZXR1cm47XG5cblx0XHRcdFx0XHRsb2dnZXIuZXJyb3IoJ1dlYlNvY2tldCBcImVycm9yXCIgZXZlbnQnKTtcblx0XHRcdFx0fTtcblxuXHRcdFx0XHRfdGhpczIuX3dzLm9ubWVzc2FnZSA9IGZ1bmN0aW9uIChldmVudCkge1xuXHRcdFx0XHRcdGlmIChfdGhpczIuX2Nsb3NlZCkgcmV0dXJuO1xuXG5cdFx0XHRcdFx0dmFyIG1lc3NhZ2UgPSBNZXNzYWdlLnBhcnNlKGV2ZW50LmRhdGEpO1xuXG5cdFx0XHRcdFx0aWYgKCFtZXNzYWdlKSByZXR1cm47XG5cblx0XHRcdFx0XHRpZiAoX3RoaXMyLmxpc3RlbmVyQ291bnQoJ21lc3NhZ2UnKSA9PT0gMCkge1xuXHRcdFx0XHRcdFx0bG9nZ2VyLmVycm9yKCdubyBsaXN0ZW5lcnMgZm9yIFdlYlNvY2tldCBcIm1lc3NhZ2VcIiBldmVudCwgaWdub3JpbmcgcmVjZWl2ZWQgbWVzc2FnZScpO1xuXG5cdFx0XHRcdFx0XHRyZXR1cm47XG5cdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0Ly8gRW1pdCAnbWVzc2FnZScgZXZlbnQuXG5cdFx0XHRcdFx0X3RoaXMyLmVtaXQoJ21lc3NhZ2UnLCBtZXNzYWdlKTtcblx0XHRcdFx0fTtcblx0XHRcdH0pO1xuXHRcdH1cblx0fSwge1xuXHRcdGtleTogJ2Nsb3NlZCcsXG5cdFx0Z2V0OiBmdW5jdGlvbiBnZXQoKSB7XG5cdFx0XHRyZXR1cm4gdGhpcy5fY2xvc2VkO1xuXHRcdH1cblx0fV0pO1xuXG5cdHJldHVybiBXZWJTb2NrZXRUcmFuc3BvcnQ7XG59KEV2ZW50RW1pdHRlcik7XG5cbm1vZHVsZS5leHBvcnRzID0gV2ViU29ja2V0VHJhbnNwb3J0OyIsIid1c2Ugc3RyaWN0JztcblxudmFyIFdlYlNvY2tldFRyYW5zcG9ydCA9IHJlcXVpcmUoJy4vV2ViU29ja2V0VHJhbnNwb3J0Jyk7XG5cbm1vZHVsZS5leHBvcnRzID0ge1xuXHRXZWJTb2NrZXRUcmFuc3BvcnQ6IFdlYlNvY2tldFRyYW5zcG9ydFxufTsiLCIndXNlIHN0cmljdCc7XG5cbnZhciByYW5kb21OdW1iZXIgPSByZXF1aXJlKCdyYW5kb20tbnVtYmVyJyk7XG5cbnZhciByYW5kb21OdW1iZXJHZW5lcmF0b3IgPSByYW5kb21OdW1iZXIuZ2VuZXJhdG9yKHtcblx0bWluOiAxMDAwMDAwLFxuXHRtYXg6IDk5OTk5OTksXG5cdGludGVnZXI6IHRydWVcbn0pO1xuXG5tb2R1bGUuZXhwb3J0cyA9IHtcblx0cmFuZG9tTnVtYmVyOiByYW5kb21OdW1iZXJHZW5lcmF0b3Jcbn07IiwiJ3VzZSBzdHJpY3QnO1xuXG52YXIgaGFzID0gT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eTtcblxuLyoqXG4gKiBEZWNvZGUgYSBVUkkgZW5jb2RlZCBzdHJpbmcuXG4gKlxuICogQHBhcmFtIHtTdHJpbmd9IGlucHV0IFRoZSBVUkkgZW5jb2RlZCBzdHJpbmcuXG4gKiBAcmV0dXJucyB7U3RyaW5nfSBUaGUgZGVjb2RlZCBzdHJpbmcuXG4gKiBAYXBpIHByaXZhdGVcbiAqL1xuZnVuY3Rpb24gZGVjb2RlKGlucHV0KSB7XG4gIHJldHVybiBkZWNvZGVVUklDb21wb25lbnQoaW5wdXQucmVwbGFjZSgvXFwrL2csICcgJykpO1xufVxuXG4vKipcbiAqIFNpbXBsZSBxdWVyeSBzdHJpbmcgcGFyc2VyLlxuICpcbiAqIEBwYXJhbSB7U3RyaW5nfSBxdWVyeSBUaGUgcXVlcnkgc3RyaW5nIHRoYXQgbmVlZHMgdG8gYmUgcGFyc2VkLlxuICogQHJldHVybnMge09iamVjdH1cbiAqIEBhcGkgcHVibGljXG4gKi9cbmZ1bmN0aW9uIHF1ZXJ5c3RyaW5nKHF1ZXJ5KSB7XG4gIHZhciBwYXJzZXIgPSAvKFtePT8mXSspPT8oW14mXSopL2dcbiAgICAsIHJlc3VsdCA9IHt9XG4gICAgLCBwYXJ0O1xuXG4gIC8vXG4gIC8vIExpdHRsZSBuaWZ0eSBwYXJzaW5nIGhhY2ssIGxldmVyYWdlIHRoZSBmYWN0IHRoYXQgUmVnRXhwLmV4ZWMgaW5jcmVtZW50c1xuICAvLyB0aGUgbGFzdEluZGV4IHByb3BlcnR5IHNvIHdlIGNhbiBjb250aW51ZSBleGVjdXRpbmcgdGhpcyBsb29wIHVudGlsIHdlJ3ZlXG4gIC8vIHBhcnNlZCBhbGwgcmVzdWx0cy5cbiAgLy9cbiAgZm9yICg7XG4gICAgcGFydCA9IHBhcnNlci5leGVjKHF1ZXJ5KTtcbiAgICByZXN1bHRbZGVjb2RlKHBhcnRbMV0pXSA9IGRlY29kZShwYXJ0WzJdKVxuICApO1xuXG4gIHJldHVybiByZXN1bHQ7XG59XG5cbi8qKlxuICogVHJhbnNmb3JtIGEgcXVlcnkgc3RyaW5nIHRvIGFuIG9iamVjdC5cbiAqXG4gKiBAcGFyYW0ge09iamVjdH0gb2JqIE9iamVjdCB0aGF0IHNob3VsZCBiZSB0cmFuc2Zvcm1lZC5cbiAqIEBwYXJhbSB7U3RyaW5nfSBwcmVmaXggT3B0aW9uYWwgcHJlZml4LlxuICogQHJldHVybnMge1N0cmluZ31cbiAqIEBhcGkgcHVibGljXG4gKi9cbmZ1bmN0aW9uIHF1ZXJ5c3RyaW5naWZ5KG9iaiwgcHJlZml4KSB7XG4gIHByZWZpeCA9IHByZWZpeCB8fCAnJztcblxuICB2YXIgcGFpcnMgPSBbXTtcblxuICAvL1xuICAvLyBPcHRpb25hbGx5IHByZWZpeCB3aXRoIGEgJz8nIGlmIG5lZWRlZFxuICAvL1xuICBpZiAoJ3N0cmluZycgIT09IHR5cGVvZiBwcmVmaXgpIHByZWZpeCA9ICc/JztcblxuICBmb3IgKHZhciBrZXkgaW4gb2JqKSB7XG4gICAgaWYgKGhhcy5jYWxsKG9iaiwga2V5KSkge1xuICAgICAgcGFpcnMucHVzaChlbmNvZGVVUklDb21wb25lbnQoa2V5KSArJz0nKyBlbmNvZGVVUklDb21wb25lbnQob2JqW2tleV0pKTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gcGFpcnMubGVuZ3RoID8gcHJlZml4ICsgcGFpcnMuam9pbignJicpIDogJyc7XG59XG5cbi8vXG4vLyBFeHBvc2UgdGhlIG1vZHVsZS5cbi8vXG5leHBvcnRzLnN0cmluZ2lmeSA9IHF1ZXJ5c3RyaW5naWZ5O1xuZXhwb3J0cy5wYXJzZSA9IHF1ZXJ5c3RyaW5nO1xuIiwidm9pZCBmdW5jdGlvbihyb290KXtcblxuICBmdW5jdGlvbiBkZWZhdWx0cyhvcHRpb25zKXtcbiAgICB2YXIgb3B0aW9ucyA9IG9wdGlvbnMgfHwge31cbiAgICB2YXIgbWluID0gb3B0aW9ucy5taW5cbiAgICB2YXIgbWF4ID0gb3B0aW9ucy5tYXhcbiAgICB2YXIgaW50ZWdlciA9IG9wdGlvbnMuaW50ZWdlciB8fCBmYWxzZVxuICAgIGlmICggbWluID09IG51bGwgJiYgbWF4ID09IG51bGwgKSB7XG4gICAgICBtaW4gPSAwXG4gICAgICBtYXggPSAxXG4gICAgfSBlbHNlIGlmICggbWluID09IG51bGwgKSB7XG4gICAgICBtaW4gPSBtYXggLSAxXG4gICAgfSBlbHNlIGlmICggbWF4ID09IG51bGwgKSB7XG4gICAgICBtYXggPSBtaW4gKyAxXG4gICAgfVxuICAgIGlmICggbWF4IDwgbWluICkgdGhyb3cgbmV3IEVycm9yKCdpbnZhbGlkIG9wdGlvbnMsIG1heCBtdXN0IGJlID49IG1pbicpXG4gICAgcmV0dXJuIHtcbiAgICAgIG1pbjogICAgIG1pblxuICAgICwgbWF4OiAgICAgbWF4XG4gICAgLCBpbnRlZ2VyOiBpbnRlZ2VyXG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gcmFuZG9tKG9wdGlvbnMpe1xuICAgIG9wdGlvbnMgPSBkZWZhdWx0cyhvcHRpb25zKVxuICAgIGlmICggb3B0aW9ucy5tYXggPT09IG9wdGlvbnMubWluICkgcmV0dXJuIG9wdGlvbnMubWluXG4gICAgdmFyIHIgPSBNYXRoLnJhbmRvbSgpICogKG9wdGlvbnMubWF4IC0gb3B0aW9ucy5taW4gKyBOdW1iZXIoISFvcHRpb25zLmludGVnZXIpKSArIG9wdGlvbnMubWluXG4gICAgcmV0dXJuIG9wdGlvbnMuaW50ZWdlciA/IE1hdGguZmxvb3IocikgOiByXG4gIH1cblxuICBmdW5jdGlvbiBnZW5lcmF0b3Iob3B0aW9ucyl7XG4gICAgb3B0aW9ucyA9IGRlZmF1bHRzKG9wdGlvbnMpXG4gICAgcmV0dXJuIGZ1bmN0aW9uKG1pbiwgbWF4LCBpbnRlZ2VyKXtcbiAgICAgIG9wdGlvbnMubWluICAgICA9IG1pbiAhPSBudWxsID8gbWluIDogb3B0aW9ucy5taW5cbiAgICAgIG9wdGlvbnMubWF4ICAgICA9IG1heCAhPSBudWxsID8gbWF4IDogb3B0aW9ucy5tYXhcbiAgICAgIG9wdGlvbnMuaW50ZWdlciA9IGludGVnZXIgIT0gbnVsbCA/IGludGVnZXIgOiBvcHRpb25zLmludGVnZXJcbiAgICAgIHJldHVybiByYW5kb20ob3B0aW9ucylcbiAgICB9XG4gIH1cblxuICBtb2R1bGUuZXhwb3J0cyA9ICByYW5kb21cbiAgbW9kdWxlLmV4cG9ydHMuZ2VuZXJhdG9yID0gZ2VuZXJhdG9yXG4gIG1vZHVsZS5leHBvcnRzLmRlZmF1bHRzID0gZGVmYXVsdHNcbn0odGhpcylcbiIsIid1c2Ugc3RyaWN0JztcblxuLyoqXG4gKiBDaGVjayBpZiB3ZSdyZSByZXF1aXJlZCB0byBhZGQgYSBwb3J0IG51bWJlci5cbiAqXG4gKiBAc2VlIGh0dHBzOi8vdXJsLnNwZWMud2hhdHdnLm9yZy8jZGVmYXVsdC1wb3J0XG4gKiBAcGFyYW0ge051bWJlcnxTdHJpbmd9IHBvcnQgUG9ydCBudW1iZXIgd2UgbmVlZCB0byBjaGVja1xuICogQHBhcmFtIHtTdHJpbmd9IHByb3RvY29sIFByb3RvY29sIHdlIG5lZWQgdG8gY2hlY2sgYWdhaW5zdC5cbiAqIEByZXR1cm5zIHtCb29sZWFufSBJcyBpdCBhIGRlZmF1bHQgcG9ydCBmb3IgdGhlIGdpdmVuIHByb3RvY29sXG4gKiBAYXBpIHByaXZhdGVcbiAqL1xubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiByZXF1aXJlZChwb3J0LCBwcm90b2NvbCkge1xuICBwcm90b2NvbCA9IHByb3RvY29sLnNwbGl0KCc6JylbMF07XG4gIHBvcnQgPSArcG9ydDtcblxuICBpZiAoIXBvcnQpIHJldHVybiBmYWxzZTtcblxuICBzd2l0Y2ggKHByb3RvY29sKSB7XG4gICAgY2FzZSAnaHR0cCc6XG4gICAgY2FzZSAnd3MnOlxuICAgIHJldHVybiBwb3J0ICE9PSA4MDtcblxuICAgIGNhc2UgJ2h0dHBzJzpcbiAgICBjYXNlICd3c3MnOlxuICAgIHJldHVybiBwb3J0ICE9PSA0NDM7XG5cbiAgICBjYXNlICdmdHAnOlxuICAgIHJldHVybiBwb3J0ICE9PSAyMTtcblxuICAgIGNhc2UgJ2dvcGhlcic6XG4gICAgcmV0dXJuIHBvcnQgIT09IDcwO1xuXG4gICAgY2FzZSAnZmlsZSc6XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG5cbiAgcmV0dXJuIHBvcnQgIT09IDA7XG59O1xuIiwibW9kdWxlLmV4cG9ydHMgPSByZXF1aXJlKCcuL2xpYi9yZXRyeScpOyIsInZhciBSZXRyeU9wZXJhdGlvbiA9IHJlcXVpcmUoJy4vcmV0cnlfb3BlcmF0aW9uJyk7XG5cbmV4cG9ydHMub3BlcmF0aW9uID0gZnVuY3Rpb24ob3B0aW9ucykge1xuICB2YXIgdGltZW91dHMgPSBleHBvcnRzLnRpbWVvdXRzKG9wdGlvbnMpO1xuICByZXR1cm4gbmV3IFJldHJ5T3BlcmF0aW9uKHRpbWVvdXRzLCB7XG4gICAgICBmb3JldmVyOiBvcHRpb25zICYmIG9wdGlvbnMuZm9yZXZlcixcbiAgICAgIHVucmVmOiBvcHRpb25zICYmIG9wdGlvbnMudW5yZWZcbiAgfSk7XG59O1xuXG5leHBvcnRzLnRpbWVvdXRzID0gZnVuY3Rpb24ob3B0aW9ucykge1xuICBpZiAob3B0aW9ucyBpbnN0YW5jZW9mIEFycmF5KSB7XG4gICAgcmV0dXJuIFtdLmNvbmNhdChvcHRpb25zKTtcbiAgfVxuXG4gIHZhciBvcHRzID0ge1xuICAgIHJldHJpZXM6IDEwLFxuICAgIGZhY3RvcjogMixcbiAgICBtaW5UaW1lb3V0OiAxICogMTAwMCxcbiAgICBtYXhUaW1lb3V0OiBJbmZpbml0eSxcbiAgICByYW5kb21pemU6IGZhbHNlXG4gIH07XG4gIGZvciAodmFyIGtleSBpbiBvcHRpb25zKSB7XG4gICAgb3B0c1trZXldID0gb3B0aW9uc1trZXldO1xuICB9XG5cbiAgaWYgKG9wdHMubWluVGltZW91dCA+IG9wdHMubWF4VGltZW91dCkge1xuICAgIHRocm93IG5ldyBFcnJvcignbWluVGltZW91dCBpcyBncmVhdGVyIHRoYW4gbWF4VGltZW91dCcpO1xuICB9XG5cbiAgdmFyIHRpbWVvdXRzID0gW107XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgb3B0cy5yZXRyaWVzOyBpKyspIHtcbiAgICB0aW1lb3V0cy5wdXNoKHRoaXMuY3JlYXRlVGltZW91dChpLCBvcHRzKSk7XG4gIH1cblxuICBpZiAob3B0aW9ucyAmJiBvcHRpb25zLmZvcmV2ZXIgJiYgIXRpbWVvdXRzLmxlbmd0aCkge1xuICAgIHRpbWVvdXRzLnB1c2godGhpcy5jcmVhdGVUaW1lb3V0KGksIG9wdHMpKTtcbiAgfVxuXG4gIC8vIHNvcnQgdGhlIGFycmF5IG51bWVyaWNhbGx5IGFzY2VuZGluZ1xuICB0aW1lb3V0cy5zb3J0KGZ1bmN0aW9uKGEsYikge1xuICAgIHJldHVybiBhIC0gYjtcbiAgfSk7XG5cbiAgcmV0dXJuIHRpbWVvdXRzO1xufTtcblxuZXhwb3J0cy5jcmVhdGVUaW1lb3V0ID0gZnVuY3Rpb24oYXR0ZW1wdCwgb3B0cykge1xuICB2YXIgcmFuZG9tID0gKG9wdHMucmFuZG9taXplKVxuICAgID8gKE1hdGgucmFuZG9tKCkgKyAxKVxuICAgIDogMTtcblxuICB2YXIgdGltZW91dCA9IE1hdGgucm91bmQocmFuZG9tICogb3B0cy5taW5UaW1lb3V0ICogTWF0aC5wb3cob3B0cy5mYWN0b3IsIGF0dGVtcHQpKTtcbiAgdGltZW91dCA9IE1hdGgubWluKHRpbWVvdXQsIG9wdHMubWF4VGltZW91dCk7XG5cbiAgcmV0dXJuIHRpbWVvdXQ7XG59O1xuXG5leHBvcnRzLndyYXAgPSBmdW5jdGlvbihvYmosIG9wdGlvbnMsIG1ldGhvZHMpIHtcbiAgaWYgKG9wdGlvbnMgaW5zdGFuY2VvZiBBcnJheSkge1xuICAgIG1ldGhvZHMgPSBvcHRpb25zO1xuICAgIG9wdGlvbnMgPSBudWxsO1xuICB9XG5cbiAgaWYgKCFtZXRob2RzKSB7XG4gICAgbWV0aG9kcyA9IFtdO1xuICAgIGZvciAodmFyIGtleSBpbiBvYmopIHtcbiAgICAgIGlmICh0eXBlb2Ygb2JqW2tleV0gPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgbWV0aG9kcy5wdXNoKGtleSk7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBtZXRob2RzLmxlbmd0aDsgaSsrKSB7XG4gICAgdmFyIG1ldGhvZCAgID0gbWV0aG9kc1tpXTtcbiAgICB2YXIgb3JpZ2luYWwgPSBvYmpbbWV0aG9kXTtcblxuICAgIG9ialttZXRob2RdID0gZnVuY3Rpb24gcmV0cnlXcmFwcGVyKCkge1xuICAgICAgdmFyIG9wICAgICAgID0gZXhwb3J0cy5vcGVyYXRpb24ob3B0aW9ucyk7XG4gICAgICB2YXIgYXJncyAgICAgPSBBcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbChhcmd1bWVudHMpO1xuICAgICAgdmFyIGNhbGxiYWNrID0gYXJncy5wb3AoKTtcblxuICAgICAgYXJncy5wdXNoKGZ1bmN0aW9uKGVycikge1xuICAgICAgICBpZiAob3AucmV0cnkoZXJyKSkge1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBpZiAoZXJyKSB7XG4gICAgICAgICAgYXJndW1lbnRzWzBdID0gb3AubWFpbkVycm9yKCk7XG4gICAgICAgIH1cbiAgICAgICAgY2FsbGJhY2suYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICAgIH0pO1xuXG4gICAgICBvcC5hdHRlbXB0KGZ1bmN0aW9uKCkge1xuICAgICAgICBvcmlnaW5hbC5hcHBseShvYmosIGFyZ3MpO1xuICAgICAgfSk7XG4gICAgfTtcbiAgICBvYmpbbWV0aG9kXS5vcHRpb25zID0gb3B0aW9ucztcbiAgfVxufTtcbiIsImZ1bmN0aW9uIFJldHJ5T3BlcmF0aW9uKHRpbWVvdXRzLCBvcHRpb25zKSB7XG4gIC8vIENvbXBhdGliaWxpdHkgZm9yIHRoZSBvbGQgKHRpbWVvdXRzLCByZXRyeUZvcmV2ZXIpIHNpZ25hdHVyZVxuICBpZiAodHlwZW9mIG9wdGlvbnMgPT09ICdib29sZWFuJykge1xuICAgIG9wdGlvbnMgPSB7IGZvcmV2ZXI6IG9wdGlvbnMgfTtcbiAgfVxuXG4gIHRoaXMuX3RpbWVvdXRzID0gdGltZW91dHM7XG4gIHRoaXMuX29wdGlvbnMgPSBvcHRpb25zIHx8IHt9O1xuICB0aGlzLl9mbiA9IG51bGw7XG4gIHRoaXMuX2Vycm9ycyA9IFtdO1xuICB0aGlzLl9hdHRlbXB0cyA9IDE7XG4gIHRoaXMuX29wZXJhdGlvblRpbWVvdXQgPSBudWxsO1xuICB0aGlzLl9vcGVyYXRpb25UaW1lb3V0Q2IgPSBudWxsO1xuICB0aGlzLl90aW1lb3V0ID0gbnVsbDtcblxuICBpZiAodGhpcy5fb3B0aW9ucy5mb3JldmVyKSB7XG4gICAgdGhpcy5fY2FjaGVkVGltZW91dHMgPSB0aGlzLl90aW1lb3V0cy5zbGljZSgwKTtcbiAgfVxufVxubW9kdWxlLmV4cG9ydHMgPSBSZXRyeU9wZXJhdGlvbjtcblxuUmV0cnlPcGVyYXRpb24ucHJvdG90eXBlLnN0b3AgPSBmdW5jdGlvbigpIHtcbiAgaWYgKHRoaXMuX3RpbWVvdXQpIHtcbiAgICBjbGVhclRpbWVvdXQodGhpcy5fdGltZW91dCk7XG4gIH1cblxuICB0aGlzLl90aW1lb3V0cyAgICAgICA9IFtdO1xuICB0aGlzLl9jYWNoZWRUaW1lb3V0cyA9IG51bGw7XG59O1xuXG5SZXRyeU9wZXJhdGlvbi5wcm90b3R5cGUucmV0cnkgPSBmdW5jdGlvbihlcnIpIHtcbiAgaWYgKHRoaXMuX3RpbWVvdXQpIHtcbiAgICBjbGVhclRpbWVvdXQodGhpcy5fdGltZW91dCk7XG4gIH1cblxuICBpZiAoIWVycikge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuXG4gIHRoaXMuX2Vycm9ycy5wdXNoKGVycik7XG5cbiAgdmFyIHRpbWVvdXQgPSB0aGlzLl90aW1lb3V0cy5zaGlmdCgpO1xuICBpZiAodGltZW91dCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgaWYgKHRoaXMuX2NhY2hlZFRpbWVvdXRzKSB7XG4gICAgICAvLyByZXRyeSBmb3JldmVyLCBvbmx5IGtlZXAgbGFzdCBlcnJvclxuICAgICAgdGhpcy5fZXJyb3JzLnNwbGljZSh0aGlzLl9lcnJvcnMubGVuZ3RoIC0gMSwgdGhpcy5fZXJyb3JzLmxlbmd0aCk7XG4gICAgICB0aGlzLl90aW1lb3V0cyA9IHRoaXMuX2NhY2hlZFRpbWVvdXRzLnNsaWNlKDApO1xuICAgICAgdGltZW91dCA9IHRoaXMuX3RpbWVvdXRzLnNoaWZ0KCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gIH1cblxuICB2YXIgc2VsZiA9IHRoaXM7XG4gIHZhciB0aW1lciA9IHNldFRpbWVvdXQoZnVuY3Rpb24oKSB7XG4gICAgc2VsZi5fYXR0ZW1wdHMrKztcblxuICAgIGlmIChzZWxmLl9vcGVyYXRpb25UaW1lb3V0Q2IpIHtcbiAgICAgIHNlbGYuX3RpbWVvdXQgPSBzZXRUaW1lb3V0KGZ1bmN0aW9uKCkge1xuICAgICAgICBzZWxmLl9vcGVyYXRpb25UaW1lb3V0Q2Ioc2VsZi5fYXR0ZW1wdHMpO1xuICAgICAgfSwgc2VsZi5fb3BlcmF0aW9uVGltZW91dCk7XG5cbiAgICAgIGlmICh0aGlzLl9vcHRpb25zLnVucmVmKSB7XG4gICAgICAgICAgc2VsZi5fdGltZW91dC51bnJlZigpO1xuICAgICAgfVxuICAgIH1cblxuICAgIHNlbGYuX2ZuKHNlbGYuX2F0dGVtcHRzKTtcbiAgfSwgdGltZW91dCk7XG5cbiAgaWYgKHRoaXMuX29wdGlvbnMudW5yZWYpIHtcbiAgICAgIHRpbWVyLnVucmVmKCk7XG4gIH1cblxuICByZXR1cm4gdHJ1ZTtcbn07XG5cblJldHJ5T3BlcmF0aW9uLnByb3RvdHlwZS5hdHRlbXB0ID0gZnVuY3Rpb24oZm4sIHRpbWVvdXRPcHMpIHtcbiAgdGhpcy5fZm4gPSBmbjtcblxuICBpZiAodGltZW91dE9wcykge1xuICAgIGlmICh0aW1lb3V0T3BzLnRpbWVvdXQpIHtcbiAgICAgIHRoaXMuX29wZXJhdGlvblRpbWVvdXQgPSB0aW1lb3V0T3BzLnRpbWVvdXQ7XG4gICAgfVxuICAgIGlmICh0aW1lb3V0T3BzLmNiKSB7XG4gICAgICB0aGlzLl9vcGVyYXRpb25UaW1lb3V0Q2IgPSB0aW1lb3V0T3BzLmNiO1xuICAgIH1cbiAgfVxuXG4gIHZhciBzZWxmID0gdGhpcztcbiAgaWYgKHRoaXMuX29wZXJhdGlvblRpbWVvdXRDYikge1xuICAgIHRoaXMuX3RpbWVvdXQgPSBzZXRUaW1lb3V0KGZ1bmN0aW9uKCkge1xuICAgICAgc2VsZi5fb3BlcmF0aW9uVGltZW91dENiKCk7XG4gICAgfSwgc2VsZi5fb3BlcmF0aW9uVGltZW91dCk7XG4gIH1cblxuICB0aGlzLl9mbih0aGlzLl9hdHRlbXB0cyk7XG59O1xuXG5SZXRyeU9wZXJhdGlvbi5wcm90b3R5cGUudHJ5ID0gZnVuY3Rpb24oZm4pIHtcbiAgY29uc29sZS5sb2coJ1VzaW5nIFJldHJ5T3BlcmF0aW9uLnRyeSgpIGlzIGRlcHJlY2F0ZWQnKTtcbiAgdGhpcy5hdHRlbXB0KGZuKTtcbn07XG5cblJldHJ5T3BlcmF0aW9uLnByb3RvdHlwZS5zdGFydCA9IGZ1bmN0aW9uKGZuKSB7XG4gIGNvbnNvbGUubG9nKCdVc2luZyBSZXRyeU9wZXJhdGlvbi5zdGFydCgpIGlzIGRlcHJlY2F0ZWQnKTtcbiAgdGhpcy5hdHRlbXB0KGZuKTtcbn07XG5cblJldHJ5T3BlcmF0aW9uLnByb3RvdHlwZS5zdGFydCA9IFJldHJ5T3BlcmF0aW9uLnByb3RvdHlwZS50cnk7XG5cblJldHJ5T3BlcmF0aW9uLnByb3RvdHlwZS5lcnJvcnMgPSBmdW5jdGlvbigpIHtcbiAgcmV0dXJuIHRoaXMuX2Vycm9ycztcbn07XG5cblJldHJ5T3BlcmF0aW9uLnByb3RvdHlwZS5hdHRlbXB0cyA9IGZ1bmN0aW9uKCkge1xuICByZXR1cm4gdGhpcy5fYXR0ZW1wdHM7XG59O1xuXG5SZXRyeU9wZXJhdGlvbi5wcm90b3R5cGUubWFpbkVycm9yID0gZnVuY3Rpb24oKSB7XG4gIGlmICh0aGlzLl9lcnJvcnMubGVuZ3RoID09PSAwKSB7XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cblxuICB2YXIgY291bnRzID0ge307XG4gIHZhciBtYWluRXJyb3IgPSBudWxsO1xuICB2YXIgbWFpbkVycm9yQ291bnQgPSAwO1xuXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgdGhpcy5fZXJyb3JzLmxlbmd0aDsgaSsrKSB7XG4gICAgdmFyIGVycm9yID0gdGhpcy5fZXJyb3JzW2ldO1xuICAgIHZhciBtZXNzYWdlID0gZXJyb3IubWVzc2FnZTtcbiAgICB2YXIgY291bnQgPSAoY291bnRzW21lc3NhZ2VdIHx8IDApICsgMTtcblxuICAgIGNvdW50c1ttZXNzYWdlXSA9IGNvdW50O1xuXG4gICAgaWYgKGNvdW50ID49IG1haW5FcnJvckNvdW50KSB7XG4gICAgICBtYWluRXJyb3IgPSBlcnJvcjtcbiAgICAgIG1haW5FcnJvckNvdW50ID0gY291bnQ7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIG1haW5FcnJvcjtcbn07XG4iLCJ2YXIgZ3JhbW1hciA9IG1vZHVsZS5leHBvcnRzID0ge1xuICB2OiBbe1xuICAgIG5hbWU6ICd2ZXJzaW9uJyxcbiAgICByZWc6IC9eKFxcZCopJC9cbiAgfV0sXG4gIG86IFt7IC8vbz0tIDIwNTE4IDAgSU4gSVA0IDIwMy4wLjExMy4xXG4gICAgLy8gTkI6IHNlc3Npb25JZCB3aWxsIGJlIGEgU3RyaW5nIGluIG1vc3QgY2FzZXMgYmVjYXVzZSBpdCBpcyBodWdlXG4gICAgbmFtZTogJ29yaWdpbicsXG4gICAgcmVnOiAvXihcXFMqKSAoXFxkKikgKFxcZCopIChcXFMqKSBJUChcXGQpIChcXFMqKS8sXG4gICAgbmFtZXM6IFsndXNlcm5hbWUnLCAnc2Vzc2lvbklkJywgJ3Nlc3Npb25WZXJzaW9uJywgJ25ldFR5cGUnLCAnaXBWZXInLCAnYWRkcmVzcyddLFxuICAgIGZvcm1hdDogJyVzICVzICVkICVzIElQJWQgJXMnXG4gIH1dLFxuICAvLyBkZWZhdWx0IHBhcnNpbmcgb2YgdGhlc2Ugb25seSAodGhvdWdoIHNvbWUgb2YgdGhlc2UgZmVlbCBvdXRkYXRlZClcbiAgczogW3sgbmFtZTogJ25hbWUnIH1dLFxuICBpOiBbeyBuYW1lOiAnZGVzY3JpcHRpb24nIH1dLFxuICB1OiBbeyBuYW1lOiAndXJpJyB9XSxcbiAgZTogW3sgbmFtZTogJ2VtYWlsJyB9XSxcbiAgcDogW3sgbmFtZTogJ3Bob25lJyB9XSxcbiAgejogW3sgbmFtZTogJ3RpbWV6b25lcycgfV0sIC8vIFRPRE86IHRoaXMgb25lIGNhbiBhY3R1YWxseSBiZSBwYXJzZWQgcHJvcGVybHkuLlxuICByOiBbeyBuYW1lOiAncmVwZWF0cycgfV0sICAgLy8gVE9ETzogdGhpcyBvbmUgY2FuIGFsc28gYmUgcGFyc2VkIHByb3Blcmx5XG4gIC8vazogW3t9XSwgLy8gb3V0ZGF0ZWQgdGhpbmcgaWdub3JlZFxuICB0OiBbeyAvL3Q9MCAwXG4gICAgbmFtZTogJ3RpbWluZycsXG4gICAgcmVnOiAvXihcXGQqKSAoXFxkKikvLFxuICAgIG5hbWVzOiBbJ3N0YXJ0JywgJ3N0b3AnXSxcbiAgICBmb3JtYXQ6ICclZCAlZCdcbiAgfV0sXG4gIGM6IFt7IC8vYz1JTiBJUDQgMTAuNDcuMTk3LjI2XG4gICAgbmFtZTogJ2Nvbm5lY3Rpb24nLFxuICAgIHJlZzogL15JTiBJUChcXGQpIChcXFMqKS8sXG4gICAgbmFtZXM6IFsndmVyc2lvbicsICdpcCddLFxuICAgIGZvcm1hdDogJ0lOIElQJWQgJXMnXG4gIH1dLFxuICBiOiBbeyAvL2I9QVM6NDAwMFxuICAgIHB1c2g6ICdiYW5kd2lkdGgnLFxuICAgIHJlZzogL14oVElBU3xBU3xDVHxSUnxSUyk6KFxcZCopLyxcbiAgICBuYW1lczogWyd0eXBlJywgJ2xpbWl0J10sXG4gICAgZm9ybWF0OiAnJXM6JXMnXG4gIH1dLFxuICBtOiBbeyAvL209dmlkZW8gNTE3NDQgUlRQL0FWUCAxMjYgOTcgOTggMzQgMzFcbiAgICAvLyBOQjogc3BlY2lhbCAtIHB1c2hlcyB0byBzZXNzaW9uXG4gICAgLy8gVE9ETzogcnRwL2ZtdHAgc2hvdWxkIGJlIGZpbHRlcmVkIGJ5IHRoZSBwYXlsb2FkcyBmb3VuZCBoZXJlP1xuICAgIHJlZzogL14oXFx3KikgKFxcZCopIChbXFx3XFwvXSopKD86ICguKikpPy8sXG4gICAgbmFtZXM6IFsndHlwZScsICdwb3J0JywgJ3Byb3RvY29sJywgJ3BheWxvYWRzJ10sXG4gICAgZm9ybWF0OiAnJXMgJWQgJXMgJXMnXG4gIH1dLFxuICBhOiBbXG4gICAgeyAvL2E9cnRwbWFwOjExMCBvcHVzLzQ4MDAwLzJcbiAgICAgIHB1c2g6ICdydHAnLFxuICAgICAgcmVnOiAvXnJ0cG1hcDooXFxkKikgKFtcXHdcXC1cXC5dKikoPzpcXHMqXFwvKFxcZCopKD86XFxzKlxcLyhcXFMqKSk/KT8vLFxuICAgICAgbmFtZXM6IFsncGF5bG9hZCcsICdjb2RlYycsICdyYXRlJywgJ2VuY29kaW5nJ10sXG4gICAgICBmb3JtYXQ6IGZ1bmN0aW9uIChvKSB7XG4gICAgICAgIHJldHVybiAoby5lbmNvZGluZykgP1xuICAgICAgICAgICdydHBtYXA6JWQgJXMvJXMvJXMnOlxuICAgICAgICAgIG8ucmF0ZSA/XG4gICAgICAgICAgJ3J0cG1hcDolZCAlcy8lcyc6XG4gICAgICAgICAgJ3J0cG1hcDolZCAlcyc7XG4gICAgICB9XG4gICAgfSxcbiAgICB7IC8vYT1mbXRwOjEwOCBwcm9maWxlLWxldmVsLWlkPTI0O29iamVjdD0yMztiaXRyYXRlPTY0MDAwXG4gICAgICAvL2E9Zm10cDoxMTEgbWlucHRpbWU9MTA7IHVzZWluYmFuZGZlYz0xXG4gICAgICBwdXNoOiAnZm10cCcsXG4gICAgICByZWc6IC9eZm10cDooXFxkKikgKFtcXFN8IF0qKS8sXG4gICAgICBuYW1lczogWydwYXlsb2FkJywgJ2NvbmZpZyddLFxuICAgICAgZm9ybWF0OiAnZm10cDolZCAlcydcbiAgICB9LFxuICAgIHsgLy9hPWNvbnRyb2w6c3RyZWFtaWQ9MFxuICAgICAgbmFtZTogJ2NvbnRyb2wnLFxuICAgICAgcmVnOiAvXmNvbnRyb2w6KC4qKS8sXG4gICAgICBmb3JtYXQ6ICdjb250cm9sOiVzJ1xuICAgIH0sXG4gICAgeyAvL2E9cnRjcDo2NTE3OSBJTiBJUDQgMTkzLjg0Ljc3LjE5NFxuICAgICAgbmFtZTogJ3J0Y3AnLFxuICAgICAgcmVnOiAvXnJ0Y3A6KFxcZCopKD86IChcXFMqKSBJUChcXGQpIChcXFMqKSk/LyxcbiAgICAgIG5hbWVzOiBbJ3BvcnQnLCAnbmV0VHlwZScsICdpcFZlcicsICdhZGRyZXNzJ10sXG4gICAgICBmb3JtYXQ6IGZ1bmN0aW9uIChvKSB7XG4gICAgICAgIHJldHVybiAoby5hZGRyZXNzICE9IG51bGwpID9cbiAgICAgICAgICAncnRjcDolZCAlcyBJUCVkICVzJzpcbiAgICAgICAgICAncnRjcDolZCc7XG4gICAgICB9XG4gICAgfSxcbiAgICB7IC8vYT1ydGNwLWZiOjk4IHRyci1pbnQgMTAwXG4gICAgICBwdXNoOiAncnRjcEZiVHJySW50JyxcbiAgICAgIHJlZzogL15ydGNwLWZiOihcXCp8XFxkKikgdHJyLWludCAoXFxkKikvLFxuICAgICAgbmFtZXM6IFsncGF5bG9hZCcsICd2YWx1ZSddLFxuICAgICAgZm9ybWF0OiAncnRjcC1mYjolZCB0cnItaW50ICVkJ1xuICAgIH0sXG4gICAgeyAvL2E9cnRjcC1mYjo5OCBuYWNrIHJwc2lcbiAgICAgIHB1c2g6ICdydGNwRmInLFxuICAgICAgcmVnOiAvXnJ0Y3AtZmI6KFxcKnxcXGQqKSAoW1xcdy1fXSopKD86IChbXFx3LV9dKikpPy8sXG4gICAgICBuYW1lczogWydwYXlsb2FkJywgJ3R5cGUnLCAnc3VidHlwZSddLFxuICAgICAgZm9ybWF0OiBmdW5jdGlvbiAobykge1xuICAgICAgICByZXR1cm4gKG8uc3VidHlwZSAhPSBudWxsKSA/XG4gICAgICAgICAgJ3J0Y3AtZmI6JXMgJXMgJXMnOlxuICAgICAgICAgICdydGNwLWZiOiVzICVzJztcbiAgICAgIH1cbiAgICB9LFxuICAgIHsgLy9hPWV4dG1hcDoyIHVybjppZXRmOnBhcmFtczpydHAtaGRyZXh0OnRvZmZzZXRcbiAgICAgIC8vYT1leHRtYXA6MS9yZWN2b25seSBVUkktZ3BzLXN0cmluZ1xuICAgICAgcHVzaDogJ2V4dCcsXG4gICAgICByZWc6IC9eZXh0bWFwOihcXGQrKSg/OlxcLyhcXHcrKSk/IChcXFMqKSg/OiAoXFxTKikpPy8sXG4gICAgICBuYW1lczogWyd2YWx1ZScsICdkaXJlY3Rpb24nLCAndXJpJywgJ2NvbmZpZyddLFxuICAgICAgZm9ybWF0OiBmdW5jdGlvbiAobykge1xuICAgICAgICByZXR1cm4gJ2V4dG1hcDolZCcgKyAoby5kaXJlY3Rpb24gPyAnLyVzJyA6ICcldicpICsgJyAlcycgKyAoby5jb25maWcgPyAnICVzJyA6ICcnKTtcbiAgICAgIH1cbiAgICB9LFxuICAgIHsgLy9hPWNyeXB0bzoxIEFFU19DTV8xMjhfSE1BQ19TSEExXzgwIGlubGluZTpQUzF1UUNWZWVDRkNhblZtY2prcFB5d2pOV2hjWUQwbVhYdHhhVkJSfDJeMjB8MTozMlxuICAgICAgcHVzaDogJ2NyeXB0bycsXG4gICAgICByZWc6IC9eY3J5cHRvOihcXGQqKSAoW1xcd19dKikgKFxcUyopKD86IChcXFMqKSk/LyxcbiAgICAgIG5hbWVzOiBbJ2lkJywgJ3N1aXRlJywgJ2NvbmZpZycsICdzZXNzaW9uQ29uZmlnJ10sXG4gICAgICBmb3JtYXQ6IGZ1bmN0aW9uIChvKSB7XG4gICAgICAgIHJldHVybiAoby5zZXNzaW9uQ29uZmlnICE9IG51bGwpID9cbiAgICAgICAgICAnY3J5cHRvOiVkICVzICVzICVzJzpcbiAgICAgICAgICAnY3J5cHRvOiVkICVzICVzJztcbiAgICAgIH1cbiAgICB9LFxuICAgIHsgLy9hPXNldHVwOmFjdHBhc3NcbiAgICAgIG5hbWU6ICdzZXR1cCcsXG4gICAgICByZWc6IC9ec2V0dXA6KFxcdyopLyxcbiAgICAgIGZvcm1hdDogJ3NldHVwOiVzJ1xuICAgIH0sXG4gICAgeyAvL2E9bWlkOjFcbiAgICAgIG5hbWU6ICdtaWQnLFxuICAgICAgcmVnOiAvXm1pZDooW15cXHNdKikvLFxuICAgICAgZm9ybWF0OiAnbWlkOiVzJ1xuICAgIH0sXG4gICAgeyAvL2E9bXNpZDowYzhiMDY0ZC1kODA3LTQzYjQtYjQzNC1mOTJhODg5ZDg1ODcgOTgxNzg2ODUtZDQwOS00NmUwLThlMTYtN2VmMGRiMGRiNjRhXG4gICAgICBuYW1lOiAnbXNpZCcsXG4gICAgICByZWc6IC9ebXNpZDooLiopLyxcbiAgICAgIGZvcm1hdDogJ21zaWQ6JXMnXG4gICAgfSxcbiAgICB7IC8vYT1wdGltZToyMFxuICAgICAgbmFtZTogJ3B0aW1lJyxcbiAgICAgIHJlZzogL15wdGltZTooXFxkKikvLFxuICAgICAgZm9ybWF0OiAncHRpbWU6JWQnXG4gICAgfSxcbiAgICB7IC8vYT1tYXhwdGltZTo2MFxuICAgICAgbmFtZTogJ21heHB0aW1lJyxcbiAgICAgIHJlZzogL15tYXhwdGltZTooXFxkKikvLFxuICAgICAgZm9ybWF0OiAnbWF4cHRpbWU6JWQnXG4gICAgfSxcbiAgICB7IC8vYT1zZW5kcmVjdlxuICAgICAgbmFtZTogJ2RpcmVjdGlvbicsXG4gICAgICByZWc6IC9eKHNlbmRyZWN2fHJlY3Zvbmx5fHNlbmRvbmx5fGluYWN0aXZlKS9cbiAgICB9LFxuICAgIHsgLy9hPWljZS1saXRlXG4gICAgICBuYW1lOiAnaWNlbGl0ZScsXG4gICAgICByZWc6IC9eKGljZS1saXRlKS9cbiAgICB9LFxuICAgIHsgLy9hPWljZS11ZnJhZzpGN2dJXG4gICAgICBuYW1lOiAnaWNlVWZyYWcnLFxuICAgICAgcmVnOiAvXmljZS11ZnJhZzooXFxTKikvLFxuICAgICAgZm9ybWF0OiAnaWNlLXVmcmFnOiVzJ1xuICAgIH0sXG4gICAgeyAvL2E9aWNlLXB3ZDp4OWNtbC9ZemljaFYyK1hsaGlNdThnXG4gICAgICBuYW1lOiAnaWNlUHdkJyxcbiAgICAgIHJlZzogL15pY2UtcHdkOihcXFMqKS8sXG4gICAgICBmb3JtYXQ6ICdpY2UtcHdkOiVzJ1xuICAgIH0sXG4gICAgeyAvL2E9ZmluZ2VycHJpbnQ6U0hBLTEgMDA6MTE6MjI6MzM6NDQ6NTU6NjY6Nzc6ODg6OTk6QUE6QkI6Q0M6REQ6RUU6RkY6MDA6MTE6MjI6MzNcbiAgICAgIG5hbWU6ICdmaW5nZXJwcmludCcsXG4gICAgICByZWc6IC9eZmluZ2VycHJpbnQ6KFxcUyopIChcXFMqKS8sXG4gICAgICBuYW1lczogWyd0eXBlJywgJ2hhc2gnXSxcbiAgICAgIGZvcm1hdDogJ2ZpbmdlcnByaW50OiVzICVzJ1xuICAgIH0sXG4gICAgeyAvL2E9Y2FuZGlkYXRlOjAgMSBVRFAgMjExMzY2NzMyNyAyMDMuMC4xMTMuMSA1NDQwMCB0eXAgaG9zdFxuICAgICAgLy9hPWNhbmRpZGF0ZToxMTYyODc1MDgxIDEgdWRwIDIxMTM5MzcxNTEgMTkyLjE2OC4zNC43NSA2MDAxNyB0eXAgaG9zdCBnZW5lcmF0aW9uIDAgbmV0d29yay1pZCAzIG5ldHdvcmstY29zdCAxMFxuICAgICAgLy9hPWNhbmRpZGF0ZTozMjg5OTEyOTU3IDIgdWRwIDE4NDU1MDE2OTUgMTkzLjg0Ljc3LjE5NCA2MDAxNyB0eXAgc3JmbHggcmFkZHIgMTkyLjE2OC4zNC43NSBycG9ydCA2MDAxNyBnZW5lcmF0aW9uIDAgbmV0d29yay1pZCAzIG5ldHdvcmstY29zdCAxMFxuICAgICAgLy9hPWNhbmRpZGF0ZToyMjk4MTU2MjAgMSB0Y3AgMTUxODI4MDQ0NyAxOTIuMTY4LjE1MC4xOSA2MDAxNyB0eXAgaG9zdCB0Y3B0eXBlIGFjdGl2ZSBnZW5lcmF0aW9uIDAgbmV0d29yay1pZCAzIG5ldHdvcmstY29zdCAxMFxuICAgICAgLy9hPWNhbmRpZGF0ZTozMjg5OTEyOTU3IDIgdGNwIDE4NDU1MDE2OTUgMTkzLjg0Ljc3LjE5NCA2MDAxNyB0eXAgc3JmbHggcmFkZHIgMTkyLjE2OC4zNC43NSBycG9ydCA2MDAxNyB0Y3B0eXBlIHBhc3NpdmUgZ2VuZXJhdGlvbiAwIG5ldHdvcmstaWQgMyBuZXR3b3JrLWNvc3QgMTBcbiAgICAgIHB1c2g6J2NhbmRpZGF0ZXMnLFxuICAgICAgcmVnOiAvXmNhbmRpZGF0ZTooXFxTKikgKFxcZCopIChcXFMqKSAoXFxkKikgKFxcUyopIChcXGQqKSB0eXAgKFxcUyopKD86IHJhZGRyIChcXFMqKSBycG9ydCAoXFxkKikpPyg/OiB0Y3B0eXBlIChcXFMqKSk/KD86IGdlbmVyYXRpb24gKFxcZCopKT8oPzogbmV0d29yay1pZCAoXFxkKikpPyg/OiBuZXR3b3JrLWNvc3QgKFxcZCopKT8vLFxuICAgICAgbmFtZXM6IFsnZm91bmRhdGlvbicsICdjb21wb25lbnQnLCAndHJhbnNwb3J0JywgJ3ByaW9yaXR5JywgJ2lwJywgJ3BvcnQnLCAndHlwZScsICdyYWRkcicsICdycG9ydCcsICd0Y3B0eXBlJywgJ2dlbmVyYXRpb24nLCAnbmV0d29yay1pZCcsICduZXR3b3JrLWNvc3QnXSxcbiAgICAgIGZvcm1hdDogZnVuY3Rpb24gKG8pIHtcbiAgICAgICAgdmFyIHN0ciA9ICdjYW5kaWRhdGU6JXMgJWQgJXMgJWQgJXMgJWQgdHlwICVzJztcblxuICAgICAgICBzdHIgKz0gKG8ucmFkZHIgIT0gbnVsbCkgPyAnIHJhZGRyICVzIHJwb3J0ICVkJyA6ICcldiV2JztcblxuICAgICAgICAvLyBOQjogY2FuZGlkYXRlIGhhcyB0aHJlZSBvcHRpb25hbCBjaHVua3MsIHNvICV2b2lkIG1pZGRsZXMgb25lIGlmIGl0J3MgbWlzc2luZ1xuICAgICAgICBzdHIgKz0gKG8udGNwdHlwZSAhPSBudWxsKSA/ICcgdGNwdHlwZSAlcycgOiAnJXYnO1xuXG4gICAgICAgIGlmIChvLmdlbmVyYXRpb24gIT0gbnVsbCkge1xuICAgICAgICAgIHN0ciArPSAnIGdlbmVyYXRpb24gJWQnO1xuICAgICAgICB9XG5cbiAgICAgICAgc3RyICs9IChvWyduZXR3b3JrLWlkJ10gIT0gbnVsbCkgPyAnIG5ldHdvcmstaWQgJWQnIDogJyV2JztcbiAgICAgICAgc3RyICs9IChvWyduZXR3b3JrLWNvc3QnXSAhPSBudWxsKSA/ICcgbmV0d29yay1jb3N0ICVkJyA6ICcldic7XG4gICAgICAgIHJldHVybiBzdHI7XG4gICAgICB9XG4gICAgfSxcbiAgICB7IC8vYT1lbmQtb2YtY2FuZGlkYXRlcyAoa2VlcCBhZnRlciB0aGUgY2FuZGlkYXRlcyBsaW5lIGZvciByZWFkYWJpbGl0eSlcbiAgICAgIG5hbWU6ICdlbmRPZkNhbmRpZGF0ZXMnLFxuICAgICAgcmVnOiAvXihlbmQtb2YtY2FuZGlkYXRlcykvXG4gICAgfSxcbiAgICB7IC8vYT1yZW1vdGUtY2FuZGlkYXRlczoxIDIwMy4wLjExMy4xIDU0NDAwIDIgMjAzLjAuMTEzLjEgNTQ0MDEgLi4uXG4gICAgICBuYW1lOiAncmVtb3RlQ2FuZGlkYXRlcycsXG4gICAgICByZWc6IC9ecmVtb3RlLWNhbmRpZGF0ZXM6KC4qKS8sXG4gICAgICBmb3JtYXQ6ICdyZW1vdGUtY2FuZGlkYXRlczolcydcbiAgICB9LFxuICAgIHsgLy9hPWljZS1vcHRpb25zOmdvb2dsZS1pY2VcbiAgICAgIG5hbWU6ICdpY2VPcHRpb25zJyxcbiAgICAgIHJlZzogL15pY2Utb3B0aW9uczooXFxTKikvLFxuICAgICAgZm9ybWF0OiAnaWNlLW9wdGlvbnM6JXMnXG4gICAgfSxcbiAgICB7IC8vYT1zc3JjOjI1NjYxMDc1NjkgY25hbWU6dDlZVThNMVV4VEY4WTFBMVxuICAgICAgcHVzaDogJ3NzcmNzJyxcbiAgICAgIHJlZzogL15zc3JjOihcXGQqKSAoW1xcd18tXSopKD86OiguKikpPy8sXG4gICAgICBuYW1lczogWydpZCcsICdhdHRyaWJ1dGUnLCAndmFsdWUnXSxcbiAgICAgIGZvcm1hdDogZnVuY3Rpb24gKG8pIHtcbiAgICAgICAgdmFyIHN0ciA9ICdzc3JjOiVkJztcbiAgICAgICAgaWYgKG8uYXR0cmlidXRlICE9IG51bGwpIHtcbiAgICAgICAgICBzdHIgKz0gJyAlcyc7XG4gICAgICAgICAgaWYgKG8udmFsdWUgIT0gbnVsbCkge1xuICAgICAgICAgICAgc3RyICs9ICc6JXMnO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gc3RyO1xuICAgICAgfVxuICAgIH0sXG4gICAgeyAvL2E9c3NyYy1ncm91cDpGRUMgMSAyXG4gICAgICAvL2E9c3NyYy1ncm91cDpGRUMtRlIgMzAwNDM2NDE5NSAxMDgwNzcyMjQxXG4gICAgICBwdXNoOiAnc3NyY0dyb3VwcycsXG4gICAgICAvLyB0b2tlbi1jaGFyID0gJXgyMSAvICV4MjMtMjcgLyAleDJBLTJCIC8gJXgyRC0yRSAvICV4MzAtMzkgLyAleDQxLTVBIC8gJXg1RS03RVxuICAgICAgcmVnOiAvXnNzcmMtZ3JvdXA6KFtcXHgyMVxceDIzXFx4MjRcXHgyNVxceDI2XFx4MjdcXHgyQVxceDJCXFx4MkRcXHgyRVxcd10qKSAoLiopLyxcbiAgICAgIG5hbWVzOiBbJ3NlbWFudGljcycsICdzc3JjcyddLFxuICAgICAgZm9ybWF0OiAnc3NyYy1ncm91cDolcyAlcydcbiAgICB9LFxuICAgIHsgLy9hPW1zaWQtc2VtYW50aWM6IFdNUyBKdmxhbTVYM1NYMU9QNnBuMjB6V29ndmFLSno1SGpmOU9ubFZcbiAgICAgIG5hbWU6ICdtc2lkU2VtYW50aWMnLFxuICAgICAgcmVnOiAvXm1zaWQtc2VtYW50aWM6XFxzPyhcXHcqKSAoXFxTKikvLFxuICAgICAgbmFtZXM6IFsnc2VtYW50aWMnLCAndG9rZW4nXSxcbiAgICAgIGZvcm1hdDogJ21zaWQtc2VtYW50aWM6ICVzICVzJyAvLyBzcGFjZSBhZnRlciAnOicgaXMgbm90IGFjY2lkZW50YWxcbiAgICB9LFxuICAgIHsgLy9hPWdyb3VwOkJVTkRMRSBhdWRpbyB2aWRlb1xuICAgICAgcHVzaDogJ2dyb3VwcycsXG4gICAgICByZWc6IC9eZ3JvdXA6KFxcdyopICguKikvLFxuICAgICAgbmFtZXM6IFsndHlwZScsICdtaWRzJ10sXG4gICAgICBmb3JtYXQ6ICdncm91cDolcyAlcydcbiAgICB9LFxuICAgIHsgLy9hPXJ0Y3AtbXV4XG4gICAgICBuYW1lOiAncnRjcE11eCcsXG4gICAgICByZWc6IC9eKHJ0Y3AtbXV4KS9cbiAgICB9LFxuICAgIHsgLy9hPXJ0Y3AtcnNpemVcbiAgICAgIG5hbWU6ICdydGNwUnNpemUnLFxuICAgICAgcmVnOiAvXihydGNwLXJzaXplKS9cbiAgICB9LFxuICAgIHsgLy9hPXNjdHBtYXA6NTAwMCB3ZWJydGMtZGF0YWNoYW5uZWwgMTAyNFxuICAgICAgbmFtZTogJ3NjdHBtYXAnLFxuICAgICAgcmVnOiAvXnNjdHBtYXA6KFtcXHdfXFwvXSopIChcXFMqKSg/OiAoXFxTKikpPy8sXG4gICAgICBuYW1lczogWydzY3RwbWFwTnVtYmVyJywgJ2FwcCcsICdtYXhNZXNzYWdlU2l6ZSddLFxuICAgICAgZm9ybWF0OiBmdW5jdGlvbiAobykge1xuICAgICAgICByZXR1cm4gKG8ubWF4TWVzc2FnZVNpemUgIT0gbnVsbCkgP1xuICAgICAgICAgICdzY3RwbWFwOiVzICVzICVzJyA6XG4gICAgICAgICAgJ3NjdHBtYXA6JXMgJXMnO1xuICAgICAgfVxuICAgIH0sXG4gICAgeyAvL2E9eC1nb29nbGUtZmxhZzpjb25mZXJlbmNlXG4gICAgICBuYW1lOiAneEdvb2dsZUZsYWcnLFxuICAgICAgcmVnOiAvXngtZ29vZ2xlLWZsYWc6KFteXFxzXSopLyxcbiAgICAgIGZvcm1hdDogJ3gtZ29vZ2xlLWZsYWc6JXMnXG4gICAgfSxcbiAgICB7IC8vYT1yaWQ6MSBzZW5kIG1heC13aWR0aD0xMjgwO21heC1oZWlnaHQ9NzIwO21heC1mcHM9MzA7ZGVwZW5kPTBcbiAgICAgIHB1c2g6ICdyaWRzJyxcbiAgICAgIHJlZzogL15yaWQ6KFtcXGRcXHddKykgKFxcdyspKD86IChbXFxTfCBdKikpPy8sXG4gICAgICBuYW1lczogWydpZCcsICdkaXJlY3Rpb24nLCAncGFyYW1zJ10sXG4gICAgICBmb3JtYXQ6IGZ1bmN0aW9uIChvKSB7XG4gICAgICAgIHJldHVybiAoby5wYXJhbXMpID8gJ3JpZDolcyAlcyAlcycgOiAncmlkOiVzICVzJztcbiAgICAgIH1cbiAgICB9LFxuICAgIHsgLy9hPWltYWdlYXR0cjo5NyBzZW5kIFt4PTgwMCx5PTY0MCxzYXI9MS4xLHE9MC42XSBbeD00ODAseT0zMjBdIHJlY3YgW3g9MzMwLHk9MjUwXVxuICAgICAgLy9hPWltYWdlYXR0cjoqIHNlbmQgW3g9ODAwLHk9NjQwXSByZWN2ICpcbiAgICAgIC8vYT1pbWFnZWF0dHI6MTAwIHJlY3YgW3g9MzIwLHk9MjQwXVxuICAgICAgcHVzaDogJ2ltYWdlYXR0cnMnLFxuICAgICAgcmVnOiBuZXcgUmVnRXhwKFxuICAgICAgICAvL2E9aW1hZ2VhdHRyOjk3XG4gICAgICAgICdeaW1hZ2VhdHRyOihcXFxcZCt8XFxcXCopJyArXG4gICAgICAgIC8vc2VuZCBbeD04MDAseT02NDAsc2FyPTEuMSxxPTAuNl0gW3g9NDgwLHk9MzIwXVxuICAgICAgICAnW1xcXFxzXFxcXHRdKyhzZW5kfHJlY3YpW1xcXFxzXFxcXHRdKyhcXFxcKnxcXFxcW1xcXFxTK1xcXFxdKD86W1xcXFxzXFxcXHRdK1xcXFxbXFxcXFMrXFxcXF0pKiknICtcbiAgICAgICAgLy9yZWN2IFt4PTMzMCx5PTI1MF1cbiAgICAgICAgJyg/OltcXFxcc1xcXFx0XSsocmVjdnxzZW5kKVtcXFxcc1xcXFx0XSsoXFxcXCp8XFxcXFtcXFxcUytcXFxcXSg/OltcXFxcc1xcXFx0XStcXFxcW1xcXFxTK1xcXFxdKSopKT8nXG4gICAgICApLFxuICAgICAgbmFtZXM6IFsncHQnLCAnZGlyMScsICdhdHRyczEnLCAnZGlyMicsICdhdHRyczInXSxcbiAgICAgIGZvcm1hdDogZnVuY3Rpb24gKG8pIHtcbiAgICAgICAgcmV0dXJuICdpbWFnZWF0dHI6JXMgJXMgJXMnICsgKG8uZGlyMiA/ICcgJXMgJXMnIDogJycpO1xuICAgICAgfVxuICAgIH0sXG4gICAgeyAvL2E9c2ltdWxjYXN0OnNlbmQgMSwyLDM7fjQsfjUgcmVjdiA2O343LH44XG4gICAgICAvL2E9c2ltdWxjYXN0OnJlY3YgMTs0LDUgc2VuZCA2OzdcbiAgICAgIG5hbWU6ICdzaW11bGNhc3QnLFxuICAgICAgcmVnOiBuZXcgUmVnRXhwKFxuICAgICAgICAvL2E9c2ltdWxjYXN0OlxuICAgICAgICAnXnNpbXVsY2FzdDonICtcbiAgICAgICAgLy9zZW5kIDEsMiwzO340LH41XG4gICAgICAgICcoc2VuZHxyZWN2KSAoW2EtekEtWjAtOVxcXFwtX347LF0rKScgK1xuICAgICAgICAvL3NwYWNlICsgcmVjdiA2O343LH44XG4gICAgICAgICcoPzpcXFxccz8oc2VuZHxyZWN2KSAoW2EtekEtWjAtOVxcXFwtX347LF0rKSk/JyArXG4gICAgICAgIC8vZW5kXG4gICAgICAgICckJ1xuICAgICAgKSxcbiAgICAgIG5hbWVzOiBbJ2RpcjEnLCAnbGlzdDEnLCAnZGlyMicsICdsaXN0MiddLFxuICAgICAgZm9ybWF0OiBmdW5jdGlvbiAobykge1xuICAgICAgICByZXR1cm4gJ3NpbXVsY2FzdDolcyAlcycgKyAoby5kaXIyID8gJyAlcyAlcycgOiAnJyk7XG4gICAgICB9XG4gICAgfSxcbiAgICB7IC8vT2xkIHNpbXVsY2FzdCBkcmFmdCAwMyAoaW1wbGVtZW50ZWQgYnkgRmlyZWZveClcbiAgICAgIC8vICBodHRwczovL3Rvb2xzLmlldGYub3JnL2h0bWwvZHJhZnQtaWV0Zi1tbXVzaWMtc2RwLXNpbXVsY2FzdC0wM1xuICAgICAgLy9hPXNpbXVsY2FzdDogcmVjdiBwdD05Nzs5OCBzZW5kIHB0PTk3XG4gICAgICAvL2E9c2ltdWxjYXN0OiBzZW5kIHJpZD01OzY7NyBwYXVzZWQ9Niw3XG4gICAgICBuYW1lOiAnc2ltdWxjYXN0XzAzJyxcbiAgICAgIHJlZzogL15zaW11bGNhc3Q6W1xcc1xcdF0rKFtcXFMrXFxzXFx0XSspJC8sXG4gICAgICBuYW1lczogWyd2YWx1ZSddLFxuICAgICAgZm9ybWF0OiAnc2ltdWxjYXN0OiAlcydcbiAgICB9LFxuICAgIHtcbiAgICAgIC8vYT1mcmFtZXJhdGU6MjVcbiAgICAgIC8vYT1mcmFtZXJhdGU6MjkuOTdcbiAgICAgIG5hbWU6ICdmcmFtZXJhdGUnLFxuICAgICAgcmVnOiAvXmZyYW1lcmF0ZTooXFxkKyg/OiR8XFwuXFxkKykpLyxcbiAgICAgIGZvcm1hdDogJ2ZyYW1lcmF0ZTolcydcbiAgICB9LFxuICAgIHsgLy8gUkZDNDU3MFxuICAgICAgLy9hPXNvdXJjZS1maWx0ZXI6IGluY2wgSU4gSVA0IDIzOS41LjIuMzEgMTAuMS4xNS41XG4gICAgICBuYW1lOiAnc291cmNlRmlsdGVyJyxcbiAgICAgIHJlZzogL15zb3VyY2UtZmlsdGVyOiAqKGV4Y2x8aW5jbCkgKFxcUyopIChJUDR8SVA2fFxcKikgKFxcUyopICguKikvLFxuICAgICAgbmFtZXM6IFsnZmlsdGVyTW9kZScsICduZXRUeXBlJywgJ2FkZHJlc3NUeXBlcycsICdkZXN0QWRkcmVzcycsICdzcmNMaXN0J10sXG4gICAgICBmb3JtYXQ6ICdzb3VyY2UtZmlsdGVyOiAlcyAlcyAlcyAlcyAlcydcbiAgICB9LFxuICAgIHsgLy8gYW55IGE9IHRoYXQgd2UgZG9uJ3QgdW5kZXJzdGFuZCBpcyBrZXB0cyB2ZXJiYXRpbSBvbiBtZWRpYS5pbnZhbGlkXG4gICAgICBwdXNoOiAnaW52YWxpZCcsXG4gICAgICBuYW1lczogWyd2YWx1ZSddXG4gICAgfVxuICBdXG59O1xuXG4vLyBzZXQgc2Vuc2libGUgZGVmYXVsdHMgdG8gYXZvaWQgcG9sbHV0aW5nIHRoZSBncmFtbWFyIHdpdGggYm9yaW5nIGRldGFpbHNcbk9iamVjdC5rZXlzKGdyYW1tYXIpLmZvckVhY2goZnVuY3Rpb24gKGtleSkge1xuICB2YXIgb2JqcyA9IGdyYW1tYXJba2V5XTtcbiAgb2Jqcy5mb3JFYWNoKGZ1bmN0aW9uIChvYmopIHtcbiAgICBpZiAoIW9iai5yZWcpIHtcbiAgICAgIG9iai5yZWcgPSAvKC4qKS87XG4gICAgfVxuICAgIGlmICghb2JqLmZvcm1hdCkge1xuICAgICAgb2JqLmZvcm1hdCA9ICclcyc7XG4gICAgfVxuICB9KTtcbn0pO1xuIiwidmFyIHBhcnNlciA9IHJlcXVpcmUoJy4vcGFyc2VyJyk7XG52YXIgd3JpdGVyID0gcmVxdWlyZSgnLi93cml0ZXInKTtcblxuZXhwb3J0cy53cml0ZSA9IHdyaXRlcjtcbmV4cG9ydHMucGFyc2UgPSBwYXJzZXIucGFyc2U7XG5leHBvcnRzLnBhcnNlRm10cENvbmZpZyA9IHBhcnNlci5wYXJzZUZtdHBDb25maWc7XG5leHBvcnRzLnBhcnNlUGFyYW1zID0gcGFyc2VyLnBhcnNlUGFyYW1zO1xuZXhwb3J0cy5wYXJzZVBheWxvYWRzID0gcGFyc2VyLnBhcnNlUGF5bG9hZHM7XG5leHBvcnRzLnBhcnNlUmVtb3RlQ2FuZGlkYXRlcyA9IHBhcnNlci5wYXJzZVJlbW90ZUNhbmRpZGF0ZXM7XG5leHBvcnRzLnBhcnNlSW1hZ2VBdHRyaWJ1dGVzID0gcGFyc2VyLnBhcnNlSW1hZ2VBdHRyaWJ1dGVzO1xuZXhwb3J0cy5wYXJzZVNpbXVsY2FzdFN0cmVhbUxpc3QgPSBwYXJzZXIucGFyc2VTaW11bGNhc3RTdHJlYW1MaXN0O1xuIiwidmFyIHRvSW50SWZJbnQgPSBmdW5jdGlvbiAodikge1xuICByZXR1cm4gU3RyaW5nKE51bWJlcih2KSkgPT09IHYgPyBOdW1iZXIodikgOiB2O1xufTtcblxudmFyIGF0dGFjaFByb3BlcnRpZXMgPSBmdW5jdGlvbiAobWF0Y2gsIGxvY2F0aW9uLCBuYW1lcywgcmF3TmFtZSkge1xuICBpZiAocmF3TmFtZSAmJiAhbmFtZXMpIHtcbiAgICBsb2NhdGlvbltyYXdOYW1lXSA9IHRvSW50SWZJbnQobWF0Y2hbMV0pO1xuICB9XG4gIGVsc2Uge1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbmFtZXMubGVuZ3RoOyBpICs9IDEpIHtcbiAgICAgIGlmIChtYXRjaFtpKzFdICE9IG51bGwpIHtcbiAgICAgICAgbG9jYXRpb25bbmFtZXNbaV1dID0gdG9JbnRJZkludChtYXRjaFtpKzFdKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbn07XG5cbnZhciBwYXJzZVJlZyA9IGZ1bmN0aW9uIChvYmosIGxvY2F0aW9uLCBjb250ZW50KSB7XG4gIHZhciBuZWVkc0JsYW5rID0gb2JqLm5hbWUgJiYgb2JqLm5hbWVzO1xuICBpZiAob2JqLnB1c2ggJiYgIWxvY2F0aW9uW29iai5wdXNoXSkge1xuICAgIGxvY2F0aW9uW29iai5wdXNoXSA9IFtdO1xuICB9XG4gIGVsc2UgaWYgKG5lZWRzQmxhbmsgJiYgIWxvY2F0aW9uW29iai5uYW1lXSkge1xuICAgIGxvY2F0aW9uW29iai5uYW1lXSA9IHt9O1xuICB9XG4gIHZhciBrZXlMb2NhdGlvbiA9IG9iai5wdXNoID9cbiAgICB7fSA6ICAvLyBibGFuayBvYmplY3QgdGhhdCB3aWxsIGJlIHB1c2hlZFxuICAgIG5lZWRzQmxhbmsgPyBsb2NhdGlvbltvYmoubmFtZV0gOiBsb2NhdGlvbjsgLy8gb3RoZXJ3aXNlLCBuYW1lZCBsb2NhdGlvbiBvciByb290XG5cbiAgYXR0YWNoUHJvcGVydGllcyhjb250ZW50Lm1hdGNoKG9iai5yZWcpLCBrZXlMb2NhdGlvbiwgb2JqLm5hbWVzLCBvYmoubmFtZSk7XG5cbiAgaWYgKG9iai5wdXNoKSB7XG4gICAgbG9jYXRpb25bb2JqLnB1c2hdLnB1c2goa2V5TG9jYXRpb24pO1xuICB9XG59O1xuXG52YXIgZ3JhbW1hciA9IHJlcXVpcmUoJy4vZ3JhbW1hcicpO1xudmFyIHZhbGlkTGluZSA9IFJlZ0V4cC5wcm90b3R5cGUudGVzdC5iaW5kKC9eKFthLXpdKT0oLiopLyk7XG5cbmV4cG9ydHMucGFyc2UgPSBmdW5jdGlvbiAoc2RwKSB7XG4gIHZhciBzZXNzaW9uID0ge31cbiAgICAsIG1lZGlhID0gW11cbiAgICAsIGxvY2F0aW9uID0gc2Vzc2lvbjsgLy8gcG9pbnRzIGF0IHdoZXJlIHByb3BlcnRpZXMgZ28gdW5kZXIgKG9uZSBvZiB0aGUgYWJvdmUpXG5cbiAgLy8gcGFyc2UgbGluZXMgd2UgdW5kZXJzdGFuZFxuICBzZHAuc3BsaXQoLyhcXHJcXG58XFxyfFxcbikvKS5maWx0ZXIodmFsaWRMaW5lKS5mb3JFYWNoKGZ1bmN0aW9uIChsKSB7XG4gICAgdmFyIHR5cGUgPSBsWzBdO1xuICAgIHZhciBjb250ZW50ID0gbC5zbGljZSgyKTtcbiAgICBpZiAodHlwZSA9PT0gJ20nKSB7XG4gICAgICBtZWRpYS5wdXNoKHtydHA6IFtdLCBmbXRwOiBbXX0pO1xuICAgICAgbG9jYXRpb24gPSBtZWRpYVttZWRpYS5sZW5ndGgtMV07IC8vIHBvaW50IGF0IGxhdGVzdCBtZWRpYSBsaW5lXG4gICAgfVxuXG4gICAgZm9yICh2YXIgaiA9IDA7IGogPCAoZ3JhbW1hclt0eXBlXSB8fCBbXSkubGVuZ3RoOyBqICs9IDEpIHtcbiAgICAgIHZhciBvYmogPSBncmFtbWFyW3R5cGVdW2pdO1xuICAgICAgaWYgKG9iai5yZWcudGVzdChjb250ZW50KSkge1xuICAgICAgICByZXR1cm4gcGFyc2VSZWcob2JqLCBsb2NhdGlvbiwgY29udGVudCk7XG4gICAgICB9XG4gICAgfVxuICB9KTtcblxuICBzZXNzaW9uLm1lZGlhID0gbWVkaWE7IC8vIGxpbmsgaXQgdXBcbiAgcmV0dXJuIHNlc3Npb247XG59O1xuXG52YXIgcGFyYW1SZWR1Y2VyID0gZnVuY3Rpb24gKGFjYywgZXhwcikge1xuICB2YXIgcyA9IGV4cHIuc3BsaXQoLz0oLispLywgMik7XG4gIGlmIChzLmxlbmd0aCA9PT0gMikge1xuICAgIGFjY1tzWzBdXSA9IHRvSW50SWZJbnQoc1sxXSk7XG4gIH1cbiAgcmV0dXJuIGFjYztcbn07XG5cbmV4cG9ydHMucGFyc2VQYXJhbXMgPSBmdW5jdGlvbiAoc3RyKSB7XG4gIHJldHVybiBzdHIuc3BsaXQoL1xcO1xccz8vKS5yZWR1Y2UocGFyYW1SZWR1Y2VyLCB7fSk7XG59O1xuXG4vLyBGb3IgYmFja3dhcmQgY29tcGF0aWJpbGl0eSAtIGFsaWFzIHdpbGwgYmUgcmVtb3ZlZCBpbiAzLjAuMFxuZXhwb3J0cy5wYXJzZUZtdHBDb25maWcgPSBleHBvcnRzLnBhcnNlUGFyYW1zO1xuXG5leHBvcnRzLnBhcnNlUGF5bG9hZHMgPSBmdW5jdGlvbiAoc3RyKSB7XG4gIHJldHVybiBzdHIuc3BsaXQoJyAnKS5tYXAoTnVtYmVyKTtcbn07XG5cbmV4cG9ydHMucGFyc2VSZW1vdGVDYW5kaWRhdGVzID0gZnVuY3Rpb24gKHN0cikge1xuICB2YXIgY2FuZGlkYXRlcyA9IFtdO1xuICB2YXIgcGFydHMgPSBzdHIuc3BsaXQoJyAnKS5tYXAodG9JbnRJZkludCk7XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgcGFydHMubGVuZ3RoOyBpICs9IDMpIHtcbiAgICBjYW5kaWRhdGVzLnB1c2goe1xuICAgICAgY29tcG9uZW50OiBwYXJ0c1tpXSxcbiAgICAgIGlwOiBwYXJ0c1tpICsgMV0sXG4gICAgICBwb3J0OiBwYXJ0c1tpICsgMl1cbiAgICB9KTtcbiAgfVxuICByZXR1cm4gY2FuZGlkYXRlcztcbn07XG5cbmV4cG9ydHMucGFyc2VJbWFnZUF0dHJpYnV0ZXMgPSBmdW5jdGlvbiAoc3RyKSB7XG4gIHJldHVybiBzdHIuc3BsaXQoJyAnKS5tYXAoZnVuY3Rpb24gKGl0ZW0pIHtcbiAgICByZXR1cm4gaXRlbS5zdWJzdHJpbmcoMSwgaXRlbS5sZW5ndGgtMSkuc3BsaXQoJywnKS5yZWR1Y2UocGFyYW1SZWR1Y2VyLCB7fSk7XG4gIH0pO1xufTtcblxuZXhwb3J0cy5wYXJzZVNpbXVsY2FzdFN0cmVhbUxpc3QgPSBmdW5jdGlvbiAoc3RyKSB7XG4gIHJldHVybiBzdHIuc3BsaXQoJzsnKS5tYXAoZnVuY3Rpb24gKHN0cmVhbSkge1xuICAgIHJldHVybiBzdHJlYW0uc3BsaXQoJywnKS5tYXAoZnVuY3Rpb24gKGZvcm1hdCkge1xuICAgICAgdmFyIHNjaWQsIHBhdXNlZCA9IGZhbHNlO1xuXG4gICAgICBpZiAoZm9ybWF0WzBdICE9PSAnficpIHtcbiAgICAgICAgc2NpZCA9IHRvSW50SWZJbnQoZm9ybWF0KTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHNjaWQgPSB0b0ludElmSW50KGZvcm1hdC5zdWJzdHJpbmcoMSwgZm9ybWF0Lmxlbmd0aCkpO1xuICAgICAgICBwYXVzZWQgPSB0cnVlO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4ge1xuICAgICAgICBzY2lkOiBzY2lkLFxuICAgICAgICBwYXVzZWQ6IHBhdXNlZFxuICAgICAgfTtcbiAgICB9KTtcbiAgfSk7XG59O1xuIiwidmFyIGdyYW1tYXIgPSByZXF1aXJlKCcuL2dyYW1tYXInKTtcblxuLy8gY3VzdG9taXplZCB1dGlsLmZvcm1hdCAtIGRpc2NhcmRzIGV4Y2VzcyBhcmd1bWVudHMgYW5kIGNhbiB2b2lkIG1pZGRsZSBvbmVzXG52YXIgZm9ybWF0UmVnRXhwID0gLyVbc2R2JV0vZztcbnZhciBmb3JtYXQgPSBmdW5jdGlvbiAoZm9ybWF0U3RyKSB7XG4gIHZhciBpID0gMTtcbiAgdmFyIGFyZ3MgPSBhcmd1bWVudHM7XG4gIHZhciBsZW4gPSBhcmdzLmxlbmd0aDtcbiAgcmV0dXJuIGZvcm1hdFN0ci5yZXBsYWNlKGZvcm1hdFJlZ0V4cCwgZnVuY3Rpb24gKHgpIHtcbiAgICBpZiAoaSA+PSBsZW4pIHtcbiAgICAgIHJldHVybiB4OyAvLyBtaXNzaW5nIGFyZ3VtZW50XG4gICAgfVxuICAgIHZhciBhcmcgPSBhcmdzW2ldO1xuICAgIGkgKz0gMTtcbiAgICBzd2l0Y2ggKHgpIHtcbiAgICBjYXNlICclJSc6XG4gICAgICByZXR1cm4gJyUnO1xuICAgIGNhc2UgJyVzJzpcbiAgICAgIHJldHVybiBTdHJpbmcoYXJnKTtcbiAgICBjYXNlICclZCc6XG4gICAgICByZXR1cm4gTnVtYmVyKGFyZyk7XG4gICAgY2FzZSAnJXYnOlxuICAgICAgcmV0dXJuICcnO1xuICAgIH1cbiAgfSk7XG4gIC8vIE5COiB3ZSBkaXNjYXJkIGV4Y2VzcyBhcmd1bWVudHMgLSB0aGV5IGFyZSB0eXBpY2FsbHkgdW5kZWZpbmVkIGZyb20gbWFrZUxpbmVcbn07XG5cbnZhciBtYWtlTGluZSA9IGZ1bmN0aW9uICh0eXBlLCBvYmosIGxvY2F0aW9uKSB7XG4gIHZhciBzdHIgPSBvYmouZm9ybWF0IGluc3RhbmNlb2YgRnVuY3Rpb24gP1xuICAgIChvYmouZm9ybWF0KG9iai5wdXNoID8gbG9jYXRpb24gOiBsb2NhdGlvbltvYmoubmFtZV0pKSA6XG4gICAgb2JqLmZvcm1hdDtcblxuICB2YXIgYXJncyA9IFt0eXBlICsgJz0nICsgc3RyXTtcbiAgaWYgKG9iai5uYW1lcykge1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgb2JqLm5hbWVzLmxlbmd0aDsgaSArPSAxKSB7XG4gICAgICB2YXIgbiA9IG9iai5uYW1lc1tpXTtcbiAgICAgIGlmIChvYmoubmFtZSkge1xuICAgICAgICBhcmdzLnB1c2gobG9jYXRpb25bb2JqLm5hbWVdW25dKTtcbiAgICAgIH1cbiAgICAgIGVsc2UgeyAvLyBmb3IgbUxpbmUgYW5kIHB1c2ggYXR0cmlidXRlc1xuICAgICAgICBhcmdzLnB1c2gobG9jYXRpb25bb2JqLm5hbWVzW2ldXSk7XG4gICAgICB9XG4gICAgfVxuICB9XG4gIGVsc2Uge1xuICAgIGFyZ3MucHVzaChsb2NhdGlvbltvYmoubmFtZV0pO1xuICB9XG4gIHJldHVybiBmb3JtYXQuYXBwbHkobnVsbCwgYXJncyk7XG59O1xuXG4vLyBSRkMgc3BlY2lmaWVkIG9yZGVyXG4vLyBUT0RPOiBleHRlbmQgdGhpcyB3aXRoIGFsbCB0aGUgcmVzdFxudmFyIGRlZmF1bHRPdXRlck9yZGVyID0gW1xuICAndicsICdvJywgJ3MnLCAnaScsXG4gICd1JywgJ2UnLCAncCcsICdjJyxcbiAgJ2InLCAndCcsICdyJywgJ3onLCAnYSdcbl07XG52YXIgZGVmYXVsdElubmVyT3JkZXIgPSBbJ2knLCAnYycsICdiJywgJ2EnXTtcblxuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChzZXNzaW9uLCBvcHRzKSB7XG4gIG9wdHMgPSBvcHRzIHx8IHt9O1xuICAvLyBlbnN1cmUgY2VydGFpbiBwcm9wZXJ0aWVzIGV4aXN0XG4gIGlmIChzZXNzaW9uLnZlcnNpb24gPT0gbnVsbCkge1xuICAgIHNlc3Npb24udmVyc2lvbiA9IDA7IC8vICd2PTAnIG11c3QgYmUgdGhlcmUgKG9ubHkgZGVmaW5lZCB2ZXJzaW9uIGF0bSlcbiAgfVxuICBpZiAoc2Vzc2lvbi5uYW1lID09IG51bGwpIHtcbiAgICBzZXNzaW9uLm5hbWUgPSAnICc7IC8vICdzPSAnIG11c3QgYmUgdGhlcmUgaWYgbm8gbWVhbmluZ2Z1bCBuYW1lIHNldFxuICB9XG4gIHNlc3Npb24ubWVkaWEuZm9yRWFjaChmdW5jdGlvbiAobUxpbmUpIHtcbiAgICBpZiAobUxpbmUucGF5bG9hZHMgPT0gbnVsbCkge1xuICAgICAgbUxpbmUucGF5bG9hZHMgPSAnJztcbiAgICB9XG4gIH0pO1xuXG4gIHZhciBvdXRlck9yZGVyID0gb3B0cy5vdXRlck9yZGVyIHx8IGRlZmF1bHRPdXRlck9yZGVyO1xuICB2YXIgaW5uZXJPcmRlciA9IG9wdHMuaW5uZXJPcmRlciB8fCBkZWZhdWx0SW5uZXJPcmRlcjtcbiAgdmFyIHNkcCA9IFtdO1xuXG4gIC8vIGxvb3AgdGhyb3VnaCBvdXRlck9yZGVyIGZvciBtYXRjaGluZyBwcm9wZXJ0aWVzIG9uIHNlc3Npb25cbiAgb3V0ZXJPcmRlci5mb3JFYWNoKGZ1bmN0aW9uICh0eXBlKSB7XG4gICAgZ3JhbW1hclt0eXBlXS5mb3JFYWNoKGZ1bmN0aW9uIChvYmopIHtcbiAgICAgIGlmIChvYmoubmFtZSBpbiBzZXNzaW9uICYmIHNlc3Npb25bb2JqLm5hbWVdICE9IG51bGwpIHtcbiAgICAgICAgc2RwLnB1c2gobWFrZUxpbmUodHlwZSwgb2JqLCBzZXNzaW9uKSk7XG4gICAgICB9XG4gICAgICBlbHNlIGlmIChvYmoucHVzaCBpbiBzZXNzaW9uICYmIHNlc3Npb25bb2JqLnB1c2hdICE9IG51bGwpIHtcbiAgICAgICAgc2Vzc2lvbltvYmoucHVzaF0uZm9yRWFjaChmdW5jdGlvbiAoZWwpIHtcbiAgICAgICAgICBzZHAucHVzaChtYWtlTGluZSh0eXBlLCBvYmosIGVsKSk7XG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgIH0pO1xuICB9KTtcblxuICAvLyB0aGVuIGZvciBlYWNoIG1lZGlhIGxpbmUsIGZvbGxvdyB0aGUgaW5uZXJPcmRlclxuICBzZXNzaW9uLm1lZGlhLmZvckVhY2goZnVuY3Rpb24gKG1MaW5lKSB7XG4gICAgc2RwLnB1c2gobWFrZUxpbmUoJ20nLCBncmFtbWFyLm1bMF0sIG1MaW5lKSk7XG5cbiAgICBpbm5lck9yZGVyLmZvckVhY2goZnVuY3Rpb24gKHR5cGUpIHtcbiAgICAgIGdyYW1tYXJbdHlwZV0uZm9yRWFjaChmdW5jdGlvbiAob2JqKSB7XG4gICAgICAgIGlmIChvYmoubmFtZSBpbiBtTGluZSAmJiBtTGluZVtvYmoubmFtZV0gIT0gbnVsbCkge1xuICAgICAgICAgIHNkcC5wdXNoKG1ha2VMaW5lKHR5cGUsIG9iaiwgbUxpbmUpKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChvYmoucHVzaCBpbiBtTGluZSAmJiBtTGluZVtvYmoucHVzaF0gIT0gbnVsbCkge1xuICAgICAgICAgIG1MaW5lW29iai5wdXNoXS5mb3JFYWNoKGZ1bmN0aW9uIChlbCkge1xuICAgICAgICAgICAgc2RwLnB1c2gobWFrZUxpbmUodHlwZSwgb2JqLCBlbCkpO1xuICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICB9KTtcbiAgfSk7XG5cbiAgcmV0dXJuIHNkcC5qb2luKCdcXHJcXG4nKSArICdcXHJcXG4nO1xufTtcbiIsIid1c2Ugc3RyaWN0JztcblxudmFyIHJlcXVpcmVkID0gcmVxdWlyZSgncmVxdWlyZXMtcG9ydCcpXG4gICwgcXMgPSByZXF1aXJlKCdxdWVyeXN0cmluZ2lmeScpXG4gICwgcHJvdG9jb2xyZSA9IC9eKFthLXpdW2EtejAtOS4rLV0qOik/KFxcL1xcLyk/KFtcXFNcXHNdKikvaVxuICAsIHNsYXNoZXMgPSAvXltBLVphLXpdW0EtWmEtejAtOSstLl0qOlxcL1xcLy87XG5cbi8qKlxuICogVGhlc2UgYXJlIHRoZSBwYXJzZSBydWxlcyBmb3IgdGhlIFVSTCBwYXJzZXIsIGl0IGluZm9ybXMgdGhlIHBhcnNlclxuICogYWJvdXQ6XG4gKlxuICogMC4gVGhlIGNoYXIgaXQgTmVlZHMgdG8gcGFyc2UsIGlmIGl0J3MgYSBzdHJpbmcgaXQgc2hvdWxkIGJlIGRvbmUgdXNpbmdcbiAqICAgIGluZGV4T2YsIFJlZ0V4cCB1c2luZyBleGVjIGFuZCBOYU4gbWVhbnMgc2V0IGFzIGN1cnJlbnQgdmFsdWUuXG4gKiAxLiBUaGUgcHJvcGVydHkgd2Ugc2hvdWxkIHNldCB3aGVuIHBhcnNpbmcgdGhpcyB2YWx1ZS5cbiAqIDIuIEluZGljYXRpb24gaWYgaXQncyBiYWNrd2FyZHMgb3IgZm9yd2FyZCBwYXJzaW5nLCB3aGVuIHNldCBhcyBudW1iZXIgaXQnc1xuICogICAgdGhlIHZhbHVlIG9mIGV4dHJhIGNoYXJzIHRoYXQgc2hvdWxkIGJlIHNwbGl0IG9mZi5cbiAqIDMuIEluaGVyaXQgZnJvbSBsb2NhdGlvbiBpZiBub24gZXhpc3RpbmcgaW4gdGhlIHBhcnNlci5cbiAqIDQuIGB0b0xvd2VyQ2FzZWAgdGhlIHJlc3VsdGluZyB2YWx1ZS5cbiAqL1xudmFyIHJ1bGVzID0gW1xuICBbJyMnLCAnaGFzaCddLCAgICAgICAgICAgICAgICAgICAgICAgIC8vIEV4dHJhY3QgZnJvbSB0aGUgYmFjay5cbiAgWyc/JywgJ3F1ZXJ5J10sICAgICAgICAgICAgICAgICAgICAgICAvLyBFeHRyYWN0IGZyb20gdGhlIGJhY2suXG4gIFsnLycsICdwYXRobmFtZSddLCAgICAgICAgICAgICAgICAgICAgLy8gRXh0cmFjdCBmcm9tIHRoZSBiYWNrLlxuICBbJ0AnLCAnYXV0aCcsIDFdLCAgICAgICAgICAgICAgICAgICAgIC8vIEV4dHJhY3QgZnJvbSB0aGUgZnJvbnQuXG4gIFtOYU4sICdob3N0JywgdW5kZWZpbmVkLCAxLCAxXSwgICAgICAgLy8gU2V0IGxlZnQgb3ZlciB2YWx1ZS5cbiAgWy86KFxcZCspJC8sICdwb3J0JywgdW5kZWZpbmVkLCAxXSwgICAgLy8gUmVnRXhwIHRoZSBiYWNrLlxuICBbTmFOLCAnaG9zdG5hbWUnLCB1bmRlZmluZWQsIDEsIDFdICAgIC8vIFNldCBsZWZ0IG92ZXIuXG5dO1xuXG4vKipcbiAqIFRoZXNlIHByb3BlcnRpZXMgc2hvdWxkIG5vdCBiZSBjb3BpZWQgb3IgaW5oZXJpdGVkIGZyb20uIFRoaXMgaXMgb25seSBuZWVkZWRcbiAqIGZvciBhbGwgbm9uIGJsb2IgVVJMJ3MgYXMgYSBibG9iIFVSTCBkb2VzIG5vdCBpbmNsdWRlIGEgaGFzaCwgb25seSB0aGVcbiAqIG9yaWdpbi5cbiAqXG4gKiBAdHlwZSB7T2JqZWN0fVxuICogQHByaXZhdGVcbiAqL1xudmFyIGlnbm9yZSA9IHsgaGFzaDogMSwgcXVlcnk6IDEgfTtcblxuLyoqXG4gKiBUaGUgbG9jYXRpb24gb2JqZWN0IGRpZmZlcnMgd2hlbiB5b3VyIGNvZGUgaXMgbG9hZGVkIHRocm91Z2ggYSBub3JtYWwgcGFnZSxcbiAqIFdvcmtlciBvciB0aHJvdWdoIGEgd29ya2VyIHVzaW5nIGEgYmxvYi4gQW5kIHdpdGggdGhlIGJsb2JibGUgYmVnaW5zIHRoZVxuICogdHJvdWJsZSBhcyB0aGUgbG9jYXRpb24gb2JqZWN0IHdpbGwgY29udGFpbiB0aGUgVVJMIG9mIHRoZSBibG9iLCBub3QgdGhlXG4gKiBsb2NhdGlvbiBvZiB0aGUgcGFnZSB3aGVyZSBvdXIgY29kZSBpcyBsb2FkZWQgaW4uIFRoZSBhY3R1YWwgb3JpZ2luIGlzXG4gKiBlbmNvZGVkIGluIHRoZSBgcGF0aG5hbWVgIHNvIHdlIGNhbiB0aGFua2Z1bGx5IGdlbmVyYXRlIGEgZ29vZCBcImRlZmF1bHRcIlxuICogbG9jYXRpb24gZnJvbSBpdCBzbyB3ZSBjYW4gZ2VuZXJhdGUgcHJvcGVyIHJlbGF0aXZlIFVSTCdzIGFnYWluLlxuICpcbiAqIEBwYXJhbSB7T2JqZWN0fFN0cmluZ30gbG9jIE9wdGlvbmFsIGRlZmF1bHQgbG9jYXRpb24gb2JqZWN0LlxuICogQHJldHVybnMge09iamVjdH0gbG9sY2F0aW9uIG9iamVjdC5cbiAqIEBhcGkgcHVibGljXG4gKi9cbmZ1bmN0aW9uIGxvbGNhdGlvbihsb2MpIHtcbiAgbG9jID0gbG9jIHx8IGdsb2JhbC5sb2NhdGlvbiB8fCB7fTtcblxuICB2YXIgZmluYWxkZXN0aW5hdGlvbiA9IHt9XG4gICAgLCB0eXBlID0gdHlwZW9mIGxvY1xuICAgICwga2V5O1xuXG4gIGlmICgnYmxvYjonID09PSBsb2MucHJvdG9jb2wpIHtcbiAgICBmaW5hbGRlc3RpbmF0aW9uID0gbmV3IFVSTCh1bmVzY2FwZShsb2MucGF0aG5hbWUpLCB7fSk7XG4gIH0gZWxzZSBpZiAoJ3N0cmluZycgPT09IHR5cGUpIHtcbiAgICBmaW5hbGRlc3RpbmF0aW9uID0gbmV3IFVSTChsb2MsIHt9KTtcbiAgICBmb3IgKGtleSBpbiBpZ25vcmUpIGRlbGV0ZSBmaW5hbGRlc3RpbmF0aW9uW2tleV07XG4gIH0gZWxzZSBpZiAoJ29iamVjdCcgPT09IHR5cGUpIHtcbiAgICBmb3IgKGtleSBpbiBsb2MpIHtcbiAgICAgIGlmIChrZXkgaW4gaWdub3JlKSBjb250aW51ZTtcbiAgICAgIGZpbmFsZGVzdGluYXRpb25ba2V5XSA9IGxvY1trZXldO1xuICAgIH1cblxuICAgIGlmIChmaW5hbGRlc3RpbmF0aW9uLnNsYXNoZXMgPT09IHVuZGVmaW5lZCkge1xuICAgICAgZmluYWxkZXN0aW5hdGlvbi5zbGFzaGVzID0gc2xhc2hlcy50ZXN0KGxvYy5ocmVmKTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gZmluYWxkZXN0aW5hdGlvbjtcbn1cblxuLyoqXG4gKiBAdHlwZWRlZiBQcm90b2NvbEV4dHJhY3RcbiAqIEB0eXBlIE9iamVjdFxuICogQHByb3BlcnR5IHtTdHJpbmd9IHByb3RvY29sIFByb3RvY29sIG1hdGNoZWQgaW4gdGhlIFVSTCwgaW4gbG93ZXJjYXNlLlxuICogQHByb3BlcnR5IHtCb29sZWFufSBzbGFzaGVzIGB0cnVlYCBpZiBwcm90b2NvbCBpcyBmb2xsb3dlZCBieSBcIi8vXCIsIGVsc2UgYGZhbHNlYC5cbiAqIEBwcm9wZXJ0eSB7U3RyaW5nfSByZXN0IFJlc3Qgb2YgdGhlIFVSTCB0aGF0IGlzIG5vdCBwYXJ0IG9mIHRoZSBwcm90b2NvbC5cbiAqL1xuXG4vKipcbiAqIEV4dHJhY3QgcHJvdG9jb2wgaW5mb3JtYXRpb24gZnJvbSBhIFVSTCB3aXRoL3dpdGhvdXQgZG91YmxlIHNsYXNoIChcIi8vXCIpLlxuICpcbiAqIEBwYXJhbSB7U3RyaW5nfSBhZGRyZXNzIFVSTCB3ZSB3YW50IHRvIGV4dHJhY3QgZnJvbS5cbiAqIEByZXR1cm4ge1Byb3RvY29sRXh0cmFjdH0gRXh0cmFjdGVkIGluZm9ybWF0aW9uLlxuICogQGFwaSBwcml2YXRlXG4gKi9cbmZ1bmN0aW9uIGV4dHJhY3RQcm90b2NvbChhZGRyZXNzKSB7XG4gIHZhciBtYXRjaCA9IHByb3RvY29scmUuZXhlYyhhZGRyZXNzKTtcblxuICByZXR1cm4ge1xuICAgIHByb3RvY29sOiBtYXRjaFsxXSA/IG1hdGNoWzFdLnRvTG93ZXJDYXNlKCkgOiAnJyxcbiAgICBzbGFzaGVzOiAhIW1hdGNoWzJdLFxuICAgIHJlc3Q6IG1hdGNoWzNdXG4gIH07XG59XG5cbi8qKlxuICogUmVzb2x2ZSBhIHJlbGF0aXZlIFVSTCBwYXRobmFtZSBhZ2FpbnN0IGEgYmFzZSBVUkwgcGF0aG5hbWUuXG4gKlxuICogQHBhcmFtIHtTdHJpbmd9IHJlbGF0aXZlIFBhdGhuYW1lIG9mIHRoZSByZWxhdGl2ZSBVUkwuXG4gKiBAcGFyYW0ge1N0cmluZ30gYmFzZSBQYXRobmFtZSBvZiB0aGUgYmFzZSBVUkwuXG4gKiBAcmV0dXJuIHtTdHJpbmd9IFJlc29sdmVkIHBhdGhuYW1lLlxuICogQGFwaSBwcml2YXRlXG4gKi9cbmZ1bmN0aW9uIHJlc29sdmUocmVsYXRpdmUsIGJhc2UpIHtcbiAgdmFyIHBhdGggPSAoYmFzZSB8fCAnLycpLnNwbGl0KCcvJykuc2xpY2UoMCwgLTEpLmNvbmNhdChyZWxhdGl2ZS5zcGxpdCgnLycpKVxuICAgICwgaSA9IHBhdGgubGVuZ3RoXG4gICAgLCBsYXN0ID0gcGF0aFtpIC0gMV1cbiAgICAsIHVuc2hpZnQgPSBmYWxzZVxuICAgICwgdXAgPSAwO1xuXG4gIHdoaWxlIChpLS0pIHtcbiAgICBpZiAocGF0aFtpXSA9PT0gJy4nKSB7XG4gICAgICBwYXRoLnNwbGljZShpLCAxKTtcbiAgICB9IGVsc2UgaWYgKHBhdGhbaV0gPT09ICcuLicpIHtcbiAgICAgIHBhdGguc3BsaWNlKGksIDEpO1xuICAgICAgdXArKztcbiAgICB9IGVsc2UgaWYgKHVwKSB7XG4gICAgICBpZiAoaSA9PT0gMCkgdW5zaGlmdCA9IHRydWU7XG4gICAgICBwYXRoLnNwbGljZShpLCAxKTtcbiAgICAgIHVwLS07XG4gICAgfVxuICB9XG5cbiAgaWYgKHVuc2hpZnQpIHBhdGgudW5zaGlmdCgnJyk7XG4gIGlmIChsYXN0ID09PSAnLicgfHwgbGFzdCA9PT0gJy4uJykgcGF0aC5wdXNoKCcnKTtcblxuICByZXR1cm4gcGF0aC5qb2luKCcvJyk7XG59XG5cbi8qKlxuICogVGhlIGFjdHVhbCBVUkwgaW5zdGFuY2UuIEluc3RlYWQgb2YgcmV0dXJuaW5nIGFuIG9iamVjdCB3ZSd2ZSBvcHRlZC1pbiB0b1xuICogY3JlYXRlIGFuIGFjdHVhbCBjb25zdHJ1Y3RvciBhcyBpdCdzIG11Y2ggbW9yZSBtZW1vcnkgZWZmaWNpZW50IGFuZFxuICogZmFzdGVyIGFuZCBpdCBwbGVhc2VzIG15IE9DRC5cbiAqXG4gKiBAY29uc3RydWN0b3JcbiAqIEBwYXJhbSB7U3RyaW5nfSBhZGRyZXNzIFVSTCB3ZSB3YW50IHRvIHBhcnNlLlxuICogQHBhcmFtIHtPYmplY3R8U3RyaW5nfSBsb2NhdGlvbiBMb2NhdGlvbiBkZWZhdWx0cyBmb3IgcmVsYXRpdmUgcGF0aHMuXG4gKiBAcGFyYW0ge0Jvb2xlYW58RnVuY3Rpb259IHBhcnNlciBQYXJzZXIgZm9yIHRoZSBxdWVyeSBzdHJpbmcuXG4gKiBAYXBpIHB1YmxpY1xuICovXG5mdW5jdGlvbiBVUkwoYWRkcmVzcywgbG9jYXRpb24sIHBhcnNlcikge1xuICBpZiAoISh0aGlzIGluc3RhbmNlb2YgVVJMKSkge1xuICAgIHJldHVybiBuZXcgVVJMKGFkZHJlc3MsIGxvY2F0aW9uLCBwYXJzZXIpO1xuICB9XG5cbiAgdmFyIHJlbGF0aXZlLCBleHRyYWN0ZWQsIHBhcnNlLCBpbnN0cnVjdGlvbiwgaW5kZXgsIGtleVxuICAgICwgaW5zdHJ1Y3Rpb25zID0gcnVsZXMuc2xpY2UoKVxuICAgICwgdHlwZSA9IHR5cGVvZiBsb2NhdGlvblxuICAgICwgdXJsID0gdGhpc1xuICAgICwgaSA9IDA7XG5cbiAgLy9cbiAgLy8gVGhlIGZvbGxvd2luZyBpZiBzdGF0ZW1lbnRzIGFsbG93cyB0aGlzIG1vZHVsZSB0d28gaGF2ZSBjb21wYXRpYmlsaXR5IHdpdGhcbiAgLy8gMiBkaWZmZXJlbnQgQVBJOlxuICAvL1xuICAvLyAxLiBOb2RlLmpzJ3MgYHVybC5wYXJzZWAgYXBpIHdoaWNoIGFjY2VwdHMgYSBVUkwsIGJvb2xlYW4gYXMgYXJndW1lbnRzXG4gIC8vICAgIHdoZXJlIHRoZSBib29sZWFuIGluZGljYXRlcyB0aGF0IHRoZSBxdWVyeSBzdHJpbmcgc2hvdWxkIGFsc28gYmUgcGFyc2VkLlxuICAvL1xuICAvLyAyLiBUaGUgYFVSTGAgaW50ZXJmYWNlIG9mIHRoZSBicm93c2VyIHdoaWNoIGFjY2VwdHMgYSBVUkwsIG9iamVjdCBhc1xuICAvLyAgICBhcmd1bWVudHMuIFRoZSBzdXBwbGllZCBvYmplY3Qgd2lsbCBiZSB1c2VkIGFzIGRlZmF1bHQgdmFsdWVzIC8gZmFsbC1iYWNrXG4gIC8vICAgIGZvciByZWxhdGl2ZSBwYXRocy5cbiAgLy9cbiAgaWYgKCdvYmplY3QnICE9PSB0eXBlICYmICdzdHJpbmcnICE9PSB0eXBlKSB7XG4gICAgcGFyc2VyID0gbG9jYXRpb247XG4gICAgbG9jYXRpb24gPSBudWxsO1xuICB9XG5cbiAgaWYgKHBhcnNlciAmJiAnZnVuY3Rpb24nICE9PSB0eXBlb2YgcGFyc2VyKSBwYXJzZXIgPSBxcy5wYXJzZTtcblxuICBsb2NhdGlvbiA9IGxvbGNhdGlvbihsb2NhdGlvbik7XG5cbiAgLy9cbiAgLy8gRXh0cmFjdCBwcm90b2NvbCBpbmZvcm1hdGlvbiBiZWZvcmUgcnVubmluZyB0aGUgaW5zdHJ1Y3Rpb25zLlxuICAvL1xuICBleHRyYWN0ZWQgPSBleHRyYWN0UHJvdG9jb2woYWRkcmVzcyB8fCAnJyk7XG4gIHJlbGF0aXZlID0gIWV4dHJhY3RlZC5wcm90b2NvbCAmJiAhZXh0cmFjdGVkLnNsYXNoZXM7XG4gIHVybC5zbGFzaGVzID0gZXh0cmFjdGVkLnNsYXNoZXMgfHwgcmVsYXRpdmUgJiYgbG9jYXRpb24uc2xhc2hlcztcbiAgdXJsLnByb3RvY29sID0gZXh0cmFjdGVkLnByb3RvY29sIHx8IGxvY2F0aW9uLnByb3RvY29sIHx8ICcnO1xuICBhZGRyZXNzID0gZXh0cmFjdGVkLnJlc3Q7XG5cbiAgLy9cbiAgLy8gV2hlbiB0aGUgYXV0aG9yaXR5IGNvbXBvbmVudCBpcyBhYnNlbnQgdGhlIFVSTCBzdGFydHMgd2l0aCBhIHBhdGhcbiAgLy8gY29tcG9uZW50LlxuICAvL1xuICBpZiAoIWV4dHJhY3RlZC5zbGFzaGVzKSBpbnN0cnVjdGlvbnNbMl0gPSBbLyguKikvLCAncGF0aG5hbWUnXTtcblxuICBmb3IgKDsgaSA8IGluc3RydWN0aW9ucy5sZW5ndGg7IGkrKykge1xuICAgIGluc3RydWN0aW9uID0gaW5zdHJ1Y3Rpb25zW2ldO1xuICAgIHBhcnNlID0gaW5zdHJ1Y3Rpb25bMF07XG4gICAga2V5ID0gaW5zdHJ1Y3Rpb25bMV07XG5cbiAgICBpZiAocGFyc2UgIT09IHBhcnNlKSB7XG4gICAgICB1cmxba2V5XSA9IGFkZHJlc3M7XG4gICAgfSBlbHNlIGlmICgnc3RyaW5nJyA9PT0gdHlwZW9mIHBhcnNlKSB7XG4gICAgICBpZiAofihpbmRleCA9IGFkZHJlc3MuaW5kZXhPZihwYXJzZSkpKSB7XG4gICAgICAgIGlmICgnbnVtYmVyJyA9PT0gdHlwZW9mIGluc3RydWN0aW9uWzJdKSB7XG4gICAgICAgICAgdXJsW2tleV0gPSBhZGRyZXNzLnNsaWNlKDAsIGluZGV4KTtcbiAgICAgICAgICBhZGRyZXNzID0gYWRkcmVzcy5zbGljZShpbmRleCArIGluc3RydWN0aW9uWzJdKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB1cmxba2V5XSA9IGFkZHJlc3Muc2xpY2UoaW5kZXgpO1xuICAgICAgICAgIGFkZHJlc3MgPSBhZGRyZXNzLnNsaWNlKDAsIGluZGV4KTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0gZWxzZSBpZiAoKGluZGV4ID0gcGFyc2UuZXhlYyhhZGRyZXNzKSkpIHtcbiAgICAgIHVybFtrZXldID0gaW5kZXhbMV07XG4gICAgICBhZGRyZXNzID0gYWRkcmVzcy5zbGljZSgwLCBpbmRleC5pbmRleCk7XG4gICAgfVxuXG4gICAgdXJsW2tleV0gPSB1cmxba2V5XSB8fCAoXG4gICAgICByZWxhdGl2ZSAmJiBpbnN0cnVjdGlvblszXSA/IGxvY2F0aW9uW2tleV0gfHwgJycgOiAnJ1xuICAgICk7XG5cbiAgICAvL1xuICAgIC8vIEhvc3RuYW1lLCBob3N0IGFuZCBwcm90b2NvbCBzaG91bGQgYmUgbG93ZXJjYXNlZCBzbyB0aGV5IGNhbiBiZSB1c2VkIHRvXG4gICAgLy8gY3JlYXRlIGEgcHJvcGVyIGBvcmlnaW5gLlxuICAgIC8vXG4gICAgaWYgKGluc3RydWN0aW9uWzRdKSB1cmxba2V5XSA9IHVybFtrZXldLnRvTG93ZXJDYXNlKCk7XG4gIH1cblxuICAvL1xuICAvLyBBbHNvIHBhcnNlIHRoZSBzdXBwbGllZCBxdWVyeSBzdHJpbmcgaW4gdG8gYW4gb2JqZWN0LiBJZiB3ZSdyZSBzdXBwbGllZFxuICAvLyB3aXRoIGEgY3VzdG9tIHBhcnNlciBhcyBmdW5jdGlvbiB1c2UgdGhhdCBpbnN0ZWFkIG9mIHRoZSBkZWZhdWx0IGJ1aWxkLWluXG4gIC8vIHBhcnNlci5cbiAgLy9cbiAgaWYgKHBhcnNlcikgdXJsLnF1ZXJ5ID0gcGFyc2VyKHVybC5xdWVyeSk7XG5cbiAgLy9cbiAgLy8gSWYgdGhlIFVSTCBpcyByZWxhdGl2ZSwgcmVzb2x2ZSB0aGUgcGF0aG5hbWUgYWdhaW5zdCB0aGUgYmFzZSBVUkwuXG4gIC8vXG4gIGlmIChcbiAgICAgIHJlbGF0aXZlXG4gICAgJiYgbG9jYXRpb24uc2xhc2hlc1xuICAgICYmIHVybC5wYXRobmFtZS5jaGFyQXQoMCkgIT09ICcvJ1xuICAgICYmICh1cmwucGF0aG5hbWUgIT09ICcnIHx8IGxvY2F0aW9uLnBhdGhuYW1lICE9PSAnJylcbiAgKSB7XG4gICAgdXJsLnBhdGhuYW1lID0gcmVzb2x2ZSh1cmwucGF0aG5hbWUsIGxvY2F0aW9uLnBhdGhuYW1lKTtcbiAgfVxuXG4gIC8vXG4gIC8vIFdlIHNob3VsZCBub3QgYWRkIHBvcnQgbnVtYmVycyBpZiB0aGV5IGFyZSBhbHJlYWR5IHRoZSBkZWZhdWx0IHBvcnQgbnVtYmVyXG4gIC8vIGZvciBhIGdpdmVuIHByb3RvY29sLiBBcyB0aGUgaG9zdCBhbHNvIGNvbnRhaW5zIHRoZSBwb3J0IG51bWJlciB3ZSdyZSBnb2luZ1xuICAvLyBvdmVycmlkZSBpdCB3aXRoIHRoZSBob3N0bmFtZSB3aGljaCBjb250YWlucyBubyBwb3J0IG51bWJlci5cbiAgLy9cbiAgaWYgKCFyZXF1aXJlZCh1cmwucG9ydCwgdXJsLnByb3RvY29sKSkge1xuICAgIHVybC5ob3N0ID0gdXJsLmhvc3RuYW1lO1xuICAgIHVybC5wb3J0ID0gJyc7XG4gIH1cblxuICAvL1xuICAvLyBQYXJzZSBkb3duIHRoZSBgYXV0aGAgZm9yIHRoZSB1c2VybmFtZSBhbmQgcGFzc3dvcmQuXG4gIC8vXG4gIHVybC51c2VybmFtZSA9IHVybC5wYXNzd29yZCA9ICcnO1xuICBpZiAodXJsLmF1dGgpIHtcbiAgICBpbnN0cnVjdGlvbiA9IHVybC5hdXRoLnNwbGl0KCc6Jyk7XG4gICAgdXJsLnVzZXJuYW1lID0gaW5zdHJ1Y3Rpb25bMF0gfHwgJyc7XG4gICAgdXJsLnBhc3N3b3JkID0gaW5zdHJ1Y3Rpb25bMV0gfHwgJyc7XG4gIH1cblxuICB1cmwub3JpZ2luID0gdXJsLnByb3RvY29sICYmIHVybC5ob3N0ICYmIHVybC5wcm90b2NvbCAhPT0gJ2ZpbGU6J1xuICAgID8gdXJsLnByb3RvY29sICsnLy8nKyB1cmwuaG9zdFxuICAgIDogJ251bGwnO1xuXG4gIC8vXG4gIC8vIFRoZSBocmVmIGlzIGp1c3QgdGhlIGNvbXBpbGVkIHJlc3VsdC5cbiAgLy9cbiAgdXJsLmhyZWYgPSB1cmwudG9TdHJpbmcoKTtcbn1cblxuLyoqXG4gKiBUaGlzIGlzIGNvbnZlbmllbmNlIG1ldGhvZCBmb3IgY2hhbmdpbmcgcHJvcGVydGllcyBpbiB0aGUgVVJMIGluc3RhbmNlIHRvXG4gKiBpbnN1cmUgdGhhdCB0aGV5IGFsbCBwcm9wYWdhdGUgY29ycmVjdGx5LlxuICpcbiAqIEBwYXJhbSB7U3RyaW5nfSBwYXJ0ICAgICAgICAgIFByb3BlcnR5IHdlIG5lZWQgdG8gYWRqdXN0LlxuICogQHBhcmFtIHtNaXhlZH0gdmFsdWUgICAgICAgICAgVGhlIG5ld2x5IGFzc2lnbmVkIHZhbHVlLlxuICogQHBhcmFtIHtCb29sZWFufEZ1bmN0aW9ufSBmbiAgV2hlbiBzZXR0aW5nIHRoZSBxdWVyeSwgaXQgd2lsbCBiZSB0aGUgZnVuY3Rpb25cbiAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHVzZWQgdG8gcGFyc2UgdGhlIHF1ZXJ5LlxuICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgV2hlbiBzZXR0aW5nIHRoZSBwcm90b2NvbCwgZG91YmxlIHNsYXNoIHdpbGwgYmVcbiAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlbW92ZWQgZnJvbSB0aGUgZmluYWwgdXJsIGlmIGl0IGlzIHRydWUuXG4gKiBAcmV0dXJucyB7VVJMfVxuICogQGFwaSBwdWJsaWNcbiAqL1xuZnVuY3Rpb24gc2V0KHBhcnQsIHZhbHVlLCBmbikge1xuICB2YXIgdXJsID0gdGhpcztcblxuICBzd2l0Y2ggKHBhcnQpIHtcbiAgICBjYXNlICdxdWVyeSc6XG4gICAgICBpZiAoJ3N0cmluZycgPT09IHR5cGVvZiB2YWx1ZSAmJiB2YWx1ZS5sZW5ndGgpIHtcbiAgICAgICAgdmFsdWUgPSAoZm4gfHwgcXMucGFyc2UpKHZhbHVlKTtcbiAgICAgIH1cblxuICAgICAgdXJsW3BhcnRdID0gdmFsdWU7XG4gICAgICBicmVhaztcblxuICAgIGNhc2UgJ3BvcnQnOlxuICAgICAgdXJsW3BhcnRdID0gdmFsdWU7XG5cbiAgICAgIGlmICghcmVxdWlyZWQodmFsdWUsIHVybC5wcm90b2NvbCkpIHtcbiAgICAgICAgdXJsLmhvc3QgPSB1cmwuaG9zdG5hbWU7XG4gICAgICAgIHVybFtwYXJ0XSA9ICcnO1xuICAgICAgfSBlbHNlIGlmICh2YWx1ZSkge1xuICAgICAgICB1cmwuaG9zdCA9IHVybC5ob3N0bmFtZSArJzonKyB2YWx1ZTtcbiAgICAgIH1cblxuICAgICAgYnJlYWs7XG5cbiAgICBjYXNlICdob3N0bmFtZSc6XG4gICAgICB1cmxbcGFydF0gPSB2YWx1ZTtcblxuICAgICAgaWYgKHVybC5wb3J0KSB2YWx1ZSArPSAnOicrIHVybC5wb3J0O1xuICAgICAgdXJsLmhvc3QgPSB2YWx1ZTtcbiAgICAgIGJyZWFrO1xuXG4gICAgY2FzZSAnaG9zdCc6XG4gICAgICB1cmxbcGFydF0gPSB2YWx1ZTtcblxuICAgICAgaWYgKC86XFxkKyQvLnRlc3QodmFsdWUpKSB7XG4gICAgICAgIHZhbHVlID0gdmFsdWUuc3BsaXQoJzonKTtcbiAgICAgICAgdXJsLnBvcnQgPSB2YWx1ZS5wb3AoKTtcbiAgICAgICAgdXJsLmhvc3RuYW1lID0gdmFsdWUuam9pbignOicpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdXJsLmhvc3RuYW1lID0gdmFsdWU7XG4gICAgICAgIHVybC5wb3J0ID0gJyc7XG4gICAgICB9XG5cbiAgICAgIGJyZWFrO1xuXG4gICAgY2FzZSAncHJvdG9jb2wnOlxuICAgICAgdXJsLnByb3RvY29sID0gdmFsdWUudG9Mb3dlckNhc2UoKTtcbiAgICAgIHVybC5zbGFzaGVzID0gIWZuO1xuICAgICAgYnJlYWs7XG5cbiAgICBjYXNlICdwYXRobmFtZSc6XG4gICAgY2FzZSAnaGFzaCc6XG4gICAgICBpZiAodmFsdWUpIHtcbiAgICAgICAgdmFyIGNoYXIgPSBwYXJ0ID09PSAncGF0aG5hbWUnID8gJy8nIDogJyMnO1xuICAgICAgICB1cmxbcGFydF0gPSB2YWx1ZS5jaGFyQXQoMCkgIT09IGNoYXIgPyBjaGFyICsgdmFsdWUgOiB2YWx1ZTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHVybFtwYXJ0XSA9IHZhbHVlO1xuICAgICAgfVxuICAgICAgYnJlYWs7XG5cbiAgICBkZWZhdWx0OlxuICAgICAgdXJsW3BhcnRdID0gdmFsdWU7XG4gIH1cblxuICBmb3IgKHZhciBpID0gMDsgaSA8IHJ1bGVzLmxlbmd0aDsgaSsrKSB7XG4gICAgdmFyIGlucyA9IHJ1bGVzW2ldO1xuXG4gICAgaWYgKGluc1s0XSkgdXJsW2luc1sxXV0gPSB1cmxbaW5zWzFdXS50b0xvd2VyQ2FzZSgpO1xuICB9XG5cbiAgdXJsLm9yaWdpbiA9IHVybC5wcm90b2NvbCAmJiB1cmwuaG9zdCAmJiB1cmwucHJvdG9jb2wgIT09ICdmaWxlOidcbiAgICA/IHVybC5wcm90b2NvbCArJy8vJysgdXJsLmhvc3RcbiAgICA6ICdudWxsJztcblxuICB1cmwuaHJlZiA9IHVybC50b1N0cmluZygpO1xuXG4gIHJldHVybiB1cmw7XG59XG5cbi8qKlxuICogVHJhbnNmb3JtIHRoZSBwcm9wZXJ0aWVzIGJhY2sgaW4gdG8gYSB2YWxpZCBhbmQgZnVsbCBVUkwgc3RyaW5nLlxuICpcbiAqIEBwYXJhbSB7RnVuY3Rpb259IHN0cmluZ2lmeSBPcHRpb25hbCBxdWVyeSBzdHJpbmdpZnkgZnVuY3Rpb24uXG4gKiBAcmV0dXJucyB7U3RyaW5nfVxuICogQGFwaSBwdWJsaWNcbiAqL1xuZnVuY3Rpb24gdG9TdHJpbmcoc3RyaW5naWZ5KSB7XG4gIGlmICghc3RyaW5naWZ5IHx8ICdmdW5jdGlvbicgIT09IHR5cGVvZiBzdHJpbmdpZnkpIHN0cmluZ2lmeSA9IHFzLnN0cmluZ2lmeTtcblxuICB2YXIgcXVlcnlcbiAgICAsIHVybCA9IHRoaXNcbiAgICAsIHByb3RvY29sID0gdXJsLnByb3RvY29sO1xuXG4gIGlmIChwcm90b2NvbCAmJiBwcm90b2NvbC5jaGFyQXQocHJvdG9jb2wubGVuZ3RoIC0gMSkgIT09ICc6JykgcHJvdG9jb2wgKz0gJzonO1xuXG4gIHZhciByZXN1bHQgPSBwcm90b2NvbCArICh1cmwuc2xhc2hlcyA/ICcvLycgOiAnJyk7XG5cbiAgaWYgKHVybC51c2VybmFtZSkge1xuICAgIHJlc3VsdCArPSB1cmwudXNlcm5hbWU7XG4gICAgaWYgKHVybC5wYXNzd29yZCkgcmVzdWx0ICs9ICc6JysgdXJsLnBhc3N3b3JkO1xuICAgIHJlc3VsdCArPSAnQCc7XG4gIH1cblxuICByZXN1bHQgKz0gdXJsLmhvc3QgKyB1cmwucGF0aG5hbWU7XG5cbiAgcXVlcnkgPSAnb2JqZWN0JyA9PT0gdHlwZW9mIHVybC5xdWVyeSA/IHN0cmluZ2lmeSh1cmwucXVlcnkpIDogdXJsLnF1ZXJ5O1xuICBpZiAocXVlcnkpIHJlc3VsdCArPSAnPycgIT09IHF1ZXJ5LmNoYXJBdCgwKSA/ICc/JysgcXVlcnkgOiBxdWVyeTtcblxuICBpZiAodXJsLmhhc2gpIHJlc3VsdCArPSB1cmwuaGFzaDtcblxuICByZXR1cm4gcmVzdWx0O1xufVxuXG5VUkwucHJvdG90eXBlID0geyBzZXQ6IHNldCwgdG9TdHJpbmc6IHRvU3RyaW5nIH07XG5cbi8vXG4vLyBFeHBvc2UgdGhlIFVSTCBwYXJzZXIgYW5kIHNvbWUgYWRkaXRpb25hbCBwcm9wZXJ0aWVzIHRoYXQgbWlnaHQgYmUgdXNlZnVsIGZvclxuLy8gb3RoZXJzIG9yIHRlc3RpbmcuXG4vL1xuVVJMLmV4dHJhY3RQcm90b2NvbCA9IGV4dHJhY3RQcm90b2NvbDtcblVSTC5sb2NhdGlvbiA9IGxvbGNhdGlvbjtcblVSTC5xcyA9IHFzO1xuXG5tb2R1bGUuZXhwb3J0cyA9IFVSTDtcbiIsIi8vIGNyZWF0ZWQgYnkgQEhlbnJpa0pvcmV0ZWdcbnZhciBwcmVmaXg7XG52YXIgdmVyc2lvbjtcblxuaWYgKHdpbmRvdy5tb3pSVENQZWVyQ29ubmVjdGlvbiB8fCBuYXZpZ2F0b3IubW96R2V0VXNlck1lZGlhKSB7XG4gICAgcHJlZml4ID0gJ21veic7XG4gICAgdmVyc2lvbiA9IHBhcnNlSW50KG5hdmlnYXRvci51c2VyQWdlbnQubWF0Y2goL0ZpcmVmb3hcXC8oWzAtOV0rKVxcLi8pWzFdLCAxMCk7XG59IGVsc2UgaWYgKHdpbmRvdy53ZWJraXRSVENQZWVyQ29ubmVjdGlvbiB8fCBuYXZpZ2F0b3Iud2Via2l0R2V0VXNlck1lZGlhKSB7XG4gICAgcHJlZml4ID0gJ3dlYmtpdCc7XG4gICAgdmVyc2lvbiA9IG5hdmlnYXRvci51c2VyQWdlbnQubWF0Y2goL0Nocm9tKGV8aXVtKS8pICYmIHBhcnNlSW50KG5hdmlnYXRvci51c2VyQWdlbnQubWF0Y2goL0Nocm9tKGV8aXVtKVxcLyhbMC05XSspXFwuLylbMl0sIDEwKTtcbn1cblxudmFyIFBDID0gd2luZG93Lm1velJUQ1BlZXJDb25uZWN0aW9uIHx8IHdpbmRvdy53ZWJraXRSVENQZWVyQ29ubmVjdGlvbjtcbnZhciBJY2VDYW5kaWRhdGUgPSB3aW5kb3cubW96UlRDSWNlQ2FuZGlkYXRlIHx8IHdpbmRvdy5SVENJY2VDYW5kaWRhdGU7XG52YXIgU2Vzc2lvbkRlc2NyaXB0aW9uID0gd2luZG93Lm1velJUQ1Nlc3Npb25EZXNjcmlwdGlvbiB8fCB3aW5kb3cuUlRDU2Vzc2lvbkRlc2NyaXB0aW9uO1xudmFyIE1lZGlhU3RyZWFtID0gd2luZG93LndlYmtpdE1lZGlhU3RyZWFtIHx8IHdpbmRvdy5NZWRpYVN0cmVhbTtcbnZhciBzY3JlZW5TaGFyaW5nID0gd2luZG93LmxvY2F0aW9uLnByb3RvY29sID09PSAnaHR0cHM6JyAmJlxuICAgICgocHJlZml4ID09PSAnd2Via2l0JyAmJiB2ZXJzaW9uID49IDI2KSB8fFxuICAgICAocHJlZml4ID09PSAnbW96JyAmJiB2ZXJzaW9uID49IDMzKSlcbnZhciBBdWRpb0NvbnRleHQgPSB3aW5kb3cuQXVkaW9Db250ZXh0IHx8IHdpbmRvdy53ZWJraXRBdWRpb0NvbnRleHQ7XG52YXIgdmlkZW9FbCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ3ZpZGVvJyk7XG52YXIgc3VwcG9ydFZwOCA9IHZpZGVvRWwgJiYgdmlkZW9FbC5jYW5QbGF5VHlwZSAmJiB2aWRlb0VsLmNhblBsYXlUeXBlKCd2aWRlby93ZWJtOyBjb2RlY3M9XCJ2cDhcIiwgdm9yYmlzJykgPT09IFwicHJvYmFibHlcIjtcbnZhciBnZXRVc2VyTWVkaWEgPSBuYXZpZ2F0b3IuZ2V0VXNlck1lZGlhIHx8IG5hdmlnYXRvci53ZWJraXRHZXRVc2VyTWVkaWEgfHwgbmF2aWdhdG9yLm1zR2V0VXNlck1lZGlhIHx8IG5hdmlnYXRvci5tb3pHZXRVc2VyTWVkaWE7XG5cbi8vIGV4cG9ydCBzdXBwb3J0IGZsYWdzIGFuZCBjb25zdHJ1Y3RvcnMucHJvdG90eXBlICYmIFBDXG5tb2R1bGUuZXhwb3J0cyA9IHtcbiAgICBwcmVmaXg6IHByZWZpeCxcbiAgICBicm93c2VyVmVyc2lvbjogdmVyc2lvbixcbiAgICBzdXBwb3J0OiAhIVBDICYmIHN1cHBvcnRWcDggJiYgISFnZXRVc2VyTWVkaWEsXG4gICAgLy8gbmV3IHN1cHBvcnQgc3R5bGVcbiAgICBzdXBwb3J0UlRDUGVlckNvbm5lY3Rpb246ICEhUEMsXG4gICAgc3VwcG9ydFZwODogc3VwcG9ydFZwOCxcbiAgICBzdXBwb3J0R2V0VXNlck1lZGlhOiAhIWdldFVzZXJNZWRpYSxcbiAgICBzdXBwb3J0RGF0YUNoYW5uZWw6ICEhKFBDICYmIFBDLnByb3RvdHlwZSAmJiBQQy5wcm90b3R5cGUuY3JlYXRlRGF0YUNoYW5uZWwpLFxuICAgIHN1cHBvcnRXZWJBdWRpbzogISEoQXVkaW9Db250ZXh0ICYmIEF1ZGlvQ29udGV4dC5wcm90b3R5cGUuY3JlYXRlTWVkaWFTdHJlYW1Tb3VyY2UpLFxuICAgIHN1cHBvcnRNZWRpYVN0cmVhbTogISEoTWVkaWFTdHJlYW0gJiYgTWVkaWFTdHJlYW0ucHJvdG90eXBlLnJlbW92ZVRyYWNrKSxcbiAgICBzdXBwb3J0U2NyZWVuU2hhcmluZzogISFzY3JlZW5TaGFyaW5nLFxuICAgIC8vIG9sZCBkZXByZWNhdGVkIHN0eWxlLiBEb250IHVzZSB0aGlzIGFueW1vcmVcbiAgICBkYXRhQ2hhbm5lbDogISEoUEMgJiYgUEMucHJvdG90eXBlICYmIFBDLnByb3RvdHlwZS5jcmVhdGVEYXRhQ2hhbm5lbCksXG4gICAgd2ViQXVkaW86ICEhKEF1ZGlvQ29udGV4dCAmJiBBdWRpb0NvbnRleHQucHJvdG90eXBlLmNyZWF0ZU1lZGlhU3RyZWFtU291cmNlKSxcbiAgICBtZWRpYVN0cmVhbTogISEoTWVkaWFTdHJlYW0gJiYgTWVkaWFTdHJlYW0ucHJvdG90eXBlLnJlbW92ZVRyYWNrKSxcbiAgICBzY3JlZW5TaGFyaW5nOiAhIXNjcmVlblNoYXJpbmcsXG4gICAgLy8gY29uc3RydWN0b3JzXG4gICAgQXVkaW9Db250ZXh0OiBBdWRpb0NvbnRleHQsXG4gICAgUGVlckNvbm5lY3Rpb246IFBDLFxuICAgIFNlc3Npb25EZXNjcmlwdGlvbjogU2Vzc2lvbkRlc2NyaXB0aW9uLFxuICAgIEljZUNhbmRpZGF0ZTogSWNlQ2FuZGlkYXRlLFxuICAgIE1lZGlhU3RyZWFtOiBNZWRpYVN0cmVhbSxcbiAgICBnZXRVc2VyTWVkaWE6IGdldFVzZXJNZWRpYVxufTtcbiIsInZhciBfZ2xvYmFsID0gKGZ1bmN0aW9uKCkgeyByZXR1cm4gdGhpczsgfSkoKTtcbnZhciBOYXRpdmVXZWJTb2NrZXQgPSBfZ2xvYmFsLldlYlNvY2tldCB8fCBfZ2xvYmFsLk1veldlYlNvY2tldDtcbnZhciB3ZWJzb2NrZXRfdmVyc2lvbiA9IHJlcXVpcmUoJy4vdmVyc2lvbicpO1xuXG5cbi8qKlxuICogRXhwb3NlIGEgVzNDIFdlYlNvY2tldCBjbGFzcyB3aXRoIGp1c3Qgb25lIG9yIHR3byBhcmd1bWVudHMuXG4gKi9cbmZ1bmN0aW9uIFczQ1dlYlNvY2tldCh1cmksIHByb3RvY29scykge1xuXHR2YXIgbmF0aXZlX2luc3RhbmNlO1xuXG5cdGlmIChwcm90b2NvbHMpIHtcblx0XHRuYXRpdmVfaW5zdGFuY2UgPSBuZXcgTmF0aXZlV2ViU29ja2V0KHVyaSwgcHJvdG9jb2xzKTtcblx0fVxuXHRlbHNlIHtcblx0XHRuYXRpdmVfaW5zdGFuY2UgPSBuZXcgTmF0aXZlV2ViU29ja2V0KHVyaSk7XG5cdH1cblxuXHQvKipcblx0ICogJ25hdGl2ZV9pbnN0YW5jZScgaXMgYW4gaW5zdGFuY2Ugb2YgbmF0aXZlV2ViU29ja2V0ICh0aGUgYnJvd3NlcidzIFdlYlNvY2tldFxuXHQgKiBjbGFzcykuIFNpbmNlIGl0IGlzIGFuIE9iamVjdCBpdCB3aWxsIGJlIHJldHVybmVkIGFzIGl0IGlzIHdoZW4gY3JlYXRpbmcgYW5cblx0ICogaW5zdGFuY2Ugb2YgVzNDV2ViU29ja2V0IHZpYSAnbmV3IFczQ1dlYlNvY2tldCgpJy5cblx0ICpcblx0ICogRUNNQVNjcmlwdCA1OiBodHRwOi8vYmNsYXJ5LmNvbS8yMDA0LzExLzA3LyNhLTEzLjIuMlxuXHQgKi9cblx0cmV0dXJuIG5hdGl2ZV9pbnN0YW5jZTtcbn1cbmlmIChOYXRpdmVXZWJTb2NrZXQpIHtcblx0WydDT05ORUNUSU5HJywgJ09QRU4nLCAnQ0xPU0lORycsICdDTE9TRUQnXS5mb3JFYWNoKGZ1bmN0aW9uKHByb3ApIHtcblx0XHRPYmplY3QuZGVmaW5lUHJvcGVydHkoVzNDV2ViU29ja2V0LCBwcm9wLCB7XG5cdFx0XHRnZXQ6IGZ1bmN0aW9uKCkgeyByZXR1cm4gTmF0aXZlV2ViU29ja2V0W3Byb3BdOyB9XG5cdFx0fSk7XG5cdH0pO1xufVxuXG4vKipcbiAqIE1vZHVsZSBleHBvcnRzLlxuICovXG5tb2R1bGUuZXhwb3J0cyA9IHtcbiAgICAndzNjd2Vic29ja2V0JyA6IE5hdGl2ZVdlYlNvY2tldCA/IFczQ1dlYlNvY2tldCA6IG51bGwsXG4gICAgJ3ZlcnNpb24nICAgICAgOiB3ZWJzb2NrZXRfdmVyc2lvblxufTtcbiIsIm1vZHVsZS5leHBvcnRzID0gcmVxdWlyZSgnLi4vcGFja2FnZS5qc29uJykudmVyc2lvbjtcbiIsIm1vZHVsZS5leHBvcnRzPXtcbiAgXCJfYXJnc1wiOiBbXG4gICAgW1xuICAgICAgXCJ3ZWJzb2NrZXRAMS4wLjI1XCIsXG4gICAgICBcIi9ob21lL2FkbWluL3ZvaWNlL3ZvaWNlLWNoYXQvYXBwXCJcbiAgICBdXG4gIF0sXG4gIFwiX2Zyb21cIjogXCJ3ZWJzb2NrZXRAMS4wLjI1XCIsXG4gIFwiX2lkXCI6IFwid2Vic29ja2V0QDEuMC4yNVwiLFxuICBcIl9pbkJ1bmRsZVwiOiBmYWxzZSxcbiAgXCJfaW50ZWdyaXR5XCI6IFwic2hhNTEyLU01OG5qdmk2WnhWYjVrN2twbkhoMkJ2Tkt1Qldpd0lZdnNUb0VyQnpXaHZCWll3bEVpTGN5THJHNDFUMWpSY3JZOWV0dHFQWUVxZHVMSTd1bDU0Q1ZRPT1cIixcbiAgXCJfbG9jYXRpb25cIjogXCIvd2Vic29ja2V0XCIsXG4gIFwiX29wdGlvbmFsXCI6IHRydWUsXG4gIFwiX3BoYW50b21DaGlsZHJlblwiOiB7XG4gICAgXCJtc1wiOiBcIjIuMC4wXCJcbiAgfSxcbiAgXCJfcmVxdWVzdGVkXCI6IHtcbiAgICBcInR5cGVcIjogXCJ2ZXJzaW9uXCIsXG4gICAgXCJyZWdpc3RyeVwiOiB0cnVlLFxuICAgIFwicmF3XCI6IFwid2Vic29ja2V0QDEuMC4yNVwiLFxuICAgIFwibmFtZVwiOiBcIndlYnNvY2tldFwiLFxuICAgIFwiZXNjYXBlZE5hbWVcIjogXCJ3ZWJzb2NrZXRcIixcbiAgICBcInJhd1NwZWNcIjogXCIxLjAuMjVcIixcbiAgICBcInNhdmVTcGVjXCI6IG51bGwsXG4gICAgXCJmZXRjaFNwZWNcIjogXCIxLjAuMjVcIlxuICB9LFxuICBcIl9yZXF1aXJlZEJ5XCI6IFtcbiAgICBcIi9wcm90b28tY2xpZW50XCJcbiAgXSxcbiAgXCJfcmVzb2x2ZWRcIjogXCJodHRwczovL3JlZ2lzdHJ5Lm5wbWpzLm9yZy93ZWJzb2NrZXQvLS93ZWJzb2NrZXQtMS4wLjI1LnRnelwiLFxuICBcIl9zcGVjXCI6IFwiMS4wLjI1XCIsXG4gIFwiX3doZXJlXCI6IFwiL2hvbWUvYWRtaW4vdm9pY2Uvdm9pY2UtY2hhdC9hcHBcIixcbiAgXCJhdXRob3JcIjoge1xuICAgIFwibmFtZVwiOiBcIkJyaWFuIE1jS2VsdmV5XCIsXG4gICAgXCJlbWFpbFwiOiBcImJyaWFuQHdvcmxpemUuY29tXCIsXG4gICAgXCJ1cmxcIjogXCJodHRwczovL3d3dy53b3JsaXplLmNvbS9cIlxuICB9LFxuICBcImJyb3dzZXJcIjogXCJsaWIvYnJvd3Nlci5qc1wiLFxuICBcImJ1Z3NcIjoge1xuICAgIFwidXJsXCI6IFwiaHR0cHM6Ly9naXRodWIuY29tL3RoZXR1cnRsZTMyL1dlYlNvY2tldC1Ob2RlL2lzc3Vlc1wiXG4gIH0sXG4gIFwiY29uZmlnXCI6IHtcbiAgICBcInZlcmJvc2VcIjogZmFsc2VcbiAgfSxcbiAgXCJjb250cmlidXRvcnNcIjogW1xuICAgIHtcbiAgICAgIFwibmFtZVwiOiBcIknDsWFraSBCYXogQ2FzdGlsbG9cIixcbiAgICAgIFwiZW1haWxcIjogXCJpYmNAYWxpYXgubmV0XCIsXG4gICAgICBcInVybFwiOiBcImh0dHA6Ly9kZXYuc2lwZG9jLm5ldFwiXG4gICAgfVxuICBdLFxuICBcImRlcGVuZGVuY2llc1wiOiB7XG4gICAgXCJkZWJ1Z1wiOiBcIl4yLjIuMFwiLFxuICAgIFwibmFuXCI6IFwiXjIuMy4zXCIsXG4gICAgXCJ0eXBlZGFycmF5LXRvLWJ1ZmZlclwiOiBcIl4zLjEuMlwiLFxuICAgIFwieWFldGlcIjogXCJeMC4wLjZcIlxuICB9LFxuICBcImRlc2NyaXB0aW9uXCI6IFwiV2Vic29ja2V0IENsaWVudCAmIFNlcnZlciBMaWJyYXJ5IGltcGxlbWVudGluZyB0aGUgV2ViU29ja2V0IHByb3RvY29sIGFzIHNwZWNpZmllZCBpbiBSRkMgNjQ1NS5cIixcbiAgXCJkZXZEZXBlbmRlbmNpZXNcIjoge1xuICAgIFwiYnVmZmVyLWVxdWFsXCI6IFwiXjEuMC4wXCIsXG4gICAgXCJmYXVjZXRcIjogXCJeMC4wLjFcIixcbiAgICBcImd1bHBcIjogXCJnaXQraHR0cHM6Ly9naXRodWIuY29tL2d1bHBqcy9ndWxwLmdpdCM0LjBcIixcbiAgICBcImd1bHAtanNoaW50XCI6IFwiXjIuMC40XCIsXG4gICAgXCJqc2hpbnRcIjogXCJeMi4wLjBcIixcbiAgICBcImpzaGludC1zdHlsaXNoXCI6IFwiXjIuMi4xXCIsXG4gICAgXCJ0YXBlXCI6IFwiXjQuMC4xXCJcbiAgfSxcbiAgXCJkaXJlY3Rvcmllc1wiOiB7XG4gICAgXCJsaWJcIjogXCIuL2xpYlwiXG4gIH0sXG4gIFwiZW5naW5lc1wiOiB7XG4gICAgXCJub2RlXCI6IFwiPj0wLjEwLjBcIlxuICB9LFxuICBcImhvbWVwYWdlXCI6IFwiaHR0cHM6Ly9naXRodWIuY29tL3RoZXR1cnRsZTMyL1dlYlNvY2tldC1Ob2RlXCIsXG4gIFwia2V5d29yZHNcIjogW1xuICAgIFwid2Vic29ja2V0XCIsXG4gICAgXCJ3ZWJzb2NrZXRzXCIsXG4gICAgXCJzb2NrZXRcIixcbiAgICBcIm5ldHdvcmtpbmdcIixcbiAgICBcImNvbWV0XCIsXG4gICAgXCJwdXNoXCIsXG4gICAgXCJSRkMtNjQ1NVwiLFxuICAgIFwicmVhbHRpbWVcIixcbiAgICBcInNlcnZlclwiLFxuICAgIFwiY2xpZW50XCJcbiAgXSxcbiAgXCJsaWNlbnNlXCI6IFwiQXBhY2hlLTIuMFwiLFxuICBcIm1haW5cIjogXCJpbmRleFwiLFxuICBcIm5hbWVcIjogXCJ3ZWJzb2NrZXRcIixcbiAgXCJyZXBvc2l0b3J5XCI6IHtcbiAgICBcInR5cGVcIjogXCJnaXRcIixcbiAgICBcInVybFwiOiBcImdpdCtodHRwczovL2dpdGh1Yi5jb20vdGhldHVydGxlMzIvV2ViU29ja2V0LU5vZGUuZ2l0XCJcbiAgfSxcbiAgXCJzY3JpcHRzXCI6IHtcbiAgICBcImd1bHBcIjogXCJndWxwXCIsXG4gICAgXCJpbnN0YWxsXCI6IFwiKG5vZGUtZ3lwIHJlYnVpbGQgMj4gYnVpbGRlcnJvci5sb2cpIHx8IChleGl0IDApXCIsXG4gICAgXCJ0ZXN0XCI6IFwiZmF1Y2V0IHRlc3QvdW5pdFwiXG4gIH0sXG4gIFwidmVyc2lvblwiOiBcIjEuMC4yNVwiXG59XG4iLCIvKlxyXG5XaWxkRW1pdHRlci5qcyBpcyBhIHNsaW0gbGl0dGxlIGV2ZW50IGVtaXR0ZXIgYnkgQGhlbnJpa2pvcmV0ZWcgbGFyZ2VseSBiYXNlZFxyXG5vbiBAdmlzaW9ubWVkaWEncyBFbWl0dGVyIGZyb20gVUkgS2l0LlxyXG5cclxuV2h5PyBJIHdhbnRlZCBpdCBzdGFuZGFsb25lLlxyXG5cclxuSSBhbHNvIHdhbnRlZCBzdXBwb3J0IGZvciB3aWxkY2FyZCBlbWl0dGVycyBsaWtlIHRoaXM6XHJcblxyXG5lbWl0dGVyLm9uKCcqJywgZnVuY3Rpb24gKGV2ZW50TmFtZSwgb3RoZXIsIGV2ZW50LCBwYXlsb2Fkcykge1xyXG5cclxufSk7XHJcblxyXG5lbWl0dGVyLm9uKCdzb21lbmFtZXNwYWNlKicsIGZ1bmN0aW9uIChldmVudE5hbWUsIHBheWxvYWRzKSB7XHJcblxyXG59KTtcclxuXHJcblBsZWFzZSBub3RlIHRoYXQgY2FsbGJhY2tzIHRyaWdnZXJlZCBieSB3aWxkY2FyZCByZWdpc3RlcmVkIGV2ZW50cyBhbHNvIGdldFxyXG50aGUgZXZlbnQgbmFtZSBhcyB0aGUgZmlyc3QgYXJndW1lbnQuXHJcbiovXHJcblxyXG5tb2R1bGUuZXhwb3J0cyA9IFdpbGRFbWl0dGVyO1xyXG5cclxuZnVuY3Rpb24gV2lsZEVtaXR0ZXIoKSB7IH1cclxuXHJcbldpbGRFbWl0dGVyLm1peGluID0gZnVuY3Rpb24gKGNvbnN0cnVjdG9yKSB7XHJcbiAgICB2YXIgcHJvdG90eXBlID0gY29uc3RydWN0b3IucHJvdG90eXBlIHx8IGNvbnN0cnVjdG9yO1xyXG5cclxuICAgIHByb3RvdHlwZS5pc1dpbGRFbWl0dGVyPSB0cnVlO1xyXG5cclxuICAgIC8vIExpc3RlbiBvbiB0aGUgZ2l2ZW4gYGV2ZW50YCB3aXRoIGBmbmAuIFN0b3JlIGEgZ3JvdXAgbmFtZSBpZiBwcmVzZW50LlxyXG4gICAgcHJvdG90eXBlLm9uID0gZnVuY3Rpb24gKGV2ZW50LCBncm91cE5hbWUsIGZuKSB7XHJcbiAgICAgICAgdGhpcy5jYWxsYmFja3MgPSB0aGlzLmNhbGxiYWNrcyB8fCB7fTtcclxuICAgICAgICB2YXIgaGFzR3JvdXAgPSAoYXJndW1lbnRzLmxlbmd0aCA9PT0gMyksXHJcbiAgICAgICAgICAgIGdyb3VwID0gaGFzR3JvdXAgPyBhcmd1bWVudHNbMV0gOiB1bmRlZmluZWQsXHJcbiAgICAgICAgICAgIGZ1bmMgPSBoYXNHcm91cCA/IGFyZ3VtZW50c1syXSA6IGFyZ3VtZW50c1sxXTtcclxuICAgICAgICBmdW5jLl9ncm91cE5hbWUgPSBncm91cDtcclxuICAgICAgICAodGhpcy5jYWxsYmFja3NbZXZlbnRdID0gdGhpcy5jYWxsYmFja3NbZXZlbnRdIHx8IFtdKS5wdXNoKGZ1bmMpO1xyXG4gICAgICAgIHJldHVybiB0aGlzO1xyXG4gICAgfTtcclxuXHJcbiAgICAvLyBBZGRzIGFuIGBldmVudGAgbGlzdGVuZXIgdGhhdCB3aWxsIGJlIGludm9rZWQgYSBzaW5nbGVcclxuICAgIC8vIHRpbWUgdGhlbiBhdXRvbWF0aWNhbGx5IHJlbW92ZWQuXHJcbiAgICBwcm90b3R5cGUub25jZSA9IGZ1bmN0aW9uIChldmVudCwgZ3JvdXBOYW1lLCBmbikge1xyXG4gICAgICAgIHZhciBzZWxmID0gdGhpcyxcclxuICAgICAgICAgICAgaGFzR3JvdXAgPSAoYXJndW1lbnRzLmxlbmd0aCA9PT0gMyksXHJcbiAgICAgICAgICAgIGdyb3VwID0gaGFzR3JvdXAgPyBhcmd1bWVudHNbMV0gOiB1bmRlZmluZWQsXHJcbiAgICAgICAgICAgIGZ1bmMgPSBoYXNHcm91cCA/IGFyZ3VtZW50c1syXSA6IGFyZ3VtZW50c1sxXTtcclxuICAgICAgICBmdW5jdGlvbiBvbigpIHtcclxuICAgICAgICAgICAgc2VsZi5vZmYoZXZlbnQsIG9uKTtcclxuICAgICAgICAgICAgZnVuYy5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xyXG4gICAgICAgIH1cclxuICAgICAgICB0aGlzLm9uKGV2ZW50LCBncm91cCwgb24pO1xyXG4gICAgICAgIHJldHVybiB0aGlzO1xyXG4gICAgfTtcclxuXHJcbiAgICAvLyBVbmJpbmRzIGFuIGVudGlyZSBncm91cFxyXG4gICAgcHJvdG90eXBlLnJlbGVhc2VHcm91cCA9IGZ1bmN0aW9uIChncm91cE5hbWUpIHtcclxuICAgICAgICB0aGlzLmNhbGxiYWNrcyA9IHRoaXMuY2FsbGJhY2tzIHx8IHt9O1xyXG4gICAgICAgIHZhciBpdGVtLCBpLCBsZW4sIGhhbmRsZXJzO1xyXG4gICAgICAgIGZvciAoaXRlbSBpbiB0aGlzLmNhbGxiYWNrcykge1xyXG4gICAgICAgICAgICBoYW5kbGVycyA9IHRoaXMuY2FsbGJhY2tzW2l0ZW1dO1xyXG4gICAgICAgICAgICBmb3IgKGkgPSAwLCBsZW4gPSBoYW5kbGVycy5sZW5ndGg7IGkgPCBsZW47IGkrKykge1xyXG4gICAgICAgICAgICAgICAgaWYgKGhhbmRsZXJzW2ldLl9ncm91cE5hbWUgPT09IGdyb3VwTmFtZSkge1xyXG4gICAgICAgICAgICAgICAgICAgIC8vY29uc29sZS5sb2coJ3JlbW92aW5nJyk7XHJcbiAgICAgICAgICAgICAgICAgICAgLy8gcmVtb3ZlIGl0IGFuZCBzaG9ydGVuIHRoZSBhcnJheSB3ZSdyZSBsb29waW5nIHRocm91Z2hcclxuICAgICAgICAgICAgICAgICAgICBoYW5kbGVycy5zcGxpY2UoaSwgMSk7XHJcbiAgICAgICAgICAgICAgICAgICAgaS0tO1xyXG4gICAgICAgICAgICAgICAgICAgIGxlbi0tO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiB0aGlzO1xyXG4gICAgfTtcclxuXHJcbiAgICAvLyBSZW1vdmUgdGhlIGdpdmVuIGNhbGxiYWNrIGZvciBgZXZlbnRgIG9yIGFsbFxyXG4gICAgLy8gcmVnaXN0ZXJlZCBjYWxsYmFja3MuXHJcbiAgICBwcm90b3R5cGUub2ZmID0gZnVuY3Rpb24gKGV2ZW50LCBmbikge1xyXG4gICAgICAgIHRoaXMuY2FsbGJhY2tzID0gdGhpcy5jYWxsYmFja3MgfHwge307XHJcbiAgICAgICAgdmFyIGNhbGxiYWNrcyA9IHRoaXMuY2FsbGJhY2tzW2V2ZW50XSxcclxuICAgICAgICAgICAgaTtcclxuXHJcbiAgICAgICAgaWYgKCFjYWxsYmFja3MpIHJldHVybiB0aGlzO1xyXG5cclxuICAgICAgICAvLyByZW1vdmUgYWxsIGhhbmRsZXJzXHJcbiAgICAgICAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPT09IDEpIHtcclxuICAgICAgICAgICAgZGVsZXRlIHRoaXMuY2FsbGJhY2tzW2V2ZW50XTtcclxuICAgICAgICAgICAgcmV0dXJuIHRoaXM7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICAvLyByZW1vdmUgc3BlY2lmaWMgaGFuZGxlclxyXG4gICAgICAgIGkgPSBjYWxsYmFja3MuaW5kZXhPZihmbik7XHJcbiAgICAgICAgY2FsbGJhY2tzLnNwbGljZShpLCAxKTtcclxuICAgICAgICBpZiAoY2FsbGJhY2tzLmxlbmd0aCA9PT0gMCkge1xyXG4gICAgICAgICAgICBkZWxldGUgdGhpcy5jYWxsYmFja3NbZXZlbnRdO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gdGhpcztcclxuICAgIH07XHJcblxyXG4gICAgLy8vIEVtaXQgYGV2ZW50YCB3aXRoIHRoZSBnaXZlbiBhcmdzLlxyXG4gICAgLy8gYWxzbyBjYWxscyBhbnkgYCpgIGhhbmRsZXJzXHJcbiAgICBwcm90b3R5cGUuZW1pdCA9IGZ1bmN0aW9uIChldmVudCkge1xyXG4gICAgICAgIHRoaXMuY2FsbGJhY2tzID0gdGhpcy5jYWxsYmFja3MgfHwge307XHJcbiAgICAgICAgdmFyIGFyZ3MgPSBbXS5zbGljZS5jYWxsKGFyZ3VtZW50cywgMSksXHJcbiAgICAgICAgICAgIGNhbGxiYWNrcyA9IHRoaXMuY2FsbGJhY2tzW2V2ZW50XSxcclxuICAgICAgICAgICAgc3BlY2lhbENhbGxiYWNrcyA9IHRoaXMuZ2V0V2lsZGNhcmRDYWxsYmFja3MoZXZlbnQpLFxyXG4gICAgICAgICAgICBpLFxyXG4gICAgICAgICAgICBsZW4sXHJcbiAgICAgICAgICAgIGl0ZW0sXHJcbiAgICAgICAgICAgIGxpc3RlbmVycztcclxuXHJcbiAgICAgICAgaWYgKGNhbGxiYWNrcykge1xyXG4gICAgICAgICAgICBsaXN0ZW5lcnMgPSBjYWxsYmFja3Muc2xpY2UoKTtcclxuICAgICAgICAgICAgZm9yIChpID0gMCwgbGVuID0gbGlzdGVuZXJzLmxlbmd0aDsgaSA8IGxlbjsgKytpKSB7XHJcbiAgICAgICAgICAgICAgICBpZiAoIWxpc3RlbmVyc1tpXSkge1xyXG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgbGlzdGVuZXJzW2ldLmFwcGx5KHRoaXMsIGFyZ3MpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBpZiAoc3BlY2lhbENhbGxiYWNrcykge1xyXG4gICAgICAgICAgICBsZW4gPSBzcGVjaWFsQ2FsbGJhY2tzLmxlbmd0aDtcclxuICAgICAgICAgICAgbGlzdGVuZXJzID0gc3BlY2lhbENhbGxiYWNrcy5zbGljZSgpO1xyXG4gICAgICAgICAgICBmb3IgKGkgPSAwLCBsZW4gPSBsaXN0ZW5lcnMubGVuZ3RoOyBpIDwgbGVuOyArK2kpIHtcclxuICAgICAgICAgICAgICAgIGlmICghbGlzdGVuZXJzW2ldKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBsaXN0ZW5lcnNbaV0uYXBwbHkodGhpcywgW2V2ZW50XS5jb25jYXQoYXJncykpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICByZXR1cm4gdGhpcztcclxuICAgIH07XHJcblxyXG4gICAgLy8gSGVscGVyIGZvciBmb3IgZmluZGluZyBzcGVjaWFsIHdpbGRjYXJkIGV2ZW50IGhhbmRsZXJzIHRoYXQgbWF0Y2ggdGhlIGV2ZW50XHJcbiAgICBwcm90b3R5cGUuZ2V0V2lsZGNhcmRDYWxsYmFja3MgPSBmdW5jdGlvbiAoZXZlbnROYW1lKSB7XHJcbiAgICAgICAgdGhpcy5jYWxsYmFja3MgPSB0aGlzLmNhbGxiYWNrcyB8fCB7fTtcclxuICAgICAgICB2YXIgaXRlbSxcclxuICAgICAgICAgICAgc3BsaXQsXHJcbiAgICAgICAgICAgIHJlc3VsdCA9IFtdO1xyXG5cclxuICAgICAgICBmb3IgKGl0ZW0gaW4gdGhpcy5jYWxsYmFja3MpIHtcclxuICAgICAgICAgICAgc3BsaXQgPSBpdGVtLnNwbGl0KCcqJyk7XHJcbiAgICAgICAgICAgIGlmIChpdGVtID09PSAnKicgfHwgKHNwbGl0Lmxlbmd0aCA9PT0gMiAmJiBldmVudE5hbWUuc2xpY2UoMCwgc3BsaXRbMF0ubGVuZ3RoKSA9PT0gc3BsaXRbMF0pKSB7XHJcbiAgICAgICAgICAgICAgICByZXN1bHQgPSByZXN1bHQuY29uY2F0KHRoaXMuY2FsbGJhY2tzW2l0ZW1dKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gcmVzdWx0O1xyXG4gICAgfTtcclxuXHJcbn07XHJcblxyXG5XaWxkRW1pdHRlci5taXhpbihXaWxkRW1pdHRlcik7XHJcbiJdfQ==